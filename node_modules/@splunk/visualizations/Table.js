/*!
 * Copyright © 2018 Splunk Inc.
 * SPLUNK CONFIDENTIAL – Use or disclosure of this material in whole or
 * in part without a valid written license from Splunk Inc. is PROHIBITED.
 */
module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 241);
/******/ })
/************************************************************************/
/******/ ({

/***/ 0:
/***/ (function(module, exports) {

module.exports = require("prop-types");

/***/ }),

/***/ 1:
/***/ (function(module, exports) {

module.exports = require("react");

/***/ }),

/***/ 10:
/***/ (function(module, exports) {

module.exports = require("@babel/runtime/helpers/classCallCheck");

/***/ }),

/***/ 103:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.validTextOverflows = exports.validAlignments = exports.validHeaderVisibilities = exports.validSparklineTypes = exports.validCellRenderers = void 0;
exports.validCellRenderers = ['TextCell', 'ArrayCell', 'SparklineCell'];
exports.validSparklineTypes = ['line', 'area'];
exports.validHeaderVisibilities = ['none', 'fixed', 'inline'];
exports.validAlignments = ['left', 'center', 'right'];
exports.validTextOverflows = ['anywhere', 'break-word', 'ellipsis'];

/***/ }),

/***/ 11:
/***/ (function(module, exports) {

module.exports = require("@splunk/visualizations-shared/colorUtils");

/***/ }),

/***/ 12:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var React = __webpack_require__(1);

var styled_components_1 = __webpack_require__(4);

var SizeAwareWrapper_1 = __webpack_require__(17);

var style_1 = __webpack_require__(13);

var colorUtils_1 = __webpack_require__(11);

var Item = styled_components_1.default.div.attrs(function (_ref) {
  var width = _ref.width;
  return {
    style: {
      width: style_1.toPx(width)
    }
  };
}).withConfig({
  displayName: "FixedSizeContainer__Item",
  componentId: "sc-1yhgpod-0"
})(["position:relative;background-color:", "};"], function (props) {
  return colorUtils_1.isColor(props.backgroundColor) && props.backgroundColor || props.theme.defaultBackgroundColor;
}); // Use `.attrs()` for highly dynamic styles. Ref: https://github.com/styled-components/styled-components/issues/134#issuecomment-312415291

var FixSizeItem = styled_components_1.default.div.attrs(function (_ref2) {
  var width = _ref2.width,
      height = _ref2.height;
  return {
    style: Object.assign(Object.assign({}, width && {
      width: style_1.toPx(width)
    }), height && {
      height: style_1.toPx(height)
    })
  };
}).withConfig({
  displayName: "FixedSizeContainer__FixSizeItem",
  componentId: "sc-1yhgpod-1"
})(["position:relative;flex-direction:column;flex:1;display:flex;background-color:", "};"], function (props) {
  return colorUtils_1.isColor(props.backgroundColor) && props.backgroundColor || props.theme.defaultBackgroundColor;
});
var ItemContent = styled_components_1.default.div.withConfig({
  displayName: "FixedSizeContainer__ItemContent",
  componentId: "sc-1yhgpod-2"
})(["position:relative;min-height:100px;width:100%;"]);
var FixSizeItemContent = styled_components_1.default.div.withConfig({
  displayName: "FixedSizeContainer__FixSizeItemContent",
  componentId: "sc-1yhgpod-3"
})(["min-height:0px;flex:1;position:relative;box-sizing:border-box;"]);

var withFixedSizeContainer = function withFixedSizeContainer(Viz) {
  var FixedSizeContainer = function FixedSizeContainer(props) {
    var width = props.width,
        height = props.height,
        backgroundColor = props.backgroundColor;

    if (!height) {
      return React.createElement(Item, {
        "data-test": "item",
        width: width,
        backgroundColor: backgroundColor
      }, React.createElement(ItemContent, null, React.createElement(Viz, Object.assign({}, props))));
    }

    return React.createElement(FixSizeItem, {
      "data-test": "fix-size-item",
      width: width,
      height: height,
      backgroundColor: backgroundColor
    }, React.createElement(FixSizeItemContent, null, React.createElement(SizeAwareWrapper_1.default, null, function (_ref3) {
      var newWidth = _ref3.width,
          newHeight = _ref3.height;
      return React.createElement(Viz, Object.assign({}, props, {
        width: newWidth,
        height: newHeight
      }));
    })));
  };

  FixedSizeContainer.displayName = 'withFixedSizeContainer';
  return FixedSizeContainer;
};

exports.default = withFixedSizeContainer;

/***/ }),

/***/ 128:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __rest = this && this.__rest || function (s, e) {
  var t = {};

  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.config = exports.PureTable = exports.themes = exports.computeVizProps = void 0;

var config_1 = __webpack_require__(242);

exports.config = config_1.default;

var withDashboardViz_1 = __webpack_require__(27);

var PureTable_1 = __webpack_require__(243);

exports.PureTable = PureTable_1.default;

var computeVizProps = function computeVizProps(_a) {
  var themeFunc = _a.themeFunc,
      props = __rest(_a, ["themeFunc"]);

  if (!props.showInternalFields) {
    var filteredFields = [];
    var filteredTable = [];
    var filteredIndexes = [];
    props.headers.forEach(function (fieldIn, index) {
      var _a;

      var field = (_a = fieldIn.name) !== null && _a !== void 0 ? _a : fieldIn;

      if (field.charAt(0) !== '_' || field === '_time') {
        filteredFields.push(field);
        filteredTable.push(props.table[index]);
        filteredIndexes.push(index);
      }
    });
    var filteredTableFormat = null;

    if (props.tableFormat) {
      filteredTableFormat = {};
      Object.keys(props.tableFormat).forEach(function (tableFormatKey, index) {
        if (Array.isArray(props.tableFormat[tableFormatKey])) {
          filteredTableFormat[tableFormatKey] = props.tableFormat[tableFormatKey].filter(function (tableFormatItem, tableFormatItemIndex) {
            return filteredIndexes.indexOf(tableFormatItemIndex) !== -1;
          });
        } else {
          filteredTableFormat[tableFormatKey] = props.tableFormat[tableFormatKey];
        }
      });
    }

    return Object.assign(Object.assign({}, props), {
      headers: filteredFields,
      table: filteredTable,
      tableFormat: filteredTableFormat
    });
  }

  return props;
};

exports.computeVizProps = computeVizProps;
var Table = withDashboardViz_1.default({
  ReactViz: PureTable_1.default,
  vizConfig: config_1.default,
  computeVizProps: exports.computeVizProps
});
var themes = Table['themes'];
exports.themes = themes;
exports.default = Table;

/***/ }),

/***/ 13:
/***/ (function(module, exports) {

module.exports = require("@splunk/visualizations-shared/style");

/***/ }),

/***/ 14:
/***/ (function(module, exports) {

module.exports = require("@splunk/visualizations-shared/schemaUtils");

/***/ }),

/***/ 16:
/***/ (function(module, exports) {

module.exports = require("@babel/runtime/helpers/createClass");

/***/ }),

/***/ 17:
/***/ (function(module, exports) {

module.exports = require("@splunk/visualizations-shared/SizeAwareWrapper");

/***/ }),

/***/ 19:
/***/ (function(module, exports) {

module.exports = require("@splunk/themes/variables");

/***/ }),

/***/ 2:
/***/ (function(module, exports) {

module.exports = require("lodash");

/***/ }),

/***/ 21:
/***/ (function(module, exports) {

module.exports = require("@splunk/themes/pick");

/***/ }),

/***/ 22:
/***/ (function(module, exports) {

module.exports = require("@babel/runtime/helpers/typeof");

/***/ }),

/***/ 23:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _defineProperty = __webpack_require__(6);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getSortingParams = exports.SortParamsPropTypes = void 0;

var T = __webpack_require__(0);

var lodash_1 = __webpack_require__(2);

var DataSource_1 = __webpack_require__(33);

exports.SortParamsPropTypes = T.shape({
  currentSortKey: T.string,
  currentSortDir: T.oneOf(DataSource_1.validSortDirs),
  onSort: T.func
});

var getSortingParams = function getSortingParams(_ref) {
  var requestParams = _ref.requestParams,
      onRequestParamsChange = _ref.onRequestParamsChange;
  var currentSortKey;
  var currentSortDir;
  var nextSortDirMap = {
    asc: 'desc',
    desc: 'asc',
    none: 'asc'
  };
  var onSort;

  if (lodash_1.isFunction(onRequestParamsChange)) {
    if (requestParams && lodash_1.has(requestParams, 'sort')) {
      currentSortKey = Object.keys(requestParams.sort).shift();
      currentSortDir = requestParams.sort[currentSortKey];
    } // undid memoization since there is a dependency on requestParams, which is a deeply nested object


    onSort = function onSort(e, _ref2) {
      var sortKey = _ref2.sortKey,
          sortDir = _ref2.sortDir;

      if (typeof sortKey === 'string') {
        var nextSortDir = lodash_1.has(nextSortDirMap, sortDir) ? nextSortDirMap[sortDir] : 'none';
        onRequestParamsChange(Object.assign(Object.assign({}, requestParams), {
          offset: 0,
          sort: _defineProperty({}, sortKey, nextSortDir)
        }));
      } else {
        onRequestParamsChange(requestParams);
      }
    };
  }

  return {
    currentSortKey: currentSortKey,
    currentSortDir: currentSortDir,
    onSort: onSort
  };
};

exports.getSortingParams = getSortingParams;

/***/ }),

/***/ 24:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getPaginationParams = exports.PaginatorParamsPropTypes = void 0;

var T = __webpack_require__(0);

var lodash_1 = __webpack_require__(2);

exports.PaginatorParamsPropTypes = T.shape({
  isPaging: T.bool,
  current: T.number,
  totalPages: T.number,
  onChange: T.func
});

var getPaginationParams = function getPaginationParams(_ref) {
  var requestParams = _ref.requestParams,
      meta = _ref.meta,
      onRequestParamsChange = _ref.onRequestParamsChange;
  var totalCount = meta && meta.totalCount || 0;
  var offset = requestParams && requestParams.offset || 0;
  var count = requestParams && requestParams.count;
  var totalPages = typeof count === 'number' && count > 0 ? Math.ceil(totalCount / count) : 0;
  var current = typeof count === 'number' && count > 0 ? Math.floor(offset / count) + 1 : 0;
  var isPaging = totalPages > 1 && lodash_1.isFunction(onRequestParamsChange);

  var onChangeHandler = function onChangeHandler(e, _ref2) {
    var page = _ref2.page,
        countArg = _ref2.count;
    var newParams = lodash_1.cloneDeep(requestParams);

    if (typeof countArg === 'number') {
      newParams.count = countArg;
      newParams.offset = 0;
    }

    var pageCount = typeof newParams.count === 'number' ? newParams.count : 10;

    if (typeof page === 'number' && page > 0) {
      newParams.count = pageCount;
      newParams.offset = (page - 1) * pageCount;
    }

    onRequestParamsChange(newParams);
  };

  return {
    isPaging: isPaging,
    current: current,
    totalPages: totalPages,
    onChange: lodash_1.isFunction(onRequestParamsChange) ? onChangeHandler : lodash_1.noop
  };
};

exports.getPaginationParams = getPaginationParams;

/***/ }),

/***/ 241:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function get() {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __exportStar = this && this.__exportStar || function (m, exports) {
  for (var p in m) {
    if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
  }
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0; // NOTE: wildcard syntax only works for named exports
// for some reason, omitting the default export worked before TS v4
// see: https://stackoverflow.com/a/34445175

__exportStar(__webpack_require__(128), exports);

var Table_1 = __webpack_require__(128);

Object.defineProperty(exports, "default", {
  enumerable: true,
  get: function get() {
    return Table_1.default;
  }
});

/***/ }),

/***/ 242:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _toConsumableArray = __webpack_require__(39);

Object.defineProperty(exports, "__esModule", {
  value: true
});

var i18n_1 = __webpack_require__(3);

var lodash_1 = __webpack_require__(2);

var schemaUtils_1 = __webpack_require__(14);

var colorConstants_1 = __webpack_require__(40);

var visualization_icons_1 = __webpack_require__(42);

var variables_1 = __webpack_require__(19);

var pick_1 = __webpack_require__(21);

var configUtils_1 = __webpack_require__(8);

var VizBehavior_1 = __webpack_require__(5);

var consts_1 = __webpack_require__(103);

var VizCategory_1 = __webpack_require__(26);

var dataContract = {
  requiredDataSources: [{
    name: 'primary',
    description: 'DataSource that powers the visualization'
  }],
  optionalDataSources: [],
  initialRequestParams: {
    primary: function primary() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      return {
        offset: 0,
        count: options.count ? options.count : 10,
        requestTotalCount: true
      };
    }
  }
};
var size = {
  initialWidth: 300,
  initialHeight: 300
};
var defaultContext = {
  tableAlignByType: [{
    match: 'string',
    value: 'left'
  }, {
    match: 'number',
    value: 'right'
  }, {
    match: 'time',
    value: 'left'
  }, {
    match: 'color',
    value: 'left'
  }, {
    match: 'array',
    value: 'left'
  }, {
    match: 'sparkline',
    value: 'center'
  }, {
    match: 'unknown',
    value: 'left'
  }],
  tableCellTypeByType: [{
    match: 'string',
    value: 'TextCell'
  }, {
    match: 'number',
    value: 'TextCell'
  }, {
    match: 'time',
    value: 'TextCell'
  }, {
    match: 'color',
    value: 'TextCell'
  }, {
    match: 'array',
    value: 'ArrayCell'
  }, {
    match: 'sparkline',
    value: 'SparklineCell'
  }, {
    match: 'unknown',
    value: 'TextCell'
  }],
  // NOTE: These contexts are used by the table background color editor.
  // Please be careful removing/renaming/altering them.
  // There are unit tests and visual test that will capture breakages.
  tableRowColorMaxContrast: {
    colors: ['> themes.textColor', '> themes.inverseTextColor'],
    default: '> themes.textColor'
  },
  tableRowBackgroundColorEvenConfig: {
    channel: 'hsv.v',
    value: '*0.96'
  },
  tableHeaderBackgroundColorConfig: {
    channel: 'hsv.v',
    value: '*0.9'
  },
  tableRowBackgroundColorsByTheme: ['> themes.rowBackgroundColorOdd'],
  tableAltRowBackgroundColorsByTheme: ['> themes.rowBackgroundColorOdd', '> themes.rowBackgroundColorEven'],
  tableRowBackgroundColorsByBackgroundColor: ['> backgroundColor'],
  tableAltRowBackgroundColorsByBackgroundColor: ['> backgroundColor', '> backgroundColor | setColorChannel(tableRowBackgroundColorEvenConfig)']
};
var unitPositionConfig = {
  label: i18n_1._('Units Position'),
  editor: 'editor.select',
  option: 'unitPosition',
  editorProps: {
    values: [{
      label: i18n_1._('Before'),
      value: 'before'
    }, {
      label: i18n_1._('After'),
      value: 'after'
    }]
  }
};
var unitLabelConfig = {
  label: i18n_1._('Unit Label'),
  option: 'unit',
  editor: 'editor.text'
};
var sequentialColorConfig = [{
  to: 20,
  value: '#D41F1F'
}, {
  from: 20,
  to: 40,
  value: '#D94E17'
}, {
  from: 40,
  to: 60,
  value: '#CBA700'
}, {
  from: 60,
  to: 80,
  value: '#669922'
}, {
  from: 80,
  value: '#118832'
}];
var optionsSchema = {
  backgroundColor: {
    default: '> themes.defaultBackgroundColor',
    description: 'Specify the color for the background. You may use a dataSource to apply the color. The default for enterprise light is "#ffffff". The default for enterprise dark is "#000000". The default for prisma dark is "#0b0c0e".',
    pattern: schemaUtils_1.COLOR_OR_TOKEN_PATTERN,
    type: 'string'
  },
  columnFormat: {
    description: 'Allows users to set column formatting for individual columns.',
    type: 'object',
    patternProperties: {
      '.*': {
        description: 'Customization for column property',
        type: 'object',
        properties: {
          align: {
            description: 'Alignment for each cell in the column. Valid alignments include "left", "center", and "right".',
            type: 'array',
            items: {
              type: 'string',
              enum: consts_1.validAlignments.concat()
            }
          },
          cellTypes: {
            description: 'Cell renderer for each cell in the column. Valid cell renders include "TextCell", "ArrayCell", "SparklineCell".',
            type: 'array',
            items: {
              type: 'string',
              enum: consts_1.validCellRenderers.concat()
            }
          },
          data: {
            description: 'Array of datapoint to be displayed in the column rows.',
            type: 'array',
            items: {
              oneOf: [{
                type: 'string'
              }, {
                type: 'number'
              }, {
                type: 'array',
                items: {
                  type: ['string', 'number']
                }
              }]
            }
          },
          rowBackgroundColors: {
            description: 'Array of colors for background color of each row of the column of the table.',
            type: 'array',
            items: {
              type: 'string',
              pattern: schemaUtils_1.COLOR_OR_TOKEN_PATTERN
            }
          },
          rowColors: {
            description: 'Array of colors for text color of each row of the column of the table.',
            type: 'array',
            items: {
              type: 'string',
              pattern: schemaUtils_1.COLOR_OR_TOKEN_PATTERN
            }
          },
          sparklineAreaColors: {
            description: 'Array of colors for sparkline area color of each row of the column of the table.',
            type: 'array',
            items: {
              type: 'string',
              pattern: schemaUtils_1.COLOR_OR_TOKEN_PATTERN
            }
          },
          sparklineColors: {
            description: 'Array of colors for sparkline line color of each row of the column of the table.',
            type: 'array',
            items: {
              type: 'string',
              pattern: schemaUtils_1.COLOR_OR_TOKEN_PATTERN
            }
          },
          sparklineTypes: {
            description: 'Area or Line Sparkline. Valid sparkline types include "line", "area".',
            type: 'array',
            items: {
              type: 'string',
              enum: consts_1.validSparklineTypes.concat()
            }
          },
          textOverflow: {
            description: 'Controls how the text should be truncated within a particular column. Valid types include "anywhere", "break-word", "ellipsis". Defaults width for ellipsis is 100px.',
            type: 'string',
            pattern: schemaUtils_1.getPattern(consts_1.validTextOverflows),
            enum: consts_1.validTextOverflows.concat()
          },
          width: {
            description: 'Controls how wide in pixels (where 1px = 1/96th of 1in) the column should be displayed.',
            type: 'number'
          }
        }
      }
    }
  },
  count: {
    description: 'Specify the maximum number of rows to display.',
    type: 'number',
    default: 10
  },
  headers: {
    default: '> table | getField()',
    description: 'Array of headers to display on the table.',
    type: 'array',
    items: {
      type: 'string'
    }
  },
  headerVisibility: {
    default: 'inline',
    description: 'Header visibility can be none, fixed (docked) or inline.',
    pattern: schemaUtils_1.getPattern(consts_1.validHeaderVisibilities),
    enum: consts_1.validHeaderVisibilities.concat(),
    type: 'string'
  },
  paginateDataSourceKey: {
    default: 'primary',
    description: 'Use the specified datasource key for pagination and sorting.',
    type: 'string'
  },
  showRowNumbers: {
    default: false,
    description: 'Show row numbers in the first column.',
    type: 'boolean'
  },
  showInternalFields: {
    default: true,
    description: 'Specify whether to show internal fields that start with an underscore. The _time field will still be shown if false.',
    type: 'boolean'
  },
  table: {
    default: '> primary',
    description: 'Two dimensional array of data to be displayed in the table.',
    type: 'array',
    items: {
      type: 'array',
      items: {
        oneOf: [{
          type: 'string'
        }, {
          type: 'number'
        }, {
          type: 'array',
          items: {
            type: ['string', 'number']
          }
        }]
      }
    }
  },
  tableFormat: {
    description: 'Allows users to set table wide options.',
    type: 'object',
    properties: {
      align: {
        default: '> table | type() | matchValue(tableAlignByType)',
        description: 'Alignment for each cell in the table. Valid alignments include "left", "center", and "right".',
        type: 'array',
        items: {
          type: 'array',
          items: {
            type: 'string',
            enum: consts_1.validAlignments.concat()
          }
        }
      },
      cellTypes: {
        default: '> table | type() | matchValue(tableCellTypeByType)',
        description: 'Render the data in one of the supported cell type. Valid cell renders include "TextCell", "ArrayCell", "SparklineCell".',
        type: 'array',
        items: {
          type: 'array',
          items: {
            type: 'string',
            enum: consts_1.validCellRenderers.concat()
          }
        }
      },
      data: {
        description: 'Two dimensional data to be displayed in the table. This is usually formatted data instead of raw data from search.',
        type: 'array',
        items: {
          type: 'array',
          items: {
            oneOf: [{
              type: 'string'
            }, {
              type: 'number'
            }, {
              type: 'array',
              items: {
                type: ['string', 'number']
              }
            }]
          }
        }
      },
      headerBackgroundColor: {
        default: '> themes.defaultHeaderBackgroundColor',
        description: 'Background color of table header.',
        pattern: schemaUtils_1.COLOR_OR_TOKEN_PATTERN,
        type: 'string'
      },
      headerColor: {
        description: 'Text color of the table header.',
        pattern: schemaUtils_1.COLOR_OR_TOKEN_PATTERN,
        type: 'string'
      },
      rowBackgroundColors: {
        default: '> table | seriesByIndex(0) | pick(tableAltRowBackgroundColorsByTheme)',
        description: 'Array of colors for background color of each row of the table.',
        type: 'array',
        items: {
          type: 'array',
          items: {
            type: 'string',
            pattern: schemaUtils_1.COLOR_OR_TOKEN_PATTERN
          }
        }
      },
      rowColors: {
        description: 'Array of colors for text color of each row of the table.',
        type: 'array',
        items: {
          type: 'array',
          items: {
            type: 'string',
            pattern: schemaUtils_1.COLOR_OR_TOKEN_PATTERN_WITH_RGBA
          }
        }
      },
      sparklineAreaColors: {
        description: 'Array of colors for sparkline area of each row of the table.',
        type: 'array',
        items: {
          type: 'array',
          items: {
            type: 'string',
            pattern: schemaUtils_1.COLOR_OR_TOKEN_PATTERN
          }
        }
      },
      sparklineColors: {
        description: 'Array of colors for sparkline line of each row of the table.',
        type: 'array',
        items: {
          type: 'array',
          items: {
            type: 'string',
            pattern: schemaUtils_1.COLOR_OR_TOKEN_PATTERN
          }
        }
      },
      sparklineTypes: {
        description: 'Area or Line Sparkline. Valid sparkline types include "line", "area".',
        type: 'array',
        items: {
          type: 'array',
          items: {
            type: 'string',
            enum: consts_1.validSparklineTypes.concat()
          }
        }
      }
    }
  }
};
var themes = {
  defaultBackgroundColor: function defaultBackgroundColor(props) {
    return pick_1.default({
      enterprise: {
        dark: variables_1.default.black(props),
        light: variables_1.default.backgroundColor(props)
      },
      prisma: variables_1.default.backgroundColorSidebar(props)
    })(props);
  },
  defaultHeaderBackgroundColor: function defaultHeaderBackgroundColor(props) {
    return pick_1.default({
      enterprise: {
        dark: variables_1.default.gray20(props),
        light: variables_1.default.gray92(props)
      },
      prisma: variables_1.default.backgroundColor(props)
    })(props);
  },
  rowBackgroundColorEven: function rowBackgroundColorEven(props) {
    return pick_1.default({
      enterprise: {
        dark: variables_1.default.black(props),
        light: variables_1.default.gray96(props)
      },
      prisma: variables_1.default.backgroundColorPage(props)
    })(props);
  },
  rowBackgroundColorOdd: function rowBackgroundColorOdd(props) {
    return pick_1.default({
      enterprise: {
        dark: '#0D1012',
        light: variables_1.default.backgroundColor(props)
      },
      prisma: variables_1.default.backgroundColorSidebar(props)
    })(props);
  },
  textColor: function textColor(props) {
    return pick_1.default({
      enterprise: variables_1.default.textColor(props),
      prisma: variables_1.default.contentColorDefault(props)
    })(props);
  },
  inverseTextColor: function inverseTextColor(props) {
    return pick_1.default({
      enterprise: {
        dark: variables_1.default.contentColorInverted(props),
        light: variables_1.default.white(props) // equal to textColor in enterpriseDark

      },
      prisma: variables_1.default.contentColorInverted(props)
    })(props);
  }
};
var backgroundColorPaletteSet = new Set([].concat(_toConsumableArray(colorConstants_1.COLOR_EDITOR_PALETTE), _toConsumableArray(lodash_1.map(themes, function (t) {
  return lodash_1.get(t, 'defaultBackgroundColor');
}))));
var EDITOR_LABEL_WIDTH = 100;
var editorConfig = [{
  label: i18n_1._('Global Formatting'),
  layout: [[{
    label: i18n_1._('Rows Displayed'),
    option: 'count',
    editor: 'editor.number',
    editorProps: {
      labelPosition: 'left',
      min: 0,
      labelWidth: EDITOR_LABEL_WIDTH
    }
  }], [{
    label: i18n_1._('Row Numbers'),
    option: 'showRowNumbers',
    editor: 'editor.toggle',
    editorProps: {
      labelPosition: 'left',
      labelWidth: EDITOR_LABEL_WIDTH
    }
  }], [{
    label: i18n_1._('Internal Fields'),
    option: 'showInternalFields',
    editor: 'editor.toggle',
    editorProps: {
      labelPosition: 'left',
      labelWidth: EDITOR_LABEL_WIDTH
    }
  }], [{
    label: i18n_1._('Header Row'),
    option: 'headerVisibility',
    editor: 'editor.radioBar',
    editorProps: {
      values: [{
        label: i18n_1._('Inline'),
        value: 'inline'
      }, {
        label: i18n_1._('Fixed'),
        value: 'fixed'
      }, {
        label: i18n_1._('Hidden'),
        value: 'none'
      }],
      labelPosition: 'left',
      labelWidth: EDITOR_LABEL_WIDTH
    }
  }], [{
    key: 'backgroundColor',
    editor: 'editor.tableBackgroundColor',
    editorProps: {
      themes: themes,
      labelPosition: 'left',
      labelWidth: EDITOR_LABEL_WIDTH,
      palette: _toConsumableArray(backgroundColorPaletteSet)
    }
  }]]
}, {
  label: i18n_1._('Column Formatting'),
  layout: [[{
    label: i18n_1._(''),
    editor: 'editor.tableColumnFormatter',
    editorProps: {
      // Table column coloring does not adhere to same DSL structure as other dynamically colored options
      // we use the FormatterEditor directly and not the DynamicColorEditor's provided DSL builders
      columnColoringConfig: {
        coloringTypes: [{
          label: i18n_1._('Text'),
          value: 'rowColors'
        }, {
          label: i18n_1._('Background'),
          value: 'rowBackgroundColors'
        }],
        formatters: [{
          label: i18n_1._('Ranges'),
          value: 'rangeValue',
          defaults: {
            rowBackgroundColors: sequentialColorConfig,
            rowColors: sequentialColorConfig
          }
        }],
        themes: themes
      },
      defaultOptionsByType: {
        number: {
          thousandSeparated: false,
          unitPosition: 'after'
        },
        string: {
          unitPosition: 'after'
        }
      },
      flyoutConfig: {
        number: [[Object.assign({}, unitPositionConfig), Object.assign({}, unitLabelConfig)], [{
          label: i18n_1._('Precision'),
          option: 'precision',
          editor: 'editor.select',
          editorProps: {
            values: configUtils_1.generatePrecisionValues(20)
          }
        }, {
          label: i18n_1._('Thousand Separators'),
          option: 'thousandSeparated',
          editor: 'editor.radioBar',
          editorProps: {
            values: [{
              label: i18n_1._('Off'),
              value: false
            }, {
              label: i18n_1._('On'),
              value: true
            }]
          }
        }]],
        // TODO(fkurniawan): fill in with proper editor components
        sparkline: [],
        string: [[Object.assign({}, unitPositionConfig), Object.assign({}, unitLabelConfig)]],
        time: []
      },
      value: function value(_ref) {
        var context = _ref.context,
            options = _ref.options;
        return {
          context: context,
          columnFormat: options.columnFormat,
          tableFormat: options.tableFormat
        };
      }
    },
    key: 'TableColumnFormatterEditor'
  }]]
}];
/**
 * visualization configuration
 */

var config = {
  /**
   * unique viz key
   */
  key: 'splunk.table',

  /**
   * viz name
   */
  name: 'Table',
  category: VizCategory_1.VizCategory.TABLE,

  /**
   * viz icon
   */
  icon: visualization_icons_1.Table,
  dataContract: dataContract,
  size: size,
  defaultContext: defaultContext,
  optionsSchema: optionsSchema,
  editorConfig: editorConfig,
  events: {
    'cell.click': {
      description: 'triggered when user clicks a table cell'
    }
  },
  supports: [VizBehavior_1.VizBehavior.DYNAMIC_OPTIONS, VizBehavior_1.VizBehavior.EVENTS, VizBehavior_1.VizBehavior.PAGE_AND_SORT, VizBehavior_1.VizBehavior.PLACEHOLDER],
  themes: themes
};
exports.default = configUtils_1.enhanceConfig(config);

/***/ }),

/***/ 243:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _taggedTemplateLiteral = __webpack_require__(94);

var _templateObject, _templateObject2;

var __rest = this && this.__rest || function (s, e) {
  var t = {};

  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var React = __webpack_require__(1);

var T = __webpack_require__(0);

var lodash_1 = __webpack_require__(2);

var debounce = __webpack_require__(244);

var styled_components_1 = __webpack_require__(4);

var i18n_1 = __webpack_require__(3);

var Table_1 = __webpack_require__(76);

var Paginator_1 = __webpack_require__(245);

var Message_1 = __webpack_require__(246);

var colorUtils_1 = __webpack_require__(11);

var style_1 = __webpack_require__(13);

var pick_1 = __webpack_require__(21);

var variables_1 = __webpack_require__(19);

var getPagination_1 = __webpack_require__(24);

var getSorting_1 = __webpack_require__(23);

var FixedSizeContainer_1 = __webpack_require__(12);

var hooks_1 = __webpack_require__(247);

var consts_1 = __webpack_require__(103);

var cells_1 = __webpack_require__(248);

var NonVisibleTableHead = styled_components_1.default(Table_1.default.Head).withConfig({
  displayName: "PureTable__NonVisibleTableHead",
  componentId: "tovzjg-0"
})(["display:none;"]);
var VizTableContainer = styled_components_1.default.div.withConfig({
  displayName: "PureTable__VizTableContainer",
  componentId: "tovzjg-1"
})(["box-sizing:border-box;padding:", ";background-color:", ";display:flex;flex-flow:column nowrap;overflow:hidden;"], pick_1.default({
  enterprise: variables_1.default.spacingHalf,
  prisma: variables_1.default.spacingSmall
}), function (props) {
  return colorUtils_1.isColor(props.backgroundColor) && props.backgroundColor || props.theme.defaultBackgroundColor;
});
VizTableContainer.displayName = 'VizTableContainer';
var PAGINATOR_CONTAINER_HEIGHT = 38;
var PAGINATOR_SPACING = 5;
var SUITableContainer = styled_components_1.default.div.withConfig({
  displayName: "PureTable__SUITableContainer",
  componentId: "tovzjg-2"
})(["box-sizing:border-box;flex-grow:1;overflow:hidden;", ";", ";", " ", ""], function (_ref) {
  var width = _ref.width,
      height = _ref.height,
      isPaging = _ref.isPaging,
      theme = _ref.theme;
  var padding = pick_1.default({
    enterprise: variables_1.default.spacingHalf({
      theme: theme
    }),
    prisma: variables_1.default.spacingSmall({
      theme: theme
    })
  })({
    theme: theme
  });
  var paddingOffset = parseInt(padding, 10) * 2;
  return style_1.toDimension({
    width: width - paddingOffset,
    height: isPaging ? height - PAGINATOR_CONTAINER_HEIGHT - PAGINATOR_SPACING - paddingOffset : height - paddingOffset
  });
}, function (_ref2) {
  var isPaging = _ref2.isPaging;
  return isPaging && "\n        margin-bottom: ".concat(PAGINATOR_SPACING, "px;\n    ");
}, function (_ref3) {
  var headerStyle = _ref3.headerStyle;
  return headerStyle && headerStyle.backgroundColor && styled_components_1.css(_templateObject || (_templateObject = _taggedTemplateLiteral(["\n            & [data-test='head-cell'] {\n                background-color: ", ";\n            }\n        "])), headerStyle.backgroundColor);
}, function (_ref4) {
  var headerStyle = _ref4.headerStyle;
  return headerStyle && headerStyle.color && styled_components_1.css(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral(["\n            & [data-test='head-cell'] > div > span {\n                color: ", ";\n            }\n        "])), headerStyle.color);
});
SUITableContainer.displayName = 'SUITableContainer';
var PaginatorContainer = styled_components_1.default.div.withConfig({
  displayName: "PureTable__PaginatorContainer",
  componentId: "tovzjg-3"
})(["position:relative;text-align:right;height:", "px;"], PAGINATOR_CONTAINER_HEIGHT);
PaginatorContainer.displayName = 'PaginatorContainer'; // allow for early return in case of empty tableBody while still following hook rules

var withEmptyTableMessage = function withEmptyTableMessage(Viz) {
  // TODO(fkurniawan): add omit type to differentiate WrapperProps from PureTableProps
  var Wrapper = function Wrapper(props) {
    var headers = props.headers,
        table = props.table,
        headerVisibility = props.headerVisibility,
        showRowNumbers = props.showRowNumbers,
        tableFormat = props.tableFormat,
        columnFormat = props.columnFormat;

    var _hooks_1$useTable = hooks_1.useTable({
      headers: headers,
      table: table,
      headerVisibility: headerVisibility,
      showRowNumbers: showRowNumbers,
      tableFormat: tableFormat,
      columnFormat: columnFormat
    }),
        tableHeader = _hooks_1$useTable.tableHeader,
        tableBody = _hooks_1$useTable.tableBody;

    if (tableBody.rows.length === 0) {
      return React.createElement(Message_1.default, {
        type: "warning"
      }, i18n_1._('No data!'));
    }

    return React.createElement(Viz, Object.assign({}, props, {
      tableHeader: tableHeader,
      tableBody: tableBody
    }));
  };

  Wrapper.displayName = 'PureTableWrapper';
  return Wrapper;
};

var PureTable = function PureTable(props) {
  var count = props.count,
      width = props.width,
      height = props.height,
      backgroundColor = props.backgroundColor,
      tableHeader = props.tableHeader,
      tableBody = props.tableBody,
      showRowNumbers = props.showRowNumbers,
      _props$sortParams = props.sortParams,
      currentSortKey = _props$sortParams.currentSortKey,
      currentSortDir = _props$sortParams.currentSortDir,
      onSort = _props$sortParams.onSort,
      _a = props.paginatorParams,
      isPaging = _a.isPaging,
      paginatorProps = __rest(_a, ["isPaging"]),
      onCellClick = props.onCellClick;

  var firstRenderCount = React.useRef(count);
  React.useEffect(function () {
    if (firstRenderCount.current !== count) {
      firstRenderCount.current = count;
      paginatorProps.onChange(null, {
        count: count
      });
    }
  }, [count, paginatorProps]);
  var TableHead = tableHeader.visibility === 'none' ? NonVisibleTableHead : Table_1.default.Head;
  var debouncedDrilldown = debounce(function (e, payload) {
    if (window.getSelection().toString() === '') {
      lodash_1.isFunction(onCellClick) && onCellClick({
        e: e,
        payload: payload
      });
    }
  }, 200);
  var drilldownHandler = React.useCallback(function (e) {
    var element = e.target;
    var row = element.getAttribute('data-row-index');
    var col = element.getAttribute('data-col-index');
    var arrayIndex = element.getAttribute('data-array-index') || -1;

    if (row && col) {
      var cellRefIndex = +col;
      var cellIndex = cellRefIndex;
      var rowIndex = +row;
      var fieldValue = tableHeader.cells[cellRefIndex].value;
      var cellValue = tableBody.rows[rowIndex].cells[cellRefIndex].value;
      var cellRawValue = tableBody.rows[rowIndex].cells[cellRefIndex].value;
      var value = arrayIndex === -1 ? cellValue : cellRawValue[+arrayIndex]; // Wish we did not have these if statements for
      // showRowNumbers

      if (showRowNumbers === true) {
        if (cellIndex === 0) {
          // no click event for row numbers
          return;
        }

        cellIndex--;
      }

      var payload = {
        cellIndex: cellIndex,
        rowIndex: rowIndex,
        fieldValue: fieldValue,
        cellValue: cellValue,
        cellRawValue: cellRawValue,
        value: value,
        name: fieldValue
      };
      tableBody.rows[rowIndex].cells.forEach(function (c, index) {
        var rowToken = 'row.' + tableHeader.cells[index].value + '.value';
        payload[rowToken] = c.value;
      });
      debouncedDrilldown(e.nativeEvent, payload);
    }
  }, [onCellClick, showRowNumbers, tableHeader, tableBody]);
  return React.createElement(VizTableContainer, {
    backgroundColor: backgroundColor
  }, React.createElement(SUITableContainer, {
    width: width,
    height: height,
    isPaging: isPaging,
    headerStyle: tableHeader.style
  }, React.createElement(Table_1.default, {
    headType: tableHeader.visibility !== 'none' ? tableHeader.visibility : undefined,
    innerStyle: {
      height: '100%'
    },
    outerStyle: {
      height: '100%',
      cursor: onCellClick ? 'pointer' : 'unset'
    },
    onClick: onCellClick ? drilldownHandler : lodash_1.noop
  }, React.createElement(TableHead, null, tableHeader.cells.map(function (_a) {
    var key = _a.key,
        value = _a.value,
        sortKey = _a.sortKey,
        rest = __rest(_a, ["key", "value", "sortKey"]);

    return React.createElement(Table_1.default.HeadCell, Object.assign({
      key: key,
      sortDir: sortKey === currentSortKey ? currentSortDir : 'none'
    }, Object.assign({
      sortKey: sortKey,
      onSort: onSort
    }, rest)), value);
  })), React.createElement(Table_1.default.Body, null, tableBody.rows.map(function (row) {
    return React.createElement(Table_1.default.Row, {
      key: row.key
    }, row.cells.map(function (cell) {
      return React.createElement(cells_1.SwitchTableCell, {
        key: cell.key,
        type: cell.cellType
      }, React.createElement(cells_1.TextCell, {
        cell: cell,
        useMouseOverEffect: !!onCellClick
      }), React.createElement(cells_1.SparklineCell, {
        cell: cell,
        useMouseOverEffect: !!onCellClick
      }), React.createElement(cells_1.ArrayCell, {
        cell: cell,
        useMouseOverEffect: !!onCellClick
      }));
    }));
  })))), isPaging ? React.createElement(PaginatorContainer, null, React.createElement(Paginator_1.default, Object.assign({}, paginatorProps))) : null);
};

var cellDataType = T.oneOfType([T.string, T.number, T.arrayOf(T.oneOfType([T.string, T.number]))]);
PureTable.propTypes = {
  backgroundColor: T.string,
  count: T.number,
  columnFormat: T.objectOf(T.shape({
    align: T.arrayOf(T.oneOf(consts_1.validAlignments)),
    cellTypes: T.arrayOf(T.oneOf(consts_1.validCellRenderers)),
    data: T.arrayOf(cellDataType),
    rowBackgroundColors: T.arrayOf(T.string),
    rowColors: T.arrayOf(T.string),
    sparklineAreaColors: T.arrayOf(T.string),
    sparklineColors: T.arrayOf(T.string),
    sparklineTypes: T.arrayOf(T.oneOf(consts_1.validSparklineTypes))
  })),
  headers: T.arrayOf(T.string),
  headerVisibility: T.oneOf(consts_1.validHeaderVisibilities),
  height: T.oneOfType([T.number]),
  mode: T.string,
  onCellClick: T.func,
  paginatorParams: getPagination_1.PaginatorParamsPropTypes,
  showRowNumbers: T.bool,
  sortParams: getSorting_1.SortParamsPropTypes,
  table: T.arrayOf(T.arrayOf(cellDataType)),
  tableFormat: T.shape({
    align: T.arrayOf(T.arrayOf(T.oneOf(consts_1.validAlignments))),
    cellTypes: T.arrayOf(T.arrayOf(T.oneOf(consts_1.validCellRenderers))),
    data: T.arrayOf(T.arrayOf(cellDataType)),
    headerBackgroundColor: T.string,
    headerColor: T.string,
    rowBackgroundColors: T.oneOfType([T.arrayOf(T.string), T.arrayOf(T.arrayOf(T.string))]),
    rowColors: T.oneOfType([T.arrayOf(T.string), T.arrayOf(T.arrayOf(T.string))]),
    sparklineAreaColors: T.arrayOf(T.arrayOf(T.string)),
    sparklineColors: T.arrayOf(T.arrayOf(T.string)),
    sparklineTypes: T.arrayOf(T.arrayOf(T.oneOf(consts_1.validSparklineTypes)))
  }),
  width: T.oneOfType([T.number])
};
PureTable.defaultProps = {
  columnFormat: {},
  headers: [],
  headerVisibility: 'inline',
  height: 300,
  mode: 'view',
  onCellClick: null,
  paginatorParams: {
    isPaging: false,
    onChange: lodash_1.noop
  },
  showRowNumbers: false,
  sortParams: {
    onSort: lodash_1.noop
  },
  table: [],
  tableFormat: {},
  theme: {},
  width: 300
};
PureTable.displayName = 'VizTable';
exports.default = withEmptyTableMessage(FixedSizeContainer_1.default(PureTable));

/***/ }),

/***/ 244:
/***/ (function(module, exports) {

module.exports = require("lodash/debounce");

/***/ }),

/***/ 245:
/***/ (function(module, exports) {

module.exports = require("@splunk/react-ui/Paginator");

/***/ }),

/***/ 246:
/***/ (function(module, exports) {

module.exports = require("@splunk/react-ui/Message");

/***/ }),

/***/ 247:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _toConsumableArray = __webpack_require__(39);

var _typeof = __webpack_require__(22);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useTable = exports.getTextOverflowType = exports.getOverflowStyles = void 0;

var lodash_1 = __webpack_require__(2);

var colorUtils_1 = __webpack_require__(11);

var style_1 = __webpack_require__(13);

var consts_1 = __webpack_require__(103);

var isArray = function isArray(v) {
  return Array.isArray(v);
};

var getOverflowStyles = function getOverflowStyles(_ref) {
  var textOverflow = _ref.textOverflow,
      variables = _ref.variables;
  var styles = {
    anywhere: {
      wordBreak: 'break-all'
    },
    'break-word': {
      wordBreak: 'break-word',
      wordWrap: 'break-word',
      overflowWrap: 'break-word'
    },
    ellipsis: {
      maxWidth: style_1.toPx(variables && variables.width || 100),
      whiteSpace: 'nowrap',
      overflow: 'hidden',
      textOverflow: 'ellipsis'
    }
  };
  return styles[textOverflow] || {};
};

exports.getOverflowStyles = getOverflowStyles;

var generateKey = function generateKey() {
  var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  var i = arguments.length > 1 ? arguments[1] : undefined;
  return "".concat(i, "-").concat(value);
};

var getTextOverflowType = function getTextOverflowType(columnFormat, currentColumn, defaultTextOverflow) {
  return lodash_1.get(columnFormat, "".concat(currentColumn, ".textOverflow")) || defaultTextOverflow;
};

exports.getTextOverflowType = getTextOverflowType;

var generateHeader = function generateHeader(value, i, columnFormat) {
  var ret = {
    key: generateKey(value, i),
    value: value,
    sortKey: value
  };
  var columnWidth = lodash_1.get(columnFormat, "".concat(value, ".width"));

  if (lodash_1.isNumber(columnWidth)) {
    var textOverflowType = exports.getTextOverflowType({}, value, 'ellipsis');
    var textOverflowStyle = exports.getOverflowStyles({
      textOverflow: textOverflowType,
      variables: {
        width: columnWidth
      }
    });
    ret['width'] = columnWidth;
    ret['truncate'] = true;
    ret['style'] = textOverflowStyle;
  }

  return ret;
};

var getColumnFormatAlign = function getColumnFormatAlign(columnFormat, currentColumn, currentRow) {
  var alignOption = lodash_1.get(columnFormat, [currentColumn.value, 'align']);
  var align;

  if (isArray(alignOption) && lodash_1.includes(consts_1.validAlignments, alignOption[currentRow])) {
    align = alignOption[currentRow];
  } else if (typeof alignOption !== 'undefined') {
    console.warn("columnFormat.".concat(currentColumn.value, ".align should be an array containing (").concat(consts_1.validAlignments.join(' | '), "). ").concat(JSON.stringify(alignOption), " provided"));
  }

  return align;
};

var getColumnFormatCellType = function getColumnFormatCellType(columnFormat, currentColumn, currentRow) {
  var cellTypes = lodash_1.get(columnFormat, [currentColumn.value, 'cellTypes']);
  var cellType;

  if (isArray(cellTypes) && lodash_1.includes(consts_1.validCellRenderers, cellTypes[currentRow])) {
    cellType = cellTypes[currentRow];
  } else if (typeof cellTypes !== 'undefined') {
    console.warn("columnFormat.".concat(currentColumn.value, ".cellType should be an array containing (").concat(consts_1.validCellRenderers.join(' | '), "). ").concat(JSON.stringify(cellTypes), " provided"));
  }

  return cellType;
};

var getColumnFormatSparklineType = function getColumnFormatSparklineType(columnFormat, currentColumn, currentRow) {
  var types = lodash_1.get(columnFormat, [currentColumn.value, 'sparklineTypes']);
  var sparklineType;

  if (isArray(types) && lodash_1.includes(consts_1.validSparklineTypes, types[currentRow])) {
    sparklineType = types[currentRow];
  } else if (typeof types !== 'undefined') {
    console.warn("columnFormat.".concat(currentColumn.value, ".sparklineTypes should be one of (").concat(consts_1.validSparklineTypes.join(' | '), "). ").concat(JSON.stringify(types), " provided"));
  }

  return sparklineType;
};

var getColumnFormatData = function getColumnFormatData(columnFormat, currentColumn, currentRow) {
  var data = lodash_1.get(columnFormat, [currentColumn.value, 'data']);
  var datum;

  if (isArray(data)) {
    datum = data[currentRow];
  } else if (typeof data !== 'undefined') {
    console.warn("columnFormat.".concat(currentColumn.value, ".data should be an array containing formatted data. ").concat(_typeof(data), " provided"));
  }

  return datum;
};

var getColumnFormatColor = function getColumnFormatColor(columnFormat, currentColumn, currentRow, field) {
  var colors = lodash_1.get(columnFormat, [currentColumn.value, field]);
  var color;

  if (isArray(colors) && colorUtils_1.isColor(colors[currentRow])) {
    color = colors[currentRow];
  } else if (typeof colors !== 'undefined') {
    console.warn("columnFormat.".concat(currentColumn.value, ".").concat(field, " should be an array containing valid colors. ").concat(JSON.stringify(colors), " provided"));
  }

  return color;
};

var getColumnFormatRowColor = function getColumnFormatRowColor(columnFormat, currentColumn, currentRow) {
  return getColumnFormatColor(columnFormat, currentColumn, currentRow, 'rowColors');
};

var getColumnFormatRowBgColor = function getColumnFormatRowBgColor(columnFormat, currentColumn, currentRow) {
  return getColumnFormatColor(columnFormat, currentColumn, currentRow, 'rowBackgroundColors');
};

var getColumnFormatSparklineColor = function getColumnFormatSparklineColor(columnFormat, currentColumn, currentRow) {
  return getColumnFormatColor(columnFormat, currentColumn, currentRow, 'sparklineColors');
};

var getColumnFormatSparklineAreaColor = function getColumnFormatSparklineAreaColor(columnFormat, currentColumn, currentRow) {
  return getColumnFormatColor(columnFormat, currentColumn, currentRow, 'sparklineAreaColors');
};

var getTableFormatAlign = function getTableFormatAlign(tableFormat, currentColumn, currentRow) {
  var alignOption = lodash_1.get(tableFormat, 'align');
  var align;

  if (isArray(alignOption) && isArray(alignOption[currentColumn]) && lodash_1.includes(consts_1.validAlignments, alignOption[currentColumn][currentRow])) {
    align = alignOption[currentColumn][currentRow];
  } else if (typeof alignOption !== 'undefined') {
    console.warn("tableFormat.align should be a 2 dimensional array containing (".concat(consts_1.validAlignments.join(' | '), "). ").concat(JSON.stringify(alignOption), " provided"));
  }

  return align;
};

var getTableFormatCellType = function getTableFormatCellType(tableFormat, currentColumn, currentRow) {
  var cellTypes = lodash_1.get(tableFormat, 'cellTypes');
  var cellType;

  if (isArray(cellTypes) && isArray(cellTypes[currentColumn]) && lodash_1.includes(consts_1.validCellRenderers, cellTypes[currentColumn][currentRow])) {
    cellType = cellTypes[currentColumn][currentRow];
  } else if (typeof cellTypes !== 'undefined') {
    console.warn("tableFormat.cellType should be a 2 dimensional array containing (".concat(consts_1.validCellRenderers.join(' | '), "). ").concat(JSON.stringify(cellTypes), " provided"));
  }

  return cellType;
};

var getTableFormatSparklineType = function getTableFormatSparklineType(tableFormat, currentColumn, currentRow) {
  var types = lodash_1.get(tableFormat, 'sparklineTypes');
  var sparklineType;

  if (isArray(types) && isArray(types[currentColumn]) && lodash_1.includes(consts_1.validSparklineTypes, types[currentColumn][currentRow])) {
    sparklineType = types[currentColumn][currentRow];
  } else if (typeof types !== 'undefined') {
    console.warn("tableFormat.sparklineTypes should be a 2 dimensional array containing one of (".concat(consts_1.validSparklineTypes.join(' | '), "). ").concat(JSON.stringify(types), " provided"));
  }

  return sparklineType;
};

var getTableFormatColor = function getTableFormatColor(tableFormat, currentColumn, currentRow, field) {
  var colors = lodash_1.get(tableFormat, field);
  var color;

  if (isArray(colors) && isArray(colors[currentColumn]) && colorUtils_1.isColor(colors[currentColumn][currentRow])) {
    color = colors[currentColumn][currentRow];
  } else if (isArray(colors) && colorUtils_1.isColor(colors[currentRow])) {
    color = colors[currentRow];
  } else if (typeof colors !== 'undefined' && isArray(colors) && isArray(colors[currentColumn]) && colors[currentColumn][currentRow] !== undefined) {
    console.warn("tableFormat.".concat(field, " needs to be an array of colors, provided ").concat(JSON.stringify(colors), ". Current value at [").concat(currentColumn, "][").concat(currentRow, "] is ").concat(JSON.stringify(colors[currentRow])));
  }

  return color;
};

var getTableFormatRowColor = function getTableFormatRowColor(tableFormat, currentCol, currentRow) {
  return getTableFormatColor(tableFormat, currentCol, currentRow, 'rowColors');
};

var getTableFormatRowBgColor = function getTableFormatRowBgColor(tableFormat, currentCol, currentRow) {
  return getTableFormatColor(tableFormat, currentCol, currentRow, 'rowBackgroundColors');
};

var getTableFormatSparklineColor = function getTableFormatSparklineColor(tableFormat, currentCol, currentRow) {
  return getTableFormatColor(tableFormat, currentCol, currentRow, 'sparklineColors');
};

var getTableFormatSparklineAreaColor = function getTableFormatSparklineAreaColor(tableFormat, currentCol, currentRow) {
  return getTableFormatColor(tableFormat, currentCol, currentRow, 'sparklineAreaColors');
};

var getTableFormatData = function getTableFormatData(tableFormat, currentCol, currentRow) {
  var data = lodash_1.get(tableFormat, 'data');
  var datum;

  if (isArray(data) && isArray(data[currentCol])) {
    datum = data[currentCol][currentRow];
  } else if (typeof data !== 'undefined') {
    console.warn("tableFormat.data should be a 2 dimensional array containing formatted data to be displayed. ".concat(_typeof(data), " provided"));
  }

  return datum;
};

var validValueSelector = function validValueSelector(v1, v2, v3, defaultValue) {
  var validTypes = ['string', 'number'];

  if (validTypes.includes(_typeof(v1)) || isArray(v1)) {
    return v1;
  }

  if (validTypes.includes(_typeof(v2)) || isArray(v2)) {
    return v2;
  }

  if (validTypes.includes(_typeof(v3)) || isArray(v3)) {
    return v3;
  }

  return defaultValue;
};

var useTable = function useTable() {
  var tableArgs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var _tableArgs$table = tableArgs.table,
      table = _tableArgs$table === void 0 ? [] : _tableArgs$table,
      _tableArgs$headers = tableArgs.headers,
      headers = _tableArgs$headers === void 0 ? [] : _tableArgs$headers;
  var _tableArgs$headerVisi = tableArgs.headerVisibility,
      headerVisibility = _tableArgs$headerVisi === void 0 ? 'inline' : _tableArgs$headerVisi,
      _tableArgs$showRowNum = tableArgs.showRowNumbers,
      showRowNumbers = _tableArgs$showRowNum === void 0 ? false : _tableArgs$showRowNum,
      _tableArgs$tableForma = tableArgs.tableFormat,
      tableFormat = _tableArgs$tableForma === void 0 ? {} : _tableArgs$tableForma,
      _tableArgs$columnForm = tableArgs.columnFormat,
      columnFormat = _tableArgs$columnForm === void 0 ? {} : _tableArgs$columnForm;
  var longestColumnLength = Math.max.apply(Math, _toConsumableArray(table.map(function (column) {
    return column.length;
  })));

  if (showRowNumbers) {
    headers = ['#'].concat(_toConsumableArray(headers));
    table = [Array.from({
      length: longestColumnLength
    }, function (v, i) {
      return i + 1;
    })].concat(_toConsumableArray(table));

    if (isArray(tableFormat.align)) {
      tableFormat.align = [new Array(longestColumnLength).fill('left')].concat(_toConsumableArray(tableFormat.align));
    }

    if (isArray(tableFormat.cellTypes)) {
      tableFormat.cellTypes = [new Array(longestColumnLength).fill('TextCell')].concat(_toConsumableArray(tableFormat.cellTypes));
    }

    if (isArray(tableFormat.data)) {
      tableFormat.data = [Array.from({
        length: longestColumnLength
      }, function (v, i) {
        return "".concat(i + 1);
      })].concat(_toConsumableArray(tableFormat.data));
    }

    if (isArray(tableFormat.rowBackgroundColors)) {
      if (tableFormat.rowBackgroundColors.length > 0 && isArray(tableFormat.rowBackgroundColors[0])) {
        tableFormat.rowBackgroundColors = [new Array(longestColumnLength)].concat(_toConsumableArray(tableFormat.rowBackgroundColors));
      }
    }

    if (isArray(tableFormat.rowColors)) {
      if (tableFormat.rowColors.length > 0 && isArray(tableFormat.rowColors[0])) {
        tableFormat.rowColors = [new Array(longestColumnLength)].concat(_toConsumableArray(tableFormat.rowColors));
      }
    }

    if (isArray(tableFormat.sparklineColors)) {
      tableFormat.sparklineColors = [new Array(longestColumnLength)].concat(_toConsumableArray(tableFormat.sparklineColors));
    }

    if (isArray(tableFormat.sparklineAreaColors)) {
      tableFormat.sparklineAreaColors = [new Array(longestColumnLength)].concat(_toConsumableArray(tableFormat.sparklineAreaColors));
    }

    if (isArray(tableFormat.sparklineTypes)) {
      tableFormat.sparklineTypes = [new Array(longestColumnLength).fill('area')].concat(_toConsumableArray(tableFormat.sparklineTypes));
    }
  }

  var tableHeader = {
    visibility: consts_1.validHeaderVisibilities.indexOf(headerVisibility) >= 0 ? headerVisibility : 'inline',
    cells: table.map(function (f, i) {
      if (i < headers.length) {
        return generateHeader(headers[i], i, columnFormat);
      } else {
        return generateHeader('', i, columnFormat);
      }
    }),
    style: {
      backgroundColor: lodash_1.has(tableFormat, 'headerBackgroundColor') && colorUtils_1.isColor(tableFormat.headerBackgroundColor) && tableFormat.headerBackgroundColor || undefined,
      color: lodash_1.has(tableFormat, 'headerColor') && colorUtils_1.isColor(tableFormat.headerColor) && tableFormat.headerColor || undefined
    }
  };
  var tableBody = {
    rows: []
  };

  var _loop = function _loop(currentRow) {
    var row = {
      key: "row-".concat(currentRow),
      index: currentRow,
      cells: []
    };
    table.forEach(function (column, i) {
      var currentHeader = tableHeader.cells[i];
      var value = validValueSelector(getColumnFormatData(columnFormat, currentHeader, currentRow), getTableFormatData(tableFormat, i, currentRow), column[currentRow], '');
      var rawValue = column[currentRow];
      var rowBackgroundColor = getColumnFormatRowBgColor(columnFormat, currentHeader, currentRow) || getTableFormatRowBgColor(tableFormat, i, currentRow) || undefined;
      var rowColor = getColumnFormatRowColor(columnFormat, currentHeader, currentRow) || getTableFormatRowColor(tableFormat, i, currentRow) || undefined;
      var align = getColumnFormatAlign(columnFormat, currentHeader, currentRow) || getTableFormatAlign(tableFormat, i, currentRow) || 'left';
      var cellType = getColumnFormatCellType(columnFormat, currentHeader, currentRow) || getTableFormatCellType(tableFormat, i, currentRow) || 'TextCell';
      var sparklineColor = getColumnFormatSparklineColor(columnFormat, currentHeader, currentRow) || getTableFormatSparklineColor(tableFormat, i, currentRow) || undefined;
      var sparklineAreaColor = getColumnFormatSparklineAreaColor(columnFormat, currentHeader, currentRow) || getTableFormatSparklineAreaColor(tableFormat, i, currentRow) || undefined;
      var sparklineType = getColumnFormatSparklineType(columnFormat, currentHeader, currentRow) || getTableFormatSparklineType(tableFormat, i, currentRow) || 'area';
      var key = generateKey(value, "".concat(currentRow, "-").concat(i));
      var additionalStyles = {};

      if (lodash_1.isNumber(currentHeader.width)) {
        var textOverflowType = exports.getTextOverflowType(columnFormat, currentHeader.value, 'ellipsis');
        var textOverflowStyle = exports.getOverflowStyles({
          textOverflow: textOverflowType,
          variables: {
            width: currentHeader.width
          }
        });
        additionalStyles = Object.assign(Object.assign(Object.assign({}, additionalStyles), textOverflowStyle), {
          width: style_1.toPx(currentHeader.width)
        });
      }

      row.cells.push({
        key: key,
        value: value,
        rawValue: rawValue,
        align: align,
        cellType: cellType,
        rowIndex: currentRow,
        columnIndex: i,
        sparklineColor: sparklineColor,
        sparklineAreaColor: sparklineAreaColor,
        sparklineType: sparklineType,
        style: Object.assign({
          backgroundColor: rowBackgroundColor,
          color: rowColor
        }, additionalStyles)
      });
    });
    tableBody.rows.push(row);
  };

  for (var currentRow = 0; currentRow < longestColumnLength; currentRow++) {
    _loop(currentRow);
  }

  return {
    tableHeader: tableHeader,
    tableBody: tableBody
  };
};

exports.useTable = useTable;

/***/ }),

/***/ 248:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function get() {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __exportStar = this && this.__exportStar || function (m, exports) {
  for (var p in m) {
    if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
  }
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

__exportStar(__webpack_require__(249), exports);

__exportStar(__webpack_require__(250), exports);

__exportStar(__webpack_require__(251), exports);

__exportStar(__webpack_require__(252), exports);

/***/ }),

/***/ 249:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SwitchTableCell = void 0;

var SwitchTableCell = function SwitchTableCell(_ref) {
  var type = _ref.type,
      children = _ref.children;
  return children.filter(function (child) {
    return child.type.displayName === type;
  });
};

exports.SwitchTableCell = SwitchTableCell;

/***/ }),

/***/ 25:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.shouldShowIconPlaceholder = void 0;

var React = __webpack_require__(1);

var T = __webpack_require__(0);

var lodash_1 = __webpack_require__(2);

var i18n_1 = __webpack_require__(3);

var Message_1 = __webpack_require__(9);

var FixedSizeContainer_1 = __webpack_require__(12);
/**
 * @method shouldShowIconPlaceholder
 * @param {object} dataSources
 * @param {boolean} loading
 * @returns {boolean}
 */


var shouldShowIconPlaceholder = function shouldShowIconPlaceholder(dataSources) {
  var loading = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var data = lodash_1.get(dataSources, 'primary.data.columns[0]', undefined);
  var noData = data === undefined;
  var fields = lodash_1.get(dataSources, 'primary.data.fields[0]', undefined);
  var noFields = fields === undefined;
  return loading || noData || noFields;
};

exports.shouldShowIconPlaceholder = shouldShowIconPlaceholder;
var propTypes = {
  icon: T.func,
  width: T.oneOfType([T.string, T.number]),
  height: T.oneOfType([T.string, T.number]),
  backgroundColor: T.string
};
/**
 * @method IconPlaceholder
 * @param {IconPlaceholderProps} props
 * @returns {React.ReactElement}
 */

var IconPlaceholder = function IconPlaceholder(props) {
  var width = props.width,
      height = props.height,
      icon = props.icon;

  if (icon) {
    return React.createElement(icon, {
      style: {
        left: '50%',
        top: '50%',
        color: 'grey',
        position: 'absolute',
        transform: 'translate(-50%, -50%)'
      },
      width: '50%',
      height: '50%'
    });
  }

  return React.createElement(Message_1.default, {
    width: width,
    height: height,
    level: "warning",
    message: i18n_1._('No DataSource Connected')
  });
};

IconPlaceholder.propTypes = propTypes;
IconPlaceholder.defaultProps = {
  width: '100%',
  height: 250
};
exports.default = FixedSizeContainer_1.default(IconPlaceholder);

/***/ }),

/***/ 250:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TextCell = void 0;

var React = __webpack_require__(1);

var Table_1 = __webpack_require__(76);

var TextCell = function TextCell(_ref) {
  var cell = _ref.cell,
      useMouseOverEffect = _ref.useMouseOverEffect;
  return React.createElement(Table_1.default.Cell, {
    style: cell.style,
    align: cell.align,
    "data-test-cell-type": "TextCell",
    "data-row-index": cell.rowIndex,
    "data-col-index": cell.columnIndex,
    onClick: useMouseOverEffect ? function () {} : undefined
  }, cell.value.toString());
};

exports.TextCell = TextCell;
exports.TextCell.displayName = 'TextCell';

/***/ }),

/***/ 251:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ArrayCell = void 0;

var React = __webpack_require__(1);

var Table_1 = __webpack_require__(76);

var ArrayCell = function ArrayCell(_ref) {
  var cell = _ref.cell,
      useMouseOverEffect = _ref.useMouseOverEffect;
  var value = Array.isArray(cell.value) ? cell.value : [cell.value];
  return React.createElement(Table_1.default.Cell, {
    style: cell.style,
    align: cell.align,
    "data-test-cell-type": "ArrayCell",
    onClick: useMouseOverEffect ? function () {} : undefined
  }, value.map(function (v, i) {
    return React.createElement("div", {
      key: v.toString(),
      "data-row-index": cell.rowIndex,
      "data-col-index": cell.columnIndex,
      "data-array-index": i
    }, v.toString());
  }));
};

exports.ArrayCell = ArrayCell;
exports.ArrayCell.displayName = 'ArrayCell';

/***/ }),

/***/ 252:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _slicedToArray = __webpack_require__(60);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SparklineCell = exports.validSparklineTypes = void 0;

var React = __webpack_require__(1);

var Table_1 = __webpack_require__(76);

var Line_1 = __webpack_require__(77);

var paddingLeftRight = 5;
var paddingTopBottom = 3;

var parseSparklineData = function parseSparklineData(data) {
  return (Array.isArray(data) ? data : [data]).map(function (d) {
    return parseInt(d.toString(), 10);
  }).map(function (d) {
    return isNaN(d) ? null : d;
  });
};

exports.validSparklineTypes = ['line', 'area'];

var SparklineCell = function SparklineCell(_ref) {
  var cell = _ref.cell,
      useMouseOverEffect = _ref.useMouseOverEffect;

  var _React$useState = React.useState(React.createRef()),
      _React$useState2 = _slicedToArray(_React$useState, 2),
      cellRef = _React$useState2[0],
      setCellRef = _React$useState2[1];

  var _React$useState3 = React.useState(null),
      _React$useState4 = _slicedToArray(_React$useState3, 2),
      height = _React$useState4[0],
      setHeight = _React$useState4[1];

  var data = React.useMemo(function () {
    return parseSparklineData(cell.value);
  }, [cell.value]);
  React.useEffect(function () {
    setHeight(cellRef.offsetHeight);
  }, [cellRef]);
  return React.createElement(Table_1.default.Cell, {
    style: Object.assign(Object.assign({}, cell.style), {
      padding: 0,
      margin: 0,
      width: "".concat(cellRef.offsetWidth, "px"),
      height: "".concat(height, "px")
    }),
    align: cell.align,
    elementRef: setCellRef,
    "data-test-cell-type": "SparklineCell",
    "data-row-index": cell.rowIndex,
    "data-col-index": cell.columnIndex,
    onClick: useMouseOverEffect ? function () {} : undefined
  }, height ? React.createElement(Line_1.default, {
    style: {
      paddingLeft: "".concat(paddingLeftRight, "px"),
      paddingTop: "".concat(paddingTopBottom, "px"),
      width: "".concat(cellRef.offsetWidth - paddingLeftRight * 2, "px"),
      height: "".concat(height - paddingTopBottom * 2, "px")
    },
    data: data,
    width: cellRef.offsetWidth - paddingLeftRight * 2,
    height: height - paddingTopBottom * 2,
    isArea: cell.sparklineType === 'area',
    acceptNull: true,
    lineColor: cell.sparklineColor,
    fillColor: cell.sparklineAreaColor
  }) : React.createElement("svg", {
    style: {
      height: 0
    }
  }));
};

exports.SparklineCell = SparklineCell;
exports.SparklineCell.displayName = 'SparklineCell';

/***/ }),

/***/ 26:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VizCategory = void 0;
var VizCategory;

(function (VizCategory) {
  VizCategory["SINGLE_VALUE"] = "Single Value";
  VizCategory["TRENDS"] = "Trends";
  VizCategory["COMPARISONS"] = "Comparisons";
  VizCategory["TABLE"] = "Table";
  VizCategory["GAUGE"] = "Gauge";
  VizCategory["DISTRIBUTIONS"] = "Distributions";
  VizCategory["CHOROPLETH"] = "Choropleth Maps";
  VizCategory["SHAPES"] = "Shapes";
  VizCategory["MISC"] = "misc";
  VizCategory["FLOW"] = "Flow";
  VizCategory["CORRELATION"] = "Correlation";
  VizCategory["SPATIAL"] = "Spatial";
})(VizCategory = exports.VizCategory || (exports.VizCategory = {}));

/***/ }),

/***/ 27:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var React = __webpack_require__(1);

var lodash_1 = __webpack_require__(2);

var getSettingsFromThemedProps_1 = __webpack_require__(28);

var Options_1 = __webpack_require__(29);

var SanitizeProps_1 = __webpack_require__(30);

var styled_components_1 = __webpack_require__(4);

var SplunkVisualization_1 = __webpack_require__(31);

var VizBehavior_1 = __webpack_require__(5);

var getSorting_1 = __webpack_require__(23);

var getPagination_1 = __webpack_require__(24);

var useDeepMemo_1 = __webpack_require__(34);

var JSONSchemaUtils_1 = __webpack_require__(35);

var MissingPropsMessage_1 = __webpack_require__(36);

var withEditModeCover_1 = __webpack_require__(37);

var withPlaceholder_1 = __webpack_require__(38);

var hocUtils_1 = __webpack_require__(7);
/**
 * hoc that wraps a pure react visualization in a Dashboard visualization
 * @param {DashboardVizOpts} opts
 * @returns {HOC}
 */


var withDashboardViz = function withDashboardViz(opts) {
  var ReactViz = opts.ReactViz,
      vizConfig = opts.vizConfig,
      _opts$computeVizProps = opts.computeVizProps,
      computeVizProps = _opts$computeVizProps === void 0 ? function () {} : _opts$computeVizProps,
      useIconPlaceholder = opts.useIconPlaceholder; // sanitizing props before sending them to reactviz.

  var SanitizedReactViz = SanitizeProps_1.withSanitizedProps(ReactViz);
  var defaultOptions = JSONSchemaUtils_1.pickFieldFromJSONSchema(vizConfig.optionsSchema, 'default');

  var DashboardViz = function DashboardViz(props) {
    var mode = props.mode,
        hasEventHandlers = props.hasEventHandlers,
        dataSources = props.dataSources,
        options = props.options,
        _props$context = props.context,
        context = _props$context === void 0 ? {} : _props$context,
        width = props.width,
        height = props.height,
        onComputedProps = props.onComputedProps,
        onEventTrigger = props.onEventTrigger,
        theme = props.theme,
        onRequestParamsChange = props.onRequestParamsChange;

    var themeFunc = function themeFunc(themeVar) {
      var _a, _b;

      return (_b = (_a = vizConfig.themes)[themeVar]) === null || _b === void 0 ? void 0 : _b.call(_a, props);
    };

    var bgColorFromTheme = themeFunc('defaultBackgroundColor');

    var _getSettingsFromTheme = getSettingsFromThemedProps_1.default({
      theme: theme
    }),
        currentThemeFamily = _getSettingsFromTheme.family,
        currentThemeColorScheme = _getSettingsFromTheme.colorScheme,
        currentThemeDensity = _getSettingsFromTheme.density;

    var evaluatedOptions = {}; // evaluatedOptions need to be initialized as an empty object

    evaluatedOptions = useDeepMemo_1.useDeepMemo(function () {
      try {
        return Options_1.Options.evaluate({
          context: lodash_1.defaultsDeep({}, context, vizConfig.defaultContext),
          options: hocUtils_1.deepMergeWithArrayOverrides({}, options, defaultOptions)
        }, dataSources, themeFunc);
      } catch (e) {
        console.error("unexpected error evaluating options:  + ".concat(e.message));
        return {};
      }
    }, [currentThemeFamily, currentThemeColorScheme, currentThemeDensity, options, context, dataSources]); // useEffect hook needs to be initialized before any early returns
    // this is in accordance with the order of hook calls being the same on each render https://reactjs.org/docs/hooks-rules.html#explanation

    React.useEffect(function () {
      onComputedProps(evaluatedOptions);
    }); // present warning message if any required props are missing

    var _vizConfig$requiredPr = vizConfig.requiredProps,
        requiredProps = _vizConfig$requiredPr === void 0 ? [] : _vizConfig$requiredPr,
        supports = vizConfig.supports;
    var missing = MissingPropsMessage_1.missingKeys(requiredProps, evaluatedOptions);

    if (missing.length > 0 && supports.includes(VizBehavior_1.VizBehavior.PLACEHOLDER)) {
      return React.createElement(MissingPropsMessage_1.default, {
        "data-test": "missing-props-message",
        width: width,
        height: height,
        missingProps: missing,
        backgroundColor: bgColorFromTheme
      });
    } // events


    var eventCallbackProps = {};

    if (hasEventHandlers && mode === 'view' && vizConfig.supports.indexOf(VizBehavior_1.VizBehavior.EVENTS) > -1) {
      var supportedEvents = vizConfig.events;
      Object.keys(supportedEvents).forEach(function (eventName) {
        var eventCallbackPropName = lodash_1.camelCase("on.".concat(eventName));
        eventCallbackProps[eventCallbackPropName] = null; // todo: refactor single value and single value icon to send payload from viz
        // then remove these lines

        var payloadKeys = supportedEvents[eventName].payloadKeys;
        var payload = {};

        if (Array.isArray(payloadKeys) && payloadKeys.length) {
          payloadKeys.forEach(function (p) {
            return payload[p] = evaluatedOptions[p];
          });
        }

        eventCallbackProps[eventCallbackPropName] = function (ev) {
          if (ev && ev.payload) {
            payload = ev.payload;
          }

          return onEventTrigger({
            originalEvent: ev,
            payload: payload,
            type: eventName
          });
        };
      });
    } // compute pure viz props which are not from options


    var computedVizProps = computeVizProps(Object.assign(Object.assign(Object.assign(Object.assign({}, props), evaluatedOptions), eventCallbackProps), {
      themeFunc: themeFunc
    }));
    /**
     * PAGE_AND_SORT behavior
     *
     * Some visualizations, like table, requires metadata about the datasource,
     * like total number of results, current count, offset, and sort, for rendering
     * paginator and sorting direction. In this approach, the visualization
     * allow users to set 'paginateDataSourceKey' to select which datasource
     * should the visualization extract the metadata from. It defaults to 'primary' datasource.
     * The visualization config should set the PAGE_AND_SORT behavior to receive
     * 'requestParams', 'meta' and onRequestParams callback as props.
     *
     * In future, we could automatically detect which all datasources are being used
     * and bind those magically to pagination/sorting behavior.
     */

    var dataSourceMetadata = {};
    var OptionKey = 'paginateDataSourceKey';
    var paginateDataSourceKey = lodash_1.has(evaluatedOptions, OptionKey) && evaluatedOptions[OptionKey] || 'primary';

    if (vizConfig.supports.indexOf(VizBehavior_1.VizBehavior.PAGE_AND_SORT) > -1 && lodash_1.has(dataSources, paginateDataSourceKey)) {
      var requestParams = lodash_1.get(dataSources, [paginateDataSourceKey, 'requestParams'], {});
      var meta = lodash_1.get(dataSources, [paginateDataSourceKey, 'meta'], {});

      var handleRequestParamsChange = function handleRequestParamsChange(payload) {
        return onRequestParamsChange(paginateDataSourceKey, payload);
      };

      var sortParams = getSorting_1.getSortingParams({
        requestParams: requestParams,
        meta: meta,
        onRequestParamsChange: handleRequestParamsChange
      });
      var paginatorParams = getPagination_1.getPaginationParams({
        requestParams: requestParams,
        meta: meta,
        onRequestParamsChange: handleRequestParamsChange
      });
      dataSourceMetadata = {
        sortParams: sortParams,
        paginatorParams: paginatorParams
      };
    }

    return React.createElement(SanitizedReactViz, Object.assign({
      mode: mode,
      width: width,
      height: height
    }, evaluatedOptions, computedVizProps, eventCallbackProps, dataSourceMetadata));
  };

  DashboardViz.propTypes = Object.assign(Object.assign({}, SplunkVisualization_1.default.propTypes), ReactViz.propTypes);
  DashboardViz.defaultProps = Object.assign(Object.assign(Object.assign({}, SplunkVisualization_1.default.defaultProps), ReactViz.defaultProps), {
    // using withTheme requires component to receive theme prop. In case the consumer did not provide ThemeProvider, a default empty object will prevent warnings.
    theme: {}
  }); // attach viz config

  DashboardViz.config = vizConfig; // @ts-ignore: TODO fix sc upgrade TS issues

  return styled_components_1.withTheme(withPlaceholder_1.default(withEditModeCover_1.default(DashboardViz), useIconPlaceholder));
};

exports.default = withDashboardViz;

/***/ }),

/***/ 28:
/***/ (function(module, exports) {

module.exports = require("@splunk/themes/getSettingsFromThemedProps");

/***/ }),

/***/ 29:
/***/ (function(module, exports) {

module.exports = require("@splunk/visualization-encoding/Options");

/***/ }),

/***/ 3:
/***/ (function(module, exports) {

module.exports = require("@splunk/ui-utils/i18n");

/***/ }),

/***/ 30:
/***/ (function(module, exports) {

module.exports = require("@splunk/visualizations-shared/SanitizeProps");

/***/ }),

/***/ 31:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _classCallCheck = __webpack_require__(10);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.INITIAL_HEIGHT = exports.INITIAL_WIDTH = void 0;
/* eslint-disable react/no-unused-prop-types,react/prefer-stateless-function */

var T = __webpack_require__(0);

var lodash_1 = __webpack_require__(2);

var VizActionHandler_1 = __webpack_require__(32); // this is identical to the initial height and width we use in BaseVisualization in dashboard-visualizations


exports.INITIAL_WIDTH = 250;
exports.INITIAL_HEIGHT = 250;
/**
 * A Splunk visualization
 */

var SplunkVisualization = function SplunkVisualization() {
  _classCallCheck(this, SplunkVisualization);
};

SplunkVisualization.propTypes = {
  /**
   * display mode
   */
  mode: T.oneOf(['view', 'edit', 'export']).isRequired,

  /**
   * width in pixel or string, defaults to 100%
   */
  width: T.oneOfType([T.string, T.number]).isRequired,

  /**
   * height in pixel or string
   */
  height: T.oneOfType([T.string, T.number]).isRequired,

  /**
   * visualization context used for dynamic option evaluation
   */
  context: T.object,

  /**
   * visualization formatting options
   */
  options: T.object,

  /**
   * A callback to update formatting options
   */
  onOptionsChange: T.func,

  /**
   * datasource state which include data and request params, object key indicate the datasource type.
   */
  dataSources: T.objectOf(T.shape({
    /**
     * current request params
     */
    requestParams: T.object,

    /**
     * current dataset
     */
    data: T.shape({
      fields: T.array,
      columns: T.array
    }),

    /**
     * error
     */
    error: T.shape({
      level: T.string,
      message: T.string
    }),

    /**
     * meta data that came with the dataset
     */
    meta: T.object
  })),

  /**
   * A callback to trigger event
   */
  onEventTrigger: T.func,

  /**
   * Inform viz if there are handlers listening to events
   */
  hasEventHandlers: T.bool,

  /**
   * A callback to communicate computed props to a consumer
   */
  onComputedProps: T.func,

  /**
   * A callback to obtain visualization api
   */
  vizActionHandlerRef: T.func,
  loading: T.bool,
  theme: T.object,

  /**
   * A callback to request new data with updated request params
   */
  onRequestParamsChange: T.func
};
/**
 *
 */

SplunkVisualization.defaultProps = {
  // BaseVisualization in dashboard-visualizations uses 100% for width but 250 for height
  width: '100%',
  height: exports.INITIAL_HEIGHT,
  dataSources: {},
  onEventTrigger: function onEventTrigger() {
    return {};
  },
  mode: 'view',
  hasEventHandlers: false,
  options: {},
  context: {},
  onOptionsChange: function onOptionsChange() {
    return {};
  },
  vizActionHandlerRef: function vizActionHandlerRef() {
    return new VizActionHandler_1.DefaultVizActionHandler();
  },
  onComputedProps: function onComputedProps() {
    return {};
  },
  loading: false,
  onRequestParamsChange: lodash_1.noop
};
exports.default = SplunkVisualization;

/***/ }),

/***/ 32:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _classCallCheck = __webpack_require__(10);

var _createClass = __webpack_require__(16);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DefaultVizActionHandler = void 0;

var DefaultVizActionHandler = /*#__PURE__*/function () {
  function DefaultVizActionHandler() {
    _classCallCheck(this, DefaultVizActionHandler);
  }

  _createClass(DefaultVizActionHandler, [{
    key: "focus",
    value: function focus() {//noop
    }
  }, {
    key: "snapshot",
    value: function snapshot() {
      return null; //noop
    }
  }]);

  return DefaultVizActionHandler;
}();

exports.DefaultVizActionHandler = DefaultVizActionHandler;

/***/ }),

/***/ 33:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.validSortDirs = void 0;
exports.validSortDirs = ['asc', 'desc', 'none'];

/***/ }),

/***/ 34:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useDeepMemo = void 0;

var react_1 = __webpack_require__(1);

var lodash_1 = __webpack_require__(2);
/**
 * This hook evaluates and stores the result of a passed function and only
 * re-evaluates the function when passed dependencies change.
 *
 * It is different from the internal React useMemo in the following aspects:
 * - it only stores the last evaluated result
 * - it uses a deep equality check to determine if dependencies have changed
 *
 * Inspired by apollo-client's useDeepMemo
 *
 * @param fn the function to be executed and
 * @param dependencies an array of dependencies
 */


var useDeepMemo = function useDeepMemo(fn, dependencies) {
  var ref = react_1.useRef();

  if (!ref.current || !lodash_1.isEqual(dependencies, ref.current.dependencies)) {
    ref.current = {
      dependencies: dependencies,
      value: fn()
    };
  }

  return ref.current.value;
};

exports.useDeepMemo = useDeepMemo;

/***/ }),

/***/ 35:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.pickFieldFromJSONSchema = void 0;

var lodash_1 = __webpack_require__(2);

var pickFieldFromJSONSchema = function pickFieldFromJSONSchema(optionsSchema) {
  var fieldName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'default';
  return Object.keys(optionsSchema).reduce(function (accum, k) {
    if (lodash_1.has(optionsSchema[k], fieldName)) {
      accum[k] = optionsSchema[k][fieldName];
    } else if (lodash_1.get(optionsSchema, [k, 'type']) === 'object' && lodash_1.has(optionsSchema[k], 'properties')) {
      var nestedSchema = exports.pickFieldFromJSONSchema(optionsSchema[k].properties, fieldName);

      if (!lodash_1.isEmpty(nestedSchema)) {
        accum[k] = nestedSchema;
      }
    }

    return accum;
  }, {});
};

exports.pickFieldFromJSONSchema = pickFieldFromJSONSchema;

/***/ }),

/***/ 36:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MissingPropsMessage = exports.missingKeys = exports.isMissing = void 0;

var React = __webpack_require__(1);

var T = __webpack_require__(0);

var i18n_1 = __webpack_require__(3);

var Message_1 = __webpack_require__(9);

var FixedSizeContainer_1 = __webpack_require__(12);
/**
 * @method isMissing
 * @param {any} v
 * @returns {boolean} true if the input value === null or undefined
 */


var isMissing = function isMissing(v) {
  return v === null || v === undefined;
};

exports.isMissing = isMissing;
/**
 * @method misskingKeys
 * @param {string[]} keys
 * @param {object} target
 * @returns {string[]} the keys of missing required props
 */

var missingKeys = function missingKeys(keys, target) {
  return keys.filter(function (k) {
    return exports.isMissing(target[k]);
  });
};

exports.missingKeys = missingKeys;
var propTypes = {
  width: T.oneOfType([T.string, T.number]),
  height: T.oneOfType([T.string, T.number]),
  backgroundColor: T.string,
  missingProps: T.arrayOf(T.string)
};
/**
 * @method MissingPropsMessage
 * @param {MissingPropsProps} props
 * @returns {React.ReactElement}
 */

var MissingPropsMessage = function MissingPropsMessage(props) {
  var width = props.width,
      height = props.height,
      missingProps = props.missingProps;
  return React.createElement(Message_1.default, {
    "data-test": "message",
    width: width,
    height: height,
    message: i18n_1._("Missing property: ".concat(missingProps.join(', ')))
  });
};

exports.MissingPropsMessage = MissingPropsMessage;
exports.MissingPropsMessage.propTypes = propTypes;
exports.MissingPropsMessage.defaultProps = {
  width: '100%',
  height: 250
};
exports.default = FixedSizeContainer_1.default(exports.MissingPropsMessage);

/***/ }),

/***/ 37:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var React = __webpack_require__(1);

var styled_components_1 = __webpack_require__(4);

var hocUtils_1 = __webpack_require__(7);

var Cover = styled_components_1.default.div.withConfig({
  displayName: "withEditModeCover__Cover",
  componentId: "sc-1gsbnxb-0"
})(["position:absolute;left:0;right:0;top:0;bottom:0;"]);
var Blocker = styled_components_1.default.div.withConfig({
  displayName: "withEditModeCover__Blocker",
  componentId: "sc-1gsbnxb-1"
})(["position:relative;width:100%;height:100%;"]);
/**
 * HOC that renders a cover layer in edit mode
 * @method withEditModeCover
 * @param {ExtendedDashViz} Visualization
 * @returns {ExtendedDashViz} Wrapper
 */

var withEditModeCover = function withEditModeCover(Visualization) {
  var Wrapper = function Wrapper(props) {
    var mode = props.mode;
    return React.createElement(Blocker, null, React.createElement(Visualization, Object.assign({}, props)), mode === 'edit' && React.createElement(Cover, {
      "data-test": "edit-mode-cover"
    }));
  };

  hocUtils_1.extendStaticWrapperProps({
    Wrapper: Wrapper,
    Visualization: Visualization
  });
  return Wrapper;
};

exports.default = withEditModeCover;

/***/ }),

/***/ 38:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var React = __webpack_require__(1);

var colorUtils_1 = __webpack_require__(11);

var IconPlaceholder_1 = __webpack_require__(25);

var VizBehavior_1 = __webpack_require__(5);

var hocUtils_1 = __webpack_require__(7);

var withPlaceholder = function withPlaceholder(Visualization) {
  var useIconPlaceholder = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : IconPlaceholder_1.shouldShowIconPlaceholder;
  var config = Visualization.config;
  var themes = config.themes;

  var Wrapper = function Wrapper(props) {
    var _a;

    var dataSources = props.dataSources,
        loading = props.loading,
        options = props.options,
        height = props.height,
        width = props.width;
    var showPlaceholder = useIconPlaceholder(dataSources, loading, options);
    var bgColorFromTheme = colorUtils_1.isColor(options === null || options === void 0 ? void 0 : options.backgroundColor) ? options === null || options === void 0 ? void 0 : options.backgroundColor : (_a = themes === null || themes === void 0 ? void 0 : themes.defaultBackgroundColor) === null || _a === void 0 ? void 0 : _a.call(themes, props);

    if (config.supports.includes(VizBehavior_1.VizBehavior.PLACEHOLDER) && showPlaceholder) {
      return React.createElement(IconPlaceholder_1.default, {
        "data-test": "icon-placeholder",
        icon: config.icon,
        width: width,
        height: height,
        backgroundColor: bgColorFromTheme
      });
    }

    return React.createElement(Visualization, Object.assign({}, props));
  };

  hocUtils_1.extendStaticWrapperProps({
    Wrapper: Wrapper,
    Visualization: Visualization
  });
  return Wrapper;
};

exports.default = withPlaceholder;

/***/ }),

/***/ 39:
/***/ (function(module, exports) {

module.exports = require("@babel/runtime/helpers/toConsumableArray");

/***/ }),

/***/ 4:
/***/ (function(module, exports) {

module.exports = require("styled-components");

/***/ }),

/***/ 40:
/***/ (function(module, exports) {

module.exports = require("@splunk/visualizations-shared/colorConstants");

/***/ }),

/***/ 42:
/***/ (function(module, exports) {

module.exports = require("@splunk/visualization-icons");

/***/ }),

/***/ 5:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VizBehavior = void 0;
var VizBehavior;

(function (VizBehavior) {
  /**
   * Dynamic Options Behavior.
   * This allows visualization options to be powered by data
   *
   * **Example**
   *
   * sparklineValues: ">primary|seriesByIndex(0)"
   * would configure sparklineValues with an array of data points
   * coming from the first series in the primary datasource
   *
   */
  VizBehavior["DYNAMIC_OPTIONS"] = "dynamic-options";
  VizBehavior["EVENTS"] = "events";
  /**
   * Placeholder behavior: visualization will display a placeholder rather than fail if any of the `requiredProps` is
   * missing.
   * @type {string}
   */

  VizBehavior["PLACEHOLDER"] = "placeholder";
  VizBehavior["PAGE_AND_SORT"] = "page-and-sort";
})(VizBehavior = exports.VizBehavior || (exports.VizBehavior = {}));

/***/ }),

/***/ 6:
/***/ (function(module, exports) {

module.exports = require("@babel/runtime/helpers/defineProperty");

/***/ }),

/***/ 60:
/***/ (function(module, exports) {

module.exports = require("@babel/runtime/helpers/slicedToArray");

/***/ }),

/***/ 7:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = __webpack_require__(22);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.deepMergeWithArrayOverrides = exports.extendStaticWrapperProps = void 0;

var lodash_1 = __webpack_require__(2);
/**
 * @method extendStaticWrapperProps
 * @param {Object} props
 * @param {DashboardVizType} props.Wrapper
 * @param {DashboardVizType} props.Visualization
 */


var extendStaticWrapperProps = function extendStaticWrapperProps(_ref) {
  var Wrapper = _ref.Wrapper,
      Visualization = _ref.Visualization;
  var extendProperties = ['propTypes', 'defaultProps', 'config'];
  extendProperties.forEach(function (prop) {
    if (Visualization[prop]) {
      Wrapper[prop] = Visualization[prop];
    }
  });
};

exports.extendStaticWrapperProps = extendStaticWrapperProps;
/**
 * helper to deeply merge objects while preserving arrays in earlier source objects
 * deeply nested primitive keys are merged similarly to lodash's defaultsDeep, while keys with arrays will be preserved if already present in the resultant merged object
 * this prevents default arrays from appending values to user-defined arrays (this occurs if the default array is longer than the user-defined one)
 *
 * @method deepMergeWithArrayOverrides
 * @param {Object} initial - target object to merge values into
 * @param {Object[]} sources - other default options to be merged into the resultant object if no explicit value is provided, with earlier args taking precedence over later ones
 *
 * @returns {Object}
 */

var deepMergeWithArrayOverrides = function deepMergeWithArrayOverrides(initial) {
  var clone = lodash_1.cloneDeep(initial);

  for (var _len = arguments.length, sources = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    sources[_key - 1] = arguments[_key];
  }

  sources.forEach(function (sourceToApply) {
    Object.keys(sourceToApply).forEach(function (sourceKey) {
      if (!clone.hasOwnProperty(sourceKey)) {
        clone[sourceKey] = lodash_1.cloneDeep(sourceToApply[sourceKey]);
      } // object merging excluding arrays


      if (clone[sourceKey] && _typeof(clone[sourceKey]) === 'object' && !Array.isArray(clone[sourceKey]) && _typeof(sourceToApply[sourceKey]) === 'object') {
        clone[sourceKey] = exports.deepMergeWithArrayOverrides(clone[sourceKey], sourceToApply[sourceKey]);
      }
    });
  });
  return clone;
};

exports.deepMergeWithArrayOverrides = deepMergeWithArrayOverrides;

/***/ }),

/***/ 76:
/***/ (function(module, exports) {

module.exports = require("@splunk/react-ui/Table");

/***/ }),

/***/ 77:
/***/ (function(module, exports) {

module.exports = require("@splunk/react-sparkline/Line");

/***/ }),

/***/ 8:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _defineProperty = __webpack_require__(6);

var __rest = this && this.__rest || function (s, e) {
  var t = {};

  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.generatePrecisionValues = exports.getInitialPreset = exports.isDynamicOption = exports.enhanceOptionsSchemaWithDynamicOptions = exports.enhanceConfig = void 0;

var lodash_1 = __webpack_require__(2);

var schemaUtils_1 = __webpack_require__(14);

var VizBehavior_1 = __webpack_require__(5);

var dynamicOptionsDSLType = {
  type: 'string',
  pattern: schemaUtils_1.DYNAMIC_OPTIONS_DSL_PATTERN
};
/**
 * Helper function to extend an options schema with dynamic options DSL
 * @param optionsSchema a visualization's options schema
 * @returns an updated options schema that additionally allows strings starting with > for each option
 */

function enhanceOptionsSchemaWithDynamicOptions(optionsSchema) {
  var enhancedOptionsSchema = {};
  Object.keys(optionsSchema).forEach(function (key) {
    var _a = optionsSchema[key],
        title = _a.title,
        description = _a.description,
        readOnly = _a.readOnly,
        writeOnly = _a.writeOnly,
        examples = _a.examples,
        defaultValue = _a.default,
        type = _a.type,
        properties = _a.properties,
        patternProperties = _a.patternProperties,
        remainingSchemaEntry = __rest(_a, ["title", "description", "readOnly", "writeOnly", "examples", "default", "type", "properties", "patternProperties"]);

    var annotations = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, title !== undefined && {
      title: title
    }), description !== undefined && {
      description: description
    }), readOnly !== undefined && {
      readOnly: readOnly
    }), writeOnly !== undefined && {
      writeOnly: writeOnly
    }), examples !== undefined && {
      examples: examples
    }), defaultValue !== undefined && {
      default: defaultValue
    });

    if (type === 'object') {
      enhancedOptionsSchema[key] = Object.assign(Object.assign(Object.assign(Object.assign({}, remainingSchemaEntry), annotations), {
        type: type
      }), properties && {
        properties: enhanceOptionsSchemaWithDynamicOptions(properties)
      });

      if (patternProperties) {
        var enhancedPatternProperties = {};
        Object.keys(patternProperties).forEach(function (key) {
          enhancedPatternProperties = Object.assign(Object.assign({}, enhancedPatternProperties), enhanceOptionsSchemaWithDynamicOptions(_defineProperty({}, key, patternProperties[key])));
        });
        enhancedOptionsSchema[key].patternProperties = enhancedPatternProperties;
      }
    } else {
      enhancedOptionsSchema[key] = Object.assign(Object.assign({}, annotations), {
        anyOf: [Object.assign(Object.assign({}, type !== undefined && {
          type: type
        }), remainingSchemaEntry), dynamicOptionsDSLType]
      });
    }
  });
  return enhancedOptionsSchema;
}

exports.enhanceOptionsSchemaWithDynamicOptions = enhanceOptionsSchemaWithDynamicOptions;
/**
 * Helper function to enhance a Visualization Config as needed based on behaviors specified in supports block
 * @param vizConfig a Visualization Config
 * @returns an enhanced Visualization Config containing updated config entries based on behaviors it supports
 */

function enhanceConfig(vizConfig) {
  var enhancedConfig = vizConfig;

  if (vizConfig.supports.indexOf(VizBehavior_1.VizBehavior.DYNAMIC_OPTIONS) !== -1) {
    enhancedConfig.optionsSchema = enhanceOptionsSchemaWithDynamicOptions(vizConfig.optionsSchema);
  }

  return enhancedConfig;
}

exports.enhanceConfig = enhanceConfig;

function isDynamicOption(option) {
  return option && typeof option === 'string' && option.trim().startsWith('>') || false;
}

exports.isDynamicOption = isDynamicOption; // private helpers to improve readability of getInitialPreset
// this shouldn't be tested since this util isn't something that we expect to use outside of getInitialPreset

/**
 * this checks to make sure that all values within vizContext are compatible with the given preset's context to determine the initialPreset
 * if a preset has explicitly specified a key as being undefined, the vizContext must also has that key as undefined, or else this CANNOT be the initialPreset
 * the inverse is true; if a preset has key is NOT undefined, it must also be NOT undefined in the corresponding vizContext
 * the internal config contents are irrelevant (as the user could customize them in source), just as long as the presence of `undefined`s match up
 *
 * Since the presetConfigs have explicit undefined keys to override the existing config, we need to explicitly check the undefined values
 */

function hasCompatibleContexts(vizContext, presetContext) {
  var presetContextKeys = Object.keys(presetContext);
  return presetContextKeys.every(function (contextKey) {
    return presetContext[contextKey] === undefined && vizContext[contextKey] === undefined || presetContext[contextKey] !== undefined && vizContext[contextKey] !== undefined;
  });
}
/**
 * Checks to make sure that dynamic (non-dynamic) options in a given preset are also dynamic (non-dynamic) in the vizOptions
 */


function hasCompatibleOptions(vizOptions, presetOptions) {
  var presetOptionKeys = Object.keys(presetOptions);
  return presetOptionKeys.every(function (optionKey) {
    return isDynamicOption(presetOptions[optionKey]) === isDynamicOption(vizOptions[optionKey]);
  });
}
/**
 * Evaluates whether there is an initialPreset that fits the current state of vizContext + vizOptions
 * This function ignores extraneous vizOptions or vizContext keys, as they could be outside the scope of what the preset is intended to configure
 *
 * @param {Object} vizContext - the current vizContext definition
 * @param {Object} vizOptions - the current vizOptions definition
 * @param {PresetEntry[]} presets - the list of presets, one of which can be considered an initialPreset
 */


function getInitialPreset(vizContext, vizOptions, presets) {
  return presets.find(function (preset) {
    var presetContext = lodash_1.get(preset, ['value', 'context'], {});
    var presetOptions = lodash_1.get(preset, ['value', 'options'], {});
    var presetContextKeys = Object.keys(presetContext);
    var presetOptionKeys = Object.keys(presetOptions); // all presets have to explicitly specify which options to reset (i.e. need explicitly undefined keys)
    // if not, then the preset is invalid in config.ts

    if (presetContextKeys.length === 0 || presetOptionKeys.length === 0) return false;
    return hasCompatibleContexts(vizContext, presetContext) && hasCompatibleOptions(vizOptions, presetOptions);
  });
}

exports.getInitialPreset = getInitialPreset;
/**
 * generates number precision values for a Select editor
 *
 * @param {Number} numPrecisionValues - number of integer precision values to generate
 * @returns {{ label: string; value; string  }[]} array of { label, value } tuples
 */

function generatePrecisionValues(numPrecisionValues) {
  return lodash_1.range(0, numPrecisionValues + 1).map(function (i) {
    return {
      label: "".concat(i, " (0").concat(i > 0 ? '.' : '').concat('0'.repeat(i), ")"),
      value: i
    };
  });
}

exports.generatePrecisionValues = generatePrecisionValues;

/***/ }),

/***/ 9:
/***/ (function(module, exports) {

module.exports = require("@splunk/visualizations-shared/Message");

/***/ }),

/***/ 94:
/***/ (function(module, exports) {

module.exports = require("@babel/runtime/helpers/taggedTemplateLiteral");

/***/ })

/******/ });
//# sourceMappingURL=Table.js.map
{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///external \"@babel/runtime/helpers/toConsumableArray\"","webpack:///external \"lodash\"","webpack:///./src/common/gaugeUtils.ts","webpack:///external \"@splunk/visualizations-shared/colorConstants\"","webpack:///external \"@splunk/ui-utils/i18n\""],"names":[],"mappings":";;;;;;;QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;AClFA,qE;;;;;;;ACAA,mC;;;;;;;;;;;;;;;;;ACAA;;AACA;;AAKA;;AAEa,0BAAkB,EAAlB;AACA,yBAAiB,EAAjB;AACb,IAAM,wBAAwB,GAAG,CAAjC;AACA,IAAM,wBAAwB,GAAG,GAAjC;AAEA;;;;;;;AAOG;;AACI,IAAM,aAAa,GAAG,SAAhB,aAAgB;AAAA,MAAG,cAAH,QAAG,cAAH;AAAA,MAAmB,WAAnB,QAAmB,WAAnB;AAAA,SACzB,WAAW,KAAK,UAAhB,GAA6B,uBAA7B,GAA+C,cAAc,GAAG,GADvC;AAAA,CAAtB;;AAAM,wBAAa,aAAb;AAGb;;;;;;;AAOG;;AACI,IAAM,cAAc,GAAG,SAAjB,cAAiB;AAAA,MAAG,eAAH,SAAG,eAAH;AAAA,MAAoB,WAApB,SAAoB,WAApB;AAAA,SAC1B,WAAW,KAAK,UAAhB,GAA6B,eAAe,GAAG,GAA/C,GAAqD,uBAD3B;AAAA,CAAvB;;AAAM,yBAAc,cAAd;AAGb;;;;;;;;;AASG;;AACI,IAAM,cAAc,GAAG,SAAjB,cAAiB;AAAA,MAAG,cAAH,SAAG,cAAH;AAAA,MAAmB,eAAnB,SAAmB,eAAnB;AAAA,MAAoC,WAApC,SAAoC,WAApC;AAAA,SAC1B,WAAW,KAAK,UAAhB,GACM,uBAAe;AAAE,mBAAe,EAAf,eAAF;AAAmB,eAAW,EAAX;AAAnB,GAAf,CADN,GAEM,sBAAc;AAAE,kBAAc,EAAd,cAAF;AAAkB,eAAW,EAAX;AAAlB,GAAd,CAHoB;AAAA,CAAvB;;AAAM,yBAAc,cAAd;AAKb;;;;;;;;;;;AAWG;;AACI,IAAM,qBAAqB,GAAG,SAAxB,qBAAwB,QAAkE;AAAA,MAA/D,cAA+D,SAA/D,cAA+D;AAAA,MAA/C,eAA+C,SAA/C,eAA+C;AAAA,MAA9B,WAA8B,SAA9B,WAA8B;AAAA,MAAjB,WAAiB,SAAjB,WAAiB;AACnG;AACA,MAAI,WAAW,GAAG,CAAC,cAAc,GAAG,WAAlB,IAAiC,GAAnD;AACA,MAAI,WAAW,GAAG,CAAC,eAAe,GAAG,uBAAnB,IAAsC,GAAxD;;AAEA,MAAI,WAAW,KAAK,UAApB,EAAgC;AAC5B,eAAW,GAAG,CAAC,cAAc,GAAG,uBAAlB,IAAqC,GAAnD;AACA,eAAW,GAAG,CAAC,eAAe,GAAG,WAAnB,IAAkC,GAAhD;AACH;;AAED,SAAO;AAAE,eAAW,EAAX,WAAF;AAAe,eAAW,EAAX;AAAf,GAAP;AACH,CAXM;;AAAM,gCAAqB,qBAArB;AAab;;;;;;;;;;;;;;AAcG;;AACI,IAAM,kBAAkB,GAAG,SAArB,kBAAqB,QAAqD;AAAA,MAAlD,cAAkD,SAAlD,cAAkD;AAAA,MAAlC,eAAkC,SAAlC,eAAkC;AAAA,MAAjB,WAAiB,SAAjB,WAAiB;AACnF,MAAM,WAAW,GAAG,uBAAe;AAAE,kBAAc,EAAd,cAAF;AAAkB,mBAAe,EAAf,eAAlB;AAAmC,eAAW,EAAX;AAAnC,GAAf,CAApB;;AADmF,8BAE9C,8BAAsB;AACvD,kBAAc,EAAd,cADuD;AAEvD,mBAAe,EAAf,eAFuD;AAGvD,eAAW,EAAX,WAHuD;AAIvD,eAAW,EAAX;AAJuD,GAAtB,CAF8C;AAAA,MAE3E,WAF2E,yBAE3E,WAF2E;AAAA,MAE9D,WAF8D,yBAE9D,WAF8D;;AAQnF,MAAM,UAAU,GAAG,sBAAc;AAAE,kBAAc,EAAd,cAAF;AAAkB,eAAW,EAAX;AAAlB,GAAd,CAAnB;AACA,MAAM,WAAW,GAAG,uBAAe;AAAE,mBAAe,EAAf,eAAF;AAAmB,eAAW,EAAX;AAAnB,GAAf,CAApB;AAEA,SAAO;AACH,eAAW,EAAX,WADG;AAEH,eAAW,EAAX,WAFG;AAGH,eAAW,EAAX,WAHG;AAIH,cAAU,EAAV,UAJG;AAKH,eAAW,EAAX;AALG,GAAP;AAOH,CAlBM;;AAAM,6BAAkB,kBAAlB;AAoBb;;;;;AAKK;;AACE,IAAM,gBAAgB,GAAG,SAAnB,gBAAmB,QAAwB;AAAA,MAArB,KAAqB,SAArB,KAAqB;AAAA,MAAd,GAAc,SAAd,GAAc;AAAA,MAAT,GAAS,SAAT,GAAS;AACpD,MAAM,IAAI,GAAG,CAAC,KAAK,GAAG,GAAT,KAAiB,GAAG,GAAG,GAAvB,CAAb;;AAEA,MAAI,IAAI,IAAI,GAAZ,EAAiB;AACb,WAAO,iCAAP;AACH;;AACD,MAAI,IAAI,GAAG,GAAP,IAAc,IAAI,IAAI,GAA1B,EAA+B;AAC3B,WAAO,iCAAP;AACH;;AAED,SAAO,+BAAP;AACH,CAXM;;AAAM,2BAAgB,gBAAhB;AAab;;;;;;;;;AASG;;AACI,IAAM,iBAAiB,GAAG,SAApB,iBAAoB,QAAqC;AAAA,MAAlC,WAAkC,SAAlC,WAAkC;AAAA,MAArB,KAAqB,SAArB,KAAqB;AAAA,MAAd,GAAc,SAAd,GAAc;AAAA,MAAT,GAAS,SAAT,GAAS;;AAClE,MAAI,GAAG,GAAG,GAAV,EAAe;AACX,WAAO,IAAP;AACH;;AAED,MAAI,KAAK,IAAI,GAAb,EAAkB;AACd,WAAO,WAAP;AACH;;AAED,MAAI,KAAK,GAAG,GAAZ,EAAiB;AACb,WAAO,CAAP;AACH;;AAED,SAAQ,WAAW,IAAI,KAAK,GAAG,GAAZ,CAAZ,IAAiC,GAAG,GAAG,GAAvC,CAAP;AACH,CAdM;;AAAM,4BAAiB,iBAAjB;AAgBb;;;;;;;;;;;;;AAaG;;AACI,IAAM,yBAAyB,GAAG,SAA5B,yBAA4B,QAOpC;AAAA,MAND,WAMC,SAND,WAMC;AAAA,MALD,WAKC,SALD,WAKC;AAAA,MAJD,UAIC,SAJD,UAIC;AAAA,MAHD,WAGC,SAHD,WAGC;AAAA,MAFD,cAEC,SAFD,cAEC;AAAA,MADD,WACC,SADD,WACC;AACD,MAAI,SAAS,GAAG,WAAhB;AACA,MAAI,SAAS,GAAG,WAAhB;;AAEA,MAAI,WAAW,KAAK,UAApB,EAAgC;AAC5B,aAAS,IAAI,CAAC,UAAU,GAAG,sBAAd,IAAgC,CAA7C;AACA,aAAS,IAAI,WAAW,GAAG,cAA3B;AACH,GAHD,MAGO;AACH,aAAS,IAAI,CAAC,WAAW,GAAG,sBAAf,IAAiC,CAA9C;AACH;;AAED,SAAO;AACH,aAAS,EAAT,SADG;AAEH,aAAS,EAAT;AAFG,GAAP;AAIH,CAtBM;;AAAM,oCAAyB,yBAAzB;AAwBb;;;;;;;AAOG;;AACI,IAAM,gBAAgB,GAAG,SAAnB,gBAAmB;AAAA,MAAG,cAAH,SAAG,cAAH;AAAA,MAAmB,WAAnB,SAAmB,WAAnB;AAAA,SAC5B,WAAW,KAAK,UAAhB,GAA6B,sBAA7B,GAA8C,cADlB;AAAA,CAAzB;;AAAM,2BAAgB,gBAAhB;AAGb;;;;;;;AAOG;;AACI,IAAM,iBAAiB,GAAG,SAApB,iBAAoB;AAAA,MAAG,cAAH,UAAG,cAAH;AAAA,MAAmB,WAAnB,UAAmB,WAAnB;AAAA,SAC7B,WAAW,KAAK,UAAhB,GAA6B,cAA7B,GAA8C,sBADjB;AAAA,CAA1B;;AAAM,4BAAiB,iBAAjB;AAGb;;;;;;;;;;;;;;;;;;;AAmBG;;AACI,IAAM,oBAAoB,GAAG,SAAvB,oBAAuB,SAU/B;AAAA,MATD,WASC,UATD,WASC;AAAA,MARD,WAQC,UARD,WAQC;AAAA,MAPD,WAOC,UAPD,WAOC;AAAA,MAND,UAMC,UAND,UAMC;AAAA,MALD,WAKC,UALD,WAKC;AAAA,MAJD,KAIC,UAJD,KAIC;AAAA,MAHD,GAGC,UAHD,GAGC;AAAA,MAFD,GAEC,UAFD,GAEC;AAAA,MADD,WACC,UADD,WACC;AACD,MAAM,cAAc,GAAG,0BAAkB;AAAE,eAAW,EAAX,WAAF;AAAe,SAAK,EAAL,KAAf;AAAsB,OAAG,EAAH,GAAtB;AAA2B,OAAG,EAAH;AAA3B,GAAlB,CAAvB;;AADC,8BAEoD,kCAA0B;AAC3E,eAAW,EAAX,WAD2E;AAE3E,eAAW,EAAX,WAF2E;AAG3E,cAAU,EAAV,UAH2E;AAI3E,eAAW,EAAX,WAJ2E;AAK3E,kBAAc,EAAd,cAL2E;AAM3E,eAAW,EAAX;AAN2E,GAA1B,CAFpD;AAAA,MAEkB,QAFlB,yBAEO,SAFP;AAAA,MAEuC,QAFvC,yBAE4B,SAF5B;;AAUD,MAAM,YAAY,GAAG,yBAAiB;AAAE,kBAAc,EAAd,cAAF;AAAkB,eAAW,EAAX;AAAlB,GAAjB,CAArB;AACA,MAAM,aAAa,GAAG,0BAAkB;AAAE,kBAAc,EAAd,cAAF;AAAkB,eAAW,EAAX;AAAlB,GAAlB,CAAtB;AAEA,SAAO;AACH,iBAAa,EAAE,cADZ;AAEH,YAAQ,EAAR,QAFG;AAGH,YAAQ,EAAR,QAHG;AAIH,gBAAY,EAAZ,YAJG;AAKH,iBAAa,EAAb;AALG,GAAP;AAOH,CA9BM;;AAAM,+BAAoB,oBAApB;AAgCb;;;;;;;;;;;AAWG;;AACI,IAAM,kCAAkC,GAAG,SAArC,kCAAqC,SAAuD;AAAA,MAApD,QAAoD,UAApD,QAAoD;AAAA,MAA1C,QAA0C,UAA1C,QAA0C;AAAA,MAAhC,aAAgC,UAAhC,aAAgC;AAAA,MAAjB,WAAiB,UAAjB,WAAiB;AACrG,MAAI,YAAY,GAAG,QAAnB;AACA,MAAI,YAAY,GAAG,QAAnB;;AAEA,MAAI,WAAW,KAAK,UAApB,EAAgC;AAC5B,gBAAY,IAAI,CAAC,0BAAkB,sBAAnB,IAAqC,CAArD;AACH,GAFD,MAEO;AACH,gBAAY,IAAI,aAAhB;AACA,gBAAY,IAAI,CAAC,0BAAkB,sBAAnB,IAAqC,CAArD;AACH;;AAED,SAAO;AACH,gBAAY,EAAZ,YADG;AAEH,gBAAY,EAAZ;AAFG,GAAP;AAIH,CAfM;;AAAM,6CAAkC,kCAAlC;AAiBb;;;;;;;;;;;;;;;;AAgBG;;AACI,IAAM,sBAAsB,GAAG,SAAzB,sBAAyB,SAOjC;AAAA,MAND,WAMC,UAND,WAMC;AAAA,MALD,WAKC,UALD,WAKC;AAAA,MAJD,WAIC,UAJD,WAIC;AAAA,MAHD,UAGC,UAHD,UAGC;AAAA,MAFD,WAEC,UAFD,WAEC;AAAA,MADD,WACC,UADD,WACC;AACD,MAAM,cAAc,GAAG,WAAvB,CADC,CACmC;;AADnC,+BAEwD,kCAA0B;AAC/E,eAAW,EAAX,WAD+E;AAE/E,eAAW,EAAX,WAF+E;AAG/E,cAAU,EAAV,UAH+E;AAI/E,eAAW,EAAX,WAJ+E;AAK/E,kBAAc,EAAd,cAL+E;AAM/E,eAAW,EAAX;AAN+E,GAA1B,CAFxD;AAAA,MAEkB,UAFlB,0BAEO,SAFP;AAAA,MAEyC,UAFzC,0BAE8B,SAF9B;;AAUD,MAAM,cAAc,GAAG,yBAAiB;AAAE,kBAAc,EAAd,cAAF;AAAkB,eAAW,EAAX;AAAlB,GAAjB,CAAvB;AACA,MAAM,eAAe,GAAG,0BAAkB;AAAE,kBAAc,EAAd,cAAF;AAAkB,eAAW,EAAX;AAAlB,GAAlB,CAAxB;AAEA,SAAO;AACH,mBAAe,EAAE,cADd;AAEH,cAAU,EAAV,UAFG;AAGH,cAAU,EAAV,UAHG;AAIH,kBAAc,EAAd,cAJG;AAKH,mBAAe,EAAf;AALG,GAAP;AAOH,CA3BM;;AAAM,iCAAsB,sBAAtB;AA6Bb;;;;;;;;;;;;;;;AAeG;;AACI,IAAM,kCAAkC,GAAG,SAArC,kCAAqC,SAS7C;AAAA,MARD,UAQC,UARD,UAQC;AAAA,MAPD,UAOC,UAPD,UAOC;AAAA,MAND,eAMC,UAND,eAMC;AAAA,MALgB,WAKhB,UALD,eAKC;AAAA,MAJD,WAIC,UAJD,WAIC;AAAA,MAHD,KAGC,UAHD,KAGC;AAAA,MAFD,GAEC,UAFD,GAEC;AAAA,MADD,GACC,UADD,GACC;AACD,MAAI,YAAY,GAAG,UAAnB;AACA,MAAI,YAAY,GAAG,UAAnB;;AACA,MAAI,WAAW,KAAK,UAApB,EAAgC;AAC5B,gBAAY,IAAI,eAAe,GAAG,0BAAkB;AAAE,iBAAW,EAAX,WAAF;AAAe,WAAK,EAAL,KAAf;AAAsB,SAAG,EAAH,GAAtB;AAA2B,SAAG,EAAH;AAA3B,KAAlB,CAAlC;AACA,gBAAY,IAAI,CAAC,0BAAkB,sBAAnB,IAAqC,CAArD;AACH,GAHD,MAGO;AACH,gBAAY,IAAI,0BAAkB;AAAE,iBAAW,EAAX,WAAF;AAAe,WAAK,EAAL,KAAf;AAAsB,SAAG,EAAH,GAAtB;AAA2B,SAAG,EAAH;AAA3B,KAAlB,CAAhB;AACA,gBAAY,IAAI,CAAC,0BAAkB,sBAAnB,IAAqC,CAArD;AACH;;AAED,SAAO;AACH,gBAAY,EAAZ,YADG;AAEH,gBAAY,EAAZ;AAFG,GAAP;AAIH,CAxBM;;AAAM,6CAAkC,kCAAlC;AA0Bb;;;;;AAKG;;AACI,IAAM,eAAe,GAAG,SAAlB,eAAkB,OAAM;AAAA,SAAI,MAAM,CAAC,IAAP,CAAY,UAAC,CAAD,EAAI,CAAJ;AAAA,WAAU,CAAC,CAAC,IAAF,GAAS,CAAC,CAAC,IAArB;AAAA,GAAZ,CAAJ;AAAA,CAA9B;;AAAM,0BAAe,eAAf;AAEb;;;;;AAKG;;AACI,IAAM,cAAc,GAAG,SAAjB,cAAiB,OAAM,EAAG;AACnC,MAAI,CAAC,MAAM,CAAC,MAAZ,EAAoB;AAChB,WAAO,SAAE,kCAAF,CAAP;AACH,GAHkC,CAKnC;;;AACA,MAAI,MAAM,CAAC,IAAP,CAAY,eAAK;AAAA,WAAI,KAAK,CAAC,IAAN,IAAc,KAAK,CAAC,EAAxB;AAAA,GAAjB,CAAJ,EAAkD;AAC9C,WAAO,SAAE,kDAAF,CAAP;AACH,GARkC,CAUnC;;;AACA,MAAI,MAAM,CAAC,MAAP,KAAkB,gBAAO,MAAP,EAAe,IAAf,EAAqB,MAAvC,IAAiD,MAAM,CAAC,MAAP,KAAkB,gBAAO,MAAP,EAAe,MAAf,EAAuB,MAA9F,EAAsG;AAClG,WAAO,SAAE,qDAAF,CAAP;AACH;;AAED,MAAM,YAAY,GAAG,wBAAgB,MAAhB,CAArB,CAfmC,CAiBnC;;AACA,OAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,YAAY,CAAC,MAAjC,EAAyC,CAAC,IAAI,CAA9C,EAAiD;AAC7C,QAAI,YAAY,CAAC,CAAD,CAAZ,CAAgB,IAAhB,KAAyB,YAAY,CAAC,CAAC,GAAG,CAAL,CAAZ,CAAoB,EAAjD,EAAqD;AACjD,aAAO,SAAE,yDAAF,CAAP;AACH;AACJ;;AAED,SAAO,IAAP;AACH,CAzBM;;AAAM,yBAAc,cAAd;AA2Bb;;;;;;;AAOG;;AACI,IAAM,aAAa,GAAG,SAAhB,aAAgB,OAAM,EAAG;AAClC,MAAM,GAAG,GAAG,IAAI,CAAC,GAAL,WAAI,qBAAQ,MAAM,CAAC,GAAP,CAAW,eAAK;AAAA,WAAI,KAAK,CAAC,IAAV;AAAA,GAAhB,CAAR,EAAhB;AACA,MAAM,GAAG,GAAG,IAAI,CAAC,GAAL,WAAI,qBAAQ,MAAM,CAAC,GAAP,CAAW,eAAK;AAAA,WAAI,KAAK,CAAC,EAAV;AAAA,GAAhB,CAAR,EAAhB;AACA,SAAO;AAAE,OAAG,EAAH,GAAF;AAAO,OAAG,EAAH;AAAP,GAAP;AACH,CAJM;;AAAM,wBAAa,aAAb;AAMb;;;;;;AAMG;;AACI,IAAM,sBAAsB,GAAG,SAAzB,sBAAyB,SAA4B;AAAA,MAAzB,MAAyB,UAAzB,MAAyB;AAAA,MAAjB,WAAiB,UAAjB,WAAiB;;AAAA,8BACzC,sBAAc,MAAd,CADyC;AAAA,MACtD,GADsD,yBACtD,GADsD;AAAA,MACjD,GADiD,yBACjD,GADiD;;AAE9D,MAAM,WAAW,GAAG,CAAC,wBAAwB,GAAG,wBAA5B,KAAyD,GAAG,GAAG,GAA/D,CAApB;AACA,MAAI,OAAO,GAAG,MAAM,CAAC,GAAP,CAAW,eAAK;AAAA,WAAI,IAAI,CAAC,GAAL,CAAS,KAAK,CAAC,IAAN,GAAa,KAAK,CAAC,EAA5B,IAAkC,WAAtC;AAAA,GAAhB,CAAd,CAH8D,CAI9D;;AACA,SAAO,GAAG,WAAW,KAAK,UAAhB,GAA6B,OAAO,CAAC,OAAR,EAA7B,GAAiD,OAA3D;AACA,MAAM,iBAAiB,GAAG,EAA1B;AACA,SAAO,CAAC,MAAR,CAAe,UAAC,WAAD,EAAc,YAAd,EAA4B,GAA5B,EAAmC;AAC9C,qBAAiB,CAAC,GAAD,CAAjB,GAAyB,WAAW,GAAG,YAAvC;AACA,WAAO,iBAAiB,CAAC,GAAD,CAAxB;AACH,GAHD,EAGG,CAHH;AAIA,SAAO,iBAAP;AACH,CAZM;;AAAM,iCAAsB,sBAAtB;AAcb;;;;;;AAMG;;AACI,IAAM,qBAAqB,GAAG,SAAxB,qBAAwB,SAA4B;AAAA,MAAzB,MAAyB,UAAzB,MAAyB;AAAA,MAAjB,WAAiB,UAAjB,WAAiB;AAC7D,MAAM,UAAU,GAAG,MAAM,CAAC,GAAP,CAAW,eAAK;AAAA,WAAI,KAAK,CAAC,KAAV;AAAA,GAAhB,CAAnB,CAD6D,CAE7D;;AACA,SAAO,WAAW,KAAK,UAAhB,GAA6B,UAAU,CAAC,OAAX,EAA7B,GAAoD,UAA3D;AACH,CAJM;;AAAM,gCAAqB,qBAArB;AAMb;;;;;;;AAOG;;AACI,IAAM,gBAAgB,GAAG,SAAnB,gBAAmB,SAA4B;AAAA,MAAzB,MAAyB,UAAzB,MAAyB;AAAA,MAAjB,WAAiB,UAAjB,WAAiB;AACxD,MAAM,KAAK,GAAG,EAAd;AACA,MAAM,OAAO,GAAG,+BAAuB;AAAE,UAAM,EAAN,MAAF;AAAU,eAAW,EAAX;AAAV,GAAvB,CAAhB;AACA,MAAM,UAAU,GAAG,8BAAsB;AAAE,UAAM,EAAN,MAAF;AAAU,eAAW,EAAX;AAAV,GAAtB,CAAnB,CAHwD,CAIxD;;AACA,OAAK,CAAC,IAAN,CAAW;AAAE,UAAM,YAAK,OAAO,CAAC,CAAD,CAAZ,MAAR;AAA4B,aAAS,EAAE,UAAU,CAAC,CAAD;AAAjD,GAAX,EALwD,CAMxD;;AACA,OAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,MAAM,CAAC,MAA3B,EAAmC,CAAC,IAAI,CAAxC,EAA2C;AACvC,SAAK,CAAC,IAAN,CAAW;AAAE,YAAM,YAAK,OAAO,CAAC,CAAC,GAAG,CAAL,CAAZ,MAAR;AAAgC,eAAS,EAAE,UAAU,CAAC,CAAD;AAArD,KAAX;AACA,SAAK,CAAC,IAAN,CAAW;AAAE,YAAM,YAAK,OAAO,CAAC,CAAD,CAAZ,MAAR;AAA4B,eAAS,EAAE,UAAU,CAAC,CAAD;AAAjD,KAAX;AACH;;AACD,SAAO,KAAP;AACH,CAZM;;AAAM,2BAAgB,gBAAhB;AAcb;;;;;;;;;AASG;;AACI,IAAM,qBAAqB,GAAG,SAAxB,qBAAwB,YAAW,EAAG;AAC/C,MAAM,EAAE,GAAG,IAAX;AACA,MAAM,EAAE,GAAG,IAAX;AACA,MAAM,EAAE,GAAG,WAAW,KAAK,YAAhB,GAA+B,MAA/B,GAAwC,IAAnD;AACA,MAAM,EAAE,GAAG,WAAW,KAAK,YAAhB,GAA+B,IAA/B,GAAsC,MAAjD;AACA,SAAO;AAAE,MAAE,EAAF,EAAF;AAAM,MAAE,EAAF,EAAN;AAAU,MAAE,EAAF,EAAV;AAAc,MAAE,EAAF;AAAd,GAAP;AACH,CANM;;AAAM,gCAAqB,qBAArB,C,CAYb;;AACA,IAAM,mBAAmB,GAAG;AACxB,mBAAiB,EAAE,WADK;AAExB,aAAW,EAAE;AAFW,CAA5B;AAKA;;;;;AAKG;;AACI,IAAM,WAAW,GAAG,SAAd,WAAc,CAAC,OAAD;AAAA,SACvB,iBAAQ,OAAR,EAAiB,UAAC,GAAD,EAAM,GAAN;AAAA,WAAe,mBAAmB,CAAC,GAAD,CAAnB,GAA2B,mBAAmB,CAAC,GAAD,CAA9C,GAAsD,GAArE;AAAA,GAAjB,CADuB;AAAA,CAApB;;AAAM,sBAAW,WAAX;AAKb;;;;;;AAMG;;AACI,IAAM,oBAAoB,GAAG,SAAvB,oBAAuB,CAAC,YAAD,EAA6B,OAA7B,EAAoE;AACpG,MAAM,YAAY,GAAW,YAAY,KAAK,OAAjB,GAA2B,OAA3B,GAAqC,OAAlE;AACA,MAAM,OAAO,GAAW,YAAY,KAAK,OAAjB,GAA2B,WAA3B,GAAyC,YAAjE;AACA,MAAM,UAAU,0BAAmB,YAAnB,CAAhB;AACA,MAAM,YAAY,aAAM,YAAN,YAAlB;AACA,MAAM,UAAU,qBAAQ,OAAR,CAAhB;;AACA,MAAI,UAAU,CAAC,YAAD,CAAd,EAA8B;AAC1B,QAAI,UAAU,CAAC,YAAD,CAAV,KAA6B,QAAjC,EAA2C;AACvC,gBAAU,CAAC,OAAD,CAAV,GAAsB,IAAtB;AACA,gBAAU,CAAC,UAAD,CAAV,GAAyB,KAAzB;AACH,KAHD,MAGO,IAAI,UAAU,CAAC,YAAD,CAAV,KAA6B,YAAjC,EAA+C;AAClD,gBAAU,CAAC,OAAD,CAAV,GAAsB,IAAtB;AACA,gBAAU,CAAC,UAAD,CAAV,GAAyB,IAAzB;AACH,KAHM,MAGA;AACH,gBAAU,CAAC,OAAD,CAAV,GAAsB,KAAtB;AACA,gBAAU,CAAC,UAAD,CAAV,GAAyB,KAAzB;AACH;AACJ;;AACD,SAAO,cAAK,UAAL,EAAiB,CAAC,YAAD,CAAjB,CAAP;AACH,CAnBM;;AAAM,+BAAoB,oBAApB;AAqBb;;;;;;AAMG;;AACI,IAAM,wBAAwB,GAAG,SAA3B,wBAA2B,CAAC,eAAD;AAAA,SACpC,eAAM,oBAAY,eAAZ,CAAN,EACK,IADL,CACU,iBAAO;AAAA,WAAI,6BAAqB,OAArB,EAA8B,OAA9B,CAAJ;AAAA,GADjB,EAEK,IAFL,CAEU,iBAAO;AAAA,WAAI,6BAAqB,OAArB,EAA8B,OAA9B,CAAJ;AAAA,GAFjB,EAGK,KAHL,EADoC;AAAA,CAAjC;;AAAM,mCAAwB,wBAAxB,C;;;;;;;ACzjBb,yE;;;;;;;ACAA,kD","file":"gaugeUtils.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 68);\n","module.exports = require(\"@babel/runtime/helpers/toConsumableArray\");","module.exports = require(\"lodash\");","import { chain, mapKeys, omit, uniqBy } from 'lodash';\nimport {\n    SEMANTIC_SUCCESS,\n    SEMANTIC_WARNING,\n    SEMANTIC_ERROR,\n} from '@splunk/visualizations-shared/colorConstants';\nimport { _ } from '@splunk/ui-utils/i18n';\n\nexport const GAUGE_THICKNESS = 50;\nexport const FILL_THICKNESS = 38;\nconst GRADIENT_STOP_OFFSET_MIN = 0;\nconst GRADIENT_STOP_OFFSET_MAX = 100;\n\n/**\n * get width for the whole gauge viz for horizontal or vertical view\n * @method getGaugeWidth\n * @param {Object} input\n * @param {Number} containerWidth\n * @param {String} orientation\n * @return {Number} width\n */\nexport const getGaugeWidth = ({ containerWidth, orientation }) =>\n    orientation === 'vertical' ? GAUGE_THICKNESS : containerWidth * 0.8;\n\n/**\n * get height for the whole gauge viz for horizontal or vertical view\n * @method getGaugeHeight\n * @param {Object} input\n * @param {Number} containerHeight\n * @param {String} orientation\n * @return {Number} height\n */\nexport const getGaugeHeight = ({ containerHeight, orientation }) =>\n    orientation === 'vertical' ? containerHeight * 0.8 : GAUGE_THICKNESS;\n\n/**\n * get how long the gauge shoud be.\n * In horizontal view, gauge length equals to gauge width. In vertical view, it equals to gauge height.\n * @method getGaugeLength\n * @param {Object} input\n * @param {Number} input.containerWidth\n * @param {Number} input.containerHeight\n * @param {String} input.orientation\n * @return {Number} gaugeLength\n */\nexport const getGaugeLength = ({ containerWidth, containerHeight, orientation }) =>\n    orientation === 'vertical'\n        ? getGaugeHeight({ containerHeight, orientation })\n        : getGaugeWidth({ containerWidth, orientation });\n\n/**\n * get start x and y for rendering gauge\n * @method getGaugeStartPosition\n * @param {Object} input\n * @param {Number} containerWidth\n * @param {Number} containerHeight\n * @param {Number} gaugeLength\n * @param {String} orientation\n * @return {Object} position\n * @return {Number} position.gaugeStartX\n * @return {Number} position.gaugeStartY\n */\nexport const getGaugeStartPosition = ({ containerWidth, containerHeight, gaugeLength, orientation }) => {\n    // for horizontal view\n    let gaugeStartX = (containerWidth - gaugeLength) / 2.0;\n    let gaugeStartY = (containerHeight - GAUGE_THICKNESS) / 2.0;\n\n    if (orientation === 'vertical') {\n        gaugeStartX = (containerWidth - GAUGE_THICKNESS) / 2.0;\n        gaugeStartY = (containerHeight - gaugeLength) / 2.0;\n    }\n\n    return { gaugeStartX, gaugeStartY };\n};\n\n/**\n * get dimensions for the whole gauge viz,\n * which can be useful to calculate background bar and major ticks positions.\n * @method getGaugeDimensions\n * @param {Object} input\n * @param {Number} input.containerWidth\n * @param {Number} input.containerHeight\n * @param {String} input.orientation  'horizontal' or 'vertical'\n * @return {Object} gaugeDimensions\n * @return {Number} gaugeDimensions.gaugeLength  how long the gauge shoud be in horizontal or vertical orientation.\n * @return {Number} gaugeDimensions.gaugeStartX  start x to render gauge\n * @return {Number} gaugeDimensions.gaugeStartY  start y to render gauge\n * @return {Number} gaugeDimensions.gaugeWidth   natural width of gauge\n * @return {Number} gaugeDimensions.gaugeHeight  natural height of gauge\n */\nexport const getGaugeDimensions = ({ containerWidth, containerHeight, orientation }) => {\n    const gaugeLength = getGaugeLength({ containerWidth, containerHeight, orientation });\n    const { gaugeStartX, gaugeStartY } = getGaugeStartPosition({\n        containerWidth,\n        containerHeight,\n        gaugeLength,\n        orientation,\n    });\n    const gaugeWidth = getGaugeWidth({ containerWidth, orientation });\n    const gaugeHeight = getGaugeHeight({ containerHeight, orientation });\n\n    return {\n        gaugeLength,\n        gaugeStartX,\n        gaugeStartY,\n        gaugeWidth,\n        gaugeHeight,\n    };\n};\n\n/**\n * if gaugeColor is not specified, auto assign a gauge color to the fill bar\n * based on how much percentage the value is taken between min and max\n * @method assignGaugeColor\n * @params\n * */\nexport const assignGaugeColor = ({ value, min, max }) => {\n    const rate = (value - min) / (max - min);\n\n    if (rate <= 0.3) {\n        return SEMANTIC_SUCCESS;\n    }\n    if (rate > 0.3 && rate <= 0.6) {\n        return SEMANTIC_WARNING;\n    }\n\n    return SEMANTIC_ERROR;\n};\n\n/**\n * get inner bar length in gauge\n * @method getGaugeBarLength\n * @param {Object} input\n * @param {Number} input.gaugeLength\n * @param {Number} input.value\n * @param {Number} input.min\n * @param {Number} input.max\n * @return {Number} gaugeBarLength\n */\nexport const getGaugeBarLength = ({ gaugeLength, value, min, max }) => {\n    if (max < min) {\n        return null;\n    }\n\n    if (value >= max) {\n        return gaugeLength;\n    }\n\n    if (value < min) {\n        return 0;\n    }\n\n    return (gaugeLength * (value - min)) / (max - min);\n};\n\n/**\n * get x and y position for rendering inner bar in gauge\n * @method getGaugeBarStartPositions\n * @param {Object} input\n * @param {Number} input.gaugeStartX\n * @param {Number} input.gaugeStartY\n * @param {Number} input.gaugeWidth\n * @param {Number} input.gaugeHeight\n * @param {Number} input.gaugeBarLength\n * @param {String} input.orientation\n * @return {Object} position\n * @return {Number} position.gaugeBarX\n * @return {Number} position.gaugeBarY\n */\nexport const getGaugeBarStartPositions = ({\n    gaugeStartX,\n    gaugeStartY,\n    gaugeWidth,\n    gaugeHeight,\n    gaugeBarLength,\n    orientation,\n}) => {\n    let gaugeBarX = gaugeStartX;\n    let gaugeBarY = gaugeStartY;\n\n    if (orientation === 'vertical') {\n        gaugeBarX += (gaugeWidth - FILL_THICKNESS) / 2;\n        gaugeBarY += gaugeHeight - gaugeBarLength;\n    } else {\n        gaugeBarY += (gaugeHeight - FILL_THICKNESS) / 2;\n    }\n\n    return {\n        gaugeBarX,\n        gaugeBarY,\n    };\n};\n\n/**\n * get width of inner bar in gauge\n * @method getGaugeBarWidth\n * @param {Object} input\n * @param {Number} input.gaugeBarLength\n * @param {String} orientation\n * @return {Number} gaugeBarWidth\n */\nexport const getGaugeBarWidth = ({ gaugeBarLength, orientation }) =>\n    orientation === 'vertical' ? FILL_THICKNESS : gaugeBarLength;\n\n/**\n * get height of inner bar in gauge\n * @method getGaugeBarWidth\n * @param {Object} input\n * @param {Number} input.gaugeBarLength\n * @param {String} orientation\n * @return {Number} gaugeBarHeight\n */\nexport const getGaugeBarHeight = ({ gaugeBarLength, orientation }) =>\n    orientation === 'vertical' ? gaugeBarLength : FILL_THICKNESS;\n\n/**\n * get dimensions for the fill bar in the gauge\n * @method getFillBarDimensions\n * @param {Object} input\n * @param {Number} input.gaugeLength\n * @param {Number} input.gaugeStartX\n * @param {Number} input.gaugeStartY\n * @param {Number} input.gaugeWidth,\n * @param {Number} input.gaugeHeight,\n * @param {Number} input.value,\n * @param {Number} input.min,\n * @param {Number} input.max,\n * @param {String} input.orientation\n * @return {Object} fillBarDimensions\n * @return {Number} fillBarDimensions.fillBarLength\n * @return {Number} fillBarDimensions.fillBarX\n * @return {Number} fillBarDimensions.fillBarY\n * @return {Number} fillBarDimensions.fillBarWidth\n * @return {Number} fillBarDimensions.fillBarHeight\n */\nexport const getFillBarDimensions = ({\n    gaugeLength,\n    gaugeStartX,\n    gaugeStartY,\n    gaugeWidth,\n    gaugeHeight,\n    value,\n    min,\n    max,\n    orientation,\n}) => {\n    const gaugeBarLength = getGaugeBarLength({ gaugeLength, value, max, min });\n    const { gaugeBarX: fillBarX, gaugeBarY: fillBarY } = getGaugeBarStartPositions({\n        gaugeStartX,\n        gaugeStartY,\n        gaugeWidth,\n        gaugeHeight,\n        gaugeBarLength,\n        orientation,\n    });\n    const fillBarWidth = getGaugeBarWidth({ gaugeBarLength, orientation });\n    const fillBarHeight = getGaugeBarHeight({ gaugeBarLength, orientation });\n\n    return {\n        fillBarLength: gaugeBarLength,\n        fillBarX,\n        fillBarY,\n        fillBarWidth,\n        fillBarHeight,\n    };\n};\n\n/**\n * get position x and y for value marker in filler gauge\n * @method getFillerGaugeValueMarkerPositions\n * @param {Object} input\n * @param {Number} input.fillBarX\n * @param {Number} input.fillBarY\n * @param {Number} input.fillBarLength\n * @param {String} input.orientation\n * @return {Object} position\n * @return {Number} position.valueMarkerX\n * @return {Number} position.valueMarkerY\n */\nexport const getFillerGaugeValueMarkerPositions = ({ fillBarX, fillBarY, fillBarLength, orientation }) => {\n    let valueMarkerX = fillBarX;\n    let valueMarkerY = fillBarY;\n\n    if (orientation === 'vertical') {\n        valueMarkerX -= (GAUGE_THICKNESS - FILL_THICKNESS) / 4;\n    } else {\n        valueMarkerX += fillBarLength;\n        valueMarkerY -= (GAUGE_THICKNESS - FILL_THICKNESS) / 4;\n    }\n\n    return {\n        valueMarkerX,\n        valueMarkerY,\n    };\n};\n\n/**\n * get dimensions for the marker bar in the gauge\n * @method getMarkerBarDimensions\n * @param {Object} input\n * @param {Number} input.gaugeLength\n * @param {Number} input.gaugeStartX\n * @param {Number} input.gaugeStartY\n * @param {Number} input.gaugeWidth,\n * @param {Number} input.gaugeHeight,\n * @param {String} input.orientation\n * @return {Object} markerBarDimensions\n * @return {Number} markerBarDimensions.markerBarLength\n * @return {Number} markerBarDimensions.markerBarX\n * @return {Number} markerBarDimensions.markerBarY\n * @return {Number} markerBarDimensions.markerBarWidth\n * @return {Number} markerBarDimensions.markerBarHeight\n */\nexport const getMarkerBarDimensions = ({\n    gaugeLength,\n    gaugeStartX,\n    gaugeStartY,\n    gaugeWidth,\n    gaugeHeight,\n    orientation,\n}) => {\n    const gaugeBarLength = gaugeLength; // For marker gauge, inner marker bar spans the entire gauge\n    const { gaugeBarX: markerBarX, gaugeBarY: markerBarY } = getGaugeBarStartPositions({\n        gaugeStartX,\n        gaugeStartY,\n        gaugeWidth,\n        gaugeHeight,\n        gaugeBarLength,\n        orientation,\n    });\n    const markerBarWidth = getGaugeBarWidth({ gaugeBarLength, orientation });\n    const markerBarHeight = getGaugeBarHeight({ gaugeBarLength, orientation });\n\n    return {\n        markerBarLength: gaugeBarLength,\n        markerBarX,\n        markerBarY,\n        markerBarWidth,\n        markerBarHeight,\n    };\n};\n\n/**\n * get position x and y for value marker in marker gauge\n * @method getMarkerGaugeValueMarkerPositions\n * @param {Object} input\n * @param {Number} input.markerBarX\n * @param {Number} input.markerBarY\n * @param {Number} input.markerBarHeight\n * @param {Number} input.markerBarLength\n * @param {Number} input.value\n * @param {Number} input.min\n * @param {Number} input.max\n * @param {String} input.orientation\n * @return {Object} position\n * @return {Number} position.valueMarkerX\n * @return {Number} position.valueMarkerY\n */\nexport const getMarkerGaugeValueMarkerPositions = ({\n    markerBarX,\n    markerBarY,\n    markerBarHeight,\n    markerBarLength: gaugeLength,\n    orientation,\n    value,\n    min,\n    max,\n}) => {\n    let valueMarkerX = markerBarX;\n    let valueMarkerY = markerBarY;\n    if (orientation === 'vertical') {\n        valueMarkerY += markerBarHeight - getGaugeBarLength({ gaugeLength, value, max, min });\n        valueMarkerX -= (GAUGE_THICKNESS - FILL_THICKNESS) / 4;\n    } else {\n        valueMarkerX += getGaugeBarLength({ gaugeLength, value, max, min });\n        valueMarkerY -= (GAUGE_THICKNESS - FILL_THICKNESS) / 4;\n    }\n\n    return {\n        valueMarkerX,\n        valueMarkerY,\n    };\n};\n\n/**\n * sort the ranges in ascending order\n * @method getSortedRanges\n * @param {Array} ranges\n * @return {Array} sortedRanges\n */\nexport const getSortedRanges = ranges => ranges.sort((a, b) => a.from - b.from);\n\n/**\n * validate whether ranges prop is valid - continuous ranges, range.to < range.from, range.from != range.to\n * @method validateRanges\n * @param {Array} ranges\n * @return {String} error\n */\nexport const validateRanges = ranges => {\n    if (!ranges.length) {\n        return _('Prop \"ranges\" is missing entries');\n    }\n\n    // check whether a range has \"from\" >= \"to\" eg: 10 - 10, 100 - 10, -20 - -10 are invalid\n    if (ranges.some(range => range.from >= range.to)) {\n        return _('Prop \"ranges\" has invalid entries: invalid range');\n    }\n\n    // check whether ranges have duplicate \"from/to\" eg: 0 - 50, 25 - 50\n    if (ranges.length !== uniqBy(ranges, 'to').length || ranges.length !== uniqBy(ranges, 'from').length) {\n        return _('Prop \"ranges\" has invalid entries: duplicate values');\n    }\n\n    const sortedRanges = getSortedRanges(ranges);\n\n    // check whether ranges are continuous eg: 0 - 10, 10 - 20, 20 - 30\n    for (let i = 1; i < sortedRanges.length; i += 1) {\n        if (sortedRanges[i].from !== sortedRanges[i - 1].to) {\n            return _('Prop \"ranges\" has invalid entries: discontinuous ranges');\n        }\n    }\n\n    return null;\n};\n\n/**\n * calculate min and max value of gauge\n * @method getGaugeRange\n * @param {Array} ranges\n * @return {Object} gaugeRange\n * @return {Number} gaugeRange.min\n * @return {Number} gaugeRange.max\n */\nexport const getGaugeRange = ranges => {\n    const min = Math.min(...ranges.map(range => range.from));\n    const max = Math.max(...ranges.map(range => range.to));\n    return { min, max };\n};\n\n/**\n * calculate stop offsets for linear gradient\n * @method getGradientStopOffsets\n * @param {Array} ranges\n * @param {String} orientation\n * @return {Array} cumulativeOffsets\n */\nexport const getGradientStopOffsets = ({ ranges, orientation }) => {\n    const { min, max } = getGaugeRange(ranges);\n    const offsetScale = (GRADIENT_STOP_OFFSET_MAX - GRADIENT_STOP_OFFSET_MIN) / (max - min);\n    let offsets = ranges.map(range => Math.abs(range.from - range.to) * offsetScale);\n    // When orientation is vertical, since the gauge starts from bottom to top, linear gradient should be reversed\n    offsets = orientation === 'vertical' ? offsets.reverse() : offsets;\n    const cumulativeOffsets = [];\n    offsets.reduce((accumulator, currentValue, idx) => {\n        cumulativeOffsets[idx] = accumulator + currentValue;\n        return cumulativeOffsets[idx];\n    }, 0);\n    return cumulativeOffsets;\n};\n\n/**\n * calculate stop colors for linear gradient\n * @method getGradientStopColors\n * @param {Array} ranges\n * @param {String} orientation\n * @return {Array} stopColors\n */\nexport const getGradientStopColors = ({ ranges, orientation }) => {\n    const stopColors = ranges.map(range => range.value);\n    // When orientation is vertical, since the gauge starts from bottom to top, linear gradient should be reversed\n    return orientation === 'vertical' ? stopColors.reverse() : stopColors;\n};\n\n/**\n * calculate linear gradient stops from ranges\n * @method getGradientStops\n * @param {Object} input\n * @param {Array} ranges\n * @param {String} orientation\n * @return {Array} stops\n */\nexport const getGradientStops = ({ ranges, orientation }) => {\n    const stops = [];\n    const offsets = getGradientStopOffsets({ ranges, orientation });\n    const stopColors = getGradientStopColors({ ranges, orientation });\n    // Initialize stops with the first color stop\n    stops.push({ offset: `${offsets[0]}%`, stopColor: stopColors[0] });\n    // Add the remaining color stops with gradient change at each stop\n    for (let i = 1; i < ranges.length; i += 1) {\n        stops.push({ offset: `${offsets[i - 1]}%`, stopColor: stopColors[i] });\n        stops.push({ offset: `${offsets[i]}%`, stopColor: stopColors[i] });\n    }\n    return stops;\n};\n\n/**\n * calculate linear gradient dimensions\n * @method getGradientDimensions\n * @param {String} orientation\n * @return {Object} dimensions\n * @return {String} dimensions.x1\n * @return {String} dimensions.y1\n * @return {String} dimensions.x2\n * @return {String} dimensions.y2\n */\nexport const getGradientDimensions = orientation => {\n    const x1 = '0%';\n    const y1 = '0%';\n    const x2 = orientation === 'horizontal' ? '100%' : '0%';\n    const y2 = orientation === 'horizontal' ? '0%' : '100%';\n    return { x1, y1, x2, y2 };\n};\n\ninterface GaugeOptions {\n    [key: string]: any;\n}\n\n// map for new options names to old option names\nconst gaugeOptionsMapping = {\n    majorTickInterval: 'majorUnit',\n    gaugeRanges: 'ranges',\n};\n\n/**\n * Helper method to update the option names which can be mapped to pure component options\n * @method mapToOldKey\n * @param {Object} options\n * @returns {Object}\n */\nexport const mapToOldKey = (options: GaugeOptions): GaugeOptions =>\n    mapKeys(options, (val, key) => (gaugeOptionsMapping[key] ? gaugeOptionsMapping[key] : key));\n\ntype LabelOrValue = 'label' | 'value';\n\n/**\n * Helper method to map labelDisplay and valueDisplay options to pure component option names\n * @method mapToOldKey\n * @param {string} labelOrValue\n * @param {Object} options\n * @returns {Object}\n */\nexport const mapValueLabelDisplay = (labelOrValue: LabelOrValue, options: GaugeOptions): GaugeOptions => {\n    const rangeOrValue: string = labelOrValue === 'value' ? 'Value' : 'Range';\n    const showKey: string = labelOrValue === 'value' ? 'showValue' : 'showLabels';\n    const percentKey = `usePercentage${rangeOrValue}`;\n    const optionString = `${labelOrValue}Display`;\n    const newOptions = { ...options };\n    if (newOptions[optionString]) {\n        if (newOptions[optionString] === 'number') {\n            newOptions[showKey] = true;\n            newOptions[percentKey] = false;\n        } else if (newOptions[optionString] === 'percentage') {\n            newOptions[showKey] = true;\n            newOptions[percentKey] = true;\n        } else {\n            newOptions[showKey] = false;\n            newOptions[percentKey] = false;\n        }\n    }\n    return omit(newOptions, [optionString]);\n};\n\n/**\n * Chained helper for mapping the option properties (and values) we expose in config.ts into property values that pure component accepts\n * This is for options that has new key name and can not directly be mapped with pure component props\n * @method convertToGaugeProperties\n * @param {Object} originalOptions\n * @returns {Object}\n */\nexport const convertToGaugeProperties = (originalOptions: GaugeOptions): GaugeOptions =>\n    chain(mapToOldKey(originalOptions))\n        .thru(options => mapValueLabelDisplay('label', options))\n        .thru(options => mapValueLabelDisplay('value', options))\n        .value();\n","module.exports = require(\"@splunk/visualizations-shared/colorConstants\");","module.exports = require(\"@splunk/ui-utils/i18n\");"],"sourceRoot":""}
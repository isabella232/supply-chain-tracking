/*!
 * Copyright © 2018 Splunk Inc.
 * SPLUNK CONFIDENTIAL – Use or disclosure of this material in whole or
 * in part without a valid written license from Splunk Inc. is PROHIBITED.
 */
module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 68);
/******/ })
/************************************************************************/
/******/ ({

/***/ 25:
/***/ (function(module, exports) {

module.exports = require("@babel/runtime/helpers/toConsumableArray");

/***/ }),

/***/ 3:
/***/ (function(module, exports) {

module.exports = require("lodash");

/***/ }),

/***/ 68:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _toConsumableArray = __webpack_require__(25);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.convertToGaugeProperties = exports.mapValueLabelDisplay = exports.mapToOldKey = exports.getGradientDimensions = exports.getGradientStops = exports.getGradientStopColors = exports.getGradientStopOffsets = exports.getGaugeRange = exports.validateRanges = exports.getSortedRanges = exports.getMarkerGaugeValueMarkerPositions = exports.getMarkerBarDimensions = exports.getFillerGaugeValueMarkerPositions = exports.getFillBarDimensions = exports.getGaugeBarHeight = exports.getGaugeBarWidth = exports.getGaugeBarStartPositions = exports.getGaugeBarLength = exports.assignGaugeColor = exports.getGaugeDimensions = exports.getGaugeStartPosition = exports.getGaugeLength = exports.getGaugeHeight = exports.getGaugeWidth = exports.FILL_THICKNESS = exports.GAUGE_THICKNESS = void 0;

var lodash_1 = __webpack_require__(3);

var colorConstants_1 = __webpack_require__(69);

var i18n_1 = __webpack_require__(7);

exports.GAUGE_THICKNESS = 50;
exports.FILL_THICKNESS = 38;
var GRADIENT_STOP_OFFSET_MIN = 0;
var GRADIENT_STOP_OFFSET_MAX = 100;
/**
 * get width for the whole gauge viz for horizontal or vertical view
 * @method getGaugeWidth
 * @param {Object} input
 * @param {Number} containerWidth
 * @param {String} orientation
 * @return {Number} width
 */

var getGaugeWidth = function getGaugeWidth(_ref) {
  var containerWidth = _ref.containerWidth,
      orientation = _ref.orientation;
  return orientation === 'vertical' ? exports.GAUGE_THICKNESS : containerWidth * 0.8;
};

exports.getGaugeWidth = getGaugeWidth;
/**
 * get height for the whole gauge viz for horizontal or vertical view
 * @method getGaugeHeight
 * @param {Object} input
 * @param {Number} containerHeight
 * @param {String} orientation
 * @return {Number} height
 */

var getGaugeHeight = function getGaugeHeight(_ref2) {
  var containerHeight = _ref2.containerHeight,
      orientation = _ref2.orientation;
  return orientation === 'vertical' ? containerHeight * 0.8 : exports.GAUGE_THICKNESS;
};

exports.getGaugeHeight = getGaugeHeight;
/**
 * get how long the gauge shoud be.
 * In horizontal view, gauge length equals to gauge width. In vertical view, it equals to gauge height.
 * @method getGaugeLength
 * @param {Object} input
 * @param {Number} input.containerWidth
 * @param {Number} input.containerHeight
 * @param {String} input.orientation
 * @return {Number} gaugeLength
 */

var getGaugeLength = function getGaugeLength(_ref3) {
  var containerWidth = _ref3.containerWidth,
      containerHeight = _ref3.containerHeight,
      orientation = _ref3.orientation;
  return orientation === 'vertical' ? exports.getGaugeHeight({
    containerHeight: containerHeight,
    orientation: orientation
  }) : exports.getGaugeWidth({
    containerWidth: containerWidth,
    orientation: orientation
  });
};

exports.getGaugeLength = getGaugeLength;
/**
 * get start x and y for rendering gauge
 * @method getGaugeStartPosition
 * @param {Object} input
 * @param {Number} containerWidth
 * @param {Number} containerHeight
 * @param {Number} gaugeLength
 * @param {String} orientation
 * @return {Object} position
 * @return {Number} position.gaugeStartX
 * @return {Number} position.gaugeStartY
 */

var getGaugeStartPosition = function getGaugeStartPosition(_ref4) {
  var containerWidth = _ref4.containerWidth,
      containerHeight = _ref4.containerHeight,
      gaugeLength = _ref4.gaugeLength,
      orientation = _ref4.orientation;
  // for horizontal view
  var gaugeStartX = (containerWidth - gaugeLength) / 2.0;
  var gaugeStartY = (containerHeight - exports.GAUGE_THICKNESS) / 2.0;

  if (orientation === 'vertical') {
    gaugeStartX = (containerWidth - exports.GAUGE_THICKNESS) / 2.0;
    gaugeStartY = (containerHeight - gaugeLength) / 2.0;
  }

  return {
    gaugeStartX: gaugeStartX,
    gaugeStartY: gaugeStartY
  };
};

exports.getGaugeStartPosition = getGaugeStartPosition;
/**
 * get dimensions for the whole gauge viz,
 * which can be useful to calculate background bar and major ticks positions.
 * @method getGaugeDimensions
 * @param {Object} input
 * @param {Number} input.containerWidth
 * @param {Number} input.containerHeight
 * @param {String} input.orientation  'horizontal' or 'vertical'
 * @return {Object} gaugeDimensions
 * @return {Number} gaugeDimensions.gaugeLength  how long the gauge shoud be in horizontal or vertical orientation.
 * @return {Number} gaugeDimensions.gaugeStartX  start x to render gauge
 * @return {Number} gaugeDimensions.gaugeStartY  start y to render gauge
 * @return {Number} gaugeDimensions.gaugeWidth   natural width of gauge
 * @return {Number} gaugeDimensions.gaugeHeight  natural height of gauge
 */

var getGaugeDimensions = function getGaugeDimensions(_ref5) {
  var containerWidth = _ref5.containerWidth,
      containerHeight = _ref5.containerHeight,
      orientation = _ref5.orientation;
  var gaugeLength = exports.getGaugeLength({
    containerWidth: containerWidth,
    containerHeight: containerHeight,
    orientation: orientation
  });

  var _exports$getGaugeStar = exports.getGaugeStartPosition({
    containerWidth: containerWidth,
    containerHeight: containerHeight,
    gaugeLength: gaugeLength,
    orientation: orientation
  }),
      gaugeStartX = _exports$getGaugeStar.gaugeStartX,
      gaugeStartY = _exports$getGaugeStar.gaugeStartY;

  var gaugeWidth = exports.getGaugeWidth({
    containerWidth: containerWidth,
    orientation: orientation
  });
  var gaugeHeight = exports.getGaugeHeight({
    containerHeight: containerHeight,
    orientation: orientation
  });
  return {
    gaugeLength: gaugeLength,
    gaugeStartX: gaugeStartX,
    gaugeStartY: gaugeStartY,
    gaugeWidth: gaugeWidth,
    gaugeHeight: gaugeHeight
  };
};

exports.getGaugeDimensions = getGaugeDimensions;
/**
 * if gaugeColor is not specified, auto assign a gauge color to the fill bar
 * based on how much percentage the value is taken between min and max
 * @method assignGaugeColor
 * @params
 * */

var assignGaugeColor = function assignGaugeColor(_ref6) {
  var value = _ref6.value,
      min = _ref6.min,
      max = _ref6.max;
  var rate = (value - min) / (max - min);

  if (rate <= 0.3) {
    return colorConstants_1.SEMANTIC_SUCCESS;
  }

  if (rate > 0.3 && rate <= 0.6) {
    return colorConstants_1.SEMANTIC_WARNING;
  }

  return colorConstants_1.SEMANTIC_ERROR;
};

exports.assignGaugeColor = assignGaugeColor;
/**
 * get inner bar length in gauge
 * @method getGaugeBarLength
 * @param {Object} input
 * @param {Number} input.gaugeLength
 * @param {Number} input.value
 * @param {Number} input.min
 * @param {Number} input.max
 * @return {Number} gaugeBarLength
 */

var getGaugeBarLength = function getGaugeBarLength(_ref7) {
  var gaugeLength = _ref7.gaugeLength,
      value = _ref7.value,
      min = _ref7.min,
      max = _ref7.max;

  if (max < min) {
    return null;
  }

  if (value >= max) {
    return gaugeLength;
  }

  if (value < min) {
    return 0;
  }

  return gaugeLength * (value - min) / (max - min);
};

exports.getGaugeBarLength = getGaugeBarLength;
/**
 * get x and y position for rendering inner bar in gauge
 * @method getGaugeBarStartPositions
 * @param {Object} input
 * @param {Number} input.gaugeStartX
 * @param {Number} input.gaugeStartY
 * @param {Number} input.gaugeWidth
 * @param {Number} input.gaugeHeight
 * @param {Number} input.gaugeBarLength
 * @param {String} input.orientation
 * @return {Object} position
 * @return {Number} position.gaugeBarX
 * @return {Number} position.gaugeBarY
 */

var getGaugeBarStartPositions = function getGaugeBarStartPositions(_ref8) {
  var gaugeStartX = _ref8.gaugeStartX,
      gaugeStartY = _ref8.gaugeStartY,
      gaugeWidth = _ref8.gaugeWidth,
      gaugeHeight = _ref8.gaugeHeight,
      gaugeBarLength = _ref8.gaugeBarLength,
      orientation = _ref8.orientation;
  var gaugeBarX = gaugeStartX;
  var gaugeBarY = gaugeStartY;

  if (orientation === 'vertical') {
    gaugeBarX += (gaugeWidth - exports.FILL_THICKNESS) / 2;
    gaugeBarY += gaugeHeight - gaugeBarLength;
  } else {
    gaugeBarY += (gaugeHeight - exports.FILL_THICKNESS) / 2;
  }

  return {
    gaugeBarX: gaugeBarX,
    gaugeBarY: gaugeBarY
  };
};

exports.getGaugeBarStartPositions = getGaugeBarStartPositions;
/**
 * get width of inner bar in gauge
 * @method getGaugeBarWidth
 * @param {Object} input
 * @param {Number} input.gaugeBarLength
 * @param {String} orientation
 * @return {Number} gaugeBarWidth
 */

var getGaugeBarWidth = function getGaugeBarWidth(_ref9) {
  var gaugeBarLength = _ref9.gaugeBarLength,
      orientation = _ref9.orientation;
  return orientation === 'vertical' ? exports.FILL_THICKNESS : gaugeBarLength;
};

exports.getGaugeBarWidth = getGaugeBarWidth;
/**
 * get height of inner bar in gauge
 * @method getGaugeBarWidth
 * @param {Object} input
 * @param {Number} input.gaugeBarLength
 * @param {String} orientation
 * @return {Number} gaugeBarHeight
 */

var getGaugeBarHeight = function getGaugeBarHeight(_ref10) {
  var gaugeBarLength = _ref10.gaugeBarLength,
      orientation = _ref10.orientation;
  return orientation === 'vertical' ? gaugeBarLength : exports.FILL_THICKNESS;
};

exports.getGaugeBarHeight = getGaugeBarHeight;
/**
 * get dimensions for the fill bar in the gauge
 * @method getFillBarDimensions
 * @param {Object} input
 * @param {Number} input.gaugeLength
 * @param {Number} input.gaugeStartX
 * @param {Number} input.gaugeStartY
 * @param {Number} input.gaugeWidth,
 * @param {Number} input.gaugeHeight,
 * @param {Number} input.value,
 * @param {Number} input.min,
 * @param {Number} input.max,
 * @param {String} input.orientation
 * @return {Object} fillBarDimensions
 * @return {Number} fillBarDimensions.fillBarLength
 * @return {Number} fillBarDimensions.fillBarX
 * @return {Number} fillBarDimensions.fillBarY
 * @return {Number} fillBarDimensions.fillBarWidth
 * @return {Number} fillBarDimensions.fillBarHeight
 */

var getFillBarDimensions = function getFillBarDimensions(_ref11) {
  var gaugeLength = _ref11.gaugeLength,
      gaugeStartX = _ref11.gaugeStartX,
      gaugeStartY = _ref11.gaugeStartY,
      gaugeWidth = _ref11.gaugeWidth,
      gaugeHeight = _ref11.gaugeHeight,
      value = _ref11.value,
      min = _ref11.min,
      max = _ref11.max,
      orientation = _ref11.orientation;
  var gaugeBarLength = exports.getGaugeBarLength({
    gaugeLength: gaugeLength,
    value: value,
    max: max,
    min: min
  });

  var _exports$getGaugeBarS = exports.getGaugeBarStartPositions({
    gaugeStartX: gaugeStartX,
    gaugeStartY: gaugeStartY,
    gaugeWidth: gaugeWidth,
    gaugeHeight: gaugeHeight,
    gaugeBarLength: gaugeBarLength,
    orientation: orientation
  }),
      fillBarX = _exports$getGaugeBarS.gaugeBarX,
      fillBarY = _exports$getGaugeBarS.gaugeBarY;

  var fillBarWidth = exports.getGaugeBarWidth({
    gaugeBarLength: gaugeBarLength,
    orientation: orientation
  });
  var fillBarHeight = exports.getGaugeBarHeight({
    gaugeBarLength: gaugeBarLength,
    orientation: orientation
  });
  return {
    fillBarLength: gaugeBarLength,
    fillBarX: fillBarX,
    fillBarY: fillBarY,
    fillBarWidth: fillBarWidth,
    fillBarHeight: fillBarHeight
  };
};

exports.getFillBarDimensions = getFillBarDimensions;
/**
 * get position x and y for value marker in filler gauge
 * @method getFillerGaugeValueMarkerPositions
 * @param {Object} input
 * @param {Number} input.fillBarX
 * @param {Number} input.fillBarY
 * @param {Number} input.fillBarLength
 * @param {String} input.orientation
 * @return {Object} position
 * @return {Number} position.valueMarkerX
 * @return {Number} position.valueMarkerY
 */

var getFillerGaugeValueMarkerPositions = function getFillerGaugeValueMarkerPositions(_ref12) {
  var fillBarX = _ref12.fillBarX,
      fillBarY = _ref12.fillBarY,
      fillBarLength = _ref12.fillBarLength,
      orientation = _ref12.orientation;
  var valueMarkerX = fillBarX;
  var valueMarkerY = fillBarY;

  if (orientation === 'vertical') {
    valueMarkerX -= (exports.GAUGE_THICKNESS - exports.FILL_THICKNESS) / 4;
  } else {
    valueMarkerX += fillBarLength;
    valueMarkerY -= (exports.GAUGE_THICKNESS - exports.FILL_THICKNESS) / 4;
  }

  return {
    valueMarkerX: valueMarkerX,
    valueMarkerY: valueMarkerY
  };
};

exports.getFillerGaugeValueMarkerPositions = getFillerGaugeValueMarkerPositions;
/**
 * get dimensions for the marker bar in the gauge
 * @method getMarkerBarDimensions
 * @param {Object} input
 * @param {Number} input.gaugeLength
 * @param {Number} input.gaugeStartX
 * @param {Number} input.gaugeStartY
 * @param {Number} input.gaugeWidth,
 * @param {Number} input.gaugeHeight,
 * @param {String} input.orientation
 * @return {Object} markerBarDimensions
 * @return {Number} markerBarDimensions.markerBarLength
 * @return {Number} markerBarDimensions.markerBarX
 * @return {Number} markerBarDimensions.markerBarY
 * @return {Number} markerBarDimensions.markerBarWidth
 * @return {Number} markerBarDimensions.markerBarHeight
 */

var getMarkerBarDimensions = function getMarkerBarDimensions(_ref13) {
  var gaugeLength = _ref13.gaugeLength,
      gaugeStartX = _ref13.gaugeStartX,
      gaugeStartY = _ref13.gaugeStartY,
      gaugeWidth = _ref13.gaugeWidth,
      gaugeHeight = _ref13.gaugeHeight,
      orientation = _ref13.orientation;
  var gaugeBarLength = gaugeLength; // For marker gauge, inner marker bar spans the entire gauge

  var _exports$getGaugeBarS2 = exports.getGaugeBarStartPositions({
    gaugeStartX: gaugeStartX,
    gaugeStartY: gaugeStartY,
    gaugeWidth: gaugeWidth,
    gaugeHeight: gaugeHeight,
    gaugeBarLength: gaugeBarLength,
    orientation: orientation
  }),
      markerBarX = _exports$getGaugeBarS2.gaugeBarX,
      markerBarY = _exports$getGaugeBarS2.gaugeBarY;

  var markerBarWidth = exports.getGaugeBarWidth({
    gaugeBarLength: gaugeBarLength,
    orientation: orientation
  });
  var markerBarHeight = exports.getGaugeBarHeight({
    gaugeBarLength: gaugeBarLength,
    orientation: orientation
  });
  return {
    markerBarLength: gaugeBarLength,
    markerBarX: markerBarX,
    markerBarY: markerBarY,
    markerBarWidth: markerBarWidth,
    markerBarHeight: markerBarHeight
  };
};

exports.getMarkerBarDimensions = getMarkerBarDimensions;
/**
 * get position x and y for value marker in marker gauge
 * @method getMarkerGaugeValueMarkerPositions
 * @param {Object} input
 * @param {Number} input.markerBarX
 * @param {Number} input.markerBarY
 * @param {Number} input.markerBarHeight
 * @param {Number} input.markerBarLength
 * @param {Number} input.value
 * @param {Number} input.min
 * @param {Number} input.max
 * @param {String} input.orientation
 * @return {Object} position
 * @return {Number} position.valueMarkerX
 * @return {Number} position.valueMarkerY
 */

var getMarkerGaugeValueMarkerPositions = function getMarkerGaugeValueMarkerPositions(_ref14) {
  var markerBarX = _ref14.markerBarX,
      markerBarY = _ref14.markerBarY,
      markerBarHeight = _ref14.markerBarHeight,
      gaugeLength = _ref14.markerBarLength,
      orientation = _ref14.orientation,
      value = _ref14.value,
      min = _ref14.min,
      max = _ref14.max;
  var valueMarkerX = markerBarX;
  var valueMarkerY = markerBarY;

  if (orientation === 'vertical') {
    valueMarkerY += markerBarHeight - exports.getGaugeBarLength({
      gaugeLength: gaugeLength,
      value: value,
      max: max,
      min: min
    });
    valueMarkerX -= (exports.GAUGE_THICKNESS - exports.FILL_THICKNESS) / 4;
  } else {
    valueMarkerX += exports.getGaugeBarLength({
      gaugeLength: gaugeLength,
      value: value,
      max: max,
      min: min
    });
    valueMarkerY -= (exports.GAUGE_THICKNESS - exports.FILL_THICKNESS) / 4;
  }

  return {
    valueMarkerX: valueMarkerX,
    valueMarkerY: valueMarkerY
  };
};

exports.getMarkerGaugeValueMarkerPositions = getMarkerGaugeValueMarkerPositions;
/**
 * sort the ranges in ascending order
 * @method getSortedRanges
 * @param {Array} ranges
 * @return {Array} sortedRanges
 */

var getSortedRanges = function getSortedRanges(ranges) {
  return ranges.sort(function (a, b) {
    return a.from - b.from;
  });
};

exports.getSortedRanges = getSortedRanges;
/**
 * validate whether ranges prop is valid - continuous ranges, range.to < range.from, range.from != range.to
 * @method validateRanges
 * @param {Array} ranges
 * @return {String} error
 */

var validateRanges = function validateRanges(ranges) {
  if (!ranges.length) {
    return i18n_1._('Prop "ranges" is missing entries');
  } // check whether a range has "from" >= "to" eg: 10 - 10, 100 - 10, -20 - -10 are invalid


  if (ranges.some(function (range) {
    return range.from >= range.to;
  })) {
    return i18n_1._('Prop "ranges" has invalid entries: invalid range');
  } // check whether ranges have duplicate "from/to" eg: 0 - 50, 25 - 50


  if (ranges.length !== lodash_1.uniqBy(ranges, 'to').length || ranges.length !== lodash_1.uniqBy(ranges, 'from').length) {
    return i18n_1._('Prop "ranges" has invalid entries: duplicate values');
  }

  var sortedRanges = exports.getSortedRanges(ranges); // check whether ranges are continuous eg: 0 - 10, 10 - 20, 20 - 30

  for (var i = 1; i < sortedRanges.length; i += 1) {
    if (sortedRanges[i].from !== sortedRanges[i - 1].to) {
      return i18n_1._('Prop "ranges" has invalid entries: discontinuous ranges');
    }
  }

  return null;
};

exports.validateRanges = validateRanges;
/**
 * calculate min and max value of gauge
 * @method getGaugeRange
 * @param {Array} ranges
 * @return {Object} gaugeRange
 * @return {Number} gaugeRange.min
 * @return {Number} gaugeRange.max
 */

var getGaugeRange = function getGaugeRange(ranges) {
  var min = Math.min.apply(Math, _toConsumableArray(ranges.map(function (range) {
    return range.from;
  })));
  var max = Math.max.apply(Math, _toConsumableArray(ranges.map(function (range) {
    return range.to;
  })));
  return {
    min: min,
    max: max
  };
};

exports.getGaugeRange = getGaugeRange;
/**
 * calculate stop offsets for linear gradient
 * @method getGradientStopOffsets
 * @param {Array} ranges
 * @param {String} orientation
 * @return {Array} cumulativeOffsets
 */

var getGradientStopOffsets = function getGradientStopOffsets(_ref15) {
  var ranges = _ref15.ranges,
      orientation = _ref15.orientation;

  var _exports$getGaugeRang = exports.getGaugeRange(ranges),
      min = _exports$getGaugeRang.min,
      max = _exports$getGaugeRang.max;

  var offsetScale = (GRADIENT_STOP_OFFSET_MAX - GRADIENT_STOP_OFFSET_MIN) / (max - min);
  var offsets = ranges.map(function (range) {
    return Math.abs(range.from - range.to) * offsetScale;
  }); // When orientation is vertical, since the gauge starts from bottom to top, linear gradient should be reversed

  offsets = orientation === 'vertical' ? offsets.reverse() : offsets;
  var cumulativeOffsets = [];
  offsets.reduce(function (accumulator, currentValue, idx) {
    cumulativeOffsets[idx] = accumulator + currentValue;
    return cumulativeOffsets[idx];
  }, 0);
  return cumulativeOffsets;
};

exports.getGradientStopOffsets = getGradientStopOffsets;
/**
 * calculate stop colors for linear gradient
 * @method getGradientStopColors
 * @param {Array} ranges
 * @param {String} orientation
 * @return {Array} stopColors
 */

var getGradientStopColors = function getGradientStopColors(_ref16) {
  var ranges = _ref16.ranges,
      orientation = _ref16.orientation;
  var stopColors = ranges.map(function (range) {
    return range.value;
  }); // When orientation is vertical, since the gauge starts from bottom to top, linear gradient should be reversed

  return orientation === 'vertical' ? stopColors.reverse() : stopColors;
};

exports.getGradientStopColors = getGradientStopColors;
/**
 * calculate linear gradient stops from ranges
 * @method getGradientStops
 * @param {Object} input
 * @param {Array} ranges
 * @param {String} orientation
 * @return {Array} stops
 */

var getGradientStops = function getGradientStops(_ref17) {
  var ranges = _ref17.ranges,
      orientation = _ref17.orientation;
  var stops = [];
  var offsets = exports.getGradientStopOffsets({
    ranges: ranges,
    orientation: orientation
  });
  var stopColors = exports.getGradientStopColors({
    ranges: ranges,
    orientation: orientation
  }); // Initialize stops with the first color stop

  stops.push({
    offset: "".concat(offsets[0], "%"),
    stopColor: stopColors[0]
  }); // Add the remaining color stops with gradient change at each stop

  for (var i = 1; i < ranges.length; i += 1) {
    stops.push({
      offset: "".concat(offsets[i - 1], "%"),
      stopColor: stopColors[i]
    });
    stops.push({
      offset: "".concat(offsets[i], "%"),
      stopColor: stopColors[i]
    });
  }

  return stops;
};

exports.getGradientStops = getGradientStops;
/**
 * calculate linear gradient dimensions
 * @method getGradientDimensions
 * @param {String} orientation
 * @return {Object} dimensions
 * @return {String} dimensions.x1
 * @return {String} dimensions.y1
 * @return {String} dimensions.x2
 * @return {String} dimensions.y2
 */

var getGradientDimensions = function getGradientDimensions(orientation) {
  var x1 = '0%';
  var y1 = '0%';
  var x2 = orientation === 'horizontal' ? '100%' : '0%';
  var y2 = orientation === 'horizontal' ? '0%' : '100%';
  return {
    x1: x1,
    y1: y1,
    x2: x2,
    y2: y2
  };
};

exports.getGradientDimensions = getGradientDimensions; // map for new options names to old option names

var gaugeOptionsMapping = {
  majorTickInterval: 'majorUnit',
  gaugeRanges: 'ranges'
};
/**
 * Helper method to update the option names which can be mapped to pure component options
 * @method mapToOldKey
 * @param {Object} options
 * @returns {Object}
 */

var mapToOldKey = function mapToOldKey(options) {
  return lodash_1.mapKeys(options, function (val, key) {
    return gaugeOptionsMapping[key] ? gaugeOptionsMapping[key] : key;
  });
};

exports.mapToOldKey = mapToOldKey;
/**
 * Helper method to map labelDisplay and valueDisplay options to pure component option names
 * @method mapToOldKey
 * @param {string} labelOrValue
 * @param {Object} options
 * @returns {Object}
 */

var mapValueLabelDisplay = function mapValueLabelDisplay(labelOrValue, options) {
  var rangeOrValue = labelOrValue === 'value' ? 'Value' : 'Range';
  var showKey = labelOrValue === 'value' ? 'showValue' : 'showLabels';
  var percentKey = "usePercentage".concat(rangeOrValue);
  var optionString = "".concat(labelOrValue, "Display");
  var newOptions = Object.assign({}, options);

  if (newOptions[optionString]) {
    if (newOptions[optionString] === 'number') {
      newOptions[showKey] = true;
      newOptions[percentKey] = false;
    } else if (newOptions[optionString] === 'percentage') {
      newOptions[showKey] = true;
      newOptions[percentKey] = true;
    } else {
      newOptions[showKey] = false;
      newOptions[percentKey] = false;
    }
  }

  return lodash_1.omit(newOptions, [optionString]);
};

exports.mapValueLabelDisplay = mapValueLabelDisplay;
/**
 * Chained helper for mapping the option properties (and values) we expose in config.ts into property values that pure component accepts
 * This is for options that has new key name and can not directly be mapped with pure component props
 * @method convertToGaugeProperties
 * @param {Object} originalOptions
 * @returns {Object}
 */

var convertToGaugeProperties = function convertToGaugeProperties(originalOptions) {
  return lodash_1.chain(exports.mapToOldKey(originalOptions)).thru(function (options) {
    return exports.mapValueLabelDisplay('label', options);
  }).thru(function (options) {
    return exports.mapValueLabelDisplay('value', options);
  }).value();
};

exports.convertToGaugeProperties = convertToGaugeProperties;

/***/ }),

/***/ 69:
/***/ (function(module, exports) {

module.exports = require("@splunk/visualizations-shared/colorConstants");

/***/ }),

/***/ 7:
/***/ (function(module, exports) {

module.exports = require("@splunk/ui-utils/i18n");

/***/ })

/******/ });
//# sourceMappingURL=gaugeUtils.js.map
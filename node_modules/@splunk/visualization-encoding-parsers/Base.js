/*!
 * Copyright © 2018 Splunk Inc.
 * SPLUNK CONFIDENTIAL – Use or disclosure of this material in whole or
 * in part without a valid written license from Splunk Inc. is PROHIBITED.
 */
module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 34);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */,
/* 1 */,
/* 2 */,
/* 3 */
/***/ (function(module, exports) {

module.exports = require("lodash/isEmpty");

/***/ }),
/* 4 */
/***/ (function(module, exports) {

module.exports = require("@babel/runtime/helpers/typeof");

/***/ }),
/* 5 */
/***/ (function(module, exports) {

module.exports = require("lodash/isNumber");

/***/ }),
/* 6 */
/***/ (function(module, exports) {

module.exports = require("chroma-js");

/***/ }),
/* 7 */
/***/ (function(module, exports) {

module.exports = require("lodash/isUndefined");

/***/ }),
/* 8 */,
/* 9 */
/***/ (function(module, exports) {

module.exports = require("@babel/runtime/helpers/defineProperty");

/***/ }),
/* 10 */
/***/ (function(module, exports) {

module.exports = require("@babel/runtime/helpers/slicedToArray");

/***/ }),
/* 11 */
/***/ (function(module, exports) {

module.exports = require("lodash/findIndex");

/***/ }),
/* 12 */
/***/ (function(module, exports) {

module.exports = require("lodash/clone");

/***/ }),
/* 13 */
/***/ (function(module, exports) {

module.exports = require("lodash/find");

/***/ }),
/* 14 */
/***/ (function(module, exports) {

module.exports = require("@splunk/visualizations-shared/console");

/***/ }),
/* 15 */
/***/ (function(module, exports) {

module.exports = require("lodash/isFinite");

/***/ }),
/* 16 */,
/* 17 */,
/* 18 */,
/* 19 */,
/* 20 */,
/* 21 */,
/* 22 */,
/* 23 */,
/* 24 */,
/* 25 */,
/* 26 */,
/* 27 */,
/* 28 */,
/* 29 */,
/* 30 */,
/* 31 */,
/* 32 */,
/* 33 */,
/* 34 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, "parseFieldRangeReference", function() { return /* binding */ Base_parseFieldRangeReference; });
__webpack_require__.d(__webpack_exports__, "parseIndexBasedFieldReference", function() { return /* binding */ parseIndexBasedFieldReference; });
__webpack_require__.d(__webpack_exports__, "parseNameBasedFieldReference", function() { return /* binding */ parseNameBasedFieldReference; });
__webpack_require__.d(__webpack_exports__, "mergeEncoding", function() { return /* binding */ Base_mergeEncoding; });
__webpack_require__.d(__webpack_exports__, "parse", function() { return /* binding */ Base_parse; });

// EXTERNAL MODULE: external "@babel/runtime/helpers/typeof"
var typeof_ = __webpack_require__(4);
var typeof_default = /*#__PURE__*/__webpack_require__.n(typeof_);

// EXTERNAL MODULE: external "@babel/runtime/helpers/defineProperty"
var defineProperty_ = __webpack_require__(9);
var defineProperty_default = /*#__PURE__*/__webpack_require__.n(defineProperty_);

// EXTERNAL MODULE: external "@babel/runtime/helpers/slicedToArray"
var slicedToArray_ = __webpack_require__(10);
var slicedToArray_default = /*#__PURE__*/__webpack_require__.n(slicedToArray_);

// EXTERNAL MODULE: external "lodash/findIndex"
var findIndex_ = __webpack_require__(11);
var findIndex_default = /*#__PURE__*/__webpack_require__.n(findIndex_);

// EXTERNAL MODULE: external "lodash/isNumber"
var isNumber_ = __webpack_require__(5);
var isNumber_default = /*#__PURE__*/__webpack_require__.n(isNumber_);

// EXTERNAL MODULE: external "lodash/isEmpty"
var isEmpty_ = __webpack_require__(3);
var isEmpty_default = /*#__PURE__*/__webpack_require__.n(isEmpty_);

// EXTERNAL MODULE: external "lodash/clone"
var clone_ = __webpack_require__(12);
var clone_default = /*#__PURE__*/__webpack_require__.n(clone_);

// EXTERNAL MODULE: external "chroma-js"
var external_chroma_js_ = __webpack_require__(6);
var external_chroma_js_default = /*#__PURE__*/__webpack_require__.n(external_chroma_js_);

// EXTERNAL MODULE: external "lodash/isUndefined"
var isUndefined_ = __webpack_require__(7);
var isUndefined_default = /*#__PURE__*/__webpack_require__.n(isUndefined_);

// EXTERNAL MODULE: external "lodash/find"
var find_ = __webpack_require__(13);
var find_default = /*#__PURE__*/__webpack_require__.n(find_);

// EXTERNAL MODULE: external "@splunk/visualizations-shared/console"
var console_ = __webpack_require__(14);

// CONCATENATED MODULE: ./src/util/format.js




var format_hasOwnProperty = Object.prototype.hasOwnProperty;
var rangeFormat = function rangeFormat(value) {
  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      ranges = _ref.ranges,
      values = _ref.values;

  if (Array.isArray(ranges) && Array.isArray(values) && !Number.isNaN(value)) {
    var floatVal = parseFloat(value);

    for (var i = 0; i < ranges.length; i += 1) {
      // bad range value
      if (Number.isNaN(Number(ranges[i]))) {
        // Could not format value: Ranges are required to be numbers. Falling back to original value
        return value;
      } // value is less than the range limit


      if (floatVal <= parseFloat(ranges[i])) {
        var valueIndex = Math.min(i, values.length - 1); // correct the index if there are more range items than values

        if (values[valueIndex]) {
          return values[valueIndex];
        }
      }
    }

    if (floatVal > parseFloat(ranges[ranges.length - 1])) {
      return values[values.length - 1];
    }
  } // Could not format value: Ranges and Value are required to be numbers


  return value;
};
var categoryFormat = function categoryFormat(value, _ref2) {
  var categories = _ref2.categories,
      values = _ref2.values;

  if (!(Array.isArray(categories) && Array.isArray(values) && categories.length === values.length)) {
    // Could not format value: categories & values should be arrays of the same length. Falling back to original value
    return value;
  }

  var valueIndex = categories.indexOf(value);

  if (valueIndex > -1) {
    return values[valueIndex];
  } // Could not format value: Category does not exist. Falling back to original value


  return value;
};
/**
 * based on a range configuration this formatter maps the value to a value specified in a range.
 * the range fitting follows this criteria: `range.from <= value < range.to` so the `to` value is not included
 * A range can be defined as either a closed bound range: `{ from: 10, to: 20, value: 'foo' }`
 * or an open bound range:
 * `{ to: 20, value: 'bar' }` (open lower bound)
 * `{ from: 100, value: 'oof' }` (open upper bound)
 *
 * @param {string} value from data
 * @param {object} formatConfig
 * @param {Object[]} formatConfig.ranges
 */

var rangeValueFormat = function rangeValueFormat(value, _ref3) {
  var _ref3$ranges = _ref3.ranges,
      ranges = _ref3$ranges === void 0 ? [] : _ref3$ranges;
  var floatValue = parseFloat(value);

  if (Number.isNaN(Number(value))) {
    return value;
  }

  for (var i = 0; i < ranges.length; i += 1) {
    if ( // open upper bound: value is bigger than or equal to open upper bound start (from)
    i === 0 && format_hasOwnProperty.call(ranges[i], 'from') && floatValue >= ranges[i].from || // inbetween: value falls into from - to range
    floatValue >= ranges[i].from && floatValue < ranges[i].to || // open lower bound: value is smaller than or equal to open lower bound end (to)
    i === ranges.length - 1 && format_hasOwnProperty.call(ranges[i], 'to') && floatValue < ranges[i].to) {
      return ranges[i].value;
    }
  }

  return value;
};
/**
 * this formatter maps the value to a value specified in a list of potential matches .
 * if the value passed is a match for what is provided in `matches[i].match`, we return that mapped value `matches[i].value`.
 * If there is not match in the array and there is a `defaultValue` provided we return that value. If there is not a match in the list
 * and no defaultValue is passed, we return the original `value`
 * `{ match: 'cherry', value: 'red' }` (exact match)
 *
 * @param {string} value from data
 * @param {object} formatConfig
 * @param {Object[]} formatConfig.matches
 * @param {object} formatConfig.defaultValue
 */

var format_matchValueFormat = function matchValueFormat(value, _ref4) {
  var _ref4$matches = _ref4.matches,
      matches = _ref4$matches === void 0 ? [] : _ref4$matches,
      _ref4$defaultValue = _ref4.defaultValue,
      defaultValue = _ref4$defaultValue === void 0 ? undefined : _ref4$defaultValue;
  var defaultResult = isUndefined_default()(defaultValue) ? value : defaultValue;
  var matchResult = find_default()(matches, function (match) {
    return match.match && match.match === value;
  });
  return isUndefined_default()(matchResult) ? defaultResult : matchResult.value;
};
var NON_NUMERIC_RANGE_ERROR = 'Could not format value: Ranges are required to be numbers. Falling back to first color';
var VALUES_AND_RANGES_HAVE_DIFFERENT_LENGTH = 'gradient ranges and values must have the same number of elements';
var INVALID_VALUE = 'Could not format value for gradient:';
/**
 * based on ranges and values this formatter maps the value to an interpolated color
 *
 * @param {string} value from data (string representation of number)
 * @param {object} formatConfig
 * @param {number[]} formatConfig.ranges value ranges
 * @param {string[]} formatConfig.values color stops to interpolate from
 * @param {string[]} data the data to be formatted
 * @param errorHandler function
 */

var format_colorGradientFormat = function colorGradientFormat(value, _ref5, data, errorHandler) {
  var ranges = _ref5.ranges,
      values = _ref5.values;
  var colorValues = values;
  var colorRanges = ranges;

  function errorColor() {
    return colorValues ? external_chroma_js_default()(colorValues[0]).hex().toUpperCase() : '#000';
  }

  if (!Number.isNaN(Number(value))) {
    // set default values for gradient colors if values not explicit
    if (!colorValues) {
      colorValues = ['white', 'red'];
    }

    if (colorValues.length === 1) {
      colorValues.unshift('white'); // force color bin to have a lower bound color
    } // set default values for ranges if ranges not explicit


    if (!ranges) {
      if (data && data.length > 0) {
        var min = data.length > 0 ? Math.min.apply(null, data) : undefined;
        var max = data.length > 0 ? Math.max.apply(null, data) : undefined;
        colorRanges = [min];

        for (var i = 1; i < colorValues.length - 1; i += 1) {
          colorRanges.push(min + i * (max - min) / (colorValues.length - 1));
        }

        colorRanges.push(max);
      } else {
        colorRanges = [0, 1]; // no data values, so just make the range from zero to 1
      }
    }

    if (colorRanges.length === 1) {
      colorRanges.push(colorRanges[0]); // force range to be at least two values
    }

    colorRanges.sort(function (a, b) {
      return a - b;
    }); // force ascending order of range stops

    if (colorRanges.length !== colorValues.length) {
      errorHandler(VALUES_AND_RANGES_HAVE_DIFFERENT_LENGTH);
      return errorColor();
    }

    var floatVal = parseFloat(value); // don't let value be outside the allowed range

    if (floatVal > parseFloat(colorRanges[colorRanges.length - 1])) {
      return external_chroma_js_default()(colorValues[colorValues.length - 1]).hex().toUpperCase(); // high end
    }

    if (floatVal < parseFloat(colorRanges[0])) {
      return external_chroma_js_default()(colorValues[0]).hex().toUpperCase(); // low end
    } // find the color gradient range that the value is inside


    for (var _i = 1; _i < colorRanges.length; _i += 1) {
      // bad range value
      if (Number.isNaN(Number(colorRanges[_i]))) {
        // eslint-disable-next-line
        errorHandler(NON_NUMERIC_RANGE_ERROR);
        return errorColor();
      }

      var upperVal = colorRanges[_i];

      if (floatVal <= upperVal) {
        // if value is inside the bin
        var lowerVal = colorRanges[_i - 1];
        var tau = (value - lowerVal) / (upperVal - lowerVal); // deal with special case when the upper and lower and bounds of the colorRange is equal

        if (upperVal === lowerVal) {
          if (value === 0) {
            // user prolly expects lower end of color range if value is zero
            tau = 0;
          } else {
            tau = 1; // otherwise use the upper bound
          }
        }

        var upperColor = colorValues[_i];
        var lowerColor = colorValues[_i - 1];
        return external_chroma_js_default.a.scale([lowerColor, upperColor])(tau).hex().toUpperCase();
      }
    }
  } // eslint-disable-next-line


  errorHandler("".concat(INVALID_VALUE, " ").concat(value));
  return errorColor();
};
var formatters = {
  rangevalue: rangeValueFormat,
  matchvalue: format_matchValueFormat,
  gradient: format_colorGradientFormat
};
var MAX_LOGGED_FORMATTER_ERRORS = 10;
var newFormatterErrorHandler = function newFormatterErrorHandler(maxErrors, handlerFunc) {
  var errorCount = 0;
  return function (msg) {
    if (errorCount < maxErrors) {
      handlerFunc(msg);
    }

    errorCount += 1;
  };
};
/**
 * returns a formatter function based on a format config
 * @param {Object} formatCfg formatter config
 * @param {number[]} formatCfg.ranges an array of numeric ranges that will be used to map to values. requires formatCfg.values
 * @param {*[]} formatCfg.values  an array of values to map to. can be used with formatCfg.ranges or formatCfg.categories or formatCfg.gradient
 * @param {string[]|number[]} formatCfg.categories  an array of categories. categories are used for a 1:1 mapping to values. requires formatCfg.values
 * @param {number[]} data the data to be formatted
 */

var format_getFormatter = function getFormatter(data) {
  var formatCfg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (formatCfg.type) {
    if (formatters[formatCfg.type]) {
      // @TODO(pwied):
      // future: should formatters have prepare stage where params are validated
      // and additional formatting context is generated (e.g. min & max value)
      return function (value) {
        return formatters[formatCfg.type](value, formatCfg, data, newFormatterErrorHandler(MAX_LOGGED_FORMATTER_ERRORS, function (msg) {
          return console_["console"].warn(msg);
        }));
      };
    }

    return function (value) {
      return value;
    };
  } // @TODO(pwied):
  // - remove post beta deadline
  // - move to formatters with type option
  // - leaving it here for now because Choropleth builds on it


  var ranges = formatCfg.ranges,
      values = formatCfg.values;

  if (values) {
    if (ranges) {
      return function (value) {
        return rangeFormat(value, formatCfg);
      };
    }

    if (formatCfg.categories) {
      return function (value) {
        return categoryFormat(value, formatCfg);
      };
    }
  } // eslint-disable-next-line


  console.warn('Could not find a formatter. Falling back to identity fn');
  return function (value) {
    return value;
  };
};
// EXTERNAL MODULE: external "lodash/isFinite"
var isFinite_ = __webpack_require__(15);
var isFinite_default = /*#__PURE__*/__webpack_require__.n(isFinite_);

// CONCATENATED MODULE: ./src/util/types.js


/**
 * getDataTypeForPoint
 * naive implementation of checking for the data type of a single data point
 * number > time > string > unknown
 * starting with number because a Date.parse(number) is a valid date
 *
 * @param {any} dataPoint
 * @return {string} type
 */

var types_getDataTypeForPoint = function getDataTypeForPoint(dataPoint) {
  if (isFinite_default()(+dataPoint) && isNumber_default()(+dataPoint)) {
    return 'number';
  }

  if (!Number.isNaN(Date.parse(dataPoint))) {
    return 'time';
  }

  if (typeof dataPoint === 'string') {
    return 'string';
  } // nulls, objects, etc


  return 'unknown';
};
/**
 * inferDataTypeFromSample
 * based on a number of data points this function determines the data type for all of them
 * and returns the most common data type (naive type inference)
 *
 * @param {Array} dataSample an array of arbitrary size containing data points of any data type
 * @return {string} type the most common type in the sample
 */

var inferDataTypeFromSample = function inferDataTypeFromSample(dataSample) {
  var typeMatches = {
    time: 0,
    number: 0,
    string: 0,
    unknown: 0
  };
  dataSample.forEach(function (point) {
    typeMatches[types_getDataTypeForPoint(point)] += 1;
  });
  var typeCount = -1;
  var returnType = 'unknown';
  Object.keys(typeMatches).forEach(function (key) {
    if (typeMatches[key] > typeCount) {
      typeCount = typeMatches[key];
      returnType = key;
    }
  });
  return returnType;
};
/**
 * based on a data array (e.g. one data column) this function returns a tiny sample of it
 * @TODO: very naive approach. there's papers with more advanced techniques but for now this should be very fast
 *
 * @param {Array} data to draw a sample from
 * @return {Array} a sample of the passed data
 */

var drawSample = function drawSample(data) {
  if (data.length > 2) {
    return [data[0], data[Math.floor(data.length / 2)], data[data.length - 1]];
  }

  if (data.length === 2) {
    return [data[0], data[1]];
  } // small enough to check everything


  return data;
};
// CONCATENATED MODULE: ./src/Base.js




function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        defineProperty_default()(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}








var getDataForDataSourceType = function getDataForDataSourceType(data, dataSourceType) {
  if (!dataSourceType || !data[dataSourceType] || !data[dataSourceType].data) {
    // @TODO: warn about datasource type not being found
    return {
      fields: [],
      columns: []
    };
  }

  return data[dataSourceType].data;
};
/*
 * parse fieldIndexRangeStr
 * @param {String} fieldIndexRangeStr   '0:', '0:5', ':5'
 * @returns {Object} info about parsed range if there is any
 */


var Base_parseFieldRangeReference = function parseFieldRangeReference(fieldIndexRangeStr) {
  if (!fieldIndexRangeStr || fieldIndexRangeStr.indexOf(':') === -1) {
    return {
      isFieldIndexRange: false
    };
  }

  var _fieldIndexRangeStr$s = fieldIndexRangeStr.split(':'),
      _fieldIndexRangeStr$s2 = slicedToArray_default()(_fieldIndexRangeStr$s, 2),
      fromFieldIndexStr = _fieldIndexRangeStr$s2[0],
      toFieldIndexStr = _fieldIndexRangeStr$s2[1];

  return {
    isFieldIndexRange: true,
    fromFieldIndex: Number.isNaN(Number(fromFieldIndexStr)) || !fromFieldIndexStr ? 0 : Number(fromFieldIndexStr),
    toFieldIndex: Number.isNaN(Number(toFieldIndexStr)) || !toFieldIndexStr ? -1 : Number(toFieldIndexStr)
  };
};
/*
 * parse fieldReferenceStr to get field index and column index for user defined encoding. e.g. 'primary[1][123]'
 * @param {String} fieldReferenceStr   'primary[1][123]'
 * @returns {Object} { fieldIndex: 1, columnIndex: 123, isFieldIndexRange: true, fromFieldIndexRange: 0, toFieldIndexRange: 3 }
 */

var parseIndexBasedFieldReference = function parseIndexBasedFieldReference(fieldReferenceStr) {
  var indices = fieldReferenceStr.replace(/^[A-Za-z0-9]+/, '').replace(/\[/g, '').replace(/\]/g, ',').split(',');
  var dataSourceName = fieldReferenceStr.match(/^[A-Za-z0-9]+/)[0];
  var fieldRange = Base_parseFieldRangeReference(indices[0]);
  return _objectSpread({
    dataSourceName: dataSourceName,
    fieldIndex: Number.isNaN(Number(indices[0])) || !indices[0] ? null : Number(indices[0]),
    columnIndex: Number.isNaN(Number(indices[1])) || !indices[1] ? null : Number(indices[1])
  }, fieldRange);
};
/*
 * parse fieldReferenceStr to get field name and column index for user defined encoding. e.g. 'primary.color[123]'
 * @param {String} fieldReferenceStr   'primary.color[123]'
 * @returns {Object} { fieldName: 'color', columnIndex: 123 }
 */

var parseNameBasedFieldReference = function parseNameBasedFieldReference(fieldReferenceStr) {
  var dataSourceName = fieldReferenceStr.match(/^[A-Za-z0-9]+/)[0];
  var fieldNameStr = fieldReferenceStr.split('.')[1];
  var splitedStr = fieldNameStr.split('[');
  var fieldName = splitedStr[0];
  var columnIndex = splitedStr[1] ? Number(splitedStr[1].replace(']', '')) : null;
  return {
    dataSourceName: dataSourceName,
    fieldName: fieldName,
    columnIndex: columnIndex
  };
};

var Base_getDataForIndexBasedFieldReference = function getDataForIndexBasedFieldReference(data, fieldReferenceStr) {
  var fields = data.fields,
      columns = data.columns;

  var _parseIndexBasedField = parseIndexBasedFieldReference(fieldReferenceStr),
      dataSourceName = _parseIndexBasedField.dataSourceName,
      isFieldIndexRange = _parseIndexBasedField.isFieldIndexRange,
      fromFieldIndex = _parseIndexBasedField.fromFieldIndex,
      toFieldIndex = _parseIndexBasedField.toFieldIndex,
      fieldIndex = _parseIndexBasedField.fieldIndex,
      columnIndex = _parseIndexBasedField.columnIndex;

  if (isFieldIndexRange) {
    var dataForRange = [];

    if (fromFieldIndex > -1) {
      var endIndex = toFieldIndex > -1 ? Math.min(fields.length - 1, toFieldIndex) : fields.length + toFieldIndex;

      for (var i = fromFieldIndex; i <= endIndex; i += 1) {
        dataForRange.push(getDataForIndexBasedFieldReference(data, "".concat(dataSourceName, "[").concat(i, "][").concat(columnIndex, "]")));
      }

      return dataForRange;
    }
  }

  if (isNumber_default()(fieldIndex)) {
    var isNegative = fieldIndex < 0;
    var absoluteIndex = Math.abs(fieldIndex);

    if (isNegative && absoluteIndex > fields.length || !isNegative && fieldIndex > fields.length - 1) {
      // The field index is out of bounds
      return {};
    }

    var correctedFieldIndex = isNegative ? fields.length - absoluteIndex : fieldIndex;
    var fieldName = typeof_default()(fields[correctedFieldIndex]) === 'object' ? fields[correctedFieldIndex].name : fields[correctedFieldIndex];
    var fieldData;

    if (isNumber_default()(columnIndex)) {
      var isNegativeColumnIndex = columnIndex < 0;

      if (isNegativeColumnIndex && columnIndex < -columns[correctedFieldIndex].length || columnIndex >= columns[correctedFieldIndex].length) {
        // The column index is out of bounds
        return {};
      }

      var correctColumnIndex = isNegativeColumnIndex ? columns[correctedFieldIndex].length + columnIndex : columnIndex;
      fieldData = columns[correctedFieldIndex].map(function () {
        return columns[correctedFieldIndex][correctColumnIndex];
      });
    } else {
      fieldData = columns[correctedFieldIndex];
    }

    return {
      fieldName: fieldName,
      data: fieldData
    };
  }

  return {};
};

var Base_getDataForNameBasedFieldReference = function getDataForNameBasedFieldReference(data, fieldReferenceStr) {
  var fields = data.fields,
      columns = data.columns;

  var _parseNameBasedFieldR = parseNameBasedFieldReference(fieldReferenceStr),
      fieldName = _parseNameBasedFieldR.fieldName,
      columnIndex = _parseNameBasedFieldR.columnIndex; // <datasource>.<fieldname>[0]


  if (fieldName) {
    var fieldIndex = findIndex_default()(fields, function (field) {
      return typeof_default()(field) === 'object' ? field.name === fieldName : field === fieldName;
    });

    if (fieldIndex > -1) {
      var fieldData;

      if (isNumber_default()(columnIndex)) {
        var isNegativeColumnIndex = columnIndex < 0;

        if (isNegativeColumnIndex && columnIndex < -columns[fieldIndex].length || columnIndex >= columns[fieldIndex].length) {
          // The column index is out of bounds
          return {};
        }

        var correctColumnIndex = isNegativeColumnIndex ? columns[fieldIndex].length + columnIndex : columnIndex;
        fieldData = columns[fieldIndex].map(function () {
          return columns[fieldIndex][correctColumnIndex];
        });
      } else {
        fieldData = columns[fieldIndex];
      }

      return {
        fieldName: fieldName,
        data: fieldData
      };
    } // eslint-disable-next-line


    console.warn("field '".concat(fieldName, "' not available."));
    return {};
  }

  return {};
};

var Base_getDataForFieldReference = function getDataForFieldReference(dataSources, fieldReference) {
  var fieldReferenceStr = fieldReference;
  var formatValue;

  if (Array.isArray(fieldReference) && !fieldReference.isDefault) {
    return fieldReference.map(function (ref) {
      return getDataForFieldReference(dataSources, ref);
    });
  } // if the reference is a default and there is multiple default fields to fall back


  if (fieldReference.isDefault && Array.isArray(fieldReference.field)) {
    // iterate through all defaults and check whether the data type matches the expected type
    for (var i = 0; i < fieldReference.field.length; i += 1) {
      fieldReferenceStr = fieldReference.field[i];
      var dataFromDefault = getDataForFieldReference(dataSources, fieldReferenceStr);

      if (Array.isArray(dataFromDefault.data)) {
        var type = inferDataTypeFromSample(drawSample(dataFromDefault.data));

        if (fieldReference.type.indexOf(type) > -1) {
          return dataFromDefault;
        }
      }
    } // if none of the defaults matched the data type use the last default

  }

  if (typeof_default()(fieldReference) === 'object') {
    var field = fieldReference.field;

    if (field && !Array.isArray(field)) {
      fieldReferenceStr = field;
    }
  }

  var indexBasedRegx = /^[A-Za-z0-9_]+\[.*\].*$/;
  var nameBasedRegx = /^[A-Za-z0-9_]+\..*$/;
  var isIndexBasedReference = indexBasedRegx.test(fieldReferenceStr);
  var isNameBasedReference = nameBasedRegx.test(fieldReferenceStr);

  if (!isIndexBasedReference && !isNameBasedReference) {
    // Unable to parse the encoding. Please verify the encoding format is correct
    return {};
  }

  var dataSourceType = fieldReferenceStr.match(/^(.*?)(\.|\[)/)[1];
  var data = getDataForDataSourceType(dataSources, dataSourceType);
  var fieldData;

  if (isIndexBasedReference) {
    fieldData = Base_getDataForIndexBasedFieldReference(data, fieldReferenceStr);
  } else {
    fieldData = Base_getDataForNameBasedFieldReference(data, fieldReferenceStr);
  }

  if (typeof_default()(fieldReference) === 'object') {
    var format = fieldReference.format;

    if (format) {
      formatValue = format_getFormatter(fieldData.data, format);
    }
  }

  if (formatValue && !isEmpty_default()(fieldData)) {
    return {
      fieldName: fieldData.fieldName,
      data: fieldData.data.map(formatValue)
    };
  }

  return fieldData;
};

var Base_mergeEncoding = function mergeEncoding(defaultEncoding) {
  var userDefinedEncoding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var mergedEncoding = _objectSpread({}, userDefinedEncoding);

  Object.keys(defaultEncoding).forEach(function (key) {
    if (isEmpty_default()(userDefinedEncoding[key]) && defaultEncoding[key].isRequired && defaultEncoding[key].default) {
      mergedEncoding[key] = typeof_default()(defaultEncoding[key].default) === 'object' && !Array.isArray(defaultEncoding[key].default) ? _objectSpread(_objectSpread({}, defaultEncoding[key].default), {}, {
        isDefault: true,
        type: defaultEncoding[key].type
      }) : {
        field: defaultEncoding[key].default,
        isDefault: true,
        type: defaultEncoding[key].type
      };
    }
  });
  return mergedEncoding;
};
var Base_parse = function parse(dataSources) {
  var encoding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var parsedOutput = {
    _meta: {
      fieldNames: {},
      types: {}
    }
  };
  Object.keys(encoding).forEach(function (key) {
    var fieldReference = clone_default()(encoding[key]); // handle the case for encoding field reference, for example fill: 'encoding.trend'

    if (typeof_default()(fieldReference) === 'object' && fieldReference.field && fieldReference.field.indexOf('encoding') === 0) {
      var replacedKey = fieldReference.field.split('.')[1]; // return for the below invalid cases
      // `encoding.z` if `z` is not a valid field in encoding

      if (!encoding[replacedKey]) {
        // eslint-disable-next-line
        console.warn("".concat(key, " field cannot refer to 'encoding.").concat(replacedKey, "'."));
      } // if `z` is an object configuration in encoding simply extract the field when refering `encoding.z`


      var field = typeof_default()(encoding[replacedKey]) === 'object' ? encoding[replacedKey].field : encoding[replacedKey];
      fieldReference = _objectSpread(_objectSpread({}, fieldReference), {}, {
        field: field
      });
    }

    var dataForFieldReference = Base_getDataForFieldReference(dataSources, fieldReference);

    if (Array.isArray(dataForFieldReference)) {
      parsedOutput[key] = dataForFieldReference.map(function (entry) {
        return entry.data;
      });
      parsedOutput._meta.fieldNames[key] = dataForFieldReference.map(function (entry) {
        return entry.fieldName;
      }); // eslint-disable-line no-underscore-dangle
      // eslint-disable-next-line no-underscore-dangle

      parsedOutput._meta.types[key] = dataForFieldReference.map(function (entry) {
        return inferDataTypeFromSample(drawSample(entry.data));
      });
    } else {
      var fieldName = dataForFieldReference.fieldName,
          data = dataForFieldReference.data;

      if (fieldName) {
        parsedOutput[key] = data;
        parsedOutput._meta.fieldNames[key] = fieldName; // eslint-disable-line no-underscore-dangle
        // eslint-disable-next-line no-underscore-dangle

        parsedOutput._meta.types[key] = inferDataTypeFromSample(drawSample(data));
      }
    }
  });
  return parsedOutput;
};

/***/ })
/******/ ]);
//# sourceMappingURL=Base.js.map
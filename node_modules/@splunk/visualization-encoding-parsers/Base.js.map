{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///external \"lodash/isEmpty\"","webpack:///external \"@babel/runtime/helpers/typeof\"","webpack:///external \"lodash/isNumber\"","webpack:///external \"chroma-js\"","webpack:///external \"lodash/isUndefined\"","webpack:///external \"@babel/runtime/helpers/defineProperty\"","webpack:///external \"@babel/runtime/helpers/slicedToArray\"","webpack:///external \"lodash/findIndex\"","webpack:///external \"lodash/clone\"","webpack:///external \"lodash/find\"","webpack:///external \"@splunk/visualizations-shared/console\"","webpack:///external \"lodash/isFinite\"","webpack:///./src/util/format.js","webpack:///./src/util/types.js","webpack:///./src/Base.js"],"names":["hasOwnProperty","Object","prototype","rangeFormat","ranges","values","Array","Number","floatVal","parseFloat","i","valueIndex","Math","categoryFormat","categories","rangeValueFormat","floatValue","matchValueFormat","matches","defaultValue","undefined","defaultResult","isUndefined","matchResult","find","match","NON_NUMERIC_RANGE_ERROR","VALUES_AND_RANGES_HAVE_DIFFERENT_LENGTH","INVALID_VALUE","colorGradientFormat","colorValues","colorRanges","chroma","data","min","max","a","errorHandler","errorColor","upperVal","lowerVal","tau","value","upperColor","lowerColor","formatters","rangevalue","matchvalue","gradient","MAX_LOGGED_FORMATTER_ERRORS","newFormatterErrorHandler","errorCount","handlerFunc","getFormatter","formatCfg","splunkConsole","console","getDataTypeForPoint","isFinite","isNumber","Date","inferDataTypeFromSample","typeMatches","time","number","string","unknown","dataSample","typeCount","returnType","drawSample","getDataForDataSourceType","fields","columns","parseFieldRangeReference","fieldIndexRangeStr","isFieldIndexRange","fromFieldIndexStr","toFieldIndexStr","fromFieldIndex","toFieldIndex","parseIndexBasedFieldReference","indices","fieldReferenceStr","dataSourceName","fieldRange","fieldIndex","columnIndex","parseNameBasedFieldReference","fieldNameStr","splitedStr","fieldName","getDataForIndexBasedFieldReference","dataForRange","endIndex","isNegative","absoluteIndex","correctedFieldIndex","isNegativeColumnIndex","correctColumnIndex","fieldData","getDataForNameBasedFieldReference","findIndex","field","getDataForFieldReference","fieldReference","dataFromDefault","type","indexBasedRegx","nameBasedRegx","isIndexBasedReference","isNameBasedReference","dataSourceType","format","formatValue","isEmpty","mergeEncoding","userDefinedEncoding","mergedEncoding","defaultEncoding","isDefault","parse","encoding","parsedOutput","_meta","fieldNames","types","clone","replacedKey","dataForFieldReference","entry"],"mappings":"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","file":"Base.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 34);\n","module.exports = require(\"lodash/isEmpty\");","module.exports = require(\"@babel/runtime/helpers/typeof\");","module.exports = require(\"lodash/isNumber\");","module.exports = require(\"chroma-js\");","module.exports = require(\"lodash/isUndefined\");","module.exports = require(\"@babel/runtime/helpers/defineProperty\");","module.exports = require(\"@babel/runtime/helpers/slicedToArray\");","module.exports = require(\"lodash/findIndex\");","module.exports = require(\"lodash/clone\");","module.exports = require(\"lodash/find\");","module.exports = require(\"@splunk/visualizations-shared/console\");","module.exports = require(\"lodash/isFinite\");","import chroma from 'chroma-js';\nimport isUndefined from 'lodash/isUndefined';\nimport find from 'lodash/find';\nimport { console as splunkConsole } from '@splunk/visualizations-shared/console';\n\nconst { hasOwnProperty } = Object.prototype;\n\nexport const rangeFormat = (value, { ranges, values } = {}) => {\n    if (Array.isArray(ranges) && Array.isArray(values) && !Number.isNaN(value)) {\n        const floatVal = parseFloat(value);\n        for (let i = 0; i < ranges.length; i += 1) {\n            // bad range value\n            if (Number.isNaN(Number(ranges[i]))) {\n                // Could not format value: Ranges are required to be numbers. Falling back to original value\n                return value;\n            }\n            // value is less than the range limit\n            if (floatVal <= parseFloat(ranges[i])) {\n                const valueIndex = Math.min(i, values.length - 1); // correct the index if there are more range items than values\n                if (values[valueIndex]) {\n                    return values[valueIndex];\n                }\n            }\n        }\n        if (floatVal > parseFloat(ranges[ranges.length - 1])) {\n            return values[values.length - 1];\n        }\n    }\n    // Could not format value: Ranges and Value are required to be numbers\n    return value;\n};\n\nexport const categoryFormat = (value, { categories, values }) => {\n    if (!(Array.isArray(categories) && Array.isArray(values) && categories.length === values.length)) {\n        // Could not format value: categories & values should be arrays of the same length. Falling back to original value\n        return value;\n    }\n    const valueIndex = categories.indexOf(value);\n    if (valueIndex > -1) {\n        return values[valueIndex];\n    }\n    // Could not format value: Category does not exist. Falling back to original value\n    return value;\n};\n\n/**\n * based on a range configuration this formatter maps the value to a value specified in a range.\n * the range fitting follows this criteria: `range.from <= value < range.to` so the `to` value is not included\n * A range can be defined as either a closed bound range: `{ from: 10, to: 20, value: 'foo' }`\n * or an open bound range:\n * `{ to: 20, value: 'bar' }` (open lower bound)\n * `{ from: 100, value: 'oof' }` (open upper bound)\n *\n * @param {string} value from data\n * @param {object} formatConfig\n * @param {Object[]} formatConfig.ranges\n */\nexport const rangeValueFormat = (value, { ranges = [] }) => {\n    const floatValue = parseFloat(value);\n    if (Number.isNaN(Number(value))) {\n        return value;\n    }\n    for (let i = 0; i < ranges.length; i += 1) {\n        if (\n            // open upper bound: value is bigger than or equal to open upper bound start (from)\n            (i === 0 && hasOwnProperty.call(ranges[i], 'from') && floatValue >= ranges[i].from) ||\n            // inbetween: value falls into from - to range\n            (floatValue >= ranges[i].from && floatValue < ranges[i].to) ||\n            // open lower bound: value is smaller than or equal to open lower bound end (to)\n            (i === ranges.length - 1 && hasOwnProperty.call(ranges[i], 'to') && floatValue < ranges[i].to)\n        ) {\n            return ranges[i].value;\n        }\n    }\n    return value;\n};\n\n/**\n * this formatter maps the value to a value specified in a list of potential matches .\n * if the value passed is a match for what is provided in `matches[i].match`, we return that mapped value `matches[i].value`.\n * If there is not match in the array and there is a `defaultValue` provided we return that value. If there is not a match in the list\n * and no defaultValue is passed, we return the original `value`\n * `{ match: 'cherry', value: 'red' }` (exact match)\n *\n * @param {string} value from data\n * @param {object} formatConfig\n * @param {Object[]} formatConfig.matches\n * @param {object} formatConfig.defaultValue\n */\nexport const matchValueFormat = (value, { matches = [], defaultValue = undefined }) => {\n    const defaultResult = isUndefined(defaultValue) ? value : defaultValue;\n    const matchResult = find(matches, match => match.match && match.match === value);\n\n    return isUndefined(matchResult) ? defaultResult : matchResult.value;\n};\n\nexport const NON_NUMERIC_RANGE_ERROR =\n    'Could not format value: Ranges are required to be numbers. Falling back to first color';\nexport const VALUES_AND_RANGES_HAVE_DIFFERENT_LENGTH =\n    'gradient ranges and values must have the same number of elements';\nexport const INVALID_VALUE = 'Could not format value for gradient:';\n\n/**\n * based on ranges and values this formatter maps the value to an interpolated color\n *\n * @param {string} value from data (string representation of number)\n * @param {object} formatConfig\n * @param {number[]} formatConfig.ranges value ranges\n * @param {string[]} formatConfig.values color stops to interpolate from\n * @param {string[]} data the data to be formatted\n * @param errorHandler function\n */\nexport const colorGradientFormat = (value, { ranges, values }, data, errorHandler) => {\n    let colorValues = values;\n    let colorRanges = ranges;\n    function errorColor() {\n        return colorValues ? chroma(colorValues[0]).hex().toUpperCase() : '#000';\n    }\n    if (!Number.isNaN(Number(value))) {\n        // set default values for gradient colors if values not explicit\n        if (!colorValues) {\n            colorValues = ['white', 'red'];\n        }\n\n        if (colorValues.length === 1) {\n            colorValues.unshift('white'); // force color bin to have a lower bound color\n        }\n        // set default values for ranges if ranges not explicit\n        if (!ranges) {\n            if (data && data.length > 0) {\n                const min = data.length > 0 ? Math.min.apply(null, data) : undefined;\n                const max = data.length > 0 ? Math.max.apply(null, data) : undefined;\n                colorRanges = [min];\n                for (let i = 1; i < colorValues.length - 1; i += 1) {\n                    colorRanges.push(min + (i * (max - min)) / (colorValues.length - 1));\n                }\n                colorRanges.push(max);\n            } else {\n                colorRanges = [0, 1]; // no data values, so just make the range from zero to 1\n            }\n        }\n\n        if (colorRanges.length === 1) {\n            colorRanges.push(colorRanges[0]); // force range to be at least two values\n        }\n        colorRanges.sort((a, b) => a - b); // force ascending order of range stops\n        if (colorRanges.length !== colorValues.length) {\n            errorHandler(VALUES_AND_RANGES_HAVE_DIFFERENT_LENGTH);\n            return errorColor();\n        }\n\n        const floatVal = parseFloat(value);\n\n        // don't let value be outside the allowed range\n        if (floatVal > parseFloat(colorRanges[colorRanges.length - 1])) {\n            return chroma(colorValues[colorValues.length - 1])\n                .hex()\n                .toUpperCase(); // high end\n        }\n        if (floatVal < parseFloat(colorRanges[0])) {\n            return chroma(colorValues[0]).hex().toUpperCase(); // low end\n        }\n\n        // find the color gradient range that the value is inside\n        for (let i = 1; i < colorRanges.length; i += 1) {\n            // bad range value\n            if (Number.isNaN(Number(colorRanges[i]))) {\n                // eslint-disable-next-line\n                errorHandler(NON_NUMERIC_RANGE_ERROR);\n                return errorColor();\n            }\n\n            const upperVal = colorRanges[i];\n            if (floatVal <= upperVal) {\n                // if value is inside the bin\n                const lowerVal = colorRanges[i - 1];\n                let tau = (value - lowerVal) / (upperVal - lowerVal);\n\n                // deal with special case when the upper and lower and bounds of the colorRange is equal\n                if (upperVal === lowerVal) {\n                    if (value === 0) {\n                        // user prolly expects lower end of color range if value is zero\n                        tau = 0;\n                    } else {\n                        tau = 1; // otherwise use the upper bound\n                    }\n                }\n\n                const upperColor = colorValues[i];\n                const lowerColor = colorValues[i - 1];\n                return chroma.scale([lowerColor, upperColor])(tau).hex().toUpperCase();\n            }\n        }\n    }\n    // eslint-disable-next-line\n    errorHandler(`${INVALID_VALUE} ${value}`);\n    return errorColor();\n};\n\nconst formatters = {\n    rangevalue: rangeValueFormat,\n    matchvalue: matchValueFormat,\n    gradient: colorGradientFormat,\n};\n\nexport const MAX_LOGGED_FORMATTER_ERRORS = 10;\nexport const newFormatterErrorHandler = (maxErrors, handlerFunc) => {\n    let errorCount = 0;\n    return msg => {\n        if (errorCount < maxErrors) {\n            handlerFunc(msg);\n        }\n        errorCount += 1;\n    };\n};\n\n/**\n * returns a formatter function based on a format config\n * @param {Object} formatCfg formatter config\n * @param {number[]} formatCfg.ranges an array of numeric ranges that will be used to map to values. requires formatCfg.values\n * @param {*[]} formatCfg.values  an array of values to map to. can be used with formatCfg.ranges or formatCfg.categories or formatCfg.gradient\n * @param {string[]|number[]} formatCfg.categories  an array of categories. categories are used for a 1:1 mapping to values. requires formatCfg.values\n * @param {number[]} data the data to be formatted\n */\nexport const getFormatter = (data, formatCfg = {}) => {\n    if (formatCfg.type) {\n        if (formatters[formatCfg.type]) {\n            // @TODO(pwied):\n            // future: should formatters have prepare stage where params are validated\n            // and additional formatting context is generated (e.g. min & max value)\n            return value =>\n                formatters[formatCfg.type](\n                    value,\n                    formatCfg,\n                    data,\n                    newFormatterErrorHandler(MAX_LOGGED_FORMATTER_ERRORS, msg => splunkConsole.warn(msg))\n                );\n        }\n        return value => value;\n    }\n    // @TODO(pwied):\n    // - remove post beta deadline\n    // - move to formatters with type option\n    // - leaving it here for now because Choropleth builds on it\n    const { ranges, values } = formatCfg;\n    if (values) {\n        if (ranges) {\n            return value => rangeFormat(value, formatCfg);\n        }\n\n        if (formatCfg.categories) {\n            return value => categoryFormat(value, formatCfg);\n        }\n    }\n    // eslint-disable-next-line\n    console.warn('Could not find a formatter. Falling back to identity fn');\n    return value => value;\n};\n","import isNumber from 'lodash/isNumber';\nimport isFinite from 'lodash/isFinite';\n\n/**\n * getDataTypeForPoint\n * naive implementation of checking for the data type of a single data point\n * number > time > string > unknown\n * starting with number because a Date.parse(number) is a valid date\n *\n * @param {any} dataPoint\n * @return {string} type\n */\nexport const getDataTypeForPoint = dataPoint => {\n    if (isFinite(+dataPoint) && isNumber(+dataPoint)) {\n        return 'number';\n    }\n    if (!Number.isNaN(Date.parse(dataPoint))) {\n        return 'time';\n    }\n    if (typeof dataPoint === 'string') {\n        return 'string';\n    }\n    // nulls, objects, etc\n    return 'unknown';\n};\n\n/**\n * inferDataTypeFromSample\n * based on a number of data points this function determines the data type for all of them\n * and returns the most common data type (naive type inference)\n *\n * @param {Array} dataSample an array of arbitrary size containing data points of any data type\n * @return {string} type the most common type in the sample\n */\nexport const inferDataTypeFromSample = dataSample => {\n    const typeMatches = {\n        time: 0,\n        number: 0,\n        string: 0,\n        unknown: 0,\n    };\n    dataSample.forEach(point => {\n        typeMatches[getDataTypeForPoint(point)] += 1;\n    });\n    let typeCount = -1;\n    let returnType = 'unknown';\n    Object.keys(typeMatches).forEach(key => {\n        if (typeMatches[key] > typeCount) {\n            typeCount = typeMatches[key];\n            returnType = key;\n        }\n    });\n    return returnType;\n};\n\n/**\n * based on a data array (e.g. one data column) this function returns a tiny sample of it\n * @TODO: very naive approach. there's papers with more advanced techniques but for now this should be very fast\n *\n * @param {Array} data to draw a sample from\n * @return {Array} a sample of the passed data\n */\nexport const drawSample = data => {\n    if (data.length > 2) {\n        return [data[0], data[Math.floor(data.length / 2)], data[data.length - 1]];\n    }\n    if (data.length === 2) {\n        return [data[0], data[1]];\n    }\n    // small enough to check everything\n    return data;\n};\n","import findIndex from 'lodash/findIndex';\nimport isNumber from 'lodash/isNumber';\nimport isEmpty from 'lodash/isEmpty';\nimport clone from 'lodash/clone';\nimport { getFormatter } from './util/format';\nimport { inferDataTypeFromSample, drawSample } from './util/types';\n\nconst getDataForDataSourceType = (data, dataSourceType) => {\n    if (!dataSourceType || !data[dataSourceType] || !data[dataSourceType].data) {\n        // @TODO: warn about datasource type not being found\n        return {\n            fields: [],\n            columns: [],\n        };\n    }\n    return data[dataSourceType].data;\n};\n/*\n * parse fieldIndexRangeStr\n * @param {String} fieldIndexRangeStr   '0:', '0:5', ':5'\n * @returns {Object} info about parsed range if there is any\n */\nexport const parseFieldRangeReference = fieldIndexRangeStr => {\n    if (!fieldIndexRangeStr || fieldIndexRangeStr.indexOf(':') === -1) {\n        return {\n            isFieldIndexRange: false,\n        };\n    }\n    const [fromFieldIndexStr, toFieldIndexStr] = fieldIndexRangeStr.split(':');\n    return {\n        isFieldIndexRange: true,\n        fromFieldIndex:\n            Number.isNaN(Number(fromFieldIndexStr)) || !fromFieldIndexStr ? 0 : Number(fromFieldIndexStr),\n        toFieldIndex:\n            Number.isNaN(Number(toFieldIndexStr)) || !toFieldIndexStr ? -1 : Number(toFieldIndexStr),\n    };\n};\n/*\n * parse fieldReferenceStr to get field index and column index for user defined encoding. e.g. 'primary[1][123]'\n * @param {String} fieldReferenceStr   'primary[1][123]'\n * @returns {Object} { fieldIndex: 1, columnIndex: 123, isFieldIndexRange: true, fromFieldIndexRange: 0, toFieldIndexRange: 3 }\n */\nexport const parseIndexBasedFieldReference = fieldReferenceStr => {\n    const indices = fieldReferenceStr\n        .replace(/^[A-Za-z0-9]+/, '')\n        .replace(/\\[/g, '')\n        .replace(/\\]/g, ',')\n        .split(',');\n    const dataSourceName = fieldReferenceStr.match(/^[A-Za-z0-9]+/)[0];\n    const fieldRange = parseFieldRangeReference(indices[0]);\n    return {\n        dataSourceName,\n        fieldIndex: Number.isNaN(Number(indices[0])) || !indices[0] ? null : Number(indices[0]),\n        columnIndex: Number.isNaN(Number(indices[1])) || !indices[1] ? null : Number(indices[1]),\n        ...fieldRange,\n    };\n};\n\n/*\n * parse fieldReferenceStr to get field name and column index for user defined encoding. e.g. 'primary.color[123]'\n * @param {String} fieldReferenceStr   'primary.color[123]'\n * @returns {Object} { fieldName: 'color', columnIndex: 123 }\n */\nexport const parseNameBasedFieldReference = fieldReferenceStr => {\n    const dataSourceName = fieldReferenceStr.match(/^[A-Za-z0-9]+/)[0];\n    const fieldNameStr = fieldReferenceStr.split('.')[1];\n    const splitedStr = fieldNameStr.split('[');\n    const fieldName = splitedStr[0];\n    const columnIndex = splitedStr[1] ? Number(splitedStr[1].replace(']', '')) : null;\n\n    return { dataSourceName, fieldName, columnIndex };\n};\n\nconst getDataForIndexBasedFieldReference = (data, fieldReferenceStr) => {\n    const { fields, columns } = data;\n    const {\n        dataSourceName,\n        isFieldIndexRange,\n        fromFieldIndex,\n        toFieldIndex,\n        fieldIndex,\n        columnIndex,\n    } = parseIndexBasedFieldReference(fieldReferenceStr);\n\n    if (isFieldIndexRange) {\n        const dataForRange = [];\n        if (fromFieldIndex > -1) {\n            const endIndex =\n                toFieldIndex > -1 ? Math.min(fields.length - 1, toFieldIndex) : fields.length + toFieldIndex;\n            for (let i = fromFieldIndex; i <= endIndex; i += 1) {\n                dataForRange.push(\n                    getDataForIndexBasedFieldReference(data, `${dataSourceName}[${i}][${columnIndex}]`)\n                );\n            }\n            return dataForRange;\n        }\n    }\n\n    if (isNumber(fieldIndex)) {\n        const isNegative = fieldIndex < 0;\n        const absoluteIndex = Math.abs(fieldIndex);\n        if (\n            (isNegative && absoluteIndex > fields.length) ||\n            (!isNegative && fieldIndex > fields.length - 1)\n        ) {\n            // The field index is out of bounds\n            return {};\n        }\n        const correctedFieldIndex = isNegative ? fields.length - absoluteIndex : fieldIndex;\n        const fieldName =\n            typeof fields[correctedFieldIndex] === 'object'\n                ? fields[correctedFieldIndex].name\n                : fields[correctedFieldIndex];\n\n        let fieldData;\n        if (isNumber(columnIndex)) {\n            const isNegativeColumnIndex = columnIndex < 0;\n\n            if (\n                (isNegativeColumnIndex && columnIndex < -columns[correctedFieldIndex].length) ||\n                columnIndex >= columns[correctedFieldIndex].length\n            ) {\n                // The column index is out of bounds\n                return {};\n            }\n            const correctColumnIndex = isNegativeColumnIndex\n                ? columns[correctedFieldIndex].length + columnIndex\n                : columnIndex;\n            fieldData = columns[correctedFieldIndex].map(\n                () => columns[correctedFieldIndex][correctColumnIndex]\n            );\n        } else {\n            fieldData = columns[correctedFieldIndex];\n        }\n        return {\n            fieldName,\n            data: fieldData,\n        };\n    }\n    return {};\n};\n\nconst getDataForNameBasedFieldReference = (data, fieldReferenceStr) => {\n    const { fields, columns } = data;\n    const { fieldName, columnIndex } = parseNameBasedFieldReference(fieldReferenceStr); // <datasource>.<fieldname>[0]\n\n    if (fieldName) {\n        const fieldIndex = findIndex(fields, field =>\n            typeof field === 'object' ? field.name === fieldName : field === fieldName\n        );\n        if (fieldIndex > -1) {\n            let fieldData;\n            if (isNumber(columnIndex)) {\n                const isNegativeColumnIndex = columnIndex < 0;\n\n                if (\n                    (isNegativeColumnIndex && columnIndex < -columns[fieldIndex].length) ||\n                    columnIndex >= columns[fieldIndex].length\n                ) {\n                    // The column index is out of bounds\n                    return {};\n                }\n                const correctColumnIndex = isNegativeColumnIndex\n                    ? columns[fieldIndex].length + columnIndex\n                    : columnIndex;\n                fieldData = columns[fieldIndex].map(() => columns[fieldIndex][correctColumnIndex]);\n            } else {\n                fieldData = columns[fieldIndex];\n            }\n            return {\n                fieldName,\n                data: fieldData,\n            };\n        }\n        // eslint-disable-next-line\n        console.warn(`field '${fieldName}' not available.`);\n        return {};\n    }\n    return {};\n};\n\nconst getDataForFieldReference = (dataSources, fieldReference) => {\n    let fieldReferenceStr = fieldReference;\n    let formatValue;\n    if (Array.isArray(fieldReference) && !fieldReference.isDefault) {\n        return fieldReference.map(ref => getDataForFieldReference(dataSources, ref));\n    }\n    // if the reference is a default and there is multiple default fields to fall back\n    if (fieldReference.isDefault && Array.isArray(fieldReference.field)) {\n        // iterate through all defaults and check whether the data type matches the expected type\n        for (let i = 0; i < fieldReference.field.length; i += 1) {\n            fieldReferenceStr = fieldReference.field[i];\n            const dataFromDefault = getDataForFieldReference(dataSources, fieldReferenceStr);\n            if (Array.isArray(dataFromDefault.data)) {\n                const type = inferDataTypeFromSample(drawSample(dataFromDefault.data));\n                if (fieldReference.type.indexOf(type) > -1) {\n                    return dataFromDefault;\n                }\n            }\n        }\n        // if none of the defaults matched the data type use the last default\n    }\n    if (typeof fieldReference === 'object') {\n        const { field } = fieldReference;\n        if (field && !Array.isArray(field)) {\n            fieldReferenceStr = field;\n        }\n    }\n\n    const indexBasedRegx = /^[A-Za-z0-9_]+\\[.*\\].*$/;\n    const nameBasedRegx = /^[A-Za-z0-9_]+\\..*$/;\n    const isIndexBasedReference = indexBasedRegx.test(fieldReferenceStr);\n    const isNameBasedReference = nameBasedRegx.test(fieldReferenceStr);\n\n    if (!isIndexBasedReference && !isNameBasedReference) {\n        // Unable to parse the encoding. Please verify the encoding format is correct\n        return {};\n    }\n\n    const dataSourceType = fieldReferenceStr.match(/^(.*?)(\\.|\\[)/)[1];\n    const data = getDataForDataSourceType(dataSources, dataSourceType);\n    let fieldData;\n\n    if (isIndexBasedReference) {\n        fieldData = getDataForIndexBasedFieldReference(data, fieldReferenceStr);\n    } else {\n        fieldData = getDataForNameBasedFieldReference(data, fieldReferenceStr);\n    }\n\n    if (typeof fieldReference === 'object') {\n        const { format } = fieldReference;\n        if (format) {\n            formatValue = getFormatter(fieldData.data, format);\n        }\n    }\n\n    if (formatValue && !isEmpty(fieldData)) {\n        return {\n            fieldName: fieldData.fieldName,\n            data: fieldData.data.map(formatValue),\n        };\n    }\n    return fieldData;\n};\n\nexport const mergeEncoding = (defaultEncoding, userDefinedEncoding = {}) => {\n    const mergedEncoding = { ...userDefinedEncoding };\n    Object.keys(defaultEncoding).forEach(key => {\n        if (\n            isEmpty(userDefinedEncoding[key]) &&\n            defaultEncoding[key].isRequired &&\n            defaultEncoding[key].default\n        ) {\n            mergedEncoding[key] =\n                typeof defaultEncoding[key].default === 'object' &&\n                !Array.isArray(defaultEncoding[key].default)\n                    ? {\n                          ...defaultEncoding[key].default,\n                          isDefault: true,\n                          type: defaultEncoding[key].type,\n                      }\n                    : {\n                          field: defaultEncoding[key].default,\n                          isDefault: true,\n                          type: defaultEncoding[key].type,\n                      };\n        }\n    });\n    return mergedEncoding;\n};\n\nexport const parse = (dataSources, encoding = {}) => {\n    const parsedOutput = {\n        _meta: {\n            fieldNames: {},\n            types: {},\n        },\n    };\n\n    Object.keys(encoding).forEach(key => {\n        let fieldReference = clone(encoding[key]);\n\n        // handle the case for encoding field reference, for example fill: 'encoding.trend'\n        if (\n            typeof fieldReference === 'object' &&\n            fieldReference.field &&\n            fieldReference.field.indexOf('encoding') === 0\n        ) {\n            const replacedKey = fieldReference.field.split('.')[1];\n\n            // return for the below invalid cases\n            // `encoding.z` if `z` is not a valid field in encoding\n            if (!encoding[replacedKey]) {\n                // eslint-disable-next-line\n                console.warn(`${key} field cannot refer to 'encoding.${replacedKey}'.`);\n            }\n            // if `z` is an object configuration in encoding simply extract the field when refering `encoding.z`\n            const field =\n                typeof encoding[replacedKey] === 'object'\n                    ? encoding[replacedKey].field\n                    : encoding[replacedKey];\n            fieldReference = {\n                ...fieldReference,\n                field,\n            };\n        }\n\n        const dataForFieldReference = getDataForFieldReference(dataSources, fieldReference);\n\n        if (Array.isArray(dataForFieldReference)) {\n            parsedOutput[key] = dataForFieldReference.map(entry => entry.data);\n            parsedOutput._meta.fieldNames[key] = dataForFieldReference.map(entry => entry.fieldName); // eslint-disable-line no-underscore-dangle\n            // eslint-disable-next-line no-underscore-dangle\n            parsedOutput._meta.types[key] = dataForFieldReference.map(entry =>\n                inferDataTypeFromSample(drawSample(entry.data))\n            );\n        } else {\n            const { fieldName, data } = dataForFieldReference;\n            if (fieldName) {\n                parsedOutput[key] = data;\n                parsedOutput._meta.fieldNames[key] = fieldName; // eslint-disable-line no-underscore-dangle\n                // eslint-disable-next-line no-underscore-dangle\n                parsedOutput._meta.types[key] = inferDataTypeFromSample(drawSample(data));\n            }\n        }\n    });\n\n    return parsedOutput;\n};\n"],"sourceRoot":""}
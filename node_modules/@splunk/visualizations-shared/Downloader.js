/*!
 * Copyright © 2018 Splunk Inc.
 * SPLUNK CONFIDENTIAL – Use or disclosure of this material in whole or
 * in part without a valid written license from Splunk Inc. is PROHIBITED.
 */
module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 27);
/******/ })
/************************************************************************/
/******/ ({

/***/ 10:
/***/ (function(module, exports) {

module.exports = require("@babel/runtime/regenerator");

/***/ }),

/***/ 11:
/***/ (function(module, exports) {

module.exports = require("@babel/runtime/helpers/slicedToArray");

/***/ }),

/***/ 27:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _regeneratorRuntime = __webpack_require__(10);

var _slicedToArray = __webpack_require__(11);

var _classCallCheck = __webpack_require__(4);

var _createClass = __webpack_require__(5);

var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.URLDownloader = exports.ImageRegistryFetcher = exports.b64DecodeUnicode = void 0;

var i18n_1 = __webpack_require__(7);

var b64DecodeUnicode = function b64DecodeUnicode(base64Data) {
  //from bytestream, to percent-encoding, to original string.
  return decodeURIComponent(atob(base64Data).split('').map(function (c) {
    return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
  }).join(''));
};

exports.b64DecodeUnicode = b64DecodeUnicode;

var ImageRegistryFetcher = /*#__PURE__*/function () {
  function ImageRegistryFetcher(context) {
    _classCallCheck(this, ImageRegistryFetcher);

    this.context = context;
  }

  _createClass(ImageRegistryFetcher, [{
    key: "downloadWithProgress",
    value: function downloadWithProgress(url, complete, progress, error) {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
        var imageRegistry, imageData, _imageData$dataURI$sp, _imageData$dataURI$sp2, mime, svgBase64;

        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                imageRegistry = this.context;

                if (!imageRegistry) {
                  error(i18n_1._('Missing Image Context'));
                }

                _context.prev = 2;
                _context.next = 5;
                return imageRegistry.getByURL(url);

              case 5:
                imageData = _context.sent;
                _imageData$dataURI$sp = imageData.dataURI.split('base64,'), _imageData$dataURI$sp2 = _slicedToArray(_imageData$dataURI$sp, 2), mime = _imageData$dataURI$sp2[0], svgBase64 = _imageData$dataURI$sp2[1];

                if (mime && mime.toLowerCase().indexOf('image/svg+xml') > -1) {
                  complete(exports.b64DecodeUnicode(svgBase64));
                } else {
                  error(i18n_1._("Unsupported MIME type ".concat(mime, " for url ").concat(url)));
                }

                _context.next = 13;
                break;

              case 10:
                _context.prev = 10;
                _context.t0 = _context["catch"](2);
                error(i18n_1._("Error retrieving ".concat(url, " from Image Registry, error was '").concat(_context.t0.message, "'")), _context.t0);

              case 13:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[2, 10]]);
      }));
    }
  }]);

  return ImageRegistryFetcher;
}();

exports.ImageRegistryFetcher = ImageRegistryFetcher;

var URLDownloader = /*#__PURE__*/function () {
  function URLDownloader() {
    _classCallCheck(this, URLDownloader);
  }

  _createClass(URLDownloader, [{
    key: "downloadWithProgress",
    value: function downloadWithProgress(url, complete, progress, error) {
      var _this = this;

      // Step 1: fetch content from URL, get reader
      fetch(url).then(function (response) {
        return __awaiter(_this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {
          var msg, reader, contentLength, bytesDownloaded, chunks, done, res, value, chunksAll, position, _i, _chunks, chunk, svg;

          return _regeneratorRuntime.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  if (response.ok) {
                    _context2.next = 5;
                    break;
                  }

                  msg = "Fetch not Ok for ".concat(url, ", status was '").concat(response.statusText, "'");
                  console.warn(msg);
                  error(msg);
                  return _context2.abrupt("return");

                case 5:
                  reader = response.body.getReader(); // Step 2: get total length

                  contentLength = +response.headers.get('Content-Length'); // Step 3: read the data

                  bytesDownloaded = 0; // length at the moment

                  chunks = []; // array of received binary chunks (comprises the body)

                  done = false;

                case 10:
                  if (done) {
                    _context2.next = 19;
                    break;
                  }

                  _context2.next = 13;
                  return reader.read();

                case 13:
                  res = _context2.sent;
                  done = res.done;
                  value = res.value;

                  if (value) {
                    chunks.push(value);
                    bytesDownloaded += value.length;
                    progress({
                      //call the progress callback...can enable the UI to show progress
                      bytesDownloaded: bytesDownloaded,
                      contentLength: contentLength,
                      message: "Received ".concat(bytesDownloaded, " bytes of ").concat(contentLength || 'unknown size')
                    });
                  }

                  _context2.next = 10;
                  break;

                case 19:
                  // Step 4: concatenate chunks into single Uint8Array
                  chunksAll = new Uint8Array(bytesDownloaded);
                  position = 0;

                  for (_i = 0, _chunks = chunks; _i < _chunks.length; _i++) {
                    chunk = _chunks[_i];
                    chunksAll.set(chunk, position);
                    position += chunk.length;
                  }

                  progress({
                    bytesDownloaded: bytesDownloaded,
                    contentLength: contentLength,
                    message: 'decoding chunks'
                  }); // Step 5: decode into a string

                  svg = new TextDecoder('utf-8').decode(chunksAll);
                  complete(svg); //show the downloaded svg back to the caller via its completion callback

                case 25:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2);
        }));
      }).catch(function (e) {
        console.error(e.toString());
        error("Fetch error for '".concat(url, "', error was '").concat(e.toString(), "'"), e); // call the supplied error handling function
      });
    }
  }]);

  return URLDownloader;
}();

exports.URLDownloader = URLDownloader;

var Downloader = /*#__PURE__*/function () {
  function Downloader(downloaders) {
    _classCallCheck(this, Downloader);

    this.downloaders = {};
    this.downloaders = downloaders;
  }

  _createClass(Downloader, [{
    key: "downloadWithProgress",
    value: function downloadWithProgress(url, complete, progress, error) {
      // url is the following:
      // data:image/svg+xml;base64....
      // http://
      // https://
      // local://
      // or otherwise return errors
      var protocol = '';
      var isUrl = true;

      try {
        protocol = new URL(url).protocol;
      } catch (e) {
        isUrl = false;
      }

      if (isUrl) {
        try {
          var _protocol$split = protocol.split(':'),
              _protocol$split2 = _slicedToArray(_protocol$split, 1),
              _protocol$split2$ = _protocol$split2[0],
              type = _protocol$split2$ === void 0 ? '' : _protocol$split2$;

          if (this.downloaders[type]) {
            // data, http(s), local....
            this.downloaders[type].downloadWithProgress(url, complete, progress, error);
          } else {
            // unknown type
            error("Unsupported URL protocol '".concat(type, "' for SVG download: ").concat(url));
          }
        } catch (e) {
          error("Unexpected error downloading SVG: ".concat(e.message));
        }
      } else {
        // the url might be literal content. <svg>...</svg>. This is kindof a hack where if you pass the downloader something
        // that is literal content, it will just return the content. Makes the code flow cleaner in layers above.
        complete(url);
      }
    }
  }]);

  return Downloader;
}();

exports.default = Downloader;

/***/ }),

/***/ 4:
/***/ (function(module, exports) {

module.exports = require("@babel/runtime/helpers/classCallCheck");

/***/ }),

/***/ 5:
/***/ (function(module, exports) {

module.exports = require("@babel/runtime/helpers/createClass");

/***/ }),

/***/ 7:
/***/ (function(module, exports) {

module.exports = require("@splunk/ui-utils/i18n");

/***/ })

/******/ });
//# sourceMappingURL=Downloader.js.map
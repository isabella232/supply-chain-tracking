/*!
 * Copyright © 2020 Splunk Inc.
 * SPLUNK CONFIDENTIAL – Use or disclosure of this material in whole or
 * in part without a valid written license from Splunk Inc. is PROHIBITED.
 */
module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 31);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */,
/* 1 */,
/* 2 */
/***/ (function(module, exports) {

module.exports = require("lodash/isString");

/***/ }),
/* 3 */,
/* 4 */
/***/ (function(module, exports) {

module.exports = require("lodash/get");

/***/ }),
/* 5 */,
/* 6 */,
/* 7 */,
/* 8 */,
/* 9 */,
/* 10 */,
/* 11 */,
/* 12 */,
/* 13 */,
/* 14 */,
/* 15 */,
/* 16 */,
/* 17 */,
/* 18 */,
/* 19 */,
/* 20 */,
/* 21 */,
/* 22 */,
/* 23 */,
/* 24 */,
/* 25 */,
/* 26 */,
/* 27 */,
/* 28 */,
/* 29 */,
/* 30 */,
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.mapTokensToURL = exports.mapURLToTokens = exports.safeReplaceTokensForObject = exports.hasTokensInObject = exports.hasTokens = exports.replaceTokensForObject = exports.replaceTokens = exports.extractTokensFromObject = exports.extractTokens = exports.DEFAULT_FILTERS = void 0;
var some_1 = __importDefault(__webpack_require__(32));
var isString_1 = __importDefault(__webpack_require__(2));
var escape_1 = __importDefault(__webpack_require__(33));
var mapValues_1 = __importDefault(__webpack_require__(34));
var isFunction_1 = __importDefault(__webpack_require__(35));
var get_1 = __importDefault(__webpack_require__(4));
var set_1 = __importDefault(__webpack_require__(36));
var map_1 = __importDefault(__webpack_require__(37));
var isPlainObject_1 = __importDefault(__webpack_require__(38));
var isArray_1 = __importDefault(__webpack_require__(39));
var isEmpty_1 = __importDefault(__webpack_require__(40));
var values_1 = __importDefault(__webpack_require__(41));
var flattenDeep_1 = __importDefault(__webpack_require__(42));
var uniqWith_1 = __importDefault(__webpack_require__(43));
var isEqual_1 = __importDefault(__webpack_require__(44));
var TOKEN_NAMESPACE_PREFIX_PATTERN = /(\w+:)?/.source;
// ex: token.name|suh               (old-style filter chain)
// ex: token.name|lower|capitalize  (new-style filter chain)
var TOKEN_NAME_CHARS_PATTERN = /([^$|:]+?)(\|[|\w]+)?/.source;
// ex: $ns:token.name|suh$
var TOKEN_PATTERN = /\$/.source +
    TOKEN_NAMESPACE_PREFIX_PATTERN +
    TOKEN_NAME_CHARS_PATTERN +
    /\$/.source;
var TOKEN_OR_DOLLAR_RE = new RegExp(TOKEN_PATTERN + "|" + /\$\$/.source, 'g');
var TokenRegExp = new RegExp(TOKEN_PATTERN);
var r = function (regexp) {
    var flags = '';
    if (regexp.global) {
        flags += 'g';
    }
    if (regexp.multiline) {
        flags += 'm';
    }
    if (regexp.ignoreCase) {
        flags += 'i';
    }
    return new RegExp(regexp.source, flags);
};
var VALUE_ESCAPERS = {
    search: function (v) {
        return JSON.stringify(String(v));
    },
    url: function (v) {
        return encodeURIComponent(String(v));
    },
    html: function (v) {
        return escape_1.default(String(v));
    },
    noEscape: function (v) {
        return v;
    },
};
exports.DEFAULT_FILTERS = {
    h: VALUE_ESCAPERS.html,
    u: VALUE_ESCAPERS.url,
    s: VALUE_ESCAPERS.search,
    n: VALUE_ESCAPERS.noEscape,
};
var MAX_RECURSION_LEVEL = 10;
var extractTokens = function (value) {
    /*
     * Looks for:
     *     (1a) $$ (literal $)
     *     (1b) $ns:token.name|suh$ (tokens)
     */
    var tokens = [];
    var rex = r(TOKEN_OR_DOLLAR_RE);
    var match = rex.exec(value);
    while (match) {
        var tokenNamespace = match[1];
        var tokenName = match[2];
        var filterChain = match[3];
        var namespace = tokenNamespace
            ? tokenNamespace.substring(0, tokenNamespace.length - 1)
            : 'default';
        var filters = filterChain ? filterChain.substring(1).split('|') : [];
        tokens.push({
            namespace: namespace,
            name: tokenName !== null && tokenName !== void 0 ? tokenName : '',
            filters: filters,
        });
        match = rex.exec(value);
    }
    return tokens;
};
exports.extractTokens = extractTokens;
/**
 * Extract tokens from an object
 * @param {*} value
 */
var extractTokensFromObject = function (value, recursionLevel) {
    if (recursionLevel === void 0) { recursionLevel = 0; }
    if (isEmpty_1.default(value)) {
        return [];
    }
    if (isString_1.default(value)) {
        return exports.extractTokens(value);
    }
    if (isPlainObject_1.default(value) && recursionLevel <= MAX_RECURSION_LEVEL) {
        return uniqWith_1.default(flattenDeep_1.default(map_1.default(values_1.default(value), function (v) {
            return exports.extractTokensFromObject(v, recursionLevel + 1);
        })), isEqual_1.default);
    }
    if (isArray_1.default(value) && recursionLevel <= MAX_RECURSION_LEVEL) {
        return uniqWith_1.default(flattenDeep_1.default(map_1.default(value, function (v) {
            return exports.extractTokensFromObject(v, recursionLevel + 1);
        })), isEqual_1.default);
    }
    return [];
};
exports.extractTokensFromObject = extractTokensFromObject;
/**
 * Replace a single string with tokens
 * @param {*} value
 * @param {*} tokens
 * @param {*} tokenFilters
 */
var replaceTokens = function (value, tokens, tokenFilters) {
    if (tokenFilters === void 0) { tokenFilters = exports.DEFAULT_FILTERS; }
    if (value == null) {
        return value;
    }
    return value.replace(r(TOKEN_OR_DOLLAR_RE), function (match, tokenNamespace, tokenName, filterChain) {
        var namespace = 'default';
        if (tokenNamespace) {
            namespace = tokenNamespace.substring(0, tokenNamespace.length - 1);
        }
        var v = match;
        var tokenValue = get_1.default(tokens, [namespace, tokenName], null);
        if (tokenValue != null) {
            v = tokenValue;
            var filters = filterChain
                ? filterChain.substring(1).split('|')
                : [];
            // apply token filters
            filters.forEach(function (f) {
                var key = f;
                if (isFunction_1.default(tokenFilters[key])) {
                    v = tokenFilters[key](v);
                }
            });
        }
        return v;
    });
};
exports.replaceTokens = replaceTokens;
/**
 * Replace tokens in an object's value
 * @param {*} value
 * @param {*} tokens
 * @param {*} tokenFilters
 */
var replaceTokensForObject = function (value, tokens, tokenFilters, recursionLevel) {
    if (tokenFilters === void 0) { tokenFilters = exports.DEFAULT_FILTERS; }
    if (recursionLevel === void 0) { recursionLevel = 0; }
    if (value == null) {
        return value;
    }
    if (isString_1.default(value)) {
        return exports.replaceTokens(value, tokens, tokenFilters);
    }
    if (isPlainObject_1.default(value) && recursionLevel <= MAX_RECURSION_LEVEL) {
        return mapValues_1.default(value, function (v) {
            return exports.replaceTokensForObject(v, tokens, tokenFilters, recursionLevel + 1);
        });
    }
    if (isArray_1.default(value) && recursionLevel <= MAX_RECURSION_LEVEL) {
        return map_1.default(value, function (v) {
            return exports.replaceTokensForObject(v, tokens, tokenFilters, recursionLevel + 1);
        });
    }
    return value;
};
exports.replaceTokensForObject = replaceTokensForObject;
/**
 * test if a string contains a token
 * @param {String} value
 */
var hasTokens = function (value) {
    return typeof value === 'string' && TokenRegExp.test(value);
};
exports.hasTokens = hasTokens;
/**
 * test if a object value contains a token
 * @param {Object} obj
 */
var hasTokensInObject = function (obj, recursionLevel) {
    if (recursionLevel === void 0) { recursionLevel = 0; }
    if (obj == null) {
        return false;
    }
    if (isString_1.default(obj)) {
        return exports.hasTokens(obj);
    }
    if ((isArray_1.default(obj) || isPlainObject_1.default(obj)) &&
        recursionLevel <= MAX_RECURSION_LEVEL) {
        return some_1.default(obj, function (v) {
            return exports.hasTokensInObject(v, recursionLevel + 1);
        });
    }
    return false;
};
exports.hasTokensInObject = hasTokensInObject;
/**
 * Calls replaceTokensForObject on an object but preserves the
 * properties that were passed in the denyList
 * @param {Object} obj object you want tokenized
 * @param {Object} tokens tokens to replace
 * @param {String[]} denyList array of strings that correspond to object properties you want preserved, used by lodash get/set. ex: ['property1', 'nested.property']
 */
var safeReplaceTokensForObject = function (obj, tokens, denyList) {
    var rawObject = {};
    denyList.forEach(function (key) {
        rawObject[key] = get_1.default(obj, key);
    });
    // Set the props back to their non-tokenized values
    var tokenizedObj = exports.replaceTokensForObject(obj, tokens);
    denyList.forEach(function (key) {
        if (rawObject[key]) {
            set_1.default(tokenizedObj, key, rawObject[key]);
        }
    });
    return tokenizedObj;
};
exports.safeReplaceTokensForObject = safeReplaceTokensForObject;
/**
 * Converts url search query into tokens in 'default' namespace
 * Current assumption is url tokens do not have a defined namespace, only default
 * @param {Object} obj
 * @param {String} obj.search url search query (window.location.search) from which token object is created
 * @returns {Object} tokens extracted from search query
 */
var mapURLToTokens = function (_a) {
    var search = _a.search;
    var urlSearchParams = new URLSearchParams(search);
    var tokens = {};
    urlSearchParams.forEach(function (value, key) {
        if (!key.startsWith('form.')) {
            return;
        }
        var tokenName = key.slice(5);
        if (tokens[tokenName]) {
            tokens[tokenName] += "," + value;
        }
        else {
            tokens[tokenName] = value;
        }
    });
    return { default: tokens };
};
exports.mapURLToTokens = mapURLToTokens;
/**
 * Maps tokens to url search params either by updating existing tokens or appending as new ones
 * @param {Object} obj
 * @param {String} obj.search url search query (window.location.search) that's to be augmented
 * @param {Object} obj.tokens derived input token values
 * @returns {String} updated search query
 */
var mapTokensToURL = function (_a) {
    var _b = _a.search, initSearch = _b === void 0 ? '?' : _b, tokens = _a.tokens;
    var initSearchParams = new URLSearchParams(initSearch);
    var updatedSearchParams = new URLSearchParams(initSearch);
    // remove the url tokens that do not exist in the derived token values and update the existing ones if they are not unset
    initSearchParams.forEach(function (value, key) {
        if (key.startsWith('form.')) {
            var tokenName = key.substring(5);
            if (tokenName in tokens.default) {
                var tokenValue = tokens.default[tokenName];
                updatedSearchParams.delete(key);
                if (tokenValue !== null && tokenValue !== undefined) {
                    updatedSearchParams.set(key, tokenValue);
                }
            }
            else {
                updatedSearchParams.delete(key);
            }
        }
    });
    // add derived tokens not present in the url search params
    Object.keys(tokens.default).forEach(function (key) {
        var formKey = "form." + key;
        var tokenValue = tokens.default[key];
        if (!updatedSearchParams.has(formKey) &&
            tokenValue !== null &&
            tokenValue !== undefined) {
            updatedSearchParams.set(formKey, tokenValue);
        }
    });
    return updatedSearchParams.toString();
};
exports.mapTokensToURL = mapTokensToURL;


/***/ }),
/* 32 */
/***/ (function(module, exports) {

module.exports = require("lodash/some");

/***/ }),
/* 33 */
/***/ (function(module, exports) {

module.exports = require("lodash/escape");

/***/ }),
/* 34 */
/***/ (function(module, exports) {

module.exports = require("lodash/mapValues");

/***/ }),
/* 35 */
/***/ (function(module, exports) {

module.exports = require("lodash/isFunction");

/***/ }),
/* 36 */
/***/ (function(module, exports) {

module.exports = require("lodash/set");

/***/ }),
/* 37 */
/***/ (function(module, exports) {

module.exports = require("lodash/map");

/***/ }),
/* 38 */
/***/ (function(module, exports) {

module.exports = require("lodash/isPlainObject");

/***/ }),
/* 39 */
/***/ (function(module, exports) {

module.exports = require("lodash/isArray");

/***/ }),
/* 40 */
/***/ (function(module, exports) {

module.exports = require("lodash/isEmpty");

/***/ }),
/* 41 */
/***/ (function(module, exports) {

module.exports = require("lodash/values");

/***/ }),
/* 42 */
/***/ (function(module, exports) {

module.exports = require("lodash/flattenDeep");

/***/ }),
/* 43 */
/***/ (function(module, exports) {

module.exports = require("lodash/uniqWith");

/***/ }),
/* 44 */
/***/ (function(module, exports) {

module.exports = require("lodash/isEqual");

/***/ })
/******/ ]);
//# sourceMappingURL=token.js.map
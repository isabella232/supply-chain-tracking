/*!
 * Copyright © 2020 Splunk Inc.
 * SPLUNK CONFIDENTIAL – Use or disclosure of this material in whole or
 * in part without a valid written license from Splunk Inc. is PROHIBITED.
 */
module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 25);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

module.exports = require("@splunk/ui-utils/i18n");

/***/ }),
/* 1 */,
/* 2 */
/***/ (function(module, exports) {

module.exports = require("lodash/isString");

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.snapUnits = exports.timeUnits = void 0;
var i18n_1 = __webpack_require__(0);
var SecondsDescription = {
    abbr: 's',
    singular: i18n_1._('second'),
    plural: i18n_1._('seconds'),
};
var MinutesDescription = {
    abbr: 'm',
    singular: i18n_1._('minute'),
    plural: i18n_1._('minutes'),
};
var HoursDescription = { abbr: 'h', singular: i18n_1._('hour'), plural: i18n_1._('hours') };
var DaysDescription = { abbr: 'd', singular: i18n_1._('day'), plural: i18n_1._('days') };
var WeeksDescription = { abbr: 'w', singular: i18n_1._('week'), plural: i18n_1._('weeks') };
var MonthsDescription = {
    abbr: 'mon',
    singular: i18n_1._('month'),
    plural: i18n_1._('months'),
};
var QuartersDescription = {
    abbr: 'q',
    singular: i18n_1._('quarter'),
    plural: i18n_1._('quarters'),
};
var YearsDescription = {
    abbr: 'y',
    singular: i18n_1._('year'),
    plural: i18n_1._('years'),
};
var u = {
    s: SecondsDescription,
    sec: SecondsDescription,
    secs: SecondsDescription,
    second: SecondsDescription,
    seconds: SecondsDescription,
    m: MinutesDescription,
    min: MinutesDescription,
    mins: MinutesDescription,
    minute: MinutesDescription,
    minutes: MinutesDescription,
    h: HoursDescription,
    hr: HoursDescription,
    hrs: HoursDescription,
    hour: HoursDescription,
    hours: HoursDescription,
    d: DaysDescription,
    day: DaysDescription,
    days: DaysDescription,
    w: WeeksDescription,
    week: WeeksDescription,
    weeks: WeeksDescription,
    mon: MonthsDescription,
    month: MonthsDescription,
    months: MonthsDescription,
    q: QuartersDescription,
    qtr: QuartersDescription,
    qtrs: QuartersDescription,
    quarter: QuartersDescription,
    quarters: QuartersDescription,
    y: YearsDescription,
    yr: YearsDescription,
    yrs: YearsDescription,
    year: YearsDescription,
    years: YearsDescription,
};
exports.timeUnits = u;
// snap units can additionally include days of the week.
exports.snapUnits = __assign(__assign({}, u), { w0: { abbr: 'w0', singular: i18n_1._('Sunday'), plural: i18n_1._('Sundays') }, w1: { abbr: 'w1', singular: i18n_1._('Monday'), plural: i18n_1._('Mondays') }, w2: { abbr: 'w2', singular: i18n_1._('Tuesday'), plural: i18n_1._('Tuesdays') }, w3: {
        abbr: 'w3',
        singular: i18n_1._('Wednesday'),
        plural: i18n_1._('Wednesdays'),
    }, w4: { abbr: 'w4', singular: i18n_1._('Thursday'), plural: i18n_1._('Thursdays') }, w5: { abbr: 'w5', singular: i18n_1._('Friday'), plural: i18n_1._('Fridays') }, w6: { abbr: 'w6', singular: i18n_1._('Saturday'), plural: i18n_1._('Saturdays') }, w7: { abbr: 'w7', singular: i18n_1._('Sunday'), plural: i18n_1._('Sundays') } });


/***/ }),
/* 4 */,
/* 5 */
/***/ (function(module, exports) {

module.exports = require("@splunk/moment");

/***/ }),
/* 6 */,
/* 7 */,
/* 8 */,
/* 9 */,
/* 10 */,
/* 11 */,
/* 12 */,
/* 13 */,
/* 14 */,
/* 15 */,
/* 16 */,
/* 17 */,
/* 18 */,
/* 19 */,
/* 20 */,
/* 21 */,
/* 22 */,
/* 23 */,
/* 24 */,
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.defaultRealTimePreset = exports.defaultTimePreset = exports.parse = exports.formatDuration = exports.createRangeLabel = exports.findPresetLabel = exports.timeRangesAreEquivalent = exports.isAllTime = exports.isLatestNow = exports.isEarliestEmpty = exports.isWholeDay = exports.isRealTime = exports.isValidTime = exports.parseTimeString = exports.isAbsolute = exports.isISO = exports.isEpoch = exports.removeISOTimezone = exports.removeRealTime = exports.getUnitLabel = exports.normalizeSnapUnit = exports.normalizeUnit = exports.epochToMoment = void 0;
// TODO: This is essentially an old copy of @splunk/time-range-utils/Time. The code in that set of utils has diverged over time, particularly where labels are generated.
var find_1 = __importDefault(__webpack_require__(26));
var has_1 = __importDefault(__webpack_require__(27));
var isString_1 = __importDefault(__webpack_require__(2));
var isFinite_1 = __importDefault(__webpack_require__(28));
var format_1 = __webpack_require__(29);
var i18n_1 = __webpack_require__(0);
var config_1 = __webpack_require__(30);
var moment_1 = __importDefault(__webpack_require__(5));
var timeUnits_1 = __webpack_require__(3);
var momentUnits = {
    s: 's',
    m: 'm',
    h: 'h',
    d: 'd',
    w: 'w',
    mon: 'M',
    q: 'Q',
    y: 'y',
};
var momentSnaps = {
    s: 'second',
    m: 'minute',
    h: 'hour',
    d: 'day',
    w: 'week',
    mon: 'month',
    q: 'quarter',
    y: 'year',
};
var weekDaySnaps = {
    w0: 0,
    w1: 1,
    w2: 2,
    w3: 3,
    w4: 4,
    w5: 5,
    w6: 6,
    w7: 0,
};
/**
 * Returns a moment for the given time or the current time, if none is given
 * @method epochToMoment
 * @param {Number} [epoch] given time in seconds
 * @returns Moment
 */
var epochToMoment = function (epoch) {
    // If we get an input time, convert to ms, otherwise generate current time
    var time = epoch || epoch === 0 ? epoch * 1000 : new Date().getTime();
    if (moment_1.default.getDefaultSplunkTimezone()) {
        return moment_1.default.newSplunkTime({ time: time });
    }
    // fallback to moment default
    return moment_1.default(time);
};
exports.epochToMoment = epochToMoment;
/**
 * Normalizes units to it's shortest version, such as `s` for `sec` and `mon` for `month`.
 * @name normalizeUnit
 * @function
 * @public
 * @param {String} unit - The unit, such as `s` or `quarter`.
 * @param {bool} [removeInvalid=true] - When true, returns an empty string for invalid units,
 * when false
 * returns 's' for invalid units.
 * @returns {String} Returns the normalized unit or empty string.
 */
function normalizeUnit(abbr, removeInvalid) {
    if (removeInvalid === void 0) { removeInvalid = true; }
    var hasUnit = has_1.default(timeUnits_1.timeUnits, abbr);
    var defaultUnit = removeInvalid ? '' : timeUnits_1.timeUnits.s.abbr;
    return hasUnit ? timeUnits_1.timeUnits[abbr].abbr : defaultUnit;
}
exports.normalizeUnit = normalizeUnit;
/**
 * Normalizes snap units to it's shortest version, this is the same as normalizeUnit, but also
 * supports weekdays, such as `w5`.
 * @public
 * @param {String} unit - The unit, such as `s`, `quarter` or `w0`.
 * @param {bool} [removeInvalid=true] - When true, returns an empty string for invalid units,
 * when false returns 's' for invalid units.
 * @returns {String} Returns the normalized unit or empty string.
 */
function normalizeSnapUnit(abbr, removeInvalid) {
    if (removeInvalid === void 0) { removeInvalid = true; }
    var hasUnit = has_1.default(timeUnits_1.snapUnits, abbr);
    var defaultUnit = removeInvalid ? '' : timeUnits_1.timeUnits.s.abbr;
    return hasUnit ? timeUnits_1.snapUnits[abbr].abbr : defaultUnit;
}
exports.normalizeSnapUnit = normalizeSnapUnit;
/**
 * Returns a label for a unit abbreviation, such as 'second' for 's' or 'sec'.
 * @public
 * @param {Object} unit -  The unit, such as `s`, `quarter` or `w0`.
 * @param {Object} [plural=false] - Whether the returned label should be plural.
 * @returns {String}
 */
function getUnitLabel(unit, plural) {
    if (plural === void 0) { plural = false; }
    return timeUnits_1.snapUnits[unit][plural ? 'plural' : 'singular'];
}
exports.getUnitLabel = getUnitLabel;
/**
 * Strips rt from the beginning of a time string when found. This makes a time string compatible
 * with the time parser. To ensure capability with the time parser 'rt' returns 'now'.
 * @public
 * @param {String} time - The time string such as `47165491` or `rt-2h@m`.
 * @returns {String} Returns the time string.
 */
function removeRealTime(time) {
    if (time === 'rt') {
        return 'now';
    }
    return time.replace(/^rt/, '');
}
exports.removeRealTime = removeRealTime;
/**
 * Removes the timezone from an iso time string
 * @public
 * @param {String} time - The time string such as `47165491` or `-2h@m`.
 * @returns {String}
 */
function removeISOTimezone(time) {
    return time.replace(/[+-]\d?\d:\d\d$/, '');
}
exports.removeISOTimezone = removeISOTimezone;
/**
 * Validates that a string represents a unix epoch time.
 * @public
 * @param {String} time - The time string such as `47165491` or `-2h@m`.
 * @returns {bool}
 */
function isEpoch(time) {
    return (isFinite_1.default(time) || (isString_1.default(time) && /^\d+((\.\d+)|(\d*))$/.test(time)));
}
exports.isEpoch = isEpoch;
/**
 * Validates that a string represents an ISO time.
 * @public
 * @param {String} time - The time string such as `47165491` or `-2h@m`.
 * @returns {bool}
 */
function isISO(time) {
    return !!time.match(/^\d\d\d\d-\d\d?-\d\d?T\d\d?:\d\d?(:\d\d?)?(\.\d\d?\d?)?([+-]\d\d?:\d\d|Z)?$/);
}
exports.isISO = isISO;
/**
 * Validates that a string represents an ISO or unix epoch time.
 * @public
 * @param {String} time - The time string such as `47165491` or `-2h@m`.
 * @returns {bool}
 */
function isAbsolute(time) {
    if (time === undefined) {
        return false;
    }
    return isEpoch(time) || isISO(time);
}
exports.isAbsolute = isAbsolute;
/**
 * Parses a time string for inspection or form population.
 *
 * Example parse for a relative time string:
 * ```
 * {
 *     string: '-3d@qtr+2hr',
 *     type: ['relative'], // 'relative', 'realTime', 'iso', or 'epoch'
 *     isFullyParsed: true,
 *     modifiers: [
 *         {
 *             string: '-3d@qtr',
 *             isParsed: true,
 *             unit: 'd',
 *             amount: -3,
 *             snap: 'q',
 *         },
 *         {
 *             string: '+2hr',
 *             isParsed: true,
 *             unit: 'h',
 *             amount: +2,
 *             snap: false,
 *         },
 *     ],
 * }
 * ```
 * Example parse for a epoch time:
 * ```
 * {
 *     string: '89451357',
 *     type: ['epoch'],
 *     isFullyParsed: true,
 *     modifiers: [],
 * }
 *
 * @public
 * @param {String} time - The time string such as `47165491` or `-2h@m`.
 * @returns {Object}
 */
function parseTimeString(timeString) {
    if (!isString_1.default(timeString)) {
        return false;
    }
    var ast = {
        string: timeString,
        type: 'relative',
        isFullyParsed: true,
        modifiers: [],
    };
    if (isISO(timeString)) {
        ast.type = 'iso';
        return ast;
    }
    if (isEpoch(timeString)) {
        ast.type = 'epoch';
        return ast;
    }
    var segments = timeString
        .trim()
        .replace(/-/g, '\n-')
        .replace(/\+/g, '\n+')
        .split('\n');
    // If only snap has been provided push empty string to beginning of segments.
    if (segments[0].charAt(0) === '@') {
        segments.unshift('');
    }
    if (segments[0] === 'rt' || segments[0] === 'rtnow') {
        ast.type = 'realTime';
    }
    else if (['rt', 'now', 'rtnow', ''].indexOf(segments[0]) < 0) {
        ast.isFullyParsed = false;
        return ast;
    }
    else {
        ast.type = 'relative';
    }
    ast.modifiers = segments.slice(1).map(function (segmentString) {
        var segment = {
            string: segmentString,
            unit: 's',
            amount: 0,
            snap: false,
            isParsed: false,
        };
        var sParse = segmentString.match(/^(([-+]\d*)([a-zA-Z]*))?(@([a-zA-Z][a-zA-Z0-7]*))?$/);
        //                                          2         3      4          5
        if (sParse) {
            segment.unit = sParse[3] && normalizeUnit(sParse[3], false);
            segment.amount = segment.unit ? parseInt(sParse[2], 10) || 1 : 0;
            segment.snap = !!sParse[4] && normalizeSnapUnit(sParse[5], false);
            segment.isParsed = true;
            if ((sParse[5] && !timeUnits_1.snapUnits[sParse[5]]) || // invalid unit
                (sParse[3] && !timeUnits_1.timeUnits[sParse[3]]) || // invalid snap unit
                segmentString.length === 1 // unqualified - or +
            ) {
                ast.isFullyParsed = false;
                segment.isParsed = false;
            }
        }
        else {
            ast.isFullyParsed = false;
        }
        return segment;
    });
    return ast;
}
exports.parseTimeString = parseTimeString;
/**
 * Validates that a string is a valid time string.
 * @public
 * @param {String} time - The time string such as `rt` , `rtnow` or `-2h@m`.
 * @returns {bool}
 */
function isValidTime(time) {
    var parsedTime = parseTimeString(time);
    return parsedTime && parsedTime.isFullyParsed;
}
exports.isValidTime = isValidTime;
/**
 * Validates that a string represents a real-time search.
 * @public
 * @param {String} time - The time string such as `rt` , `rtnow` or `-2h@m`.
 * @returns {bool}
 */
function isRealTime(time) {
    var parsedTimeString = parseTimeString(time);
    return (parsedTimeString &&
        parsedTimeString.type === 'realTime' &&
        parsedTimeString.isFullyParsed);
}
exports.isRealTime = isRealTime;
/**
 * Validates that a iso time string is a whole day.
 * @public
 * @param {string|object} time - A time string (such as `2008-09-15T15:53:00+05:00`) or a
 * @splunk/moment time instance.
 * @returns {bool}
 */
function isWholeDay(time) {
    if ((isString_1.default(time) && isISO(time)) ||
        (moment_1.default.isMoment(time) && time.isValid())) {
        var timeMoment = moment_1.default(time);
        return timeMoment.valueOf() === timeMoment.startOf('day').valueOf();
    }
    return false;
}
exports.isWholeDay = isWholeDay;
/**
 * Validate that a time string acts is either empty or `0`.
 * @public
 * @param {String} time - The time string such as `rt` , `rtnow` or `-2h@m`.
 * @returns {bool}
 */
function isEarliestEmpty(time) {
    return !time || time === '0';
}
exports.isEarliestEmpty = isEarliestEmpty;
/**
 * Validate that a time string acts is either empty or now
 * @public
 * @param {String} time - The time string such as `rt` , `rtnow` or `-2h@m`.
 * @returns {bool}
 */
function isLatestNow(time) {
    return !time || (isString_1.default(time) && time === 'now');
}
exports.isLatestNow = isLatestNow;
/**
 * Validate that a time range acts is equivalent to all-time.
 * @public
 * @param {String} earliest - The time string such as `rt` , `rtnow` or `-2h@m`.
 * @param {String} latest - The time string such as `rt` , `rtnow` or `-2h@m`.
 * @returns {bool}
 */
function isAllTime(earliest, latest) {
    return (isEarliestEmpty(removeRealTime(earliest)) &&
        isLatestNow(removeRealTime(latest)));
}
exports.isAllTime = isAllTime;
/**
 * Validate that two time range are equivalent. This normalizes the two comparisons using
 * isEarliestEmpty() and isLatestNow().
 * @public
 * @param {Object} range1 - The time string range  such as `{ earliest: '-1d', latest: 'now' }`.
 * @param {Object} range2 -  The time string range such as `{ earliest: '0', latest: '-1d' }`.
 * @returns {bool}
 */
function timeRangesAreEquivalent(range1, range2) {
    var earliest1 = range1.earliest;
    var latest1 = range1.latest;
    var earliest2 = range2.earliest;
    var latest2 = range2.latest;
    var earliestEqual = false;
    var latestEqual = false;
    if (isEarliestEmpty(earliest1) && isEarliestEmpty(earliest2)) {
        earliestEqual = true;
    }
    else {
        earliestEqual = earliest1 === earliest2;
    }
    if (isLatestNow(latest1) && isLatestNow(latest2)) {
        latestEqual = true;
    }
    else {
        latestEqual = latest1 === latest2;
    }
    return earliestEqual && latestEqual;
}
exports.timeRangesAreEquivalent = timeRangesAreEquivalent;
/**
 * Searches through an array of presets and returns any equivalent labels using
 * timeRangesAreEquivalent().
 * @public
 * @param {array} presets - An array of presents such as:
 * ```
 * [
 *     { label: '30 second window', earliest: 'rt-30s', latest: 'rt' },
 *     { label: 'Today', earliest: '@d', latest: 'now' },
 *     { label: 'Previous year', earliest: '-1y@y', latest: '@y' },
 *     { label: 'Last 15 minutes', earliest: '-15m', latest: 'now' },
 *     { label: 'All time', earliest: '0', latest: '' },
 * ]
 * ```
 * @param {String} earliest - The time string such as `rt` , `rtnow` or `-2h@m`.
 * @param {String} latest - The time string such as `rt` , `rtnow` or `-2h@m`.
 * @returns {string | false } The matched preset label.
 */
function findPresetLabel(presets, earliest, latest) {
    /* JSDoc and eslint cannot agree on the appropriate format of this */
    /* eslint-disable */
    var currentPreset = find_1.default(presets, function (preset) {
        var range2 = { earliest: preset.earliest, latest: preset.latest };
        return timeRangesAreEquivalent({ earliest: earliest, latest: latest }, range2);
    });
    /* eslint-enable */
    return currentPreset ? currentPreset.label : false;
}
exports.findPresetLabel = findPresetLabel;
/**
 * Generates a label for a real-time time search.
 * For example:  '5 minute window' or 'Real-time'
 * @private
 * @param {String} earliest - The time string such as `rt` , `rtnow` or `-2h@m`.
 * @param {String} latest - The time string such as `rt` , `rtnow` or `-2h@m`.
 * @returns {null|string}
 */
function createRealTimeLabel(earliest, latest) {
    if (isRealTime(earliest) || isRealTime(latest)) {
        var earliestParse = parseTimeString(earliest);
        var latestParse = parseTimeString(latest);
        if (!earliestParse || !latestParse) {
            return false;
        }
        var earliestModifier = earliestParse.modifiers[0];
        var labelTemplates = {
            s: i18n_1._('%(time)d second window'),
            m: i18n_1._('%(time)d minute window'),
            h: i18n_1._('%(time)d hour window'),
            d: i18n_1._('%(time)d day window'),
            w: i18n_1._('%(time)d week window'),
            mon: i18n_1._('%(time)d month window'),
            q: i18n_1._('%(time)d quarter window'),
            y: i18n_1._('%(time)d year window'),
        };
        if (earliestModifier &&
            earliestParse.type === 'realTime' &&
            latestParse.type === 'realTime' &&
            latestParse.modifiers.length === 0 && (earliestModifier === null || earliestModifier === void 0 ? void 0 : earliestModifier.unit) &&
            has_1.default(labelTemplates, earliestModifier.unit) &&
            earliestParse.modifiers.length === 1) {
            return format_1.sprintf(labelTemplates[earliestModifier.unit], {
                time: Math.abs(earliestModifier.amount || 0),
            });
        }
        // Other Real-Time.
        return i18n_1._('Real-time');
    }
    return false;
}
/**
 * Generates a label for a relative time search.
 * For example:  'Last 5 minutes'
 * @private
 * @param {String} earliest - The time string such as `rt` , `rtnow` or `-2h@m`.
 * @param {String} latest - The time string such as `rt` , `rtnow` or `-2h@m`.
 * @returns {null|string}
 */
function createRelativeTimeLabel(earliest, latest) {
    var earliestParse = parseTimeString(earliest);
    var latestParse = parseTimeString(latest);
    if (!earliestParse || !latestParse) {
        return false;
    }
    var earliestModifier = earliestParse.modifiers[0];
    var latestModifier = latestParse.modifiers[0];
    if (earliestParse.type === 'realTime' ||
        latestParse.type === 'realTime' ||
        !earliestModifier ||
        earliestParse.modifiers.length > 1 ||
        latestParse.modifiers.length > 1) {
        return false;
    }
    if (earliestModifier.amount < 0 &&
        (!earliestModifier.snap ||
            earliestModifier.unit === earliestModifier.snap) &&
        (isLatestNow(latest) || (latestModifier && !latestModifier.amount)) &&
        (!latestModifier ||
            !latestModifier.snap ||
            earliestModifier.unit === latestModifier.snap)) {
        var amount = Math.abs(earliestModifier.amount);
        var pluralKey = amount > 1 ? 'plural' : 'singular';
        return format_1.sprintf(i18n_1._('Last %(amount)d %(unit)s'), {
            amount: amount,
            unit: timeUnits_1.timeUnits[earliestModifier.unit][pluralKey],
        });
    }
    return false;
}
/**
 * Compares two moment instances to determine if they are on the same day.
 * @private
 * @param {Object} earliest - @splunk/moment time instance
 * @param {Object} latest - @splunk/moment time instance
 * @returns {bool}
 */
function areSameDay(a, b) {
    var aTime = a.clone().startOf('day');
    var bTime = b.clone().startOf('day');
    return aTime.isSame(bTime);
}
/**
 * Determines whether the date is the start of a year, month or day.
 * @private
 * @param {Object} date - @splunk/moment time instance
 * @returns {'year'|'month'|'date'|undefined}
 */
function largestDateUnit(date) {
    return find_1.default(['year', 'month', 'date'], function (unit) {
        var dateStart = date.clone().startOf(unit);
        return date.isSame(dateStart);
    });
}
/**
 * Finds the largest date unit that can describe a date range: years, months or days.
 * @private
 * @param {Object} earliest - @splunk/moment time instance
 * @param {Object} latest - @splunk/moment time instance
 * @returns {'year'|'month'|'date'|null}
 */
function findSingleDateUnit(a, b) {
    if (!(isWholeDay(a) && isWholeDay(b))) {
        return null;
    }
    if (a.month() === 0 &&
        b.month() === 0 &&
        a.date() === 1 &&
        b.date() === 1) {
        return 'year';
    }
    if ((a.year() === b.year() && a.date() === 1 && b.date() === 1) ||
        (a.year() + 1 === b.year() &&
            b.month() === 0 &&
            a.date() === 1 &&
            b.date() === 1)) {
        return 'month';
    }
    if ((a.year() === b.year() && a.month() === b.month()) ||
        (a.year() === b.year() &&
            a.month() + 1 === b.month() &&
            b.date() === 1) ||
        (a.year() + 1 === b.year() && b.month() === 0)) {
        return 'date';
    }
    return null;
}
/**
 * Generates a date range label for a single year, month or day.
 * For example:  '2017', 'Feb 2017' or 'Feb 18, 2017'
 * @private
 * @param {Object} date - @splunk/moment time instance
 * @param {'year'|'month'|'date'} unit
 * @returns {String}
 */
function createSingleUnitOnLabel(date, unit) {
    switch (unit) {
        case 'year':
            return date.format('YYYY');
        case 'month':
            return format_1.sprintf(i18n_1._('%(month)s %(year)s'), {
                month: date.format('MMM'),
                year: date.format('YYYY'),
            });
        default:
            return date.format('ll');
    }
}
/**
 * Generates a date range label for a range of years, months or days.
 * For example:  '2015 though 2017', 'Feb through Apr, 2017' or 'Feb 17 through 18, 2017'
 * @private
 * @param {Object} earliest - @splunk/moment time instance
 * @param {Object} latest - @splunk/moment time instance
 * @param {'year'|'month'|'date'} unit
 * @returns {String}
 */
function createSingleUnitThroughLabel(a, b, unit) {
    var b2 = b.subtract(1, unit === 'date' ? 'day' : unit);
    switch (unit) {
        case 'year':
            return format_1.sprintf(i18n_1._('%(earliestYear)s through %(latestYear)s'), {
                earliestYear: a.format('YYYY'),
                latestYear: b2.format('YYYY'),
            });
        case 'month':
            return format_1.sprintf(i18n_1._('%(earliestMonth)s through %(latestMonth)s, %(inYear)s'), {
                earliestMonth: a.format('MMM'),
                latestMonth: b2.format('MMM'),
                inYear: b2.format('YYYY'),
            });
        default:
            return format_1.sprintf(i18n_1._('%(month)s %(earliestDayOfMonth)s through %(latestDayOfMonth)s, %(inYear)s'), {
                month: a.format('MMM'),
                earliestDayOfMonth: a.format('D'),
                latestDayOfMonth: b2.format('D'),
                inYear: b2.format('YYYY'),
            });
    }
}
/**
 * Generates date-time label with the minimum specificity for time:minute, seconds or milliseconds.
 * For example:  'Feb 18, 2017 4:12:30.567 AM'
 * @private
 * @param {Object} date - @splunk/moment time instance
 * @returns {String}
 */
function createDateTimeLabel(date) {
    if (date.millisecond()) {
        return date.splunkFormat('llms');
    }
    if (date.second()) {
        return date.splunkFormat('lls');
    }
    return date.splunkFormat('lll');
}
/**
 * Generates time label with the minimum specificity for time: minute, seconds or milliseconds.
 * For example:  '6:00 AM', '6:00:20 AM' or '6:00:20.712 AM'
 * @private
 * @param {Object} time - @splunk/moment time instance
 * @returns {String}
 */
function createTimeLabel(time) {
    if (time.millisecond()) {
        return time.splunkFormat('LTMS');
    }
    if (time.second()) {
        return time.format('LTS');
    }
    return time.format('LT');
}
/**
 * Generates a date-time label with the minimum specificity for time: minute, seconds or milliseconds.
 * For example: 'Feb 17, 2017 6:00 AM to Feb 18, 2017 12:20 AM'
 * @private
 * @param {Object} earliestTime - @splunk/moment time instance
 * @param {Object} latestTime - @splunk/moment time instance
 * @returns {String}
 */
function createTimeRangeLabel(a, b) {
    var format;
    if (a.millisecond() || b.millisecond()) {
        format = 'llms';
    }
    else if (a.second() || b.second()) {
        format = 'lls';
    }
    else {
        format = 'lll';
    }
    return format_1.sprintf(i18n_1._('%(earliestDateTime)s to %(latestDateTime)s'), {
        earliestDateTime: a.splunkFormat(format),
        latestDateTime: b.splunkFormat(format),
    });
}
/**
 * Generates a label for a time range on a single date.
 * For example: '6:00:20.850 AM to 8:00:40.490 PM, Feb 17, 2017'
 * @private
 * @param {Object} earliestTime - @splunk/moment time instance
 * @param {Object} latestTime - @splunk/moment time instance
 * @returns {String}
 */
function createPartOfDayLabel(a, b) {
    return format_1.sprintf(i18n_1._('%(earliestTime)s to %(latestTime)s, %(date)s'), {
        earliestTime: createTimeLabel(a),
        latestTime: createTimeLabel(b),
        date: a.format('ll'),
    });
}
function conformToMaxChars(label, shortLabel, maxChars) {
    // if label is shorter than the shortLabel and longer than maxChars, use the label.
    // This scenario may arise due to long translations of the shortLabel.
    return maxChars && label.length > Math.max(shortLabel.length, maxChars)
        ? shortLabel
        : label;
}
/**
 * Generates a label for a date range when provided two ISO date formats.
 * @private
 * @param {String} earliest - An ISO time string, or other splunk time string.
 * @param {String} latest - An ISO time string, or other splunk time string .
 * @param {Number} maxChars - If the generated label is too long, it will abbreviate
   to a more generic form, such as 'Between Date-times' instead of 'Feb 17, 2017 6:00 AM to Feb 18, 2017 12:20 AM'.
 * @returns {null|string}
 */
function createDateTimeRangeLabel(earliest, latest, maxChars) {
    var a = isISO(earliest)
        ? moment_1.default(earliest).locale(config_1.locale || 'en_US')
        : undefined;
    var b = isISO(latest)
        ? moment_1.default(latest).locale(config_1.locale || 'en_US')
        : undefined;
    if (a && b) {
        // During Year, Month Day
        var unit = findSingleDateUnit(a, b);
        // Single Year, Month or Day
        var next = unit && moment_1.default(a).add(1, unit === 'date' ? 'days' : unit);
        if (unit && next[unit]() === b[unit]()) {
            return createSingleUnitOnLabel(a, unit);
        }
        if (unit) {
            return conformToMaxChars(createSingleUnitThroughLabel(a, b, unit), i18n_1._('Date Range'), maxChars);
        }
        // Part of Day
        if (areSameDay(a, b)) {
            return conformToMaxChars(createPartOfDayLabel(a, b), i18n_1._('Part of a Day'), maxChars);
        }
        // Full
        return conformToMaxChars(createTimeRangeLabel(a, b), i18n_1._('Between Date-times'), maxChars);
    }
    if (a && isLatestNow(latest)) {
        // Since
        var unit = largestDateUnit(a);
        var since = unit
            ? createSingleUnitOnLabel(a, unit)
            : createDateTimeLabel(a);
        var longLabel = format_1.sprintf(i18n_1._('Since %(dateTime)s'), { dateTime: since });
        return conformToMaxChars(longLabel, i18n_1._('Since Date-time'), maxChars);
    }
    if (isEarliestEmpty(earliest) && b) {
        // Before
        var unit = largestDateUnit(b);
        var before = unit
            ? createSingleUnitOnLabel(b, unit)
            : createDateTimeLabel(b);
        var longLabel = format_1.sprintf(i18n_1._('Before %(dateTime)s'), {
            dateTime: before,
        });
        return conformToMaxChars(longLabel, i18n_1._('Before Date-time'), maxChars);
    }
    return null;
}
/**
 * Returns 'All-time' is the search is all-time or a close equivalent.
 * @private
 * @param {String} earliest - The time string such as `rt` , `rtnow` or `-2h@m`.
 * @param {String} latest - The time string such as `rt` , `rtnow` or `-2h@m`.
 * @returns {String}
 */
function createAllTimeLabel(earliest, latest) {
    if (isEarliestEmpty(earliest) && isLatestNow(latest)) {
        return i18n_1._('All time');
    }
    return false;
}
/**
 * Creates an appropriate label for a time range, using a preset label if available.
 * @public
 * @param {String} earliest - The time string such as `rt` , `rtnow` or `-2h@m`.
 * @param {String} latest - The time string such as `rt` , `rtnow` or `-2h@m`.
 * @param {Object} [options] - An array of presents such as:
 * @param {Number} [options.maxChars = 0] - If the generated label is too long, it will abbreviate
 * to a more generic form, such as 'Between Date-times' instead of 'Feb 17, 2017 6:00 AM to Feb 18, 2017 12:20 AM'.
 * `Infinity` and `0` allow labels of any length.
 * @param {array} [options.presets] - An array of presents such as:
 * ```
 * [
 *     { label: '30 second window', earliest: 'rt-30s', latest: 'rt' },
 *     { label: 'Today', earliest: '@d', latest: 'now' },
 *     { label: 'Previous year', earliest: '-1y@y', latest: '@y' },
 *     { label: 'Last 15 minutes', earliest: '-15m', latest: 'now' },
 *     { label: 'All time', earliest: '0', latest: '' },
 * ]
 * ```
 * @returns {String} Returns `'Custom time'` if one cannot be made.
 */
function createRangeLabel(earliest, latest, _a) {
    var _b = _a === void 0 ? {} : _a, presets = _b.presets, _c = _b.maxChars, maxChars = _c === void 0 ? 0 : _c;
    var earliestTrimmed = earliest.trim();
    var latestTrimmed = latest.trim();
    return (createAllTimeLabel(earliestTrimmed, latestTrimmed) ||
        (presets && findPresetLabel(presets, earliestTrimmed, latestTrimmed)) ||
        createRealTimeLabel(earliestTrimmed, latestTrimmed) ||
        createRelativeTimeLabel(earliestTrimmed, latestTrimmed) ||
        createDateTimeRangeLabel(earliestTrimmed, latestTrimmed, maxChars) ||
        i18n_1._('Custom time'));
}
exports.createRangeLabel = createRangeLabel;
function pluralize(singular, plural, numberOf) {
    if (numberOf === 0) {
        return null;
    }
    return numberOf === 1 ? singular : format_1.sprintf(plural, { numberOf: numberOf });
}
/**
 * Takes a duration in milliseconds and returns a string describing the duration in terms of
 * years, months, days, hours, minutes, seconds and milliseconds.
 * If a unit isn't needed it's omitted, e.g. durations less than a year won't include '0 years'.
 * @public
 * @param {number} ms - The duration in milliseconds.
 * @returns {String} A formatted duration string, for example `27 days 16 hours 36 minutes 59 seconds`.
 * Durations <= 0 return `null`.
 */
function formatDuration(ms) {
    if (ms <= 0) {
        return null;
    }
    var duration = moment_1.default.duration(ms);
    return [
        pluralize(i18n_1._('1 year'), i18n_1._('%(numberOf)d years'), duration.years()),
        pluralize(i18n_1._('1 month'), i18n_1._('%(numberOf)d months'), duration.months()),
        pluralize(i18n_1._('1 day'), i18n_1._('%(numberOf)d days'), duration.days()),
        pluralize(i18n_1._('1 hour'), i18n_1._('%(numberOf)d hours'), duration.hours()),
        pluralize(i18n_1._('1 minute'), i18n_1._('%(numberOf)d minutes'), duration.minutes()),
        pluralize(i18n_1._('1 second'), i18n_1._('%(numberOf)d seconds'), duration.seconds()),
        pluralize(i18n_1._('1 millisecond'), i18n_1._('%(numberOf)d milliseconds'), duration.milliseconds()),
    ]
        .filter(function (display) { return !!display; })
        .join(' ');
}
exports.formatDuration = formatDuration;
var parse = function (time, baseTime) {
    if (baseTime === void 0) { baseTime = exports.epochToMoment(); }
    var parsed = parseTimeString(time);
    if (time === '' || !parsed) {
        return { error: new Error('Invalid time string'), time: time };
    }
    if (!parsed.isFullyParsed) {
        return {
            error: new Error('The time string could not be parsed'),
            time: time,
        };
    }
    if (parsed.type === 'iso') {
        return { error: null, iso: time, time: time };
    }
    if (parsed.type === 'epoch') {
        return {
            error: null,
            iso: exports.epochToMoment(parseFloat(time)).format(),
            time: time,
        };
    }
    var date = moment_1.default(baseTime);
    parsed.modifiers.forEach(function (mod) {
        if (mod.amount && momentUnits[mod.unit]) {
            date.add(mod.amount, momentUnits[mod.unit]);
        }
        if (mod.snap) {
            if (momentSnaps[mod.snap]) {
                date.startOf(momentSnaps[mod.snap]);
            }
            else if (weekDaySnaps[mod.snap] != null) {
                date.startOf(momentSnaps.w).add(weekDaySnaps[mod.snap], 'd');
                if (exports.epochToMoment().isBefore(date)) {
                    // always snap to past time, so we need to shift back for 1 week.
                    date.add(-1, 'w');
                }
            }
        }
    });
    return { error: null, iso: date.format(), time: time, momentTime: date };
};
exports.parse = parse;
exports.defaultTimePreset = [
    { label: i18n_1._('Today'), earliest: '@d', latest: 'now' },
    { label: i18n_1._('Week to date'), earliest: '@w0', latest: 'now' },
    { label: i18n_1._('Business week to date'), earliest: '@w1', latest: 'now' },
    { label: i18n_1._('Month to date'), earliest: '@mon', latest: 'now' },
    { label: i18n_1._('Year to date'), earliest: '@y', latest: 'now' },
    { label: i18n_1._('Yesterday'), earliest: '-1d@d', latest: '@d' },
    { label: i18n_1._('Previous week'), earliest: '-7d@w0', latest: '@w0' },
    {
        label: i18n_1._('Previous business week'),
        earliest: '-6d@w1',
        latest: '-1d@w6',
    },
    { label: i18n_1._('Previous month'), earliest: '-1mon@mon', latest: '@mon' },
    { label: i18n_1._('Previous year'), earliest: '-1y@y', latest: '@y' },
    { label: i18n_1._('Last 15 minutes'), earliest: '-15m', latest: 'now' },
    { label: i18n_1._('Last 60 minutes'), earliest: '-60m@m', latest: 'now' },
    { label: i18n_1._('Last 4 hours'), earliest: '-4h@m', latest: 'now' },
    { label: i18n_1._('Last 24 hours'), earliest: '-24h@h', latest: 'now' },
    { label: i18n_1._('Last 7 days'), earliest: '-7d@h', latest: 'now' },
    { label: i18n_1._('Last 30 days'), earliest: '-30d@d', latest: 'now' },
    { label: i18n_1._('All time'), earliest: '0', latest: 'now' },
];
exports.defaultRealTimePreset = [
    { label: i18n_1._('30 second window'), earliest: 'rt-30s', latest: 'rt' },
    { label: i18n_1._('1 minute window'), earliest: 'rt-1m', latest: 'rt' },
    { label: i18n_1._('5 minute window'), earliest: 'rt-5m', latest: 'rt' },
    { label: i18n_1._('30 minute window'), earliest: 'rt-30m', latest: 'rt' },
    { label: i18n_1._('1 hour window'), earliest: 'rt-1h', latest: 'rt' },
    { label: i18n_1._('All time (real-time)'), earliest: 'rt', latest: 'rt' },
].concat(exports.defaultTimePreset);


/***/ }),
/* 26 */
/***/ (function(module, exports) {

module.exports = require("lodash/find");

/***/ }),
/* 27 */
/***/ (function(module, exports) {

module.exports = require("lodash/has");

/***/ }),
/* 28 */
/***/ (function(module, exports) {

module.exports = require("lodash/isFinite");

/***/ }),
/* 29 */
/***/ (function(module, exports) {

module.exports = require("@splunk/ui-utils/format");

/***/ }),
/* 30 */
/***/ (function(module, exports) {

module.exports = require("@splunk/splunk-utils/config");

/***/ })
/******/ ]);
//# sourceMappingURL=time.js.map
/*!
 * Copyright © 2020 Splunk Inc.
 * SPLUNK CONFIDENTIAL – Use or disclosure of this material in whole or
 * in part without a valid written license from Splunk Inc. is PROHIBITED.
 */
module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 49);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

module.exports = require("@splunk/ui-utils/i18n");

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.logfmt = void 0;
var hasWindowConsole = typeof window !== 'undefined' && 'console' in window;
var hasConsoleMethod = function (method) {
    return hasWindowConsole && typeof window.console[method] === 'function';
};
var noop = function () { return undefined; };
var console = {
    log: hasConsoleMethod('log')
        ? function () {
            var _a;
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return (_a = window.console).log.apply(_a, __spread(args));
        }
        : noop,
    debug: hasConsoleMethod('debug')
        ? function () {
            var _a;
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return (_a = window.console).debug.apply(_a, __spread(args));
        }
        : noop,
    info: hasConsoleMethod('info')
        ? function () {
            var _a;
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return (_a = window.console).info.apply(_a, __spread(args));
        }
        : noop,
    warn: hasConsoleMethod('warn')
        ? function () {
            var _a;
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return (_a = window.console).warn.apply(_a, __spread(args));
        }
        : noop,
    error: hasConsoleMethod('error')
        ? function () {
            var _a;
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return (_a = window.console).error.apply(_a, __spread(args));
        }
        : noop,
    group: hasConsoleMethod('group')
        ? function () {
            var _a;
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return (_a = window.console).group.apply(_a, __spread(args));
        }
        : noop,
    groupCollapsed: hasConsoleMethod('groupCollapsed')
        ? function () {
            var _a;
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return (_a = window.console).groupCollapsed.apply(_a, __spread(args));
        }
        : noop,
    groupEnd: hasConsoleMethod('groupEnd')
        ? function () { return window.console.groupEnd(); }
        : noop,
    logWithDetails: function (message, lines) {
        console.groupCollapsed(message);
        lines.forEach(function (line) {
            return Array.isArray(line) ? console.log.apply(console, __spread(line)) : console.log(line);
        });
        console.groupEnd();
    },
};
exports.default = console;
function logfmt(strings) {
    var values = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        values[_i - 1] = arguments[_i];
    }
    return __spread([strings.join('%o')], (values || []));
}
exports.logfmt = logfmt;


/***/ }),
/* 2 */
/***/ (function(module, exports) {

module.exports = require("lodash/isString");

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.snapUnits = exports.timeUnits = void 0;
var i18n_1 = __webpack_require__(0);
var SecondsDescription = {
    abbr: 's',
    singular: i18n_1._('second'),
    plural: i18n_1._('seconds'),
};
var MinutesDescription = {
    abbr: 'm',
    singular: i18n_1._('minute'),
    plural: i18n_1._('minutes'),
};
var HoursDescription = { abbr: 'h', singular: i18n_1._('hour'), plural: i18n_1._('hours') };
var DaysDescription = { abbr: 'd', singular: i18n_1._('day'), plural: i18n_1._('days') };
var WeeksDescription = { abbr: 'w', singular: i18n_1._('week'), plural: i18n_1._('weeks') };
var MonthsDescription = {
    abbr: 'mon',
    singular: i18n_1._('month'),
    plural: i18n_1._('months'),
};
var QuartersDescription = {
    abbr: 'q',
    singular: i18n_1._('quarter'),
    plural: i18n_1._('quarters'),
};
var YearsDescription = {
    abbr: 'y',
    singular: i18n_1._('year'),
    plural: i18n_1._('years'),
};
var u = {
    s: SecondsDescription,
    sec: SecondsDescription,
    secs: SecondsDescription,
    second: SecondsDescription,
    seconds: SecondsDescription,
    m: MinutesDescription,
    min: MinutesDescription,
    mins: MinutesDescription,
    minute: MinutesDescription,
    minutes: MinutesDescription,
    h: HoursDescription,
    hr: HoursDescription,
    hrs: HoursDescription,
    hour: HoursDescription,
    hours: HoursDescription,
    d: DaysDescription,
    day: DaysDescription,
    days: DaysDescription,
    w: WeeksDescription,
    week: WeeksDescription,
    weeks: WeeksDescription,
    mon: MonthsDescription,
    month: MonthsDescription,
    months: MonthsDescription,
    q: QuartersDescription,
    qtr: QuartersDescription,
    qtrs: QuartersDescription,
    quarter: QuartersDescription,
    quarters: QuartersDescription,
    y: YearsDescription,
    yr: YearsDescription,
    yrs: YearsDescription,
    year: YearsDescription,
    years: YearsDescription,
};
exports.timeUnits = u;
// snap units can additionally include days of the week.
exports.snapUnits = __assign(__assign({}, u), { w0: { abbr: 'w0', singular: i18n_1._('Sunday'), plural: i18n_1._('Sundays') }, w1: { abbr: 'w1', singular: i18n_1._('Monday'), plural: i18n_1._('Mondays') }, w2: { abbr: 'w2', singular: i18n_1._('Tuesday'), plural: i18n_1._('Tuesdays') }, w3: {
        abbr: 'w3',
        singular: i18n_1._('Wednesday'),
        plural: i18n_1._('Wednesdays'),
    }, w4: { abbr: 'w4', singular: i18n_1._('Thursday'), plural: i18n_1._('Thursdays') }, w5: { abbr: 'w5', singular: i18n_1._('Friday'), plural: i18n_1._('Fridays') }, w6: { abbr: 'w6', singular: i18n_1._('Saturday'), plural: i18n_1._('Saturdays') }, w7: { abbr: 'w7', singular: i18n_1._('Sunday'), plural: i18n_1._('Sundays') } });


/***/ }),
/* 4 */
/***/ (function(module, exports) {

module.exports = require("lodash/get");

/***/ }),
/* 5 */
/***/ (function(module, exports) {

module.exports = require("@splunk/moment");

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.b64EncodeUnicode = void 0;
/*
 * base64 encoding
 * @param {String} str
 * @return {Base64} string using based-64 encoding
 */
var b64EncodeUnicode = function (str) {
    // first we use encodeURIComponent to get percent-encoded UTF-8,
    // then we convert the percent encodings into raw bytes which
    // can be fed into btoa.
    return btoa(encodeURIComponent(str).replace(/%([0-9A-F]{2})/g, function toSolidBytes(match, p1) {
        return String.fromCharCode(parseInt("0x" + p1, 16));
    }));
};
exports.b64EncodeUnicode = b64EncodeUnicode;


/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var isObjectLike = function (value) { return value && typeof value === 'object'; };
/**
 * Recursively freezes obj and its properties using Object.freeze(). The values of a frozen object
 * cannot be changed. There is a risk that this function may freeze an object that should not be
 * frozen (i.e. window).
 * @param {*} obj The object the should be recursively frozen.
 * @returns {*} The object after having all its properties recursively frozen.
 */
var deepFreeze = function (obj) {
    if (!isObjectLike(obj)) {
        return obj;
    }
    Object.values(obj).forEach(function (val) {
        deepFreeze(val);
    });
    return Object.freeze(obj);
};
exports.default = deepFreeze;


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var isObjectLike = function (value) { return value && typeof value === 'object'; };
var mergeWithDefaultRecursive = function (val, defaultVal) {
    if (val === undefined) {
        return defaultVal;
    }
    if (!isObjectLike(val) || !isObjectLike(defaultVal)) {
        return val;
    }
    // val and defaultVal must be objects
    var obj = val;
    var defaultObj = defaultVal;
    var newObj = {};
    // gather the keys of obj and defaultObj
    var keys = new Set(__spread(Object.keys(obj), Object.keys(defaultObj)));
    // apply the properties with default values onto newObj
    var didObjChange = false;
    keys.forEach(function (k) {
        newObj[k] = mergeWithDefaultRecursive(obj[k], defaultObj[k]);
        if (obj[k] !== newObj[k]) {
            didObjChange = true;
        }
    });
    return didObjChange ? newObj : obj;
};
/**
 * Recursively replaces the undefined values of obj with the values from the defaults objects.
 * Defaults objects are applied from left to right. Does not mutate the reference of objects that
 * are not changed, unlike lodash's defaultsDeep.
 * @param obj The base object.
 * @param defaultsToApply A list of objects that will have their values applied to the base object.
 * @returns The base object with the default values applied to it.
 */
var deepMergeWithDefaults = function (obj) {
    var defaultsToApply = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        defaultsToApply[_i - 1] = arguments[_i];
    }
    return defaultsToApply.reduce(function (objWithDefaults, defaultToApply) {
        return mergeWithDefaultRecursive(objWithDefaults, defaultToApply);
    }, obj);
};
exports.default = deepMergeWithDefaults;


/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var memoize_1 = __importDefault(__webpack_require__(10));
var console_1 = __importDefault(__webpack_require__(1));
/**
 * display deprecation message
 */
var deprecated = memoize_1.default(function (message) {
    if (message == null) {
        throw new Error('deprecation message is required');
    }
    console_1.default.warn(message);
});
exports.default = deprecated;


/***/ }),
/* 10 */
/***/ (function(module, exports) {

module.exports = require("lodash/memoize");

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.isDynamicOption = exports.DYNAMIC_STRING_SUBSTITUTE = void 0;
exports.DYNAMIC_STRING_SUBSTITUTE = '--dynamicValue--';
/**
 * Determines if the option's value is a dynamicOption
 * @param optionValue
 * @returns boolean
 */
var isDynamicOption = function (optionValue) {
    return typeof optionValue === 'string' && optionValue.trim().startsWith('>');
};
exports.isDynamicOption = isDynamicOption;


/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var sha256_1 = __importDefault(__webpack_require__(13));
/**
 * A hash function based on md5 to provide one-way string hashing. You can optionally give it a prefix.
 * @param {String} str
 * @param {String} [prefix]
 */
var hashString = function (str, prefix) {
    if (prefix === void 0) { prefix = ''; }
    return "" + prefix + sha256_1.default(str);
};
exports.default = hashString;


/***/ }),
/* 13 */
/***/ (function(module, exports) {

module.exports = require("crypto-js/sha256");

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.default = (function (a, b) {
    return JSON.stringify(a) === JSON.stringify(b);
});


/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.getFocus = exports.hasFocus = void 0;
/**
 * Return true if there's document.activeElement
 */
var hasFocus = function () { return document.activeElement !== document.body; };
exports.hasFocus = hasFocus;
/**
 * return current focus dom element
 */
var getFocus = function () {
    return document.activeElement === document.body ? null : document.activeElement;
};
exports.getFocus = getFocus;


/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.useScrollbarOverlay = exports.computeNewGridStructureItem = exports.computeNewAbsoluteStructureItem = exports.computeMaxHeight = exports.computeNewLinePosition = exports.computeNewBlockItemPosition = exports.computeNextAvailablePosition = exports.getDefaultPosition = exports.getPositionByType = exports.getFirstCollision = exports.sortLayoutItems = exports.convertToBlockItems = exports.convertToBlockItem = exports.convertLineToBlockItem = exports.toCoordinate = exports.computeLocationPort = exports.collides = exports.DEFAULT_CANVAS_HEIGHT = exports.DEFAULT_CANVAS_WIDTH = exports.VIZ_DEFAULT_HEIGHT_PX = exports.DEFAULT_SCALE_FACTOR = void 0;
var cloneDeep_1 = __importDefault(__webpack_require__(17));
exports.DEFAULT_SCALE_FACTOR = 3;
exports.VIZ_DEFAULT_HEIGHT_PX = 400;
exports.DEFAULT_CANVAS_WIDTH = 1200;
exports.DEFAULT_CANVAS_HEIGHT = 900;
/**
 * Given two layout items, check if they collide.
 * @method collides
 * @param {Object} layoutItemA
 * @param {Object} layoutItemB
 * @returns {Boolean} true or false
 */
var collides = function (layoutItemA, layoutItemB) {
    // same element
    if (layoutItemA.item === layoutItemB.item) {
        return false;
    }
    // layoutItemA is left of layoutItemB
    if (layoutItemA.position.x + layoutItemA.position.w <=
        layoutItemB.position.x) {
        return false;
    }
    // layoutItemA is right of layoutItemB
    if (layoutItemA.position.x >=
        layoutItemB.position.x + layoutItemB.position.w) {
        return false;
    }
    // layoutItemA is above layoutItemB
    if (layoutItemA.position.y + layoutItemA.position.h <=
        layoutItemB.position.y) {
        return false;
    }
    // layoutItemA is below layoutItemB
    if (layoutItemA.position.y >=
        layoutItemB.position.y + layoutItemB.position.h) {
        return false;
    }
    // boxes overlap
    return true;
};
exports.collides = collides;
/**
 * compute end position based on port
 * @method computeLocationPort
 * @param {Object} linePosition to or from
 * @param {Array} layout
 * @returns {Object} converted end position
 */
var computeLocationPort = function (endPosition, layout) {
    var id = endPosition.item;
    var index = layout.map(function (item) { return item.item; }).indexOf(id);
    var position;
    if (index >= 0) {
        position = cloneDeep_1.default(layout[index].position);
    }
    else {
        return null;
    }
    switch (endPosition.port) {
        case 'n':
            return { x: position.x + position.w / 2, y: position.y };
        case 'e':
            return {
                x: position.x + position.w,
                y: position.y + position.h / 2,
            };
        case 's':
            return {
                x: position.x + position.w / 2,
                y: position.y + position.h,
            };
        case 'w':
            return { x: position.x, y: position.y + position.h / 2 };
        default:
            return null;
    }
};
exports.computeLocationPort = computeLocationPort;
var toCoordinate = function (itemPosition, layout) {
    var _a;
    var topLeft = { x: 0, y: 0 };
    if (itemPosition.item && itemPosition.port) {
        return ((_a = exports.computeLocationPort({ item: itemPosition.item, port: itemPosition.port }, layout)) !== null && _a !== void 0 ? _a : topLeft);
    }
    if (typeof itemPosition.x === 'number' &&
        typeof itemPosition.y === 'number') {
        return { x: itemPosition.x, y: itemPosition.y };
    }
    return topLeft;
};
exports.toCoordinate = toCoordinate;
/**
 * convert line position to block position
 * @method convertLineToBlockItem
 * @param {Object} itemPosition
 * @param {Array} layout
 * @param {Number} status
 * @returns {Object} converted block position
 */
var convertLineToBlockItem = function (itemPosition, layout) {
    var from = exports.toCoordinate(itemPosition.from, layout);
    var to = exports.toCoordinate(itemPosition.to, layout);
    return {
        x: Math.min(from.x, to.x),
        y: Math.min(from.y, to.y),
        w: Math.abs(from.x - to.x),
        h: Math.abs(from.y - to.y),
    };
};
exports.convertLineToBlockItem = convertLineToBlockItem;
/**
 * convert layout item to block item
 * @method convertToBlockItem
 * @param {Object} item
 * @returns {Object} converted block item
 */
var convertToBlockItem = function (item, layout) {
    var blockItem = {
        item: item.item,
        type: 'block',
        position: {
            x: 0,
            y: 0,
            w: 0,
            h: 0,
        },
    };
    if (item.type === 'line') {
        blockItem.position = exports.convertLineToBlockItem(item.position, layout);
    }
    else {
        // default item type is block
        blockItem.position = cloneDeep_1.default(item.position);
    }
    return blockItem;
};
exports.convertToBlockItem = convertToBlockItem;
/**
 * convert layout items to block items
 * @method convertToBlockItems
 * @param {Array} layout
 * @returns {Array} converted block items
 */
var convertToBlockItems = function (layout) {
    return layout.map(function (item) { return exports.convertToBlockItem(item, layout); });
};
exports.convertToBlockItems = convertToBlockItems;
/**
 * Get layout items sorted from top left to right and down.
 * @method sortLayoutItems
 * @param {Array} layout
 * @returns {Array} sorted layout
 */
var sortLayoutItems = function (layout) {
    return cloneDeep_1.default(layout).sort(function (BlockItem1, BlockItem2) {
        var res = -1;
        if (BlockItem1.position.y > BlockItem2.position.y ||
            (BlockItem1.position.y === BlockItem2.position.y &&
                BlockItem1.position.x > BlockItem2.position.x)) {
            res = 1;
        }
        else if (BlockItem1.position.y === BlockItem2.position.y &&
            BlockItem1.position.x === BlockItem2.position.x) {
            // Without this, we can get different sort results in IE vs. Chrome/FF
            res = 0;
        }
        return res;
    });
};
exports.sortLayoutItems = sortLayoutItems;
/**
 * Returns the first item this layout collides with.
 * @method getFirstCollision
 * @param {Array} layout
 * @param {Object} layoutItem
 * @returns {Object} first collision or undefined
 */
var getFirstCollision = function (layout, layoutItem) {
    return layout.find(function (item) { return exports.collides(item, layoutItem); });
};
exports.getFirstCollision = getFirstCollision;
/**
 * get position based on type
 * @method getPositionByType
 * @param {Object} config
 * @param {Number} config.col
 * @param {Number} config.row
 * @param {Number} config.width
 * @param {Number} config.height
 * @param {String} config.type
 * @returns {Object} new position
 */
var getPositionByType = function (_a) {
    var col = _a.col, row = _a.row, width = _a.width, height = _a.height, type = _a.type;
    if (type === 'line') {
        return {
            from: {
                x: col,
                y: row + height,
            },
            to: {
                x: col + width,
                y: row + height / 2,
            },
        };
    }
    return {
        x: col,
        y: row,
        w: width,
        h: height,
    };
};
exports.getPositionByType = getPositionByType;
/**
 * get the default position based on type (Note: does not support legacy grid)
 * @method getDefaultPosition
 * @param {Object} config
 * @param {Number} config.canvasWidth
 * @param {Number} config.canvasHeight
 * @param {Number} config.width
 * @param {Number} config.height
 * @param {String} config.type
 * @returns {Object} default position
 */
var getDefaultPosition = function (_a) {
    var canvasWidth = _a.canvasWidth, canvasHeight = _a.canvasHeight, width = _a.width, height = _a.height, type = _a.type;
    if (type === 'line') {
        return {
            from: {
                x: Math.round(canvasWidth / exports.DEFAULT_SCALE_FACTOR),
                y: Math.round(canvasHeight / exports.DEFAULT_SCALE_FACTOR),
            },
            to: {
                x: Math.round(canvasWidth / exports.DEFAULT_SCALE_FACTOR + width),
                y: Math.round(canvasHeight / exports.DEFAULT_SCALE_FACTOR + height),
            },
        };
    }
    return {
        x: Math.round(canvasWidth / exports.DEFAULT_SCALE_FACTOR),
        y: Math.round(canvasHeight / exports.DEFAULT_SCALE_FACTOR),
        w: width,
        h: height,
    };
};
exports.getDefaultPosition = getDefaultPosition;
/**
 * compute next available position for new added item (Note: does not support legacy grid)
 * @method computeNextAvailablePosition
 * @param {Object} config
 * @param {Number} config.width
 * @param {Number} config.height
 * @param {Number} config.canvasHeight
 * @param {Number} config.canvasWidth
 * @param {Number} config.items
 * @param {Number} config.type absolute/line
 * @returns {Object} position
 */
var computeNextAvailablePosition = function (_a) {
    var width = _a.width, height = _a.height, canvasHeight = _a.canvasHeight, canvasWidth = _a.canvasWidth, items = _a.items, type = _a.type;
    var rectA = {
        item: '__canvas__',
        position: {
            x: 0,
            y: 0,
            w: width,
            h: height,
        },
    };
    var minHeight;
    var layout = exports.convertToBlockItems(items);
    var sorted = exports.sortLayoutItems(layout);
    // iterate all possible positions from top left to bottom right
    // for each position, we first try to find collision.
    // for each row, we record the minHeight for the collisions in this row.
    // if we can find a collision,  update col to the right boundary of current collision and update minHeight.
    // After each row, we update row to minHeight.
    // In this way, we can skip a lot of meaningless positions.
    // if find a good position, return this position
    // else return default position
    // Time complexity: O(K*K)   K is the number of layout items.
    var row = 0;
    var col;
    for (; row < canvasHeight; row += 1) {
        minHeight = canvasHeight - 1;
        col = 0;
        for (; col < canvasWidth; col += 1) {
            rectA.position.x = col;
            rectA.position.y = row;
            var rightBoundary = rectA.position.x + rectA.position.w - 1;
            var bottomBoundary = rectA.position.y + rectA.position.h - 1;
            // possible position must within canvas on horizontal and vertical side
            if (!(rightBoundary > canvasWidth || bottomBoundary > canvasHeight)) {
                var collision = exports.getFirstCollision(sorted, rectA);
                if (collision) {
                    minHeight = Math.min(minHeight, collision.position.y + collision.position.h - 1);
                    // update col
                    col = collision.position.x + collision.position.w - 1; // NOSONAR
                }
                else {
                    return exports.getPositionByType({ col: col, row: row, width: width, height: height, type: type });
                }
            }
            else {
                break;
            }
        }
        // update row
        row = minHeight; // NOSONAR
    }
    return exports.getDefaultPosition({
        canvasWidth: canvasWidth,
        canvasHeight: canvasHeight,
        width: width,
        height: height,
        type: type,
    });
};
exports.computeNextAvailablePosition = computeNextAvailablePosition;
/**
 * Given the current absolute layout items, return position that new visualization should locate.
 * @method computeNewBlockItemPosition
 * @param {Object} options
 * @param {Number} options.canvasWidth
 * @param {Number} options.canvasHeight
 * @param {Object} options.vizContract
 * @param {Array} options.items
 * @param {Object} options.config
 * @returns {Object} nextPosition
 */
var computeNewBlockItemPosition = function (_a) {
    var _b, _c, _d, _e, _f, _g, _h, _j;
    var canvasWidth = _a.canvasWidth, canvasHeight = _a.canvasHeight, vizContract = _a.vizContract, config = _a.config, items = _a.items;
    var width = (_e = (_c = (_b = vizContract === null || vizContract === void 0 ? void 0 : vizContract.initialDimension) === null || _b === void 0 ? void 0 : _b.width) !== null && _c !== void 0 ? _c : (_d = config === null || config === void 0 ? void 0 : config.size) === null || _d === void 0 ? void 0 : _d.initialWidth) !== null && _e !== void 0 ? _e : Math.round(canvasWidth / 3);
    var height = (_j = (_g = (_f = vizContract === null || vizContract === void 0 ? void 0 : vizContract.initialDimension) === null || _f === void 0 ? void 0 : _f.height) !== null && _g !== void 0 ? _g : (_h = config === null || config === void 0 ? void 0 : config.size) === null || _h === void 0 ? void 0 : _h.initialHeight) !== null && _j !== void 0 ? _j : Math.round(canvasHeight / 3);
    return exports.computeNextAvailablePosition({
        width: width,
        height: height,
        canvasHeight: canvasHeight,
        canvasWidth: canvasWidth,
        items: items,
        type: 'block',
    });
};
exports.computeNewBlockItemPosition = computeNewBlockItemPosition;
/**
 * Given the current absolute layout items, return point position
 * @method computeNewLinePosition
 * @params {Object} config
 * @param {Number} config.canvasWidth
 * @param {Number} config.canvasHeight
 * @param {Array} config.items
 * @returns {*} position
 */
var computeNewLinePosition = function (_a) {
    var canvasWidth = _a.canvasWidth, canvasHeight = _a.canvasHeight, items = _a.items;
    // default width and height for line
    var width = 150;
    var height = 20;
    return exports.computeNextAvailablePosition({
        width: width,
        height: height,
        canvasHeight: canvasHeight,
        canvasWidth: canvasWidth,
        items: items,
        type: 'line',
    });
};
exports.computeNewLinePosition = computeNewLinePosition;
/**
 * compute the max height based on current layout items and minimum height
 * @method computeMaxHeight
 * @param {Array} layoutItems
 * @param {Number} minHeight
 * @returns {Number} max height
 */
var computeMaxHeight = function (layoutItems, minHeight) {
    if (minHeight === void 0) { minHeight = 0; }
    return layoutItems.length > 0
        ? Math.max.apply(Math, __spread(layoutItems.map(function (item) { return item.position.y + item.position.h; }), [1])) : minHeight;
};
exports.computeMaxHeight = computeMaxHeight;
/**
 * Computes a new layout item position for the absolute layout
 * @param {Object} options
 * @param {String} options.itemId The identifier for a visualization
 * @param {String} [options.type="block"] The structure type for a viz: must be "line" or "block"
 * @param {Number} options.canvasWidth The width of the canvas
 * @param {Number} options.canvasHeight The height of the canvas
 * @param {Object} options.vizContract Metadata to define the default height/width of a new viz
 * @param {Object} options.config
 * @param {Array} layoutItems List of items in the layout structure
 * @returns {LayoutItem}
 */
var computeNewAbsoluteStructureItem = function (_a) {
    var itemId = _a.itemId, _b = _a.type, type = _b === void 0 ? 'block' : _b, canvasWidth = _a.canvasWidth, canvasHeight = _a.canvasHeight, vizContract = _a.vizContract, layoutItems = _a.layoutItems, config = _a.config;
    if (type === 'line') {
        return {
            item: itemId,
            type: 'line',
            position: exports.computeNewLinePosition({
                canvasWidth: canvasWidth,
                canvasHeight: canvasHeight,
                items: layoutItems,
            }),
        };
    }
    return {
        item: itemId,
        type: 'block',
        position: exports.computeNewBlockItemPosition({
            canvasWidth: canvasWidth,
            canvasHeight: canvasHeight,
            vizContract: vizContract,
            config: config,
            items: layoutItems,
        }),
    };
};
exports.computeNewAbsoluteStructureItem = computeNewAbsoluteStructureItem;
/**
 * Computes a new layout item position for the grid layout
 * @param {Object} config
 * @param {String} config.itemId The identifier for a visualization
 * @param {Number} config.canvasWidth The width of the canvas
 * @param {Array} layoutItems List of items in the layout structure
 * @returns {LayoutItem}
 */
var computeNewGridStructureItem = function (_a) {
    var itemId = _a.itemId, layoutItems = _a.layoutItems, canvasWidth = _a.canvasWidth;
    return ({
        item: itemId,
        type: 'block',
        position: {
            x: 0,
            y: exports.computeMaxHeight(layoutItems),
            w: canvasWidth,
            h: exports.VIZ_DEFAULT_HEIGHT_PX,
        },
    });
};
exports.computeNewGridStructureItem = computeNewGridStructureItem;
/**
 * Check if the default scrollbar is obtrusive (uses screen real estate) or not (directly overlaid on content)
 * @returns {Boolean}
 */
var hasObtrusiveDefaultScrollbar = function () {
    var scrollDiv = document.createElement('div');
    scrollDiv.setAttribute('style', 'width:100px;height:100px;overflow:scroll;position:absolute;top:-9999px;');
    document.body.appendChild(scrollDiv);
    // get the scrollbar width
    var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;
    // delete the div
    document.body.removeChild(scrollDiv);
    return scrollbarWidth !== 0;
};
/**
 * Determine if scrollbar is required to be overlaid (non obtrusive)
 * @returns {Boolean}
 */
var useScrollbarOverlay = function () {
    /**
     * NOTE: only webkit and blink based browsers support 'overflow:overlay'
     * this fix is for https://jira.splunk.com/browse/SCP-36275 which predominantly exists in Chrome on Windows OS
     * @returns {Boolean}
     */
    return (hasObtrusiveDefaultScrollbar() && CSS.supports('overflow', 'overlay'));
};
exports.useScrollbarOverlay = useScrollbarOverlay;


/***/ }),
/* 17 */
/***/ (function(module, exports) {

module.exports = require("lodash/cloneDeep");

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.MAX_CHAIN_LENGTH = exports.runningSearchStatuses = void 0;
exports.runningSearchStatuses = [
    'running',
    'queued',
    'parsing',
    'paused',
    'finalizing',
];
// The max chained searches: base -> chain -> chain
exports.MAX_CHAIN_LENGTH = 2;


/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var intersection_1 = __importDefault(__webpack_require__(20));
var difference_1 = __importDefault(__webpack_require__(21));
var every_1 = __importDefault(__webpack_require__(22));
exports.default = (function (obj1, obj2, _a) {
    var _b = _a === void 0 ? {} : _a, _c = _b.includeKeys, includeKeys = _c === void 0 ? [] : _c, _d = _b.omitKeys, omitKeys = _d === void 0 ? [] : _d;
    if (obj1 === obj2) {
        return true;
    }
    var keysA = Object.keys(obj1);
    var keysB = Object.keys(obj2);
    if (includeKeys.length) {
        keysA = intersection_1.default(keysA, includeKeys);
        keysB = intersection_1.default(keysB, includeKeys);
    }
    if (omitKeys.length) {
        keysA = difference_1.default(keysA, omitKeys);
        keysB = difference_1.default(keysB, omitKeys);
    }
    return (keysA.length === keysB.length &&
        every_1.default(keysA, function (key) { return obj1[key] === obj2[key]; }));
});


/***/ }),
/* 20 */
/***/ (function(module, exports) {

module.exports = require("lodash/intersection");

/***/ }),
/* 21 */
/***/ (function(module, exports) {

module.exports = require("lodash/difference");

/***/ }),
/* 22 */
/***/ (function(module, exports) {

module.exports = require("lodash/every");

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.toPadding = exports.toMargin = exports.arrayToCSSProp = exports.toDimension = exports.toPx = void 0;
var isNumber_1 = __importDefault(__webpack_require__(24));
/**
 * convert number to px
 * @param {number | string | null | undefined} number
 * @param {Number} defaultNumber
 * @returns {String}
 */
var toPx = function (num, defaultNumber) {
    if (defaultNumber === void 0) { defaultNumber = 0; }
    return (isNumber_1.default(num) ? num + "px" : num || exports.toPx(defaultNumber));
};
exports.toPx = toPx;
/**
 * generate width/height css properties
 * @param {Object} obj
 * @param {Number | String | null | undefined} obj.width
 * @param {Number | String | null | undefined} obj.height
 * @returns {String}
 */
var toDimension = function (_a) {
    var width = _a.width, height = _a.height;
    var css = '';
    if (width || width === 0) {
        css = "\n        width: " + exports.toPx(width) + ";\n        ";
    }
    if (height || height === 0) {
        css = "\n        " + css + "\n        height: " + exports.toPx(height) + ";\n        ";
    }
    return css;
};
exports.toDimension = toDimension;
/**
 * generate margin css property
 */
var arrayToCSSProp = function (prop, values) {
    if (values === void 0) { values = [0, 0, 0, 0]; }
    if (Array.isArray(values)) {
        return "\n            " + prop + ": " + exports.toPx(values[0]) + " " + exports.toPx(values[1]) + " " + exports.toPx(values[2]) + " " + exports.toPx(values[3]) + ";\n        ";
    }
    return prop + ": " + exports.toPx(values) + ";";
};
exports.arrayToCSSProp = arrayToCSSProp;
/**
 * generate margin css property
 */
var toMargin = function (margins) {
    if (margins === void 0) { margins = [0, 0, 0, 0]; }
    return exports.arrayToCSSProp('margin', margins);
};
exports.toMargin = toMargin;
/**
 * generate padding css property
 */
var toPadding = function (paddings) {
    if (paddings === void 0) { paddings = [0, 0, 0, 0]; }
    return exports.arrayToCSSProp('padding', paddings);
};
exports.toPadding = toPadding;


/***/ }),
/* 24 */
/***/ (function(module, exports) {

module.exports = require("lodash/isNumber");

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.defaultRealTimePreset = exports.defaultTimePreset = exports.parse = exports.formatDuration = exports.createRangeLabel = exports.findPresetLabel = exports.timeRangesAreEquivalent = exports.isAllTime = exports.isLatestNow = exports.isEarliestEmpty = exports.isWholeDay = exports.isRealTime = exports.isValidTime = exports.parseTimeString = exports.isAbsolute = exports.isISO = exports.isEpoch = exports.removeISOTimezone = exports.removeRealTime = exports.getUnitLabel = exports.normalizeSnapUnit = exports.normalizeUnit = exports.epochToMoment = void 0;
// TODO: This is essentially an old copy of @splunk/time-range-utils/Time. The code in that set of utils has diverged over time, particularly where labels are generated.
var find_1 = __importDefault(__webpack_require__(26));
var has_1 = __importDefault(__webpack_require__(27));
var isString_1 = __importDefault(__webpack_require__(2));
var isFinite_1 = __importDefault(__webpack_require__(28));
var format_1 = __webpack_require__(29);
var i18n_1 = __webpack_require__(0);
var config_1 = __webpack_require__(30);
var moment_1 = __importDefault(__webpack_require__(5));
var timeUnits_1 = __webpack_require__(3);
var momentUnits = {
    s: 's',
    m: 'm',
    h: 'h',
    d: 'd',
    w: 'w',
    mon: 'M',
    q: 'Q',
    y: 'y',
};
var momentSnaps = {
    s: 'second',
    m: 'minute',
    h: 'hour',
    d: 'day',
    w: 'week',
    mon: 'month',
    q: 'quarter',
    y: 'year',
};
var weekDaySnaps = {
    w0: 0,
    w1: 1,
    w2: 2,
    w3: 3,
    w4: 4,
    w5: 5,
    w6: 6,
    w7: 0,
};
/**
 * Returns a moment for the given time or the current time, if none is given
 * @method epochToMoment
 * @param {Number} [epoch] given time in seconds
 * @returns Moment
 */
var epochToMoment = function (epoch) {
    // If we get an input time, convert to ms, otherwise generate current time
    var time = epoch || epoch === 0 ? epoch * 1000 : new Date().getTime();
    if (moment_1.default.getDefaultSplunkTimezone()) {
        return moment_1.default.newSplunkTime({ time: time });
    }
    // fallback to moment default
    return moment_1.default(time);
};
exports.epochToMoment = epochToMoment;
/**
 * Normalizes units to it's shortest version, such as `s` for `sec` and `mon` for `month`.
 * @name normalizeUnit
 * @function
 * @public
 * @param {String} unit - The unit, such as `s` or `quarter`.
 * @param {bool} [removeInvalid=true] - When true, returns an empty string for invalid units,
 * when false
 * returns 's' for invalid units.
 * @returns {String} Returns the normalized unit or empty string.
 */
function normalizeUnit(abbr, removeInvalid) {
    if (removeInvalid === void 0) { removeInvalid = true; }
    var hasUnit = has_1.default(timeUnits_1.timeUnits, abbr);
    var defaultUnit = removeInvalid ? '' : timeUnits_1.timeUnits.s.abbr;
    return hasUnit ? timeUnits_1.timeUnits[abbr].abbr : defaultUnit;
}
exports.normalizeUnit = normalizeUnit;
/**
 * Normalizes snap units to it's shortest version, this is the same as normalizeUnit, but also
 * supports weekdays, such as `w5`.
 * @public
 * @param {String} unit - The unit, such as `s`, `quarter` or `w0`.
 * @param {bool} [removeInvalid=true] - When true, returns an empty string for invalid units,
 * when false returns 's' for invalid units.
 * @returns {String} Returns the normalized unit or empty string.
 */
function normalizeSnapUnit(abbr, removeInvalid) {
    if (removeInvalid === void 0) { removeInvalid = true; }
    var hasUnit = has_1.default(timeUnits_1.snapUnits, abbr);
    var defaultUnit = removeInvalid ? '' : timeUnits_1.timeUnits.s.abbr;
    return hasUnit ? timeUnits_1.snapUnits[abbr].abbr : defaultUnit;
}
exports.normalizeSnapUnit = normalizeSnapUnit;
/**
 * Returns a label for a unit abbreviation, such as 'second' for 's' or 'sec'.
 * @public
 * @param {Object} unit -  The unit, such as `s`, `quarter` or `w0`.
 * @param {Object} [plural=false] - Whether the returned label should be plural.
 * @returns {String}
 */
function getUnitLabel(unit, plural) {
    if (plural === void 0) { plural = false; }
    return timeUnits_1.snapUnits[unit][plural ? 'plural' : 'singular'];
}
exports.getUnitLabel = getUnitLabel;
/**
 * Strips rt from the beginning of a time string when found. This makes a time string compatible
 * with the time parser. To ensure capability with the time parser 'rt' returns 'now'.
 * @public
 * @param {String} time - The time string such as `47165491` or `rt-2h@m`.
 * @returns {String} Returns the time string.
 */
function removeRealTime(time) {
    if (time === 'rt') {
        return 'now';
    }
    return time.replace(/^rt/, '');
}
exports.removeRealTime = removeRealTime;
/**
 * Removes the timezone from an iso time string
 * @public
 * @param {String} time - The time string such as `47165491` or `-2h@m`.
 * @returns {String}
 */
function removeISOTimezone(time) {
    return time.replace(/[+-]\d?\d:\d\d$/, '');
}
exports.removeISOTimezone = removeISOTimezone;
/**
 * Validates that a string represents a unix epoch time.
 * @public
 * @param {String} time - The time string such as `47165491` or `-2h@m`.
 * @returns {bool}
 */
function isEpoch(time) {
    return (isFinite_1.default(time) || (isString_1.default(time) && /^\d+((\.\d+)|(\d*))$/.test(time)));
}
exports.isEpoch = isEpoch;
/**
 * Validates that a string represents an ISO time.
 * @public
 * @param {String} time - The time string such as `47165491` or `-2h@m`.
 * @returns {bool}
 */
function isISO(time) {
    return !!time.match(/^\d\d\d\d-\d\d?-\d\d?T\d\d?:\d\d?(:\d\d?)?(\.\d\d?\d?)?([+-]\d\d?:\d\d|Z)?$/);
}
exports.isISO = isISO;
/**
 * Validates that a string represents an ISO or unix epoch time.
 * @public
 * @param {String} time - The time string such as `47165491` or `-2h@m`.
 * @returns {bool}
 */
function isAbsolute(time) {
    if (time === undefined) {
        return false;
    }
    return isEpoch(time) || isISO(time);
}
exports.isAbsolute = isAbsolute;
/**
 * Parses a time string for inspection or form population.
 *
 * Example parse for a relative time string:
 * ```
 * {
 *     string: '-3d@qtr+2hr',
 *     type: ['relative'], // 'relative', 'realTime', 'iso', or 'epoch'
 *     isFullyParsed: true,
 *     modifiers: [
 *         {
 *             string: '-3d@qtr',
 *             isParsed: true,
 *             unit: 'd',
 *             amount: -3,
 *             snap: 'q',
 *         },
 *         {
 *             string: '+2hr',
 *             isParsed: true,
 *             unit: 'h',
 *             amount: +2,
 *             snap: false,
 *         },
 *     ],
 * }
 * ```
 * Example parse for a epoch time:
 * ```
 * {
 *     string: '89451357',
 *     type: ['epoch'],
 *     isFullyParsed: true,
 *     modifiers: [],
 * }
 *
 * @public
 * @param {String} time - The time string such as `47165491` or `-2h@m`.
 * @returns {Object}
 */
function parseTimeString(timeString) {
    if (!isString_1.default(timeString)) {
        return false;
    }
    var ast = {
        string: timeString,
        type: 'relative',
        isFullyParsed: true,
        modifiers: [],
    };
    if (isISO(timeString)) {
        ast.type = 'iso';
        return ast;
    }
    if (isEpoch(timeString)) {
        ast.type = 'epoch';
        return ast;
    }
    var segments = timeString
        .trim()
        .replace(/-/g, '\n-')
        .replace(/\+/g, '\n+')
        .split('\n');
    // If only snap has been provided push empty string to beginning of segments.
    if (segments[0].charAt(0) === '@') {
        segments.unshift('');
    }
    if (segments[0] === 'rt' || segments[0] === 'rtnow') {
        ast.type = 'realTime';
    }
    else if (['rt', 'now', 'rtnow', ''].indexOf(segments[0]) < 0) {
        ast.isFullyParsed = false;
        return ast;
    }
    else {
        ast.type = 'relative';
    }
    ast.modifiers = segments.slice(1).map(function (segmentString) {
        var segment = {
            string: segmentString,
            unit: 's',
            amount: 0,
            snap: false,
            isParsed: false,
        };
        var sParse = segmentString.match(/^(([-+]\d*)([a-zA-Z]*))?(@([a-zA-Z][a-zA-Z0-7]*))?$/);
        //                                          2         3      4          5
        if (sParse) {
            segment.unit = sParse[3] && normalizeUnit(sParse[3], false);
            segment.amount = segment.unit ? parseInt(sParse[2], 10) || 1 : 0;
            segment.snap = !!sParse[4] && normalizeSnapUnit(sParse[5], false);
            segment.isParsed = true;
            if ((sParse[5] && !timeUnits_1.snapUnits[sParse[5]]) || // invalid unit
                (sParse[3] && !timeUnits_1.timeUnits[sParse[3]]) || // invalid snap unit
                segmentString.length === 1 // unqualified - or +
            ) {
                ast.isFullyParsed = false;
                segment.isParsed = false;
            }
        }
        else {
            ast.isFullyParsed = false;
        }
        return segment;
    });
    return ast;
}
exports.parseTimeString = parseTimeString;
/**
 * Validates that a string is a valid time string.
 * @public
 * @param {String} time - The time string such as `rt` , `rtnow` or `-2h@m`.
 * @returns {bool}
 */
function isValidTime(time) {
    var parsedTime = parseTimeString(time);
    return parsedTime && parsedTime.isFullyParsed;
}
exports.isValidTime = isValidTime;
/**
 * Validates that a string represents a real-time search.
 * @public
 * @param {String} time - The time string such as `rt` , `rtnow` or `-2h@m`.
 * @returns {bool}
 */
function isRealTime(time) {
    var parsedTimeString = parseTimeString(time);
    return (parsedTimeString &&
        parsedTimeString.type === 'realTime' &&
        parsedTimeString.isFullyParsed);
}
exports.isRealTime = isRealTime;
/**
 * Validates that a iso time string is a whole day.
 * @public
 * @param {string|object} time - A time string (such as `2008-09-15T15:53:00+05:00`) or a
 * @splunk/moment time instance.
 * @returns {bool}
 */
function isWholeDay(time) {
    if ((isString_1.default(time) && isISO(time)) ||
        (moment_1.default.isMoment(time) && time.isValid())) {
        var timeMoment = moment_1.default(time);
        return timeMoment.valueOf() === timeMoment.startOf('day').valueOf();
    }
    return false;
}
exports.isWholeDay = isWholeDay;
/**
 * Validate that a time string acts is either empty or `0`.
 * @public
 * @param {String} time - The time string such as `rt` , `rtnow` or `-2h@m`.
 * @returns {bool}
 */
function isEarliestEmpty(time) {
    return !time || time === '0';
}
exports.isEarliestEmpty = isEarliestEmpty;
/**
 * Validate that a time string acts is either empty or now
 * @public
 * @param {String} time - The time string such as `rt` , `rtnow` or `-2h@m`.
 * @returns {bool}
 */
function isLatestNow(time) {
    return !time || (isString_1.default(time) && time === 'now');
}
exports.isLatestNow = isLatestNow;
/**
 * Validate that a time range acts is equivalent to all-time.
 * @public
 * @param {String} earliest - The time string such as `rt` , `rtnow` or `-2h@m`.
 * @param {String} latest - The time string such as `rt` , `rtnow` or `-2h@m`.
 * @returns {bool}
 */
function isAllTime(earliest, latest) {
    return (isEarliestEmpty(removeRealTime(earliest)) &&
        isLatestNow(removeRealTime(latest)));
}
exports.isAllTime = isAllTime;
/**
 * Validate that two time range are equivalent. This normalizes the two comparisons using
 * isEarliestEmpty() and isLatestNow().
 * @public
 * @param {Object} range1 - The time string range  such as `{ earliest: '-1d', latest: 'now' }`.
 * @param {Object} range2 -  The time string range such as `{ earliest: '0', latest: '-1d' }`.
 * @returns {bool}
 */
function timeRangesAreEquivalent(range1, range2) {
    var earliest1 = range1.earliest;
    var latest1 = range1.latest;
    var earliest2 = range2.earliest;
    var latest2 = range2.latest;
    var earliestEqual = false;
    var latestEqual = false;
    if (isEarliestEmpty(earliest1) && isEarliestEmpty(earliest2)) {
        earliestEqual = true;
    }
    else {
        earliestEqual = earliest1 === earliest2;
    }
    if (isLatestNow(latest1) && isLatestNow(latest2)) {
        latestEqual = true;
    }
    else {
        latestEqual = latest1 === latest2;
    }
    return earliestEqual && latestEqual;
}
exports.timeRangesAreEquivalent = timeRangesAreEquivalent;
/**
 * Searches through an array of presets and returns any equivalent labels using
 * timeRangesAreEquivalent().
 * @public
 * @param {array} presets - An array of presents such as:
 * ```
 * [
 *     { label: '30 second window', earliest: 'rt-30s', latest: 'rt' },
 *     { label: 'Today', earliest: '@d', latest: 'now' },
 *     { label: 'Previous year', earliest: '-1y@y', latest: '@y' },
 *     { label: 'Last 15 minutes', earliest: '-15m', latest: 'now' },
 *     { label: 'All time', earliest: '0', latest: '' },
 * ]
 * ```
 * @param {String} earliest - The time string such as `rt` , `rtnow` or `-2h@m`.
 * @param {String} latest - The time string such as `rt` , `rtnow` or `-2h@m`.
 * @returns {string | false } The matched preset label.
 */
function findPresetLabel(presets, earliest, latest) {
    /* JSDoc and eslint cannot agree on the appropriate format of this */
    /* eslint-disable */
    var currentPreset = find_1.default(presets, function (preset) {
        var range2 = { earliest: preset.earliest, latest: preset.latest };
        return timeRangesAreEquivalent({ earliest: earliest, latest: latest }, range2);
    });
    /* eslint-enable */
    return currentPreset ? currentPreset.label : false;
}
exports.findPresetLabel = findPresetLabel;
/**
 * Generates a label for a real-time time search.
 * For example:  '5 minute window' or 'Real-time'
 * @private
 * @param {String} earliest - The time string such as `rt` , `rtnow` or `-2h@m`.
 * @param {String} latest - The time string such as `rt` , `rtnow` or `-2h@m`.
 * @returns {null|string}
 */
function createRealTimeLabel(earliest, latest) {
    if (isRealTime(earliest) || isRealTime(latest)) {
        var earliestParse = parseTimeString(earliest);
        var latestParse = parseTimeString(latest);
        if (!earliestParse || !latestParse) {
            return false;
        }
        var earliestModifier = earliestParse.modifiers[0];
        var labelTemplates = {
            s: i18n_1._('%(time)d second window'),
            m: i18n_1._('%(time)d minute window'),
            h: i18n_1._('%(time)d hour window'),
            d: i18n_1._('%(time)d day window'),
            w: i18n_1._('%(time)d week window'),
            mon: i18n_1._('%(time)d month window'),
            q: i18n_1._('%(time)d quarter window'),
            y: i18n_1._('%(time)d year window'),
        };
        if (earliestModifier &&
            earliestParse.type === 'realTime' &&
            latestParse.type === 'realTime' &&
            latestParse.modifiers.length === 0 && (earliestModifier === null || earliestModifier === void 0 ? void 0 : earliestModifier.unit) &&
            has_1.default(labelTemplates, earliestModifier.unit) &&
            earliestParse.modifiers.length === 1) {
            return format_1.sprintf(labelTemplates[earliestModifier.unit], {
                time: Math.abs(earliestModifier.amount || 0),
            });
        }
        // Other Real-Time.
        return i18n_1._('Real-time');
    }
    return false;
}
/**
 * Generates a label for a relative time search.
 * For example:  'Last 5 minutes'
 * @private
 * @param {String} earliest - The time string such as `rt` , `rtnow` or `-2h@m`.
 * @param {String} latest - The time string such as `rt` , `rtnow` or `-2h@m`.
 * @returns {null|string}
 */
function createRelativeTimeLabel(earliest, latest) {
    var earliestParse = parseTimeString(earliest);
    var latestParse = parseTimeString(latest);
    if (!earliestParse || !latestParse) {
        return false;
    }
    var earliestModifier = earliestParse.modifiers[0];
    var latestModifier = latestParse.modifiers[0];
    if (earliestParse.type === 'realTime' ||
        latestParse.type === 'realTime' ||
        !earliestModifier ||
        earliestParse.modifiers.length > 1 ||
        latestParse.modifiers.length > 1) {
        return false;
    }
    if (earliestModifier.amount < 0 &&
        (!earliestModifier.snap ||
            earliestModifier.unit === earliestModifier.snap) &&
        (isLatestNow(latest) || (latestModifier && !latestModifier.amount)) &&
        (!latestModifier ||
            !latestModifier.snap ||
            earliestModifier.unit === latestModifier.snap)) {
        var amount = Math.abs(earliestModifier.amount);
        var pluralKey = amount > 1 ? 'plural' : 'singular';
        return format_1.sprintf(i18n_1._('Last %(amount)d %(unit)s'), {
            amount: amount,
            unit: timeUnits_1.timeUnits[earliestModifier.unit][pluralKey],
        });
    }
    return false;
}
/**
 * Compares two moment instances to determine if they are on the same day.
 * @private
 * @param {Object} earliest - @splunk/moment time instance
 * @param {Object} latest - @splunk/moment time instance
 * @returns {bool}
 */
function areSameDay(a, b) {
    var aTime = a.clone().startOf('day');
    var bTime = b.clone().startOf('day');
    return aTime.isSame(bTime);
}
/**
 * Determines whether the date is the start of a year, month or day.
 * @private
 * @param {Object} date - @splunk/moment time instance
 * @returns {'year'|'month'|'date'|undefined}
 */
function largestDateUnit(date) {
    return find_1.default(['year', 'month', 'date'], function (unit) {
        var dateStart = date.clone().startOf(unit);
        return date.isSame(dateStart);
    });
}
/**
 * Finds the largest date unit that can describe a date range: years, months or days.
 * @private
 * @param {Object} earliest - @splunk/moment time instance
 * @param {Object} latest - @splunk/moment time instance
 * @returns {'year'|'month'|'date'|null}
 */
function findSingleDateUnit(a, b) {
    if (!(isWholeDay(a) && isWholeDay(b))) {
        return null;
    }
    if (a.month() === 0 &&
        b.month() === 0 &&
        a.date() === 1 &&
        b.date() === 1) {
        return 'year';
    }
    if ((a.year() === b.year() && a.date() === 1 && b.date() === 1) ||
        (a.year() + 1 === b.year() &&
            b.month() === 0 &&
            a.date() === 1 &&
            b.date() === 1)) {
        return 'month';
    }
    if ((a.year() === b.year() && a.month() === b.month()) ||
        (a.year() === b.year() &&
            a.month() + 1 === b.month() &&
            b.date() === 1) ||
        (a.year() + 1 === b.year() && b.month() === 0)) {
        return 'date';
    }
    return null;
}
/**
 * Generates a date range label for a single year, month or day.
 * For example:  '2017', 'Feb 2017' or 'Feb 18, 2017'
 * @private
 * @param {Object} date - @splunk/moment time instance
 * @param {'year'|'month'|'date'} unit
 * @returns {String}
 */
function createSingleUnitOnLabel(date, unit) {
    switch (unit) {
        case 'year':
            return date.format('YYYY');
        case 'month':
            return format_1.sprintf(i18n_1._('%(month)s %(year)s'), {
                month: date.format('MMM'),
                year: date.format('YYYY'),
            });
        default:
            return date.format('ll');
    }
}
/**
 * Generates a date range label for a range of years, months or days.
 * For example:  '2015 though 2017', 'Feb through Apr, 2017' or 'Feb 17 through 18, 2017'
 * @private
 * @param {Object} earliest - @splunk/moment time instance
 * @param {Object} latest - @splunk/moment time instance
 * @param {'year'|'month'|'date'} unit
 * @returns {String}
 */
function createSingleUnitThroughLabel(a, b, unit) {
    var b2 = b.subtract(1, unit === 'date' ? 'day' : unit);
    switch (unit) {
        case 'year':
            return format_1.sprintf(i18n_1._('%(earliestYear)s through %(latestYear)s'), {
                earliestYear: a.format('YYYY'),
                latestYear: b2.format('YYYY'),
            });
        case 'month':
            return format_1.sprintf(i18n_1._('%(earliestMonth)s through %(latestMonth)s, %(inYear)s'), {
                earliestMonth: a.format('MMM'),
                latestMonth: b2.format('MMM'),
                inYear: b2.format('YYYY'),
            });
        default:
            return format_1.sprintf(i18n_1._('%(month)s %(earliestDayOfMonth)s through %(latestDayOfMonth)s, %(inYear)s'), {
                month: a.format('MMM'),
                earliestDayOfMonth: a.format('D'),
                latestDayOfMonth: b2.format('D'),
                inYear: b2.format('YYYY'),
            });
    }
}
/**
 * Generates date-time label with the minimum specificity for time:minute, seconds or milliseconds.
 * For example:  'Feb 18, 2017 4:12:30.567 AM'
 * @private
 * @param {Object} date - @splunk/moment time instance
 * @returns {String}
 */
function createDateTimeLabel(date) {
    if (date.millisecond()) {
        return date.splunkFormat('llms');
    }
    if (date.second()) {
        return date.splunkFormat('lls');
    }
    return date.splunkFormat('lll');
}
/**
 * Generates time label with the minimum specificity for time: minute, seconds or milliseconds.
 * For example:  '6:00 AM', '6:00:20 AM' or '6:00:20.712 AM'
 * @private
 * @param {Object} time - @splunk/moment time instance
 * @returns {String}
 */
function createTimeLabel(time) {
    if (time.millisecond()) {
        return time.splunkFormat('LTMS');
    }
    if (time.second()) {
        return time.format('LTS');
    }
    return time.format('LT');
}
/**
 * Generates a date-time label with the minimum specificity for time: minute, seconds or milliseconds.
 * For example: 'Feb 17, 2017 6:00 AM to Feb 18, 2017 12:20 AM'
 * @private
 * @param {Object} earliestTime - @splunk/moment time instance
 * @param {Object} latestTime - @splunk/moment time instance
 * @returns {String}
 */
function createTimeRangeLabel(a, b) {
    var format;
    if (a.millisecond() || b.millisecond()) {
        format = 'llms';
    }
    else if (a.second() || b.second()) {
        format = 'lls';
    }
    else {
        format = 'lll';
    }
    return format_1.sprintf(i18n_1._('%(earliestDateTime)s to %(latestDateTime)s'), {
        earliestDateTime: a.splunkFormat(format),
        latestDateTime: b.splunkFormat(format),
    });
}
/**
 * Generates a label for a time range on a single date.
 * For example: '6:00:20.850 AM to 8:00:40.490 PM, Feb 17, 2017'
 * @private
 * @param {Object} earliestTime - @splunk/moment time instance
 * @param {Object} latestTime - @splunk/moment time instance
 * @returns {String}
 */
function createPartOfDayLabel(a, b) {
    return format_1.sprintf(i18n_1._('%(earliestTime)s to %(latestTime)s, %(date)s'), {
        earliestTime: createTimeLabel(a),
        latestTime: createTimeLabel(b),
        date: a.format('ll'),
    });
}
function conformToMaxChars(label, shortLabel, maxChars) {
    // if label is shorter than the shortLabel and longer than maxChars, use the label.
    // This scenario may arise due to long translations of the shortLabel.
    return maxChars && label.length > Math.max(shortLabel.length, maxChars)
        ? shortLabel
        : label;
}
/**
 * Generates a label for a date range when provided two ISO date formats.
 * @private
 * @param {String} earliest - An ISO time string, or other splunk time string.
 * @param {String} latest - An ISO time string, or other splunk time string .
 * @param {Number} maxChars - If the generated label is too long, it will abbreviate
   to a more generic form, such as 'Between Date-times' instead of 'Feb 17, 2017 6:00 AM to Feb 18, 2017 12:20 AM'.
 * @returns {null|string}
 */
function createDateTimeRangeLabel(earliest, latest, maxChars) {
    var a = isISO(earliest)
        ? moment_1.default(earliest).locale(config_1.locale || 'en_US')
        : undefined;
    var b = isISO(latest)
        ? moment_1.default(latest).locale(config_1.locale || 'en_US')
        : undefined;
    if (a && b) {
        // During Year, Month Day
        var unit = findSingleDateUnit(a, b);
        // Single Year, Month or Day
        var next = unit && moment_1.default(a).add(1, unit === 'date' ? 'days' : unit);
        if (unit && next[unit]() === b[unit]()) {
            return createSingleUnitOnLabel(a, unit);
        }
        if (unit) {
            return conformToMaxChars(createSingleUnitThroughLabel(a, b, unit), i18n_1._('Date Range'), maxChars);
        }
        // Part of Day
        if (areSameDay(a, b)) {
            return conformToMaxChars(createPartOfDayLabel(a, b), i18n_1._('Part of a Day'), maxChars);
        }
        // Full
        return conformToMaxChars(createTimeRangeLabel(a, b), i18n_1._('Between Date-times'), maxChars);
    }
    if (a && isLatestNow(latest)) {
        // Since
        var unit = largestDateUnit(a);
        var since = unit
            ? createSingleUnitOnLabel(a, unit)
            : createDateTimeLabel(a);
        var longLabel = format_1.sprintf(i18n_1._('Since %(dateTime)s'), { dateTime: since });
        return conformToMaxChars(longLabel, i18n_1._('Since Date-time'), maxChars);
    }
    if (isEarliestEmpty(earliest) && b) {
        // Before
        var unit = largestDateUnit(b);
        var before = unit
            ? createSingleUnitOnLabel(b, unit)
            : createDateTimeLabel(b);
        var longLabel = format_1.sprintf(i18n_1._('Before %(dateTime)s'), {
            dateTime: before,
        });
        return conformToMaxChars(longLabel, i18n_1._('Before Date-time'), maxChars);
    }
    return null;
}
/**
 * Returns 'All-time' is the search is all-time or a close equivalent.
 * @private
 * @param {String} earliest - The time string such as `rt` , `rtnow` or `-2h@m`.
 * @param {String} latest - The time string such as `rt` , `rtnow` or `-2h@m`.
 * @returns {String}
 */
function createAllTimeLabel(earliest, latest) {
    if (isEarliestEmpty(earliest) && isLatestNow(latest)) {
        return i18n_1._('All time');
    }
    return false;
}
/**
 * Creates an appropriate label for a time range, using a preset label if available.
 * @public
 * @param {String} earliest - The time string such as `rt` , `rtnow` or `-2h@m`.
 * @param {String} latest - The time string such as `rt` , `rtnow` or `-2h@m`.
 * @param {Object} [options] - An array of presents such as:
 * @param {Number} [options.maxChars = 0] - If the generated label is too long, it will abbreviate
 * to a more generic form, such as 'Between Date-times' instead of 'Feb 17, 2017 6:00 AM to Feb 18, 2017 12:20 AM'.
 * `Infinity` and `0` allow labels of any length.
 * @param {array} [options.presets] - An array of presents such as:
 * ```
 * [
 *     { label: '30 second window', earliest: 'rt-30s', latest: 'rt' },
 *     { label: 'Today', earliest: '@d', latest: 'now' },
 *     { label: 'Previous year', earliest: '-1y@y', latest: '@y' },
 *     { label: 'Last 15 minutes', earliest: '-15m', latest: 'now' },
 *     { label: 'All time', earliest: '0', latest: '' },
 * ]
 * ```
 * @returns {String} Returns `'Custom time'` if one cannot be made.
 */
function createRangeLabel(earliest, latest, _a) {
    var _b = _a === void 0 ? {} : _a, presets = _b.presets, _c = _b.maxChars, maxChars = _c === void 0 ? 0 : _c;
    var earliestTrimmed = earliest.trim();
    var latestTrimmed = latest.trim();
    return (createAllTimeLabel(earliestTrimmed, latestTrimmed) ||
        (presets && findPresetLabel(presets, earliestTrimmed, latestTrimmed)) ||
        createRealTimeLabel(earliestTrimmed, latestTrimmed) ||
        createRelativeTimeLabel(earliestTrimmed, latestTrimmed) ||
        createDateTimeRangeLabel(earliestTrimmed, latestTrimmed, maxChars) ||
        i18n_1._('Custom time'));
}
exports.createRangeLabel = createRangeLabel;
function pluralize(singular, plural, numberOf) {
    if (numberOf === 0) {
        return null;
    }
    return numberOf === 1 ? singular : format_1.sprintf(plural, { numberOf: numberOf });
}
/**
 * Takes a duration in milliseconds and returns a string describing the duration in terms of
 * years, months, days, hours, minutes, seconds and milliseconds.
 * If a unit isn't needed it's omitted, e.g. durations less than a year won't include '0 years'.
 * @public
 * @param {number} ms - The duration in milliseconds.
 * @returns {String} A formatted duration string, for example `27 days 16 hours 36 minutes 59 seconds`.
 * Durations <= 0 return `null`.
 */
function formatDuration(ms) {
    if (ms <= 0) {
        return null;
    }
    var duration = moment_1.default.duration(ms);
    return [
        pluralize(i18n_1._('1 year'), i18n_1._('%(numberOf)d years'), duration.years()),
        pluralize(i18n_1._('1 month'), i18n_1._('%(numberOf)d months'), duration.months()),
        pluralize(i18n_1._('1 day'), i18n_1._('%(numberOf)d days'), duration.days()),
        pluralize(i18n_1._('1 hour'), i18n_1._('%(numberOf)d hours'), duration.hours()),
        pluralize(i18n_1._('1 minute'), i18n_1._('%(numberOf)d minutes'), duration.minutes()),
        pluralize(i18n_1._('1 second'), i18n_1._('%(numberOf)d seconds'), duration.seconds()),
        pluralize(i18n_1._('1 millisecond'), i18n_1._('%(numberOf)d milliseconds'), duration.milliseconds()),
    ]
        .filter(function (display) { return !!display; })
        .join(' ');
}
exports.formatDuration = formatDuration;
var parse = function (time, baseTime) {
    if (baseTime === void 0) { baseTime = exports.epochToMoment(); }
    var parsed = parseTimeString(time);
    if (time === '' || !parsed) {
        return { error: new Error('Invalid time string'), time: time };
    }
    if (!parsed.isFullyParsed) {
        return {
            error: new Error('The time string could not be parsed'),
            time: time,
        };
    }
    if (parsed.type === 'iso') {
        return { error: null, iso: time, time: time };
    }
    if (parsed.type === 'epoch') {
        return {
            error: null,
            iso: exports.epochToMoment(parseFloat(time)).format(),
            time: time,
        };
    }
    var date = moment_1.default(baseTime);
    parsed.modifiers.forEach(function (mod) {
        if (mod.amount && momentUnits[mod.unit]) {
            date.add(mod.amount, momentUnits[mod.unit]);
        }
        if (mod.snap) {
            if (momentSnaps[mod.snap]) {
                date.startOf(momentSnaps[mod.snap]);
            }
            else if (weekDaySnaps[mod.snap] != null) {
                date.startOf(momentSnaps.w).add(weekDaySnaps[mod.snap], 'd');
                if (exports.epochToMoment().isBefore(date)) {
                    // always snap to past time, so we need to shift back for 1 week.
                    date.add(-1, 'w');
                }
            }
        }
    });
    return { error: null, iso: date.format(), time: time, momentTime: date };
};
exports.parse = parse;
exports.defaultTimePreset = [
    { label: i18n_1._('Today'), earliest: '@d', latest: 'now' },
    { label: i18n_1._('Week to date'), earliest: '@w0', latest: 'now' },
    { label: i18n_1._('Business week to date'), earliest: '@w1', latest: 'now' },
    { label: i18n_1._('Month to date'), earliest: '@mon', latest: 'now' },
    { label: i18n_1._('Year to date'), earliest: '@y', latest: 'now' },
    { label: i18n_1._('Yesterday'), earliest: '-1d@d', latest: '@d' },
    { label: i18n_1._('Previous week'), earliest: '-7d@w0', latest: '@w0' },
    {
        label: i18n_1._('Previous business week'),
        earliest: '-6d@w1',
        latest: '-1d@w6',
    },
    { label: i18n_1._('Previous month'), earliest: '-1mon@mon', latest: '@mon' },
    { label: i18n_1._('Previous year'), earliest: '-1y@y', latest: '@y' },
    { label: i18n_1._('Last 15 minutes'), earliest: '-15m', latest: 'now' },
    { label: i18n_1._('Last 60 minutes'), earliest: '-60m@m', latest: 'now' },
    { label: i18n_1._('Last 4 hours'), earliest: '-4h@m', latest: 'now' },
    { label: i18n_1._('Last 24 hours'), earliest: '-24h@h', latest: 'now' },
    { label: i18n_1._('Last 7 days'), earliest: '-7d@h', latest: 'now' },
    { label: i18n_1._('Last 30 days'), earliest: '-30d@d', latest: 'now' },
    { label: i18n_1._('All time'), earliest: '0', latest: 'now' },
];
exports.defaultRealTimePreset = [
    { label: i18n_1._('30 second window'), earliest: 'rt-30s', latest: 'rt' },
    { label: i18n_1._('1 minute window'), earliest: 'rt-1m', latest: 'rt' },
    { label: i18n_1._('5 minute window'), earliest: 'rt-5m', latest: 'rt' },
    { label: i18n_1._('30 minute window'), earliest: 'rt-30m', latest: 'rt' },
    { label: i18n_1._('1 hour window'), earliest: 'rt-1h', latest: 'rt' },
    { label: i18n_1._('All time (real-time)'), earliest: 'rt', latest: 'rt' },
].concat(exports.defaultTimePreset);


/***/ }),
/* 26 */
/***/ (function(module, exports) {

module.exports = require("lodash/find");

/***/ }),
/* 27 */
/***/ (function(module, exports) {

module.exports = require("lodash/has");

/***/ }),
/* 28 */
/***/ (function(module, exports) {

module.exports = require("lodash/isFinite");

/***/ }),
/* 29 */
/***/ (function(module, exports) {

module.exports = require("@splunk/ui-utils/format");

/***/ }),
/* 30 */
/***/ (function(module, exports) {

module.exports = require("@splunk/splunk-utils/config");

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.mapTokensToURL = exports.mapURLToTokens = exports.safeReplaceTokensForObject = exports.hasTokensInObject = exports.hasTokens = exports.replaceTokensForObject = exports.replaceTokens = exports.extractTokensFromObject = exports.extractTokens = exports.DEFAULT_FILTERS = void 0;
var some_1 = __importDefault(__webpack_require__(32));
var isString_1 = __importDefault(__webpack_require__(2));
var escape_1 = __importDefault(__webpack_require__(33));
var mapValues_1 = __importDefault(__webpack_require__(34));
var isFunction_1 = __importDefault(__webpack_require__(35));
var get_1 = __importDefault(__webpack_require__(4));
var set_1 = __importDefault(__webpack_require__(36));
var map_1 = __importDefault(__webpack_require__(37));
var isPlainObject_1 = __importDefault(__webpack_require__(38));
var isArray_1 = __importDefault(__webpack_require__(39));
var isEmpty_1 = __importDefault(__webpack_require__(40));
var values_1 = __importDefault(__webpack_require__(41));
var flattenDeep_1 = __importDefault(__webpack_require__(42));
var uniqWith_1 = __importDefault(__webpack_require__(43));
var isEqual_1 = __importDefault(__webpack_require__(44));
var TOKEN_NAMESPACE_PREFIX_PATTERN = /(\w+:)?/.source;
// ex: token.name|suh               (old-style filter chain)
// ex: token.name|lower|capitalize  (new-style filter chain)
var TOKEN_NAME_CHARS_PATTERN = /([^$|:]+?)(\|[|\w]+)?/.source;
// ex: $ns:token.name|suh$
var TOKEN_PATTERN = /\$/.source +
    TOKEN_NAMESPACE_PREFIX_PATTERN +
    TOKEN_NAME_CHARS_PATTERN +
    /\$/.source;
var TOKEN_OR_DOLLAR_RE = new RegExp(TOKEN_PATTERN + "|" + /\$\$/.source, 'g');
var TokenRegExp = new RegExp(TOKEN_PATTERN);
var r = function (regexp) {
    var flags = '';
    if (regexp.global) {
        flags += 'g';
    }
    if (regexp.multiline) {
        flags += 'm';
    }
    if (regexp.ignoreCase) {
        flags += 'i';
    }
    return new RegExp(regexp.source, flags);
};
var VALUE_ESCAPERS = {
    search: function (v) {
        return JSON.stringify(String(v));
    },
    url: function (v) {
        return encodeURIComponent(String(v));
    },
    html: function (v) {
        return escape_1.default(String(v));
    },
    noEscape: function (v) {
        return v;
    },
};
exports.DEFAULT_FILTERS = {
    h: VALUE_ESCAPERS.html,
    u: VALUE_ESCAPERS.url,
    s: VALUE_ESCAPERS.search,
    n: VALUE_ESCAPERS.noEscape,
};
var MAX_RECURSION_LEVEL = 10;
var extractTokens = function (value) {
    /*
     * Looks for:
     *     (1a) $$ (literal $)
     *     (1b) $ns:token.name|suh$ (tokens)
     */
    var tokens = [];
    var rex = r(TOKEN_OR_DOLLAR_RE);
    var match = rex.exec(value);
    while (match) {
        var tokenNamespace = match[1];
        var tokenName = match[2];
        var filterChain = match[3];
        var namespace = tokenNamespace
            ? tokenNamespace.substring(0, tokenNamespace.length - 1)
            : 'default';
        var filters = filterChain ? filterChain.substring(1).split('|') : [];
        tokens.push({
            namespace: namespace,
            name: tokenName !== null && tokenName !== void 0 ? tokenName : '',
            filters: filters,
        });
        match = rex.exec(value);
    }
    return tokens;
};
exports.extractTokens = extractTokens;
/**
 * Extract tokens from an object
 * @param {*} value
 */
var extractTokensFromObject = function (value, recursionLevel) {
    if (recursionLevel === void 0) { recursionLevel = 0; }
    if (isEmpty_1.default(value)) {
        return [];
    }
    if (isString_1.default(value)) {
        return exports.extractTokens(value);
    }
    if (isPlainObject_1.default(value) && recursionLevel <= MAX_RECURSION_LEVEL) {
        return uniqWith_1.default(flattenDeep_1.default(map_1.default(values_1.default(value), function (v) {
            return exports.extractTokensFromObject(v, recursionLevel + 1);
        })), isEqual_1.default);
    }
    if (isArray_1.default(value) && recursionLevel <= MAX_RECURSION_LEVEL) {
        return uniqWith_1.default(flattenDeep_1.default(map_1.default(value, function (v) {
            return exports.extractTokensFromObject(v, recursionLevel + 1);
        })), isEqual_1.default);
    }
    return [];
};
exports.extractTokensFromObject = extractTokensFromObject;
/**
 * Replace a single string with tokens
 * @param {*} value
 * @param {*} tokens
 * @param {*} tokenFilters
 */
var replaceTokens = function (value, tokens, tokenFilters) {
    if (tokenFilters === void 0) { tokenFilters = exports.DEFAULT_FILTERS; }
    if (value == null) {
        return value;
    }
    return value.replace(r(TOKEN_OR_DOLLAR_RE), function (match, tokenNamespace, tokenName, filterChain) {
        var namespace = 'default';
        if (tokenNamespace) {
            namespace = tokenNamespace.substring(0, tokenNamespace.length - 1);
        }
        var v = match;
        var tokenValue = get_1.default(tokens, [namespace, tokenName], null);
        if (tokenValue != null) {
            v = tokenValue;
            var filters = filterChain
                ? filterChain.substring(1).split('|')
                : [];
            // apply token filters
            filters.forEach(function (f) {
                var key = f;
                if (isFunction_1.default(tokenFilters[key])) {
                    v = tokenFilters[key](v);
                }
            });
        }
        return v;
    });
};
exports.replaceTokens = replaceTokens;
/**
 * Replace tokens in an object's value
 * @param {*} value
 * @param {*} tokens
 * @param {*} tokenFilters
 */
var replaceTokensForObject = function (value, tokens, tokenFilters, recursionLevel) {
    if (tokenFilters === void 0) { tokenFilters = exports.DEFAULT_FILTERS; }
    if (recursionLevel === void 0) { recursionLevel = 0; }
    if (value == null) {
        return value;
    }
    if (isString_1.default(value)) {
        return exports.replaceTokens(value, tokens, tokenFilters);
    }
    if (isPlainObject_1.default(value) && recursionLevel <= MAX_RECURSION_LEVEL) {
        return mapValues_1.default(value, function (v) {
            return exports.replaceTokensForObject(v, tokens, tokenFilters, recursionLevel + 1);
        });
    }
    if (isArray_1.default(value) && recursionLevel <= MAX_RECURSION_LEVEL) {
        return map_1.default(value, function (v) {
            return exports.replaceTokensForObject(v, tokens, tokenFilters, recursionLevel + 1);
        });
    }
    return value;
};
exports.replaceTokensForObject = replaceTokensForObject;
/**
 * test if a string contains a token
 * @param {String} value
 */
var hasTokens = function (value) {
    return typeof value === 'string' && TokenRegExp.test(value);
};
exports.hasTokens = hasTokens;
/**
 * test if a object value contains a token
 * @param {Object} obj
 */
var hasTokensInObject = function (obj, recursionLevel) {
    if (recursionLevel === void 0) { recursionLevel = 0; }
    if (obj == null) {
        return false;
    }
    if (isString_1.default(obj)) {
        return exports.hasTokens(obj);
    }
    if ((isArray_1.default(obj) || isPlainObject_1.default(obj)) &&
        recursionLevel <= MAX_RECURSION_LEVEL) {
        return some_1.default(obj, function (v) {
            return exports.hasTokensInObject(v, recursionLevel + 1);
        });
    }
    return false;
};
exports.hasTokensInObject = hasTokensInObject;
/**
 * Calls replaceTokensForObject on an object but preserves the
 * properties that were passed in the denyList
 * @param {Object} obj object you want tokenized
 * @param {Object} tokens tokens to replace
 * @param {String[]} denyList array of strings that correspond to object properties you want preserved, used by lodash get/set. ex: ['property1', 'nested.property']
 */
var safeReplaceTokensForObject = function (obj, tokens, denyList) {
    var rawObject = {};
    denyList.forEach(function (key) {
        rawObject[key] = get_1.default(obj, key);
    });
    // Set the props back to their non-tokenized values
    var tokenizedObj = exports.replaceTokensForObject(obj, tokens);
    denyList.forEach(function (key) {
        if (rawObject[key]) {
            set_1.default(tokenizedObj, key, rawObject[key]);
        }
    });
    return tokenizedObj;
};
exports.safeReplaceTokensForObject = safeReplaceTokensForObject;
/**
 * Converts url search query into tokens in 'default' namespace
 * Current assumption is url tokens do not have a defined namespace, only default
 * @param {Object} obj
 * @param {String} obj.search url search query (window.location.search) from which token object is created
 * @returns {Object} tokens extracted from search query
 */
var mapURLToTokens = function (_a) {
    var search = _a.search;
    var urlSearchParams = new URLSearchParams(search);
    var tokens = {};
    urlSearchParams.forEach(function (value, key) {
        if (!key.startsWith('form.')) {
            return;
        }
        var tokenName = key.slice(5);
        if (tokens[tokenName]) {
            tokens[tokenName] += "," + value;
        }
        else {
            tokens[tokenName] = value;
        }
    });
    return { default: tokens };
};
exports.mapURLToTokens = mapURLToTokens;
/**
 * Maps tokens to url search params either by updating existing tokens or appending as new ones
 * @param {Object} obj
 * @param {String} obj.search url search query (window.location.search) that's to be augmented
 * @param {Object} obj.tokens derived input token values
 * @returns {String} updated search query
 */
var mapTokensToURL = function (_a) {
    var _b = _a.search, initSearch = _b === void 0 ? '?' : _b, tokens = _a.tokens;
    var initSearchParams = new URLSearchParams(initSearch);
    var updatedSearchParams = new URLSearchParams(initSearch);
    // remove the url tokens that do not exist in the derived token values and update the existing ones if they are not unset
    initSearchParams.forEach(function (value, key) {
        if (key.startsWith('form.')) {
            var tokenName = key.substring(5);
            if (tokenName in tokens.default) {
                var tokenValue = tokens.default[tokenName];
                updatedSearchParams.delete(key);
                if (tokenValue !== null && tokenValue !== undefined) {
                    updatedSearchParams.set(key, tokenValue);
                }
            }
            else {
                updatedSearchParams.delete(key);
            }
        }
    });
    // add derived tokens not present in the url search params
    Object.keys(tokens.default).forEach(function (key) {
        var formKey = "form." + key;
        var tokenValue = tokens.default[key];
        if (!updatedSearchParams.has(formKey) &&
            tokenValue !== null &&
            tokenValue !== undefined) {
            updatedSearchParams.set(formKey, tokenValue);
        }
    });
    return updatedSearchParams.toString();
};
exports.mapTokensToURL = mapTokensToURL;


/***/ }),
/* 32 */
/***/ (function(module, exports) {

module.exports = require("lodash/some");

/***/ }),
/* 33 */
/***/ (function(module, exports) {

module.exports = require("lodash/escape");

/***/ }),
/* 34 */
/***/ (function(module, exports) {

module.exports = require("lodash/mapValues");

/***/ }),
/* 35 */
/***/ (function(module, exports) {

module.exports = require("lodash/isFunction");

/***/ }),
/* 36 */
/***/ (function(module, exports) {

module.exports = require("lodash/set");

/***/ }),
/* 37 */
/***/ (function(module, exports) {

module.exports = require("lodash/map");

/***/ }),
/* 38 */
/***/ (function(module, exports) {

module.exports = require("lodash/isPlainObject");

/***/ }),
/* 39 */
/***/ (function(module, exports) {

module.exports = require("lodash/isArray");

/***/ }),
/* 40 */
/***/ (function(module, exports) {

module.exports = require("lodash/isEmpty");

/***/ }),
/* 41 */
/***/ (function(module, exports) {

module.exports = require("lodash/values");

/***/ }),
/* 42 */
/***/ (function(module, exports) {

module.exports = require("lodash/flattenDeep");

/***/ }),
/* 43 */
/***/ (function(module, exports) {

module.exports = require("lodash/uniqWith");

/***/ }),
/* 44 */
/***/ (function(module, exports) {

module.exports = require("lodash/isEqual");

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.getWindowLocationSearch = exports.isValidUrl = exports.isRelativeURL = exports.isAbsoluteURL = void 0;
/**
 * check if a url starts with http or https
 * @param {String} url
 */
var isAbsoluteURL = function (url) {
    return /^https?:\/\//.test(url);
};
exports.isAbsoluteURL = isAbsoluteURL;
/**
 * check if a url is a valid relative url
 * @param {String} url
 */
var isRelativeURL = function (url) {
    return !!(url === null || url === void 0 ? void 0 : url.length) && url[0] === '/' && !/^\/\//.test(url);
};
exports.isRelativeURL = isRelativeURL;
/**
 * check if a url is consider as valid
 * @param {String} url
 */
var isValidUrl = function (url) {
    return exports.isAbsoluteURL(url) || exports.isRelativeURL(url);
};
exports.isValidUrl = isValidUrl;
// A utility function to make it easier to mock in unit test
var getWindowLocationSearch = function () { return window.location.search; };
exports.getWindowLocationSearch = getWindowLocationSearch;


/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.formatRiskyCommandErrorMessage = exports.getRiskyCommands = exports.isRiskyCommandError = void 0;
var i18n_1 = __webpack_require__(0);
/**
 * Function to check if returned error message is a risky command error message
 * @param {String} message
 * @returns {Boolean}
 */
var isRiskyCommandError = function (message) {
    // TODO: fix this after SUI-2487 is resolved
    // For error cases, the search job currently only returns message.text instead of the whole message, use message.text to identify the risky command cases is not ideal, this should be fixed after SUI-2487 is resolved.
    // Note: the backend only returns the message.text in english
    return !!message && message.startsWith('Found potentially risky commands:');
};
exports.isRiskyCommandError = isRiskyCommandError;
/**
 * Risky commands error message returns in the following format: Found potentially risky commands: cmd1 cmd2 cmd3
 * Function to parse the error message and return the unique risky commands in array
 * @param {String} message
 * @returns {Array} commands
 */
var getRiskyCommands = function (message) {
    if (!exports.isRiskyCommandError(message)) {
        return [];
    }
    return message
        ? Array.from(new Set(message.split(':')[1].trim().split(' ')))
        : [];
};
exports.getRiskyCommands = getRiskyCommands;
/**
 * Formats the risky command error message to be more readable
 * @param {String} message
 * @returns {String} formattedErrorMessage
 */
var formatRiskyCommandErrorMessage = function (message) {
    return (i18n_1._('Found potentially risky command(s): ') +
        exports.getRiskyCommands(message).join(' '));
};
exports.formatRiskyCommandErrorMessage = formatRiskyCommandErrorMessage;


/***/ }),
/* 47 */,
/* 48 */,
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.deepMergeWithDefaults = exports.deepFreeze = exports.shallowEqual = exports.jsonEqual = exports.hashString = exports.deprecated = exports.console = void 0;
__exportStar(__webpack_require__(1), exports);
var console_1 = __webpack_require__(1);
Object.defineProperty(exports, "console", { enumerable: true, get: function () { return __importDefault(console_1).default; } });
__exportStar(__webpack_require__(6), exports);
var deprecated_1 = __webpack_require__(9);
Object.defineProperty(exports, "deprecated", { enumerable: true, get: function () { return __importDefault(deprecated_1).default; } });
__exportStar(__webpack_require__(11), exports);
var hashString_1 = __webpack_require__(12);
Object.defineProperty(exports, "hashString", { enumerable: true, get: function () { return __importDefault(hashString_1).default; } });
var jsonEqual_1 = __webpack_require__(14);
Object.defineProperty(exports, "jsonEqual", { enumerable: true, get: function () { return __importDefault(jsonEqual_1).default; } });
__exportStar(__webpack_require__(15), exports);
__exportStar(__webpack_require__(16), exports);
__exportStar(__webpack_require__(18), exports);
var shallowEqual_1 = __webpack_require__(19);
Object.defineProperty(exports, "shallowEqual", { enumerable: true, get: function () { return __importDefault(shallowEqual_1).default; } });
__exportStar(__webpack_require__(23), exports);
// export * from './test';
__exportStar(__webpack_require__(25), exports);
__exportStar(__webpack_require__(3), exports);
__exportStar(__webpack_require__(31), exports);
__exportStar(__webpack_require__(45), exports);
__exportStar(__webpack_require__(46), exports);
var deepFreeze_1 = __webpack_require__(7);
Object.defineProperty(exports, "deepFreeze", { enumerable: true, get: function () { return __importDefault(deepFreeze_1).default; } });
var deepMergeWithDefaults_1 = __webpack_require__(8);
Object.defineProperty(exports, "deepMergeWithDefaults", { enumerable: true, get: function () { return __importDefault(deepMergeWithDefaults_1).default; } });


/***/ })
/******/ ]);
//# sourceMappingURL=index.js.map
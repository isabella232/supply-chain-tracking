declare type PlainObject = Record<string, unknown>;
declare type FilterType = Record<'h' | 'u' | 's' | 'n', (v: string) => string>;
export declare const DEFAULT_FILTERS: FilterType;
/**
 * extract tokens from value
 * @param {*} value
 */
declare type Tokens = {
    namespace: string;
    name: string;
    filters: string[];
}[];
export declare const extractTokens: (value: string) => Tokens;
/**
 * Extract tokens from an object
 * @param {*} value
 */
export declare const extractTokensFromObject: (value: string | PlainObject | unknown, recursionLevel?: number) => Tokens;
/**
 * Replace a single string with tokens
 * @param {*} value
 * @param {*} tokens
 * @param {*} tokenFilters
 */
export declare const replaceTokens: (value: string | null, tokens: PlainObject, tokenFilters?: Record<"h" | "u" | "s" | "n", (v: string) => string>) => string | null;
/**
 * Replace tokens in an object's value
 * @param {*} value
 * @param {*} tokens
 * @param {*} tokenFilters
 */
export declare const replaceTokensForObject: (value: string | PlainObject | unknown, tokens: PlainObject, tokenFilters?: Record<"h" | "u" | "s" | "n", (v: string) => string>, recursionLevel?: number) => string | PlainObject | unknown;
/**
 * test if a string contains a token
 * @param {String} value
 */
export declare const hasTokens: (value: string) => boolean;
/**
 * test if a object value contains a token
 * @param {Object} obj
 */
export declare const hasTokensInObject: <T extends Record<string, unknown>>(obj: T | T[], recursionLevel?: number) => boolean;
/**
 * Calls replaceTokensForObject on an object but preserves the
 * properties that were passed in the denyList
 * @param {Object} obj object you want tokenized
 * @param {Object} tokens tokens to replace
 * @param {String[]} denyList array of strings that correspond to object properties you want preserved, used by lodash get/set. ex: ['property1', 'nested.property']
 */
export declare const safeReplaceTokensForObject: <T extends Record<string, unknown>>(obj: T, tokens: Record<string, Record<string, string>>, denyList: string[]) => T;
/**
 * Converts url search query into tokens in 'default' namespace
 * Current assumption is url tokens do not have a defined namespace, only default
 * @param {Object} obj
 * @param {String} obj.search url search query (window.location.search) from which token object is created
 * @returns {Object} tokens extracted from search query
 */
export declare const mapURLToTokens: ({ search, }: {
    search: string;
}) => {
    default: Record<string, string>;
};
/**
 * Maps tokens to url search params either by updating existing tokens or appending as new ones
 * @param {Object} obj
 * @param {String} obj.search url search query (window.location.search) that's to be augmented
 * @param {Object} obj.tokens derived input token values
 * @returns {String} updated search query
 */
export declare const mapTokensToURL: ({ search: initSearch, tokens, }: {
    tokens: Record<string, Record<string, string | null>>;
    search?: string | undefined;
}) => string;
export {};
//# sourceMappingURL=token.d.ts.map
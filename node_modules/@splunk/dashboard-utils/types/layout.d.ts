import type { ConnectedLineItem, ConnectedPosition, AbsoluteBlockItem, AbsoluteLayoutStructure, Coordinate, AbsolutePosition, ConnectedLinePosition, AbsoluteLayoutItem, VizContract, VizConfig } from '@splunk/dashboard-types';
export declare const DEFAULT_SCALE_FACTOR = 3;
export declare const VIZ_DEFAULT_HEIGHT_PX = 400;
export declare const DEFAULT_CANVAS_WIDTH = 1200;
export declare const DEFAULT_CANVAS_HEIGHT = 900;
/**
 * Given two layout items, check if they collide.
 * @method collides
 * @param {Object} layoutItemA
 * @param {Object} layoutItemB
 * @returns {Boolean} true or false
 */
export declare const collides: (layoutItemA: AbsoluteBlockItem, layoutItemB: AbsoluteBlockItem) => boolean;
/**
 * compute end position based on port
 * @method computeLocationPort
 * @param {Object} linePosition to or from
 * @param {Array} layout
 * @returns {Object} converted end position
 */
export declare const computeLocationPort: (endPosition: ConnectedPosition, layout: AbsoluteLayoutStructure) => Coordinate | null;
export declare const toCoordinate: (itemPosition: Partial<Coordinate> & Partial<ConnectedPosition>, layout: AbsoluteLayoutStructure) => Coordinate;
/**
 * convert line position to block position
 * @method convertLineToBlockItem
 * @param {Object} itemPosition
 * @param {Array} layout
 * @param {Number} status
 * @returns {Object} converted block position
 */
export declare const convertLineToBlockItem: (itemPosition: ConnectedLinePosition, layout: AbsoluteLayoutItem[]) => AbsolutePosition;
/**
 * convert layout item to block item
 * @method convertToBlockItem
 * @param {Object} item
 * @returns {Object} converted block item
 */
export declare const convertToBlockItem: (item: AbsoluteLayoutItem, layout: AbsoluteLayoutStructure) => AbsoluteBlockItem;
/**
 * convert layout items to block items
 * @method convertToBlockItems
 * @param {Array} layout
 * @returns {Array} converted block items
 */
export declare const convertToBlockItems: (layout: AbsoluteLayoutStructure) => AbsoluteBlockItem[];
/**
 * Get layout items sorted from top left to right and down.
 * @method sortLayoutItems
 * @param {Array} layout
 * @returns {Array} sorted layout
 */
export declare const sortLayoutItems: (layout: AbsoluteBlockItem[]) => AbsoluteBlockItem[];
/**
 * Returns the first item this layout collides with.
 * @method getFirstCollision
 * @param {Array} layout
 * @param {Object} layoutItem
 * @returns {Object} first collision or undefined
 */
export declare const getFirstCollision: (layout: AbsoluteBlockItem[], layoutItem: AbsoluteBlockItem) => AbsoluteBlockItem | undefined;
interface GetPositionByTypeProps {
    col: number;
    row: number;
    width: number;
    height: number;
    type: 'line' | 'block' | string;
}
/**
 * get position based on type
 * @method getPositionByType
 * @param {Object} config
 * @param {Number} config.col
 * @param {Number} config.row
 * @param {Number} config.width
 * @param {Number} config.height
 * @param {String} config.type
 * @returns {Object} new position
 */
export declare const getPositionByType: ({ col, row, width, height, type, }: GetPositionByTypeProps) => AbsolutePosition | ConnectedLinePosition;
interface GetDefaultPositionProps {
    width: number;
    height: number;
    canvasHeight: number;
    canvasWidth: number;
    type: 'block' | 'line';
}
/**
 * get the default position based on type (Note: does not support legacy grid)
 * @method getDefaultPosition
 * @param {Object} config
 * @param {Number} config.canvasWidth
 * @param {Number} config.canvasHeight
 * @param {Number} config.width
 * @param {Number} config.height
 * @param {String} config.type
 * @returns {Object} default position
 */
export declare const getDefaultPosition: <T extends GetDefaultPositionProps>({ canvasWidth, canvasHeight, width, height, type, }: T) => AbsolutePosition | ConnectedLinePosition;
interface ComputeNextAvailablePositionProps {
    width: number;
    height: number;
    canvasHeight: number;
    canvasWidth: number;
    items: AbsoluteLayoutStructure;
    type: 'block' | 'line';
}
/**
 * compute next available position for new added item (Note: does not support legacy grid)
 * @method computeNextAvailablePosition
 * @param {Object} config
 * @param {Number} config.width
 * @param {Number} config.height
 * @param {Number} config.canvasHeight
 * @param {Number} config.canvasWidth
 * @param {Number} config.items
 * @param {Number} config.type absolute/line
 * @returns {Object} position
 */
export declare const computeNextAvailablePosition: <T extends ComputeNextAvailablePositionProps>({ width, height, canvasHeight, canvasWidth, items, type, }: T) => AbsolutePosition | ConnectedLinePosition;
interface ComputeNewBlockItemPositionProps {
    canvasWidth: number;
    canvasHeight: number;
    vizContract?: VizContract;
    config?: VizConfig;
    items: AbsoluteLayoutStructure;
}
/**
 * Given the current absolute layout items, return position that new visualization should locate.
 * @method computeNewBlockItemPosition
 * @param {Object} options
 * @param {Number} options.canvasWidth
 * @param {Number} options.canvasHeight
 * @param {Object} options.vizContract
 * @param {Array} options.items
 * @param {Object} options.config
 * @returns {Object} nextPosition
 */
export declare const computeNewBlockItemPosition: ({ canvasWidth, canvasHeight, vizContract, config, items, }: ComputeNewBlockItemPositionProps) => AbsolutePosition;
interface ComputeNewLinePositionProps {
    canvasWidth: number;
    canvasHeight: number;
    items: AbsoluteLayoutStructure;
}
/**
 * Given the current absolute layout items, return point position
 * @method computeNewLinePosition
 * @params {Object} config
 * @param {Number} config.canvasWidth
 * @param {Number} config.canvasHeight
 * @param {Array} config.items
 * @returns {*} position
 */
export declare const computeNewLinePosition: ({ canvasWidth, canvasHeight, items, }: ComputeNewLinePositionProps) => ConnectedLinePosition;
/**
 * compute the max height based on current layout items and minimum height
 * @method computeMaxHeight
 * @param {Array} layoutItems
 * @param {Number} minHeight
 * @returns {Number} max height
 */
export declare const computeMaxHeight: (layoutItems: AbsoluteBlockItem[], minHeight?: number) => number;
interface ComputeNewAbsoluteStructureItemProps {
    itemId: string;
    type?: 'block' | 'line';
    canvasWidth: number;
    canvasHeight: number;
    vizContract?: VizContract;
    config?: VizConfig;
    layoutItems: AbsoluteLayoutStructure;
}
/**
 * Computes a new layout item position for the absolute layout
 * @param {Object} options
 * @param {String} options.itemId The identifier for a visualization
 * @param {String} [options.type="block"] The structure type for a viz: must be "line" or "block"
 * @param {Number} options.canvasWidth The width of the canvas
 * @param {Number} options.canvasHeight The height of the canvas
 * @param {Object} options.vizContract Metadata to define the default height/width of a new viz
 * @param {Object} options.config
 * @param {Array} layoutItems List of items in the layout structure
 * @returns {LayoutItem}
 */
export declare const computeNewAbsoluteStructureItem: <T extends ComputeNewAbsoluteStructureItemProps>({ itemId, type, canvasWidth, canvasHeight, vizContract, layoutItems, config, }: T) => AbsoluteBlockItem | ConnectedLineItem;
interface ComputeNewGridStructureItemProps {
    itemId: string;
    layoutItems: AbsoluteBlockItem[];
    canvasWidth: number;
}
/**
 * Computes a new layout item position for the grid layout
 * @param {Object} config
 * @param {String} config.itemId The identifier for a visualization
 * @param {Number} config.canvasWidth The width of the canvas
 * @param {Array} layoutItems List of items in the layout structure
 * @returns {LayoutItem}
 */
export declare const computeNewGridStructureItem: ({ itemId, layoutItems, canvasWidth, }: ComputeNewGridStructureItemProps) => AbsoluteBlockItem;
/**
 * Determine if scrollbar is required to be overlaid (non obtrusive)
 * @returns {Boolean}
 */
export declare const useScrollbarOverlay: () => boolean;
export {};
//# sourceMappingURL=layout.d.ts.map
/*!
 * Copyright © 2020 Splunk Inc.
 * SPLUNK CONFIDENTIAL – Use or disclosure of this material in whole or
 * in part without a valid written license from Splunk Inc. is PROHIBITED.
 */
module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 5);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

module.exports = require("lodash/cloneDeep");

/***/ }),
/* 1 */
/***/ (function(module, exports) {

module.exports = require("lodash/each");

/***/ }),
/* 2 */
/***/ (function(module, exports) {

module.exports = require("lodash/isEmpty");

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _a, _b, _c, _d, _e, _f, _g, _h;
Object.defineProperty(exports, "__esModule", { value: true });
exports.createSchemaBasedOnPresets = exports.createComponentDict = exports.createSchemaBasedOnDicts = exports.combineSchema = exports.createMonacoSchema = void 0;
var each_1 = __importDefault(__webpack_require__(1));
var isEmpty_1 = __importDefault(__webpack_require__(2));
var cloneDeep_1 = __importDefault(__webpack_require__(0));
var set_1 = __importDefault(__webpack_require__(4));
var keyPattern = '^[a-zA-Z0-9_-]*$';
var eventHandlerSchema = {
    type: 'array',
    items: {
        type: 'object',
        properties: {
            type: {
                type: 'string',
            },
            options: {
                type: 'object',
                nullable: true,
                properties: {
                    url: { type: 'string', nullable: true },
                    newTab: { type: 'boolean', nullable: true },
                    key: { type: 'string', nullable: true },
                    value: { type: 'string', nullable: true },
                    tokens: {
                        type: 'array',
                        nullable: true,
                        items: {
                            type: 'object',
                            properties: {
                                token: { type: 'string' },
                                key: {
                                    type: 'string',
                                    nullable: true,
                                    description: 'Fetches the data from the event using this key.',
                                },
                                value: {
                                    type: 'string',
                                    nullable: true,
                                    description: 'Specify a static value.',
                                },
                            },
                            required: ['token'],
                            oneOf: [
                                { required: ['key'] },
                                { required: ['value'] },
                            ],
                        },
                    },
                    tokenNamespace: { type: 'string', nullable: true },
                    events: {
                        type: 'array',
                        items: {
                            type: 'string',
                        },
                        nullable: true,
                    },
                },
            },
        },
        required: ['type'],
        additionalProperties: false,
    },
    nullable: true,
};
var dataSourcesSchema = {
    type: 'object',
    nullable: true,
    required: [],
    additionalProperties: false,
    patternProperties: (_a = {},
        _a[keyPattern] = {
            type: 'object',
            properties: {
                type: {
                    type: 'string',
                },
                options: {
                    type: 'object',
                    nullable: true,
                },
                // datasource name
                name: {
                    type: 'string',
                    nullable: true,
                },
                // some metadata for this data source
                meta: {
                    type: 'object',
                },
                extend: {
                    type: 'string',
                },
                eventHandlers: eventHandlerSchema,
            },
            required: ['type'],
            additionalProperties: false,
        },
        _a),
};
var visualizationsSchema = {
    type: 'object',
    required: [],
    nullable: true,
    additionalProperties: false,
    patternProperties: (_b = {},
        _b[keyPattern] = {
            type: 'object',
            properties: {
                context: { type: 'object', nullable: true },
                type: {
                    type: 'string',
                },
                options: {
                    type: 'object',
                    nullable: true,
                },
                encoding: {
                    type: 'object',
                    nullable: true,
                },
                dataSources: {
                    type: 'object',
                    patternProperties: (_c = {},
                        _c[keyPattern] = { type: 'string' },
                        _c),
                    required: [],
                    nullable: true,
                },
                eventHandlers: eventHandlerSchema,
                title: {
                    type: 'string',
                    nullable: true,
                },
                description: {
                    type: 'string',
                    nullable: true,
                },
                showProgressBar: {
                    type: 'boolean',
                    nullable: true,
                },
                showLastUpdated: {
                    type: 'boolean',
                    nullable: true,
                },
            },
            required: ['type'],
            additionalProperties: false,
        },
        _b),
};
var inputsSchema = {
    type: 'object',
    nullable: true,
    required: [],
    additionalProperties: false,
    patternProperties: (_d = {},
        _d[keyPattern] = {
            type: 'object',
            properties: {
                context: { type: 'object', nullable: true },
                type: {
                    type: 'string',
                },
                options: {
                    type: 'object',
                    nullable: true,
                },
                encoding: {
                    type: 'object',
                    nullable: true,
                },
                dataSources: {
                    type: 'object',
                    nullable: true,
                    required: [],
                    patternProperties: (_e = {},
                        _e[keyPattern] = { type: 'string' },
                        _e),
                },
                title: {
                    type: 'string',
                    nullable: true,
                },
                eventHandlers: eventHandlerSchema,
            },
            required: ['type'],
            additionalProperties: false,
        },
        _d),
};
var layoutSchema = {
    type: 'object',
    nullable: true,
    required: ['type'],
    additionalProperties: false,
    properties: {
        type: {
            type: 'string',
        },
        options: {
            type: 'object',
            nullable: true,
        },
        globalInputs: {
            type: 'array',
            items: {
                type: 'string',
            },
            nullable: true,
        },
        structure: {
            type: 'array',
            items: {
                type: 'object',
                nullable: true,
                required: [],
            },
            nullable: true,
        },
    },
};
var defaultsSchema = {
    type: 'object',
    nullable: true,
    properties: {
        inputs: {
            type: 'object',
            nullable: true,
            required: [],
        },
        visualizations: {
            type: 'object',
            nullable: true,
            required: [],
            additionalProperties: false,
        },
        dataSources: {
            type: 'object',
            nullable: true,
            required: [],
            properties: {
                global: {
                    type: 'object',
                    nullable: true,
                },
            },
            patternProperties: (_f = {},
                _f[keyPattern] = {
                    type: 'object',
                    nullable: true,
                },
                _f),
        },
        tokens: {
            type: 'object',
            nullable: true,
            required: [],
            patternProperties: (_g = {},
                // namespaces
                _g[keyPattern] = {
                    type: 'object',
                    required: [],
                    patternProperties: (_h = {},
                        // tokens
                        _h[keyPattern] = {
                            type: 'object',
                            required: ['value'],
                            properties: {
                                value: {
                                    type: 'string',
                                },
                            },
                        },
                        _h),
                },
                _g),
        },
    },
};
// note, this alone doesn't provide precise schema validation, it is best to use the createSchemaBasedOnPresets().
var defaultDashboardSchema = {
    $id: 'http://www.splunk.com/dashboard.schema.json',
    title: 'Dashboard Definition',
    description: 'Dashboard Definition',
    type: 'object',
    properties: {
        version: {
            type: 'string',
            nullable: true,
        },
        title: {
            type: 'string',
            nullable: true,
        },
        description: {
            type: 'string',
            nullable: true,
        },
        dataSources: dataSourcesSchema,
        visualizations: visualizationsSchema,
        inputs: inputsSchema,
        defaults: defaultsSchema,
        layout: layoutSchema,
    },
    required: [],
};
/**
 * create new schema
 * @method createMonacoSchema
 * @param {Object} config
 * @param {Object} config.newSchema
 * @param {String} config.modelUri
 * @returns {Object} monaco schema
 */
var createMonacoSchema = function (_a) {
    var _b = _a.newSchema, newSchema = _b === void 0 ? {} : _b, modelUri = _a.modelUri;
    var finalSchema = isEmpty_1.default(newSchema) ? defaultDashboardSchema : newSchema;
    return [
        {
            // made up fake uri
            uri: 'http://splunk/json-schema.json',
            fileMatch: [modelUri],
            schema: finalSchema,
        },
    ];
};
exports.createMonacoSchema = createMonacoSchema;
/**
 * combine schemas for the same type
 * @method combineSchema
 * @param {Object} componentDict {type : optionSchema}
 * @param {Boolean} [additionalProperties=true] allow extra properties in options object
 * @returns {array} allOf statement of if else statements
 */
var combineSchema = function (componentDict, additionalProperties) {
    if (additionalProperties === void 0) { additionalProperties = true; }
    var allOfStatement = [];
    each_1.default(componentDict, function (optionSchema, type) {
        if (!isEmpty_1.default(optionSchema)) {
            var statement = {
                if: {
                    properties: { type: { const: type } },
                },
                then: {
                    properties: {
                        // if the schema is extended beyond just a list of properties, use it instead
                        options: (optionSchema === null || optionSchema === void 0 ? void 0 : optionSchema.extend) ? optionSchema.extend
                            : {
                                type: 'object',
                                properties: optionSchema,
                                // TODO: Revisit additionalProperties to disallow unknown keys as a warning
                                additionalProperties: additionalProperties,
                            },
                    },
                },
            };
            allOfStatement.push(statement);
        }
    });
    return allOfStatement;
};
exports.combineSchema = combineSchema;
/**
 * @method createSchemaBasedOnDicts
 * @param {Object} config
 * @param {Object} layoutDict {type : optionSchema}
 * @param {Object} dataSourceDict {type : optionSchema}
 * @param {Object} visualizationDict {type : optionSchema}
 * @param {Object} inputDict {type : optionSchema}
 * @returns {Object} schema
 */
var createSchemaBasedOnDicts = function (_a) {
    var _b = _a.layoutDict, layoutDict = _b === void 0 ? {} : _b, _c = _a.dataSourceDict, dataSourceDict = _c === void 0 ? {} : _c, _d = _a.visualizationDict, visualizationDict = _d === void 0 ? {} : _d, _e = _a.inputDict, inputDict = _e === void 0 ? {} : _e;
    var layoutAllOfStatement = exports.combineSchema(layoutDict);
    var dataSourceAllOfStatement = exports.combineSchema(dataSourceDict);
    var visualizationAllOfStatement = exports.combineSchema(visualizationDict);
    var inputAllOfStatement = exports.combineSchema(inputDict, false);
    var newSchema = cloneDeep_1.default(defaultDashboardSchema);
    if (!isEmpty_1.default(layoutDict)) {
        set_1.default(newSchema, 'properties.layout.properties.type.enum', Object.keys(layoutDict));
    }
    if (!isEmpty_1.default(layoutAllOfStatement)) {
        set_1.default(newSchema, 'properties.layout.allOf', layoutAllOfStatement);
    }
    if (!isEmpty_1.default(inputDict)) {
        set_1.default(newSchema, [
            'properties',
            'inputs',
            'patternProperties',
            keyPattern,
            'properties',
            'type',
            'enum',
        ], Object.keys(inputDict));
    }
    if (!isEmpty_1.default(inputAllOfStatement)) {
        set_1.default(newSchema, ['properties', 'inputs', 'patternProperties', keyPattern, 'allOf'], inputAllOfStatement);
    }
    if (!isEmpty_1.default(visualizationDict)) {
        set_1.default(newSchema, [
            'properties',
            'visualizations',
            'patternProperties',
            keyPattern,
            'properties',
            'type',
            'enum',
        ], Object.keys(visualizationDict));
        // caveat1: preset is provided at runtime, thus there's no way to let it perfectly match DashboardJSON at compile time. So we put a vague schema into /defaults/visualizations in the defaultDashboardSchema, and modify it at runtime based on the preset.
        // caveat2: `global` cannot be specified at compile time because of AJV limitation https://github.com/ajv-validator/ajv/issues/1588
        // caveat3: use lodash get/set to workaround the typechecking
        set_1.default(newSchema, [
            'properties',
            'defaults',
            'properties',
            'visualizations',
            'properties',
            'global',
        ], {
            type: 'object',
            nullable: true,
            additionalProperties: false,
            properties: {
                context: {
                    type: 'object',
                    nullable: true,
                },
                showLastUpdated: {
                    type: 'boolean',
                    default: false,
                    nullable: true,
                },
                showProgressBar: {
                    type: 'boolean',
                    default: false,
                    nullable: true,
                },
            },
        });
        Object.entries(visualizationDict).forEach(function (_a) {
            var _b = __read(_a, 2), key = _b[0], optionsSchema = _b[1];
            return set_1.default(newSchema, [
                'properties',
                'defaults',
                'properties',
                'visualizations',
                'properties',
                key,
            ], {
                type: 'object',
                nullable: true,
                additionalProperties: false,
                properties: {
                    context: {
                        type: 'object',
                        nullable: true,
                    },
                    showLastUpdated: {
                        type: 'boolean',
                        default: false,
                        nullable: true,
                    },
                    showProgressBar: {
                        type: 'boolean',
                        default: false,
                        nullable: true,
                    },
                    options: {
                        type: 'object',
                        properties: optionsSchema,
                        nullable: true,
                        additionalProperties: false,
                    },
                },
            });
        });
    }
    if (!isEmpty_1.default(visualizationAllOfStatement)) {
        set_1.default(newSchema, [
            'properties',
            'visualizations',
            'patternProperties',
            keyPattern,
            'allOf',
        ], visualizationAllOfStatement);
    }
    if (!isEmpty_1.default(dataSourceDict)) {
        set_1.default(newSchema, [
            'properties',
            'dataSources',
            'patternProperties',
            keyPattern,
            'properties',
            'type',
            'enum',
        ], Object.keys(dataSourceDict));
    }
    if (!isEmpty_1.default(dataSourceAllOfStatement)) {
        set_1.default(newSchema, [
            'properties',
            'dataSources',
            'patternProperties',
            keyPattern,
            'allOf',
        ], dataSourceAllOfStatement);
    }
    return newSchema;
};
exports.createSchemaBasedOnDicts = createSchemaBasedOnDicts;
/**
 * create component dictionary based on preset
 * @method createComponentDict
 * @param {Object} preset
 * @returns {Object} component object {type : optionSchema}
 */
var createComponentDict = function (preset) {
    var componentDict = {};
    each_1.default(preset, function (component, type) {
        var _a;
        componentDict[type] =
            ((_a = component === null || component === void 0 ? void 0 : component.config) === null || _a === void 0 ? void 0 : _a.optionsSchema) || (component === null || component === void 0 ? void 0 : component.schema);
    });
    return componentDict;
};
exports.createComponentDict = createComponentDict;
/**
 * create schema based on presets
 * @method createSchemaBasedOnPresets
 * @param {Object} presets combined with all custom presets
 * @returns {Object} schema
 */
var createSchemaBasedOnPresets = function (presets) {
    var layoutDict = exports.createComponentDict(presets.layouts);
    var dataSourceDict = exports.createComponentDict(presets.dataSources);
    var visualizationDict = exports.createComponentDict(presets.visualizations);
    var inputDict = exports.createComponentDict(presets.inputs);
    return exports.createSchemaBasedOnDicts({
        layoutDict: layoutDict,
        dataSourceDict: dataSourceDict,
        visualizationDict: visualizationDict,
        inputDict: inputDict,
    });
};
exports.createSchemaBasedOnPresets = createSchemaBasedOnPresets;
exports.default = defaultDashboardSchema;


/***/ }),
/* 4 */
/***/ (function(module, exports) {

module.exports = require("lodash/set");

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getDefaultsForVisualizationType = exports.getGlobalDefaultsForVisualizations = exports.hasDuplicateId = exports.generateId = exports.getDefaultOptionsForDataSourceType = exports.DEFAULT_DEFINITION = exports.GLOBAL_TRP_TOKEN_NAME = exports.normalizeLayoutStructure = void 0;
var cloneDeep_1 = __importDefault(__webpack_require__(0));
var each_1 = __importDefault(__webpack_require__(1));
var find_1 = __importDefault(__webpack_require__(6));
var omit_1 = __importDefault(__webpack_require__(7));
var get_1 = __importDefault(__webpack_require__(8));
var isString_1 = __importDefault(__webpack_require__(9));
var isEmpty_1 = __importDefault(__webpack_require__(2));
var isPlainObject_1 = __importDefault(__webpack_require__(10));
var isEqual_1 = __importDefault(__webpack_require__(11));
var defaultsDeep_1 = __importDefault(__webpack_require__(12));
var memoize_1 = __importDefault(__webpack_require__(13));
var keyBy_1 = __importDefault(__webpack_require__(14));
var pickBy_1 = __importDefault(__webpack_require__(15));
var uniqueId_1 = __webpack_require__(16);
var layout_1 = __webpack_require__(17);
var search_1 = __webpack_require__(18);
var dashboard_utils_1 = __webpack_require__(19);
var i18n_1 = __webpack_require__(20);
var ajv_1 = __importDefault(__webpack_require__(21));
var fast_json_patch_1 = __webpack_require__(22);
var DashboardSchema_1 = __importDefault(__webpack_require__(3));
var generateUniqueId = function (prefix) { return prefix + "_" + uniqueId_1.uniqueId(); };
var ajv = new ajv_1.default({
    allErrors: true,
    // This is to make sure the definition `defaults` can have both `properties` and `patternProperties`
    allowMatchingProperties: true,
    // todo: lots of viz schemas violate this rule, will fix them later
    allowUnionTypes: true,
});
// We hash the string representation of the the schema to use as the memoize resolver.
var memoizedCompile = memoize_1.default(function (newSchema) {
    // Prevent warnings when adding a new schema with the same id
    if (ajv.getSchema(newSchema.$id)) {
        ajv.removeSchema(newSchema.$id);
    }
    return ajv.compile(newSchema);
}, function (newSchema) { return dashboard_utils_1.hashString(JSON.stringify(newSchema)); });
/**
 * A utility module to convert layout structure from array to object in dashboard definition.
 * This module is needed when generating meaningful json patches.
 * @private
 * @param {Object} def dashboard definition json object
 */
var normalizeLayoutStructure = function (def) {
    var layout = get_1.default(def, 'layout', {});
    var structure = get_1.default(def, 'layout.structure', []);
    // in absolute layout the layer is decided by the order in the array, so we need a temporary solution to reflect this info.
    var structureWithExplicitLayers = structure.map(function (viz, index) { return (__assign(__assign({}, viz), { layer: index })); });
    return __assign(__assign({}, def), { layout: __assign(__assign({}, layout), { structure: keyBy_1.default(structureWithExplicitLayers, 'item') }) });
};
exports.normalizeLayoutStructure = normalizeLayoutStructure;
exports.GLOBAL_TRP_TOKEN_NAME = 'global_time';
exports.DEFAULT_DEFINITION = {
    visualizations: {},
    dataSources: {},
    defaults: {
        dataSources: {
            global: {
                options: {
                    queryParameters: {
                        latest: "$" + exports.GLOBAL_TRP_TOKEN_NAME + ".latest$",
                        earliest: "$" + exports.GLOBAL_TRP_TOKEN_NAME + ".earliest$",
                    },
                },
            },
        },
    },
    inputs: {
        input_global_trp: {
            type: 'input.timerange',
            options: {
                token: "" + exports.GLOBAL_TRP_TOKEN_NAME,
                defaultValue: '-24h@h,now',
            },
            title: i18n_1._('Global Time Range'),
        },
    },
    layout: {
        type: 'absolute',
        options: {},
        structure: [],
        globalInputs: ['input_global_trp'],
    },
};
/**
 * Fetch a flattened set of global defaults for the given type
 * @param {Object} defaults The object containing default configurations
 * @param {String} type The type of dataSource to search for specific configurations
 * @returns {Object} Result of flattening global and specific configurations
 * @private
 */
var getDefaultOptionsForDataSourceType = function (defaults, type) {
    if (!defaults || !type) {
        return {};
    }
    // Get the options that apply to all datasources
    var globalOptions = get_1.default(defaults, 'dataSources.global.options', {});
    // Get type specific options
    var typeSpecificOptions = get_1.default(defaults, ['dataSources', type, 'options'], {});
    // merge global options onto specific options
    var flattenedOptions = defaultsDeep_1.default(typeSpecificOptions, globalOptions);
    // Don't include "query"
    return omit_1.default(flattenedOptions, ['query']);
};
exports.getDefaultOptionsForDataSourceType = getDefaultOptionsForDataSourceType;
/**
 * Generate a unique id given a prefix and a search function to verify uniqueness
 * @param {String} prefix The prefix of the id (viz, ds, input, etc)
 * @param {Function} searchFn A function that can search the definition to detect if an id is used, default return first id
 * @returns {String} A "guaranteed" unique id
 */
var generateId = function (prefix, searchFn) {
    if (searchFn === void 0) { searchFn = function () { return false; }; }
    var nextId = generateUniqueId(prefix);
    while (searchFn(nextId)) {
        nextId = generateUniqueId(prefix);
    }
    return nextId;
};
exports.generateId = generateId;
/**
 * Search for a key or string that matches the provided key
 * @param {Object} definition The haystack to search for an id in
 * @param {String} newId The key to search for
 * @returns {Boolean}
 */
var hasDuplicateId = function (definition, newId) {
    // Wrap in quotes to look for keys and not substrings
    return JSON.stringify(definition).indexOf("\"" + newId + "\"") !== -1;
};
exports.hasDuplicateId = hasDuplicateId;
/**
 * Obtain the global defaults for all visualizations
 * @param {DefinitionJSON.defaults} defaults The defaults configuration for the dashboard
 * @returns {Object} Shared context and flags
 */
var getGlobalDefaultsForVisualizations = function (defaults) {
    var _a, _b;
    var _c = (_b = (_a = defaults === null || defaults === void 0 ? void 0 : defaults.visualizations) === null || _a === void 0 ? void 0 : _a.global) !== null && _b !== void 0 ? _b : {}, _d = _c.showProgressBar, showProgressBar = _d === void 0 ? false : _d, _e = _c.showLastUpdated, showLastUpdated = _e === void 0 ? false : _e, _f = _c.context, context = _f === void 0 ? {} : _f;
    // Intentionally not allowing a shared options object for visualizations
    return {
        showProgressBar: showProgressBar,
        showLastUpdated: showLastUpdated,
        context: context,
    };
};
exports.getGlobalDefaultsForVisualizations = getGlobalDefaultsForVisualizations;
/**
 * Fetch the defaults for the given viz type. Note: this does not flatten with global defaults for all viz
 * @param {DashboardJSON.defaults} defaults Default configuration
 * @param {String} type The type of visualization
 * @return {Object} Shared context, options, and flags
 */
var getDefaultsForVisualizationType = function (defaults, type) {
    var _a, _b;
    var _c = (_b = (_a = defaults === null || defaults === void 0 ? void 0 : defaults.visualizations) === null || _a === void 0 ? void 0 : _a[type]) !== null && _b !== void 0 ? _b : {}, showProgressBar = _c.showProgressBar, showLastUpdated = _c.showLastUpdated, _d = _c.context, context = _d === void 0 ? {} : _d, _e = _c.options, options = _e === void 0 ? {} : _e;
    var result = { options: options, context: context };
    // Do not add these flags to the viz defaults unless they are defined,
    // we don't want to override the global defaults unless explicitly defined here
    if (typeof showProgressBar === 'boolean') {
        result.showProgressBar = showProgressBar;
    }
    if (typeof showLastUpdated === 'boolean') {
        result.showLastUpdated = showLastUpdated;
    }
    return result;
};
exports.getDefaultsForVisualizationType = getDefaultsForVisualizationType;
/**
 * A dashboard definition helper class
 * @class DashboardDefinition
 */
var DashboardDefinition = /** @class */ (function () {
    /**
     * Creates a new DashboardDefinition based on input def
     * @param {Object} [def] A dashboard definition
     * @returns {DashboardDefinition}
     * @constructor
     */
    function DashboardDefinition(def) {
        if (def === void 0) { def = {}; }
        this.definition = def;
        this.setSchema(DashboardSchema_1.default);
    }
    /**
     * Creates a new DashboardDefinition based on input def
     * @method fromJSON
     * @param {Object} [def] A dashboard definition
     * @returns {DashboardDefinition}
     * @static
     */
    DashboardDefinition.fromJSON = function (def) {
        if (def === void 0) { def = {}; }
        return new DashboardDefinition(def);
    };
    /**
     * @param {Object} dataSources Datasources from dashboard definition
     * @param {Object} defaults Defaults from dashboard definition
     * @return {Object} Flattened data sources with the default options.
     */
    DashboardDefinition.flattenDataSources = function (dataSources, defaults) {
        var flattenedGlobalOptions = {};
        var dataSourcesWithDefaults = {};
        // Loop through all datasources
        each_1.default(dataSources, function (dataSourceDef, dsId) {
            var dataSourceType = get_1.default(dataSourceDef, 'type');
            var optionsCopy = cloneDeep_1.default(get_1.default(dataSourceDef, 'options'));
            // memoize calculation of the defaults for a given type
            if (!flattenedGlobalOptions[dataSourceType]) {
                flattenedGlobalOptions[dataSourceType] = exports.getDefaultOptionsForDataSourceType(defaults, dataSourceType);
            }
            var defaultOptions = flattenedGlobalOptions[dataSourceType];
            // Merge specific options with flattened global defaults
            dataSourcesWithDefaults[dsId] = __assign(__assign({}, dataSourceDef), { options: defaultsDeep_1.default(optionsCopy, defaultOptions) });
        });
        return dataSourcesWithDefaults;
    };
    /**
     * Returns a configuration for all visualizations with global defaults flattened in
     * @param {Object} visualizations Visualizations from dashboard definition
     * @param {Object} defaults Defaults from the dashboard definition
     * @return {Object} Flattened visualizations with the global context, options, and flags
     */
    DashboardDefinition.flattenVisualizations = function (visualizations, defaults) {
        var vizTypeDefaults = new Map();
        var globalDefaults = exports.getGlobalDefaultsForVisualizations(defaults);
        var flattenedVisualizations = {};
        each_1.default(visualizations, function (vizDef, vizId) {
            if (!vizTypeDefaults.has(vizDef.type)) {
                var typeDefaults = exports.getDefaultsForVisualizationType(defaults, vizDef.type);
                vizTypeDefaults.set(vizDef.type, typeDefaults);
            }
            var vizDefaults = vizTypeDefaults.get(vizDef.type);
            // deeply cascade settings with the precedent order highest to lowest of vizDef, vizTypeDefault, vizGlobalDefault
            flattenedVisualizations[vizId] = defaultsDeep_1.default({}, vizDef, vizDefaults, globalDefaults);
        });
        return flattenedVisualizations;
    };
    /**
     * set up customized schema
     * @method setSchema
     * @param {Object} newSchema
     * @returns {Object} error
     */
    DashboardDefinition.prototype.setSchema = function (newSchema) {
        if (!newSchema.$id) {
            return null;
        }
        try {
            this.validateDefinition = memoizedCompile(newSchema);
        }
        catch (error) {
            return error;
        }
        return null;
    };
    /**
     * check duplication of inputs tokens
     * @method checkDuplicateTokens
     * @returns {Array} errors
     */
    DashboardDefinition.prototype.checkDuplicateTokens = function () {
        var cache = {};
        var inputs = this.definition.inputs;
        var errors = [];
        each_1.default(inputs, function (input, key) {
            var token = (input.options || {}).token;
            if (token === undefined) {
                // if there is no token provided
                return;
            }
            if (token in cache) {
                cache[token].push(key);
            }
            else {
                cache[token] = [key];
            }
        });
        each_1.default(cache, function (keys, token) {
            if (keys.length > 1) {
                var lastKey = keys[keys.length - 1];
                var msg = keys.slice(0, -1).join(', ');
                errors.push({
                    instancePath: i18n_1._('Error: Token duplicated across multiple inputs'),
                    message: i18n_1._(msg + " and " + lastKey + " have the same token (" + token + ")"),
                });
            }
        });
        return errors;
    };
    DashboardDefinition.prototype.checkVisualizationsInStructure = function () {
        var seen = new Set();
        var _a = this.definition, _b = _a.visualizations, visualizations = _b === void 0 ? {} : _b, _c = _a.layout, _d = _c === void 0 ? {} : _c, _e = _d.structure, structure = _e === void 0 ? [] : _e;
        var errors = [];
        each_1.default(structure, function (item, idx) {
            if (seen.has(item.item)) {
                errors.push({
                    instancePath: i18n_1._('Error: Visualization duplicated in layout structure'),
                    message: i18n_1._("Structure item " + idx + " has the same key \"" + item.item + "\" as another structure item"),
                });
            }
            if (!isPlainObject_1.default(visualizations[item.item])) {
                errors.push({
                    instancePath: i18n_1._('Error: Visualization in layout structure does not exist'),
                    message: i18n_1._("Structure item " + idx + " references a visualization \"" + item.item + "\" that does not exist"),
                });
            }
            seen.add(item.item);
        });
        Object.keys(visualizations).forEach(function (vizId) {
            if (!seen.has(vizId)) {
                errors.push({
                    instancePath: i18n_1._('Error: Visualization is not present in layout structure'),
                    message: i18n_1._("Visualization \"" + vizId + "\" is not present in Layout Structure"),
                });
            }
        });
        return errors;
    };
    DashboardDefinition.prototype.checkInputsInStructure = function () {
        var _a = this.definition, _b = _a.inputs, inputs = _b === void 0 ? {} : _b, _c = _a.layout, _d = _c === void 0 ? {} : _c, _e = _d.globalInputs, globalInputs = _e === void 0 ? [] : _e;
        var errors = [];
        Object.keys(inputs).forEach(function (inputId) {
            if (!globalInputs.includes(inputId)) {
                errors.push({
                    instancePath: i18n_1._('Error: Input is not present in the global inputs structure'),
                    message: i18n_1._("Input \"" + inputId + "\" is defined but not used in the Global Inputs Structure"),
                });
            }
        });
        each_1.default(globalInputs, function (inputId, idx) {
            if (isEmpty_1.default(inputs[inputId])) {
                errors.push({
                    instancePath: i18n_1._('Error: Input in global input structure does not exist'),
                    message: i18n_1._("Input item " + idx + " references an input \"" + inputId + "\" that does not exist"),
                });
            }
        });
        return errors;
    };
    /**
     * Validates the current definition
     * @method validate
     * @returns {Array} list of errors, or null
     */
    DashboardDefinition.prototype.validate = function () {
        var _a, _b;
        var valid = this.validateDefinition(this.definition);
        if (!valid && ((_b = (_a = this.validateDefinition) === null || _a === void 0 ? void 0 : _a.errors) === null || _b === void 0 ? void 0 : _b.length)) {
            return cloneDeep_1.default(this.validateDefinition.errors);
        }
        var res = __spread(this.checkDuplicateTokens(), this.checkVisualizationsInStructure(), this.checkInputsInStructure());
        if (!isEmpty_1.default(res)) {
            return res;
        }
        return null;
    };
    /**
     * Update the dashboard title or description
     * @method updateDashboard
     * @param {String} title The new title
     * @param {String} desc The new description
     * @returns {DashboardDefinition}
     */
    DashboardDefinition.prototype.updateDashboard = function (_a) {
        var title = _a.title, desc = _a.desc;
        if (isString_1.default(title)) {
            this.definition = __assign(__assign({}, this.definition), { title: (title && title.trim()) || '' });
        }
        if (desc) {
            this.definition = __assign(__assign({}, this.definition), { description: desc });
        }
        return this;
    };
    /**
     * Add a new datasource configuration
     * @method addDataSource
     * @param {String} dsId     The key to identify the datasource
     * @param {Object} dsDef    The configuration
     * @returns {DashboardDefinition}
     */
    DashboardDefinition.prototype.addDataSource = function (dsId, dsDef) {
        var _a;
        if (!dsDef) {
            return this;
        }
        this.definition = __assign(__assign({}, this.definition), { dataSources: __assign(__assign({}, this.definition.dataSources), (_a = {}, _a[dsId] = dsDef, _a)) });
        return this;
    };
    /**
     * Add a visualization configuration to the definition
     * @method addVisualization
     * @param {String} vizId    The key to identify the vis
     * @param {Object} vizDef   The configuration of the vis
     * @returns {DashboardDefinition}
     */
    DashboardDefinition.prototype.addVisualization = function (vizId, vizDef) {
        return this.updateVisualization(vizId, vizDef);
    };
    /**
     * Add an input config to the definition
     * @method addInput
     * @param {String} inputId      Key to identify the input
     * @param {Object} [inputDef]     The input config
     * @returns {DashboardDefinition}
     */
    DashboardDefinition.prototype.addInput = function (inputId, inputDef) {
        var _a;
        // All inputs require type and options.token, set these if not provided
        var token = get_1.default(inputDef, 'options.token', this.nextTokenId());
        var type = get_1.default(inputDef, 'type', 'input.text');
        this.definition = __assign(__assign({}, this.definition), { inputs: __assign(__assign({}, this.definition.inputs), (_a = {}, _a[inputId] = __assign(__assign({}, inputDef), { type: type, options: __assign(__assign({}, inputDef === null || inputDef === void 0 ? void 0 : inputDef.options), { token: token }) }), _a)) });
        return this;
    };
    /**
     * Adds a new input to the global inputs array
     * @param {String} inputId The id for the input
     * @returns {DashboardDefinition}
     */
    DashboardDefinition.prototype.addInputToLayout = function (inputId) {
        var globalInputs = this.getGlobalInputs();
        return this.updateGlobalInputs(__spread(globalInputs, [inputId]));
    };
    /**
     * removes the input from the global inputs array
     * @param {String} inputId The inputId to remove
     * @returns {DashboardDefinition}
     */
    DashboardDefinition.prototype.removeInputFromLayout = function (inputId) {
        var filteredGlobalInputs = this.getGlobalInputs().filter(function (id) { return id !== inputId; });
        return this.updateGlobalInputs(filteredGlobalInputs);
    };
    /**
     * Sets global inputs to passed array
     * @param {String[]} newGlobalInputs Array of input ids
     * @returns {DashboardDefinition}
     */
    DashboardDefinition.prototype.updateGlobalInputs = function (newGlobalInputs) {
        if (newGlobalInputs === void 0) { newGlobalInputs = []; }
        this.definition = __assign(__assign({}, this.definition), { layout: __assign(__assign({ type: 'absolute' }, this.definition.layout), { globalInputs: newGlobalInputs }) });
        return this;
    };
    /**
     * Clones a datasource configuration
     * @method cloneDataSource
     * @param {String} dsId     Key to identify datasource
     * @returns {String} The newly created DatasourceId
     */
    DashboardDefinition.prototype.cloneDataSource = function (dsId) {
        var dsDefinition = this.getDataSource(dsId);
        if (!dsDefinition) {
            return null;
        }
        if (dsDefinition.name) {
            dsDefinition = __assign(__assign({}, dsDefinition), { name: "Copy of " + dsDefinition.name });
        }
        var newDatasourceId = this.nextDataSourceId() + "_" + dsId;
        this.addDataSource(newDatasourceId, dsDefinition);
        return newDatasourceId;
    };
    /**
     * Clones a Visualization configuration
     * @method cloneVisualization
     * @param {String} vizId     Key to identify Viz
     * @param {String} newVizId  Key for new cloned Viz
     * @returns {String} The newly created VizId
     */
    DashboardDefinition.prototype.cloneVisualization = function (vizId, newVizId) {
        var _this = this;
        if (!newVizId) {
            return null;
        }
        var vizDef = this.getVisualization(vizId);
        if (!vizDef) {
            return null;
        }
        var newVizDef = __assign({}, vizDef);
        if (!isEmpty_1.default(vizDef.dataSources)) {
            var dataSources_1 = {};
            each_1.default(vizDef.dataSources, function (dataSourceId, dataSourceType) {
                if (_this.getDataSource(dataSourceId)) {
                    var newDatasourceId = _this.cloneDataSource(dataSourceId);
                    dataSources_1[dataSourceType] = newDatasourceId;
                }
            });
            newVizDef.dataSources = dataSources_1;
        }
        this.addVisualization(newVizId, newVizDef);
        return newVizId;
    };
    /**
     * Removes a datasource configuration
     * @method removeDataSource
     * @param {String} dsId     Key to identify datasource
     * @returns {DashboardDefinition}
     */
    DashboardDefinition.prototype.removeDataSource = function (dsId) {
        this.definition = __assign(__assign({}, this.definition), { dataSources: omit_1.default(this.definition.dataSources, [dsId]) });
        return this;
    };
    /**
     * Removes a visualization configuration
     * @method removeVisualization
     * @param {String} vizId key to identify visualization
     * @returns {DashboardDefinition}
     */
    DashboardDefinition.prototype.removeVisualization = function (vizId) {
        // TODO: also remove from structure?
        this.definition = __assign(__assign({}, this.definition), { visualizations: omit_1.default(this.definition.visualizations, [vizId]) });
        return this;
    };
    /**
     * Removes an input configuration
     * @method removeInput
     * @param {String} inputId key to identify input
     * @returns {DashboardDefinition}
     */
    DashboardDefinition.prototype.removeInput = function (inputId) {
        this.definition = __assign(__assign({}, this.definition), { inputs: omit_1.default(this.definition.inputs, [inputId]) });
        return this;
    };
    /**
     * Update the layout to a different type
     * @method updateLayoutType
     * @param {String} type     Layout type, e.g. grid, absolute
     * @returns {DashboardDefinition}
     */
    DashboardDefinition.prototype.updateLayoutType = function (type) {
        this.definition = __assign(__assign({}, this.definition), { layout: __assign(__assign({}, this.definition.layout), { type: type }) });
        return this;
    };
    /**
     * Replaces current layout options config
     * @method updateLayoutOptions
     * @param {Object} layoutOptions Options object to replace existing def
     * @returns {DashboardDefinition}
     */
    DashboardDefinition.prototype.updateLayoutOptions = function (layoutOptions) {
        this.definition = __assign(__assign({}, this.definition), { layout: __assign(__assign({ type: 'absolute' }, this.definition.layout), { options: layoutOptions }) });
        return this;
    };
    /**
     * Replace current structure with a new one
     * @method updateLayoutStructure
     * @param {Array} newStructure List of vis layout item position data
     * @returns {DashboardDefinition}
     */
    DashboardDefinition.prototype.updateLayoutStructure = function (newStructure) {
        this.definition = __assign(__assign({}, this.definition), { layout: __assign(__assign({ type: 'absolute' }, this.definition.layout), { structure: newStructure }) });
        return this;
    };
    /**
     * Replace a visualization config
     * @method updateVisualization
     * @param {String} vizId  key to identify vis
     * @param {Object} vizDef Visualization definition
     * @returns {DashboardDefinition}
     */
    DashboardDefinition.prototype.updateVisualization = function (vizId, vizDef) {
        var _a;
        if (!vizDef) {
            return this;
        }
        this.definition = __assign(__assign({}, this.definition), { visualizations: __assign(__assign({}, this.definition.visualizations), (_a = {}, _a[vizId] = vizDef, _a)) });
        return this;
    };
    /**
     * Replaces existing datasource config
     * @method updateDataSource
     * @param {String} dsId     key to identify datasource
     * @param {Object} [dsDef]    The datasource definition
     * @returns {DashboardDefinition}
     */
    DashboardDefinition.prototype.updateDataSource = function (dsId, dsDef) {
        var _a;
        if (!dsDef ||
            isEqual_1.default(dsDef, get_1.default(this.definition, ['dataSources', dsId]))) {
            // if the config is the same, don't create a new definition
            return this;
        }
        this.definition = __assign(__assign({}, this.definition), { dataSources: __assign(__assign({}, this.definition.dataSources), (_a = {}, _a[dsId] = dsDef, _a)) });
        return this;
    };
    /**
     * Replaces existing input config
     * @method updateInput
     * @param {String} inputId key to identify input
     * @param {Object} inputDef New input config
     * @returns {DashboardDefinition}
     */
    DashboardDefinition.prototype.updateInput = function (inputId, inputDef) {
        var _a;
        if (!inputDef) {
            return this;
        }
        this.definition = __assign(__assign({}, this.definition), { inputs: __assign(__assign({}, this.definition.inputs), (_a = {}, _a[inputId] = inputDef, _a)) });
        return this;
    };
    /**
     * Return the JSON representation of the dashboard
     * @method toJSON
     * @returns {Object}
     */
    DashboardDefinition.prototype.toJSON = function () {
        return this.definition;
    };
    /**
     * Get the current layout structure
     * @method getLayoutStructure
     * @returns {Array} The current structure
     */
    DashboardDefinition.prototype.getLayoutStructure = function () {
        var structure = get_1.default(this.definition, 'layout.structure');
        return Array.isArray(structure) ? structure : [];
    };
    /**
     * return current layout type
     */
    DashboardDefinition.prototype.getLayoutType = function () {
        return get_1.default(this.definition, 'layout.type');
    };
    /**
     * Return the current options for the layout
     * @method getLayoutOptions
     * @returns {Object}
     */
    DashboardDefinition.prototype.getLayoutOptions = function () {
        return get_1.default(this.definition, 'layout.options') || {};
    };
    /**
     * Fetch the current definition for a visualization by id
     * @method getVisualization
     * @param {String} visId    The identifier for the vis
     * @returns {Object} The vis definition, or null if not found
     */
    DashboardDefinition.prototype.getVisualization = function (visId) {
        return get_1.default(this.definition, "visualizations[\"" + visId + "\"]", null);
    };
    /**
     * Fetch the current definition for a visualization by id with all the global defaults flattened in
     * @param {String} vizId The identifier for the visualization
     * @returns {Object} The viz definition, or null if not found.
     */
    DashboardDefinition.prototype.getVisualizationWithFlattenedDefaults = function (vizId) {
        var vizDef = this.getVisualization(vizId);
        if (!vizDef) {
            return null;
        }
        var defaults = this.getDefaults();
        var globalDefaults = exports.getGlobalDefaultsForVisualizations(defaults);
        var typeDefaults = exports.getDefaultsForVisualizationType(defaults, vizDef.type);
        return dashboard_utils_1.deepMergeWithDefaults(vizDef, typeDefaults, globalDefaults);
    };
    /**
     * Fetch all the visualization ids
     * @method getVisualizationIds
     * @returns {Array} All the Viz Ids
     */
    DashboardDefinition.prototype.getVisualizationIds = function () {
        return Object.keys(get_1.default(this.definition, 'visualizations', {}));
    };
    /**
     * Fetch the current definition for a datasource by id
     * @param {String} dsId
     * @returns {Object} The datasource definition, or null if not found
     */
    DashboardDefinition.prototype.getDataSource = function (dsId) {
        return get_1.default(this.definition, "dataSources[\"" + dsId + "\"]", null);
    };
    /**
     * Returns true if datasource can be a base datasource for a chain datasource
     * @param {String} dsId
     * @param {Number} count
     * @returns {Boolean}
     */
    DashboardDefinition.prototype.canBeBaseDataSource = function (dsId, count) {
        if (count === void 0) { count = 0; }
        var parentDsId = get_1.default(this.getDataSource(dsId), 'options.extend', '');
        var isValidLength = count < search_1.MAX_CHAIN_LENGTH;
        return parentDsId && isValidLength
            ? this.canBeBaseDataSource(parentDsId, count + 1)
            : isValidLength;
    };
    /**
     * Returns datasources which can be a base datasource for a chain datasource
     * @returns {Object} Map of objects of form { dataSourceId: dataSourceDefinition }
     */
    DashboardDefinition.prototype.getBaseDataSources = function () {
        var _this = this;
        var dataSources = get_1.default(this.definition, 'dataSources', {});
        return pickBy_1.default(dataSources, function (dsDef, dsId) {
            return _this.canBeBaseDataSource(dsId);
        });
    };
    /**
     * Fetch the default options for a datasource by id
     * @param {String} dsId
     * @returns {Object} The datasource default options
     */
    DashboardDefinition.prototype.getDataSourceDefaultOptions = function (dsId) {
        var dataSourceType = get_1.default(this.getDataSource(dsId), 'type');
        return dataSourceType
            ? exports.getDefaultOptionsForDataSourceType(this.getDefaults(), dataSourceType)
            : null;
    };
    /**
     * Get an input configuration for the provided id
     * @param {String} inputId The id for the desired input
     * @returns {Object} Returns config or null if not found
     */
    DashboardDefinition.prototype.getInput = function (inputId) {
        return get_1.default(this.definition, ['inputs', inputId], null);
    };
    /**
     * Get the list of displayed inputs in the global input area
     * @returns {String[]}
     */
    DashboardDefinition.prototype.getGlobalInputs = function () {
        // Return a copy of the array, so it can't be accidentally mutated
        return get_1.default(this.definition, 'layout.globalInputs', []).slice();
    };
    /**
     * Get an input that uses the provided token
     * @param {String} tokenId The token to look for
     * @returns {Object} The config for the first input that sets data with the provided token
     */
    DashboardDefinition.prototype.getInputByToken = function (tokenId) {
        if (!tokenId) {
            return null;
        }
        var inputs = get_1.default(this.definition, 'inputs');
        return (find_1.default(inputs, function (config) { return get_1.default(config, 'options.token') === tokenId; }) || null);
    };
    /**
     * Get the type for the given visualization
     * @method getVisualizationType
     * @param {String} visId key to identify visualization
     * @returns {String}
     */
    DashboardDefinition.prototype.getVisualizationType = function (visId) {
        return get_1.default(this.definition, "visualizations[\"" + visId + "\"].type") || null;
    };
    /**
     * return event handler array
     * @param {String} hostId node id, can be searchId, vizId or inputId
     * @param {String} [type='visualizations'] can be visualizations, dataSources or inputs
     */
    DashboardDefinition.prototype.getEventHandlers = function (hostId, type) {
        if (type === void 0) { type = 'visualizations'; }
        if (!hostId) {
            return [];
        }
        var host = get_1.default(this.definition, [type, hostId], null);
        return ((host && Array.isArray(host.eventHandlers) && host.eventHandlers) ||
            []);
    };
    /**
     *
     * @param {String} hostId node id, can be search id, viz id or input id
     * @param {Object} handler eventhandler
     * @param {String} [type='visualizations'] can be visualizations, dataSources or inputs
     */
    DashboardDefinition.prototype.createEventHandler = function (hostId, handler, type) {
        var _a, _b;
        var _c;
        if (type === void 0) { type = 'visualizations'; }
        var host = get_1.default(this.definition, [type, hostId], null);
        if (host == null) {
            return this;
        }
        var eventHandlers = __spread(this.getEventHandlers(hostId, type), [handler]);
        this.definition = __assign(__assign({}, this.definition), (_a = {}, _a[type] = __assign(__assign({}, this.definition[type]), (_b = {}, _b[hostId] = __assign(__assign({}, (_c = this.definition[type]) === null || _c === void 0 ? void 0 : _c[hostId]), { eventHandlers: eventHandlers }), _b)), _a));
        return this;
    };
    /**
     *
     * @param {String} hostId node id, can be search id, viz id or input id
     * @param {Number} handlerIdx handler index
     * @param {String} [type='visualizations'] can be visualizations, dataSources or inputs
     */
    DashboardDefinition.prototype.removeEventHandler = function (hostId, handlerIdx, type) {
        var _a, _b;
        var _c;
        if (handlerIdx === void 0) { handlerIdx = 0; }
        if (type === void 0) { type = 'visualizations'; }
        var host = get_1.default(this.definition, [type, hostId], null);
        if (host == null) {
            return this;
        }
        var eventHandlers = __spread(this.getEventHandlers(hostId, type));
        // delete 1 element at handlerIdx
        eventHandlers.splice(handlerIdx, 1);
        this.definition = __assign(__assign({}, this.definition), (_a = {}, _a[type] = __assign(__assign({}, this.definition[type]), (_b = {}, _b[hostId] = __assign(__assign({}, (_c = this.definition[type]) === null || _c === void 0 ? void 0 : _c[hostId]), { eventHandlers: eventHandlers }), _b)), _a));
        return this;
    };
    /**
     *
     * @param {String} hostId node id, can be search id, viz id or input id
     * @param {Number} [handlerIdx=0] handler index
     * @param {Object} [handler={}] new handler
     * @param {String} [type='visualizations'] can be visualizations, dataSources or inputs
     */
    DashboardDefinition.prototype.editEventHandler = function (hostId, handlerIdx, handler, type) {
        var _a, _b;
        var _c;
        if (handlerIdx === void 0) { handlerIdx = 0; }
        if (handler === void 0) { handler = {}; }
        if (type === void 0) { type = 'visualizations'; }
        var host = get_1.default(this.definition, [type, hostId], null);
        if (host == null) {
            return this;
        }
        var eventHandlers = __spread(this.getEventHandlers(hostId, type));
        if (handlerIdx >= 0 && handlerIdx <= eventHandlers.length - 1) {
            eventHandlers[handlerIdx] = handler;
            this.definition = __assign(__assign({}, this.definition), (_a = {}, _a[type] = __assign(__assign({}, this.definition[type]), (_b = {}, _b[hostId] = __assign(__assign({}, (_c = this.definition[type]) === null || _c === void 0 ? void 0 : _c[hostId]), { eventHandlers: eventHandlers }), _b)), _a));
        }
        return this;
    };
    /**
     * connect a visualization with new datasource
     * @param {Object} params
     * @param {String} params.vizId visualization id
     * @param {String} params.dataSourceType dataSource binding type such as primary, annotation
     * @param {Object} params.dataSourceDefinition dataSource definition
     */
    DashboardDefinition.prototype.connectNewDataSourceToVisualization = function (_a) {
        var vizId = _a.vizId, dataSourceType = _a.dataSourceType, dataSourceDefinition = _a.dataSourceDefinition;
        var dataSourceId = this.nextDataSourceId();
        this.addDataSource(dataSourceId, dataSourceDefinition);
        this.connectDataSourceToVisualization({
            vizId: vizId,
            dataSourceType: dataSourceType,
            dataSourceId: dataSourceId,
        });
        return this;
    };
    /**
     * connect an input with new datasource
     * @param {Object} params
     * @param {String} params.inputId inputId id
     * @param {String} params.dataSourceType dataSource binding type such as primary, annotation
     * @param {Object} params.dataSourceDefinition dataSource definition
     */
    DashboardDefinition.prototype.connectNewDataSourceToInput = function (_a) {
        var inputId = _a.inputId, dataSourceType = _a.dataSourceType, dataSourceDefinition = _a.dataSourceDefinition;
        var dataSourceId = this.nextDataSourceId();
        this.addDataSource(dataSourceId, dataSourceDefinition);
        this.connectDataSourceToInput({
            inputId: inputId,
            dataSourceType: dataSourceType,
            dataSourceId: dataSourceId,
        });
        return this;
    };
    /**
     * connect an item with a new datasource
     * @param {Object} params
     * @param {String} params.itemId item id
     * @param {String} params.dataSourceType dataSource binding type such as primary, annotation
     * @param {Object} params.dataSourceDefinition dataSource definition
     */
    DashboardDefinition.prototype.connectNewDataSourceToItem = function (_a) {
        var itemId = _a.itemId, dataSourceType = _a.dataSourceType, dataSourceDefinition = _a.dataSourceDefinition;
        var itemType = this.getItemType(itemId);
        return itemType === 'input'
            ? this.connectNewDataSourceToInput({
                inputId: itemId,
                dataSourceType: dataSourceType,
                dataSourceDefinition: dataSourceDefinition,
            })
            : this.connectNewDataSourceToVisualization({
                vizId: itemId,
                dataSourceType: dataSourceType,
                dataSourceDefinition: dataSourceDefinition,
            });
    };
    /**
     * connect a visualization with existing datasource
     * @param {Object} params
     * @param {String} params.vizId visualization id
     * @param {String} params.dataSourceType dataSource binding type such as primary, annotation
     * @param {String} params.dataSourceId existing datasource id
     */
    DashboardDefinition.prototype.connectDataSourceToVisualization = function (_a) {
        var _b;
        var vizId = _a.vizId, dataSourceType = _a.dataSourceType, dataSourceId = _a.dataSourceId;
        var visualization = this.getVisualization(vizId);
        var dataSource = this.getDataSource(dataSourceId);
        if (visualization && dataSource) {
            this.updateVisualization(vizId, __assign(__assign({}, visualization), { dataSources: __assign(__assign({}, visualization.dataSources), (_b = {}, _b[dataSourceType] = dataSourceId, _b)) }));
        }
        return this;
    };
    /**
     * connect an input with existing datasource
     * @param {Object} params
     * @param {String} params.inputId input id
     * @param {String} params.dataSourceType dataSource binding type such as primary, annotation
     * @param {String} params.dataSourceId existing datasource id
     */
    DashboardDefinition.prototype.connectDataSourceToInput = function (_a) {
        var _b;
        var inputId = _a.inputId, dataSourceType = _a.dataSourceType, dataSourceId = _a.dataSourceId;
        var input = this.getInput(inputId);
        var dataSource = this.getDataSource(dataSourceId);
        if (input && dataSource) {
            this.updateInput(inputId, __assign(__assign({}, input), { dataSources: __assign(__assign({}, input.dataSources), (_b = {}, _b[dataSourceType] = dataSourceId, _b)) }));
        }
        return this;
    };
    /**
     * connect an item with existing datasource
     * @param {Object} params
     * @param {String} params.itemId item id
     * @param {String} params.dataSourceType dataSource binding type such as primary, annotation
     * @param {String} params.dataSourceId existing datasource id
     * @param {String} [params.type=block] type of item such as 'block', 'input'
     */
    DashboardDefinition.prototype.connectDataSourceToItem = function (_a) {
        var itemId = _a.itemId, dataSourceType = _a.dataSourceType, dataSourceId = _a.dataSourceId, _b = _a.type, type = _b === void 0 ? 'block' : _b;
        return type === 'input'
            ? this.connectDataSourceToInput({
                inputId: itemId,
                dataSourceType: dataSourceType,
                dataSourceId: dataSourceId,
            })
            : this.connectDataSourceToVisualization({
                vizId: itemId,
                dataSourceType: dataSourceType,
                dataSourceId: dataSourceId,
            });
    };
    /**
     * disconnect a visualization from existing datasource
     * @param {Object} params
     * @param {String} params.vizId visualization id
     * @param {String} params.dataSourceType dataSource binding type such as primary, annotation
     * @param {String} params.dataSourceId existing datasource id
     */
    DashboardDefinition.prototype.disconnectDataSourceFromVisualization = function (_a) {
        var vizId = _a.vizId, dataSourceType = _a.dataSourceType, dataSourceId = _a.dataSourceId;
        var visualization = this.getVisualization(vizId);
        if (visualization && visualization.dataSources) {
            if (visualization.dataSources[dataSourceType] === dataSourceId) {
                this.updateVisualization(vizId, __assign(__assign({}, visualization), { dataSources: omit_1.default(visualization.dataSources, dataSourceType) }));
            }
        }
        return this;
    };
    /**
     * disconnect an input from existing datasource
     * @param {Object} params
     * @param {String} params.inputId input id
     * @param {String} params.dataSourceType dataSource binding type such as primary, annotation
     * @param {String} params.dataSourceId existing datasource id
     */
    DashboardDefinition.prototype.disconnectDataSourceFromInput = function (_a) {
        var inputId = _a.inputId, dataSourceType = _a.dataSourceType, dataSourceId = _a.dataSourceId;
        var input = this.getInput(inputId);
        if (input && input.dataSources) {
            if (input.dataSources[dataSourceType] === dataSourceId) {
                this.updateInput(inputId, __assign(__assign({}, input), { dataSources: omit_1.default(input.dataSources, dataSourceType) }));
            }
        }
        return this;
    };
    /**
     * disconnect item from an existing datasource
     * @param {Object} params
     * @param {String} params.itemId item id
     * @param {String} params.dataSourceType dataSource binding type such as primary, annotation
     * @param {String} params.dataSourceId existing datasource id
     */
    DashboardDefinition.prototype.disconnectDataSourceFromItem = function (_a) {
        var itemId = _a.itemId, dataSourceType = _a.dataSourceType, dataSourceId = _a.dataSourceId;
        var itemType = this.getItemType(itemId);
        return itemType === 'input'
            ? this.disconnectDataSourceFromInput({
                inputId: itemId,
                dataSourceType: dataSourceType,
                dataSourceId: dataSourceId,
            })
            : this.disconnectDataSourceFromVisualization({
                vizId: itemId,
                dataSourceType: dataSourceType,
                dataSourceId: dataSourceId,
            });
    };
    /**
     * generate visualization id
     */
    DashboardDefinition.prototype.nextVisualizationId = function () {
        var _this = this;
        return exports.generateId('viz', function (id) { return _this.getVisualization(id); });
    };
    /**
     * generate datasource id
     */
    DashboardDefinition.prototype.nextDataSourceId = function () {
        var _this = this;
        return exports.generateId('ds', function (id) { return _this.getDataSource(id); });
    };
    /**
     * generate input id
     */
    DashboardDefinition.prototype.nextInputId = function () {
        var _this = this;
        return exports.generateId('input', function (id) { return _this.getInput(id); });
    };
    /**
     * generate token id
     */
    DashboardDefinition.prototype.nextTokenId = function (prefix) {
        var _this = this;
        if (prefix === void 0) { prefix = 'token'; }
        return exports.generateId(prefix, function (id) { return _this.getInputByToken(id); });
    };
    /**
     * Returns the number of Visualizations using the Data Source with passed in dsId
     * @method countVisualizationsUsingDataSource
     * @param {String} dsId     Key to identify datasource
     * @returns {Number}
     */
    DashboardDefinition.prototype.countVisualizationsUsingDataSource = function (dsId) {
        var _a = this.definition.visualizations, visualizations = _a === void 0 ? {} : _a;
        var visualizationUseCount = 0;
        Object.keys(visualizations).forEach(function (vizId) {
            var dataSources = get_1.default(visualizations, [vizId, 'dataSources'], {});
            Object.keys(dataSources).forEach(function (dataSourceType) {
                if (dataSources[dataSourceType] === dsId) {
                    visualizationUseCount += 1;
                }
            });
        });
        return visualizationUseCount;
    };
    /**
     * Returns the number of Inputs using the Data Source with passed in dsId
     * @method countInputsUsingDataSource
     * @param {String} dsId     Key to identify datasource
     * @returns {Number}
     */
    DashboardDefinition.prototype.countInputsUsingDataSource = function (dsId) {
        var _a = this.definition.inputs, inputs = _a === void 0 ? {} : _a;
        var inputUseCount = 0;
        Object.keys(inputs).forEach(function (inputId) {
            var dataSources = get_1.default(inputs, [inputId, 'dataSources'], {});
            Object.keys(dataSources).forEach(function (dataSourceType) {
                if (dataSources[dataSourceType] === dsId) {
                    inputUseCount += 1;
                }
            });
        });
        return inputUseCount;
    };
    /**
     * Returns the Data Sources of chain searches using the Data Source with passed in dsId
     * @method getChainSearchesUsingDataSource
     * @param {String} dsId     Key to identify datasource
     * @param {Number} count     running count of current chain length
     * @returns {Array} List of object of form { id: dsId, config: ds} which are descendants of Data Source with dsId with max length of MAX_CHAIN_LENGTH
     */
    DashboardDefinition.prototype.getChainSearchesUsingDataSource = function (dsId, count) {
        var _this = this;
        if (count === void 0) { count = 0; }
        var dataSources = get_1.default(this.definition, 'dataSources', {});
        var chainSearches = [];
        each_1.default(dataSources, function (ds, id) {
            var parentId = get_1.default(ds, 'options.extend', '');
            if (parentId === dsId && count < search_1.MAX_CHAIN_LENGTH) {
                chainSearches.push.apply(chainSearches, __spread([{ id: id, config: _this.getDataSource(id) }], _this.getChainSearchesUsingDataSource(id, count + 1)));
            }
        });
        return chainSearches;
    };
    /**
     * Disconnects a dataSource from all visualizations and inputs in the definition
     * @method disconnectDataSource
     * @param {String} dataSourceId     Key to identify datasource
     * @returns {DashboardDefinition}
     */
    DashboardDefinition.prototype.disconnectDataSource = function (dataSourceId) {
        var _this = this;
        var _a = this.definition, _b = _a.visualizations, visualizations = _b === void 0 ? {} : _b, _c = _a.inputs, inputs = _c === void 0 ? {} : _c;
        Object.keys(visualizations).forEach(function (vizId) {
            var dataSources = get_1.default(visualizations, [vizId, 'dataSources'], {});
            Object.keys(dataSources).forEach(function (dataSourceType) {
                _this.disconnectDataSourceFromVisualization({
                    vizId: vizId,
                    dataSourceType: dataSourceType,
                    dataSourceId: dataSourceId,
                });
            });
        });
        Object.keys(inputs).forEach(function (inputId) {
            var dataSources = get_1.default(inputs, [inputId, 'dataSources'], {});
            Object.keys(dataSources).forEach(function (dataSourceType) {
                _this.disconnectDataSourceFromInput({
                    inputId: inputId,
                    dataSourceType: dataSourceType,
                    dataSourceId: dataSourceId,
                });
            });
        });
        return this;
    };
    /**
     * Search for a key or string that matches the provided key
     * @param {String} newId The key to search for
     * @returns {Boolean}
     */
    DashboardDefinition.prototype.hasDuplicateId = function (newId) {
        // Wrap in quotes to look for keys and not substrings
        return exports.hasDuplicateId(this.definition, newId);
    };
    /**
     * Converts all instances of an old id to a new id
     * @param {String} oldId The original string to replace
     * @param {String} newId The new string to add
     * @return {Boolean} To show success/fail
     */
    DashboardDefinition.prototype.updateComponentId = function (oldId, newId) {
        if (oldId === newId ||
            !/^(viz|input|ds)_[a-zA-Z0-9-_]+$/.test(newId) ||
            this.hasDuplicateId(newId) ||
            !this.hasDuplicateId(oldId)) {
            return false;
        }
        var stringDef = JSON.stringify(this.definition);
        // Wrapping quotes around the dsId to make sure we target entire keys and not substrings
        var re = new RegExp("\"" + oldId + "\"", 'g');
        // Wrap newId with quotes to make sure we replace the ones we remove
        this.definition = JSON.parse(stringDef.replace(re, "\"" + newId + "\""));
        return true;
    };
    /**
     * Compare two definitions to generate json patches.
     * @param {DashboardDefinition} other another instance of DashboardDefinition
     * @returns {object[]}
     */
    DashboardDefinition.prototype.compare = function (other) {
        return fast_json_patch_1.compare(exports.normalizeLayoutStructure(this.toJSON()), exports.normalizeLayoutStructure(other.toJSON()));
    };
    /**
     * Get the id of first time range input
     * @public
     */
    DashboardDefinition.prototype.getFirstTimeRangeInputId = function () {
        var _this = this;
        return find_1.default(get_1.default(this.definition, ['layout', 'globalInputs'], []), 
        // note: `input.timerange` is hardcoded, I can't think of a better way to determine what is a time range input
        function (inputId) {
            return get_1.default(_this.getInput(inputId), 'type') === 'input.timerange';
        });
    };
    /**
     * Get defaults
     * @returns {Object} dashboard defaults
     * @public
     */
    DashboardDefinition.prototype.getDefaults = function () {
        return get_1.default(this.definition, 'defaults', {});
    };
    /**
     * Get default time range when create a new `ds.search` data source. The rule is:
     * 1. use `defaults` section from the definition if available.
     * 2. use the first time range input token if available
     * 3. use static time range `Last 24 hours`
     * @returns {Object} earliest and latest
     */
    DashboardDefinition.prototype.getDefaultTimeRangeForNewSearch = function () {
        var defaultOptions = exports.getDefaultOptionsForDataSourceType(this.getDefaults(), 'ds.search');
        var defaultQueryParameters = get_1.default(defaultOptions, 'queryParameters', {});
        // prefer definition defaults over hardcoded time range values
        if (defaultQueryParameters.earliest || defaultQueryParameters.latest) {
            return {};
        }
        var timeRangeInputToken = get_1.default(this.getInput(this.getFirstTimeRangeInputId()), ['options', 'token']);
        // if there's at least one time range input, use it
        if (timeRangeInputToken) {
            return {
                earliest: "$" + timeRangeInputToken + ".earliest$",
                latest: "$" + timeRangeInputToken + ".latest$",
            };
        }
        return {
            earliest: '-24h@h',
            latest: 'now',
        };
    };
    /**
     * Get the visualization layout type - block/line
     * @method getVisualizationLayoutType
     * @param {String} vizId Key to identify visualization
     * @returns {String} The viz layout type - line/block, or block if type is not found
     */
    DashboardDefinition.prototype.getVisualizationLayoutType = function (vizId) {
        var layoutStructure = this.getLayoutStructure();
        var _a = (layoutStructure.find(function (viz) { return viz.item === vizId; }) || {}).type, type = _a === void 0 ? 'block' : _a;
        return type;
    };
    /**
     * Get the item type - visualizations are of type 'block' and inputs are of type 'input'
     * @method getItemType
     * @param {String} itemId item id
     * @returns {String} 'block' or 'input'
     */
    DashboardDefinition.prototype.getItemType = function (itemId) {
        return this.getInput(itemId) ? 'input' : 'block';
    };
    /**
     * Makes a best guess try to determine a good position for a new item in absolute/grid layouts
     * @method addLayoutItem
     * @param {Object} config
     * @param {String} config.visualizationId The id for a visualization which already has a configuration in the definition
     * @param {Object} config.vizContract Metadata defining the default size properties for a viz. Usually defined by presets.
     */
    DashboardDefinition.prototype.addLayoutItem = function (_a) {
        var _b = _a === void 0 ? {} : _a, visualizationId = _b.visualizationId, vizContract = _b.vizContract;
        // Tell us what we are adding!
        if (!visualizationId) {
            throw new SyntaxError('No visualization id supplied');
        }
        // Check that this exists
        var viz = this.getVisualization(visualizationId);
        if (!viz) {
            throw new ReferenceError('Visualization does not exist');
        }
        // Make sure we support this layout structure
        var layoutType = this.getLayoutType();
        if (layoutType !== 'grid' && layoutType !== 'absolute') {
            throw new TypeError(layoutType + " is not supported by this api");
        }
        // Don't add the same thing to the structure twice
        var layoutItems = this.getLayoutStructure();
        if (layoutItems.find(function (li) { return li.item === visualizationId; })) {
            throw new Error(visualizationId + " is already in the layout structure");
        }
        var layoutOptions = this.getLayoutOptions();
        var canvasWidth = get_1.default(layoutOptions, 'width', layout_1.DEFAULT_CANVAS_WIDTH);
        var item = null;
        if (layoutType === 'grid') {
            item = layout_1.computeNewGridStructureItem({
                canvasWidth: canvasWidth,
                layoutItems: layoutItems,
                itemId: visualizationId,
            });
        }
        else {
            // No way around fetching the preset type for this. Lines are special.
            var isLine = get_1.default(viz, 'type') === 'abslayout.line';
            var canvasHeight = get_1.default(layoutOptions, 'height', layout_1.DEFAULT_CANVAS_HEIGHT);
            item = layout_1.computeNewAbsoluteStructureItem({
                itemId: visualizationId,
                type: isLine ? 'line' : 'block',
                canvasWidth: canvasWidth,
                canvasHeight: canvasHeight,
                vizContract: vizContract,
                layoutItems: layoutItems,
            });
        }
        this.updateLayoutStructure(__spread(layoutItems, [item]));
        return this;
    };
    /**
     * Parses out all static tokens defined in defaults, and removes any in reserved namespaces
     * @param {Set} reservedNamespaces The list of namespaces the user may NOT override
     * @returns {ResolvedTokenNamespaces} a tokenBinding
     */
    DashboardDefinition.prototype.getDefaultStaticTokens = function (reservedNamespaces) {
        var _a;
        if (reservedNamespaces === void 0) { reservedNamespaces = new Set(); }
        var tokenDefaults = (_a = this.getDefaults()) === null || _a === void 0 ? void 0 : _a.tokens;
        var tokens = {};
        if (!tokenDefaults) {
            return tokens;
        }
        Object.keys(tokenDefaults).forEach(function (namespace) {
            var _a;
            if (!reservedNamespaces.has(namespace)) {
                (_a = tokens[namespace]) !== null && _a !== void 0 ? _a : (tokens[namespace] = {});
                Object.keys(tokenDefaults[namespace]).forEach(function (token) {
                    if (typeof tokenDefaults[namespace][token].value ===
                        'string') {
                        // TODO: typescript is not figuring out types correctly here
                        tokens[namespace][token] = tokenDefaults[namespace][token].value;
                    }
                });
            }
        });
        return tokens;
    };
    return DashboardDefinition;
}());
exports.default = DashboardDefinition;


/***/ }),
/* 6 */
/***/ (function(module, exports) {

module.exports = require("lodash/find");

/***/ }),
/* 7 */
/***/ (function(module, exports) {

module.exports = require("lodash/omit");

/***/ }),
/* 8 */
/***/ (function(module, exports) {

module.exports = require("lodash/get");

/***/ }),
/* 9 */
/***/ (function(module, exports) {

module.exports = require("lodash/isString");

/***/ }),
/* 10 */
/***/ (function(module, exports) {

module.exports = require("lodash/isPlainObject");

/***/ }),
/* 11 */
/***/ (function(module, exports) {

module.exports = require("lodash/isEqual");

/***/ }),
/* 12 */
/***/ (function(module, exports) {

module.exports = require("lodash/defaultsDeep");

/***/ }),
/* 13 */
/***/ (function(module, exports) {

module.exports = require("lodash/memoize");

/***/ }),
/* 14 */
/***/ (function(module, exports) {

module.exports = require("lodash/keyBy");

/***/ }),
/* 15 */
/***/ (function(module, exports) {

module.exports = require("lodash/pickBy");

/***/ }),
/* 16 */
/***/ (function(module, exports) {

module.exports = require("@splunk/dashboard-utils/uniqueId");

/***/ }),
/* 17 */
/***/ (function(module, exports) {

module.exports = require("@splunk/dashboard-utils/layout");

/***/ }),
/* 18 */
/***/ (function(module, exports) {

module.exports = require("@splunk/dashboard-utils/search");

/***/ }),
/* 19 */
/***/ (function(module, exports) {

module.exports = require("@splunk/dashboard-utils");

/***/ }),
/* 20 */
/***/ (function(module, exports) {

module.exports = require("@splunk/ui-utils/i18n");

/***/ }),
/* 21 */
/***/ (function(module, exports) {

module.exports = require("ajv");

/***/ }),
/* 22 */
/***/ (function(module, exports) {

module.exports = require("fast-json-patch");

/***/ })
/******/ ]);
//# sourceMappingURL=DashboardDefinition.js.map
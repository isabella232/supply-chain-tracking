import type { DashboardDefaultsDefinition, DashboardJSON, DataSourceDefinition, DataSourceOptions, EventHandlerDefinition, InputDefinition, LayoutOptions, ResolvedTokenNamespaces, RootDataSourcesDefinition, RootVisualizationsDefinition, StructureItem, TimeRange, VisualizationDefinition, VizContract } from '@splunk/dashboard-types';
import type { ErrorObject, ValidateFunction, JSONSchemaType } from 'ajv';
import { compare } from 'fast-json-patch';
declare type ValidationErrors = Partial<ErrorObject>[];
interface UpdateDashboardArgs {
    title?: string;
    desc?: string;
}
declare type CollectionType = 'visualizations' | 'dataSources' | 'inputs';
interface NewDataSourceConnectionArgs {
    dataSourceType: string;
    dataSourceDefinition: DataSourceDefinition;
}
interface ConnectNewDataSourceToVisualizationArgs extends NewDataSourceConnectionArgs {
    vizId: string;
}
interface ConnectNewDataSourceToInputArgs extends NewDataSourceConnectionArgs {
    inputId: string;
}
interface ConnectNewDataSourceToItemArgs extends NewDataSourceConnectionArgs {
    itemId: string;
}
interface ExistingDataSourceConnectionArgs {
    dataSourceType: string;
    dataSourceId: string;
}
interface DataSourceToVisualizationArgs extends ExistingDataSourceConnectionArgs {
    vizId: string;
}
interface DataSourceToInputArgs extends ExistingDataSourceConnectionArgs {
    inputId: string;
}
interface DataSourceToItemArgs extends ExistingDataSourceConnectionArgs {
    itemId: string;
    type?: 'input' | 'block';
}
declare type ChainSearchDefinitionList = {
    id: string;
    config: DataSourceDefinition | null;
}[];
interface AddLayoutItemArgs {
    visualizationId?: string;
    vizContract?: VizContract;
}
/**
 * A utility module to convert layout structure from array to object in dashboard definition.
 * This module is needed when generating meaningful json patches.
 * @private
 * @param {Object} def dashboard definition json object
 */
export declare const normalizeLayoutStructure: (def: DashboardJSON) => Pick<DashboardJSON, "title" | "description" | "dataSources" | "visualizations" | "inputs" | "version" | "defaults"> & {
    layout: {
        structure: Record<string, StructureItem>;
    };
};
export declare const GLOBAL_TRP_TOKEN_NAME = "global_time";
export declare const DEFAULT_DEFINITION: DashboardJSON;
/**
 * Fetch a flattened set of global defaults for the given type
 * @param {Object} defaults The object containing default configurations
 * @param {String} type The type of dataSource to search for specific configurations
 * @returns {Object} Result of flattening global and specific configurations
 * @private
 */
export declare const getDefaultOptionsForDataSourceType: (defaults?: DashboardDefaultsDefinition | undefined, type?: string | undefined) => DataSourceOptions;
/**
 * Generate a unique id given a prefix and a search function to verify uniqueness
 * @param {String} prefix The prefix of the id (viz, ds, input, etc)
 * @param {Function} searchFn A function that can search the definition to detect if an id is used, default return first id
 * @returns {String} A "guaranteed" unique id
 */
export declare const generateId: (prefix: string, searchFn?: (nextId: string) => unknown | null) => string;
/**
 * Search for a key or string that matches the provided key
 * @param {Object} definition The haystack to search for an id in
 * @param {String} newId The key to search for
 * @returns {Boolean}
 */
export declare const hasDuplicateId: (definition: DashboardJSON, newId: string) => boolean;
declare type VisualizationDefaults = Pick<VisualizationDefinition, 'showLastUpdated' | 'showProgressBar' | 'context'>;
/**
 * Obtain the global defaults for all visualizations
 * @param {DefinitionJSON.defaults} defaults The defaults configuration for the dashboard
 * @returns {Object} Shared context and flags
 */
export declare const getGlobalDefaultsForVisualizations: (defaults: DashboardDefaultsDefinition) => VisualizationDefaults;
declare type VisualizationTypeDefaults = Partial<VisualizationDefaults> & {
    options?: Record<string, unknown>;
};
/**
 * Fetch the defaults for the given viz type. Note: this does not flatten with global defaults for all viz
 * @param {DashboardJSON.defaults} defaults Default configuration
 * @param {String} type The type of visualization
 * @return {Object} Shared context, options, and flags
 */
export declare const getDefaultsForVisualizationType: (defaults: DashboardDefaultsDefinition, type: string) => VisualizationTypeDefaults;
/**
 * A dashboard definition helper class
 * @class DashboardDefinition
 */
declare class DashboardDefinition {
    private definition;
    validateDefinition: ValidateFunction;
    /**
     * Creates a new DashboardDefinition based on input def
     * @method fromJSON
     * @param {Object} [def] A dashboard definition
     * @returns {DashboardDefinition}
     * @static
     */
    static fromJSON(def?: DashboardJSON): DashboardDefinition;
    /**
     * @param {Object} dataSources Datasources from dashboard definition
     * @param {Object} defaults Defaults from dashboard definition
     * @return {Object} Flattened data sources with the default options.
     */
    static flattenDataSources(dataSources: RootDataSourcesDefinition, defaults: DashboardDefaultsDefinition): RootDataSourcesDefinition;
    /**
     * Returns a configuration for all visualizations with global defaults flattened in
     * @param {Object} visualizations Visualizations from dashboard definition
     * @param {Object} defaults Defaults from the dashboard definition
     * @return {Object} Flattened visualizations with the global context, options, and flags
     */
    static flattenVisualizations(visualizations: RootVisualizationsDefinition, defaults: DashboardDefaultsDefinition): RootVisualizationsDefinition;
    /**
     * Creates a new DashboardDefinition based on input def
     * @param {Object} [def] A dashboard definition
     * @returns {DashboardDefinition}
     * @constructor
     */
    constructor(def?: DashboardJSON);
    /**
     * set up customized schema
     * @method setSchema
     * @param {Object} newSchema
     * @returns {Object} error
     */
    setSchema(newSchema: JSONSchemaType<DashboardJSON>): Error | null;
    /**
     * check duplication of inputs tokens
     * @method checkDuplicateTokens
     * @returns {Array} errors
     */
    checkDuplicateTokens(): ValidationErrors;
    checkVisualizationsInStructure(): ValidationErrors;
    checkInputsInStructure(): ValidationErrors;
    /**
     * Validates the current definition
     * @method validate
     * @returns {Array} list of errors, or null
     */
    validate(): ErrorObject[] | ValidationErrors | null;
    /**
     * Update the dashboard title or description
     * @method updateDashboard
     * @param {String} title The new title
     * @param {String} desc The new description
     * @returns {DashboardDefinition}
     */
    updateDashboard({ title, desc }: UpdateDashboardArgs): DashboardDefinition;
    /**
     * Add a new datasource configuration
     * @method addDataSource
     * @param {String} dsId     The key to identify the datasource
     * @param {Object} dsDef    The configuration
     * @returns {DashboardDefinition}
     */
    addDataSource(dsId: string, dsDef?: DataSourceDefinition): DashboardDefinition;
    /**
     * Add a visualization configuration to the definition
     * @method addVisualization
     * @param {String} vizId    The key to identify the vis
     * @param {Object} vizDef   The configuration of the vis
     * @returns {DashboardDefinition}
     */
    addVisualization(vizId: string, vizDef?: VisualizationDefinition): DashboardDefinition;
    /**
     * Add an input config to the definition
     * @method addInput
     * @param {String} inputId      Key to identify the input
     * @param {Object} [inputDef]     The input config
     * @returns {DashboardDefinition}
     */
    addInput(inputId: string, inputDef?: InputDefinition): DashboardDefinition;
    /**
     * Adds a new input to the global inputs array
     * @param {String} inputId The id for the input
     * @returns {DashboardDefinition}
     */
    addInputToLayout(inputId: string): DashboardDefinition;
    /**
     * removes the input from the global inputs array
     * @param {String} inputId The inputId to remove
     * @returns {DashboardDefinition}
     */
    removeInputFromLayout(inputId: string): DashboardDefinition;
    /**
     * Sets global inputs to passed array
     * @param {String[]} newGlobalInputs Array of input ids
     * @returns {DashboardDefinition}
     */
    updateGlobalInputs(newGlobalInputs?: string[]): DashboardDefinition;
    /**
     * Clones a datasource configuration
     * @method cloneDataSource
     * @param {String} dsId     Key to identify datasource
     * @returns {String} The newly created DatasourceId
     */
    cloneDataSource(dsId: string): string | null;
    /**
     * Clones a Visualization configuration
     * @method cloneVisualization
     * @param {String} vizId     Key to identify Viz
     * @param {String} newVizId  Key for new cloned Viz
     * @returns {String} The newly created VizId
     */
    cloneVisualization(vizId: string, newVizId?: string): string | null;
    /**
     * Removes a datasource configuration
     * @method removeDataSource
     * @param {String} dsId     Key to identify datasource
     * @returns {DashboardDefinition}
     */
    removeDataSource(dsId: string): DashboardDefinition;
    /**
     * Removes a visualization configuration
     * @method removeVisualization
     * @param {String} vizId key to identify visualization
     * @returns {DashboardDefinition}
     */
    removeVisualization(vizId: string): DashboardDefinition;
    /**
     * Removes an input configuration
     * @method removeInput
     * @param {String} inputId key to identify input
     * @returns {DashboardDefinition}
     */
    removeInput(inputId: string): DashboardDefinition;
    /**
     * Update the layout to a different type
     * @method updateLayoutType
     * @param {String} type     Layout type, e.g. grid, absolute
     * @returns {DashboardDefinition}
     */
    updateLayoutType(type: string): DashboardDefinition;
    /**
     * Replaces current layout options config
     * @method updateLayoutOptions
     * @param {Object} layoutOptions Options object to replace existing def
     * @returns {DashboardDefinition}
     */
    updateLayoutOptions(layoutOptions: LayoutOptions): DashboardDefinition;
    /**
     * Replace current structure with a new one
     * @method updateLayoutStructure
     * @param {Array} newStructure List of vis layout item position data
     * @returns {DashboardDefinition}
     */
    updateLayoutStructure(newStructure: unknown): DashboardDefinition;
    /**
     * Replace a visualization config
     * @method updateVisualization
     * @param {String} vizId  key to identify vis
     * @param {Object} vizDef Visualization definition
     * @returns {DashboardDefinition}
     */
    updateVisualization(vizId: string, vizDef?: VisualizationDefinition): DashboardDefinition;
    /**
     * Replaces existing datasource config
     * @method updateDataSource
     * @param {String} dsId     key to identify datasource
     * @param {Object} [dsDef]    The datasource definition
     * @returns {DashboardDefinition}
     */
    updateDataSource(dsId: string, dsDef?: DataSourceDefinition): DashboardDefinition;
    /**
     * Replaces existing input config
     * @method updateInput
     * @param {String} inputId key to identify input
     * @param {Object} inputDef New input config
     * @returns {DashboardDefinition}
     */
    updateInput(inputId: string, inputDef?: InputDefinition): DashboardDefinition;
    /**
     * Return the JSON representation of the dashboard
     * @method toJSON
     * @returns {Object}
     */
    toJSON(): DashboardJSON;
    /**
     * Get the current layout structure
     * @method getLayoutStructure
     * @returns {Array} The current structure
     */
    getLayoutStructure(): unknown[];
    /**
     * return current layout type
     */
    getLayoutType(): string;
    /**
     * Return the current options for the layout
     * @method getLayoutOptions
     * @returns {Object}
     */
    getLayoutOptions(): LayoutOptions;
    /**
     * Fetch the current definition for a visualization by id
     * @method getVisualization
     * @param {String} visId    The identifier for the vis
     * @returns {Object} The vis definition, or null if not found
     */
    getVisualization(visId: string): VisualizationDefinition | null;
    /**
     * Fetch the current definition for a visualization by id with all the global defaults flattened in
     * @param {String} vizId The identifier for the visualization
     * @returns {Object} The viz definition, or null if not found.
     */
    getVisualizationWithFlattenedDefaults(vizId: string): VisualizationDefinition | null;
    /**
     * Fetch all the visualization ids
     * @method getVisualizationIds
     * @returns {Array} All the Viz Ids
     */
    getVisualizationIds(): string[];
    /**
     * Fetch the current definition for a datasource by id
     * @param {String} dsId
     * @returns {Object} The datasource definition, or null if not found
     */
    getDataSource(dsId: string): DataSourceDefinition | null;
    /**
     * Returns true if datasource can be a base datasource for a chain datasource
     * @param {String} dsId
     * @param {Number} count
     * @returns {Boolean}
     */
    canBeBaseDataSource(dsId: string, count?: number): boolean;
    /**
     * Returns datasources which can be a base datasource for a chain datasource
     * @returns {Object} Map of objects of form { dataSourceId: dataSourceDefinition }
     */
    getBaseDataSources(): RootDataSourcesDefinition;
    /**
     * Fetch the default options for a datasource by id
     * @param {String} dsId
     * @returns {Object} The datasource default options
     */
    getDataSourceDefaultOptions(dsId: string): DataSourceOptions | null;
    /**
     * Get an input configuration for the provided id
     * @param {String} inputId The id for the desired input
     * @returns {Object} Returns config or null if not found
     */
    getInput(inputId: string): InputDefinition | null;
    /**
     * Get the list of displayed inputs in the global input area
     * @returns {String[]}
     */
    getGlobalInputs(): string[];
    /**
     * Get an input that uses the provided token
     * @param {String} tokenId The token to look for
     * @returns {Object} The config for the first input that sets data with the provided token
     */
    getInputByToken(tokenId?: string): InputDefinition | null;
    /**
     * Get the type for the given visualization
     * @method getVisualizationType
     * @param {String} visId key to identify visualization
     * @returns {String}
     */
    getVisualizationType(visId: string): VisualizationDefinition | null;
    /**
     * return event handler array
     * @param {String} hostId node id, can be searchId, vizId or inputId
     * @param {String} [type='visualizations'] can be visualizations, dataSources or inputs
     */
    getEventHandlers(hostId?: string, type?: CollectionType): EventHandlerDefinition[];
    /**
     *
     * @param {String} hostId node id, can be search id, viz id or input id
     * @param {Object} handler eventhandler
     * @param {String} [type='visualizations'] can be visualizations, dataSources or inputs
     */
    createEventHandler(hostId: string, handler: EventHandlerDefinition, type?: CollectionType): DashboardDefinition;
    /**
     *
     * @param {String} hostId node id, can be search id, viz id or input id
     * @param {Number} handlerIdx handler index
     * @param {String} [type='visualizations'] can be visualizations, dataSources or inputs
     */
    removeEventHandler(hostId: string, handlerIdx?: number, type?: CollectionType): DashboardDefinition;
    /**
     *
     * @param {String} hostId node id, can be search id, viz id or input id
     * @param {Number} [handlerIdx=0] handler index
     * @param {Object} [handler={}] new handler
     * @param {String} [type='visualizations'] can be visualizations, dataSources or inputs
     */
    editEventHandler(hostId: string, handlerIdx?: number, handler?: EventHandlerDefinition, type?: CollectionType): DashboardDefinition;
    /**
     * connect a visualization with new datasource
     * @param {Object} params
     * @param {String} params.vizId visualization id
     * @param {String} params.dataSourceType dataSource binding type such as primary, annotation
     * @param {Object} params.dataSourceDefinition dataSource definition
     */
    connectNewDataSourceToVisualization({ vizId, dataSourceType, dataSourceDefinition, }: ConnectNewDataSourceToVisualizationArgs): DashboardDefinition;
    /**
     * connect an input with new datasource
     * @param {Object} params
     * @param {String} params.inputId inputId id
     * @param {String} params.dataSourceType dataSource binding type such as primary, annotation
     * @param {Object} params.dataSourceDefinition dataSource definition
     */
    connectNewDataSourceToInput({ inputId, dataSourceType, dataSourceDefinition, }: ConnectNewDataSourceToInputArgs): DashboardDefinition;
    /**
     * connect an item with a new datasource
     * @param {Object} params
     * @param {String} params.itemId item id
     * @param {String} params.dataSourceType dataSource binding type such as primary, annotation
     * @param {Object} params.dataSourceDefinition dataSource definition
     */
    connectNewDataSourceToItem({ itemId, dataSourceType, dataSourceDefinition, }: ConnectNewDataSourceToItemArgs): DashboardDefinition;
    /**
     * connect a visualization with existing datasource
     * @param {Object} params
     * @param {String} params.vizId visualization id
     * @param {String} params.dataSourceType dataSource binding type such as primary, annotation
     * @param {String} params.dataSourceId existing datasource id
     */
    connectDataSourceToVisualization({ vizId, dataSourceType, dataSourceId, }: DataSourceToVisualizationArgs): DashboardDefinition;
    /**
     * connect an input with existing datasource
     * @param {Object} params
     * @param {String} params.inputId input id
     * @param {String} params.dataSourceType dataSource binding type such as primary, annotation
     * @param {String} params.dataSourceId existing datasource id
     */
    connectDataSourceToInput({ inputId, dataSourceType, dataSourceId, }: DataSourceToInputArgs): DashboardDefinition;
    /**
     * connect an item with existing datasource
     * @param {Object} params
     * @param {String} params.itemId item id
     * @param {String} params.dataSourceType dataSource binding type such as primary, annotation
     * @param {String} params.dataSourceId existing datasource id
     * @param {String} [params.type=block] type of item such as 'block', 'input'
     */
    connectDataSourceToItem({ itemId, dataSourceType, dataSourceId, type, }: DataSourceToItemArgs): DashboardDefinition;
    /**
     * disconnect a visualization from existing datasource
     * @param {Object} params
     * @param {String} params.vizId visualization id
     * @param {String} params.dataSourceType dataSource binding type such as primary, annotation
     * @param {String} params.dataSourceId existing datasource id
     */
    disconnectDataSourceFromVisualization({ vizId, dataSourceType, dataSourceId, }: DataSourceToVisualizationArgs): DashboardDefinition;
    /**
     * disconnect an input from existing datasource
     * @param {Object} params
     * @param {String} params.inputId input id
     * @param {String} params.dataSourceType dataSource binding type such as primary, annotation
     * @param {String} params.dataSourceId existing datasource id
     */
    disconnectDataSourceFromInput({ inputId, dataSourceType, dataSourceId, }: DataSourceToInputArgs): DashboardDefinition;
    /**
     * disconnect item from an existing datasource
     * @param {Object} params
     * @param {String} params.itemId item id
     * @param {String} params.dataSourceType dataSource binding type such as primary, annotation
     * @param {String} params.dataSourceId existing datasource id
     */
    disconnectDataSourceFromItem({ itemId, dataSourceType, dataSourceId, }: DataSourceToItemArgs): DashboardDefinition;
    /**
     * generate visualization id
     */
    nextVisualizationId(): string;
    /**
     * generate datasource id
     */
    nextDataSourceId(): string;
    /**
     * generate input id
     */
    nextInputId(): string;
    /**
     * generate token id
     */
    nextTokenId(prefix?: string): string;
    /**
     * Returns the number of Visualizations using the Data Source with passed in dsId
     * @method countVisualizationsUsingDataSource
     * @param {String} dsId     Key to identify datasource
     * @returns {Number}
     */
    countVisualizationsUsingDataSource(dsId: string): number;
    /**
     * Returns the number of Inputs using the Data Source with passed in dsId
     * @method countInputsUsingDataSource
     * @param {String} dsId     Key to identify datasource
     * @returns {Number}
     */
    countInputsUsingDataSource(dsId: string): number;
    /**
     * Returns the Data Sources of chain searches using the Data Source with passed in dsId
     * @method getChainSearchesUsingDataSource
     * @param {String} dsId     Key to identify datasource
     * @param {Number} count     running count of current chain length
     * @returns {Array} List of object of form { id: dsId, config: ds} which are descendants of Data Source with dsId with max length of MAX_CHAIN_LENGTH
     */
    getChainSearchesUsingDataSource(dsId: string, count?: number): ChainSearchDefinitionList;
    /**
     * Disconnects a dataSource from all visualizations and inputs in the definition
     * @method disconnectDataSource
     * @param {String} dataSourceId     Key to identify datasource
     * @returns {DashboardDefinition}
     */
    disconnectDataSource(dataSourceId: string): DashboardDefinition;
    /**
     * Search for a key or string that matches the provided key
     * @param {String} newId The key to search for
     * @returns {Boolean}
     */
    hasDuplicateId(newId: string): boolean;
    /**
     * Converts all instances of an old id to a new id
     * @param {String} oldId The original string to replace
     * @param {String} newId The new string to add
     * @return {Boolean} To show success/fail
     */
    updateComponentId(oldId: string, newId: string): boolean;
    /**
     * Compare two definitions to generate json patches.
     * @param {DashboardDefinition} other another instance of DashboardDefinition
     * @returns {object[]}
     */
    compare(other: DashboardDefinition): ReturnType<typeof compare>;
    /**
     * Get the id of first time range input
     * @public
     */
    getFirstTimeRangeInputId(): string;
    /**
     * Get defaults
     * @returns {Object} dashboard defaults
     * @public
     */
    getDefaults(): DashboardDefaultsDefinition;
    /**
     * Get default time range when create a new `ds.search` data source. The rule is:
     * 1. use `defaults` section from the definition if available.
     * 2. use the first time range input token if available
     * 3. use static time range `Last 24 hours`
     * @returns {Object} earliest and latest
     */
    getDefaultTimeRangeForNewSearch(): TimeRange;
    /**
     * Get the visualization layout type - block/line
     * @method getVisualizationLayoutType
     * @param {String} vizId Key to identify visualization
     * @returns {String} The viz layout type - line/block, or block if type is not found
     */
    getVisualizationLayoutType(vizId: string): string;
    /**
     * Get the item type - visualizations are of type 'block' and inputs are of type 'input'
     * @method getItemType
     * @param {String} itemId item id
     * @returns {String} 'block' or 'input'
     */
    getItemType(itemId: string): 'input' | 'block';
    /**
     * Makes a best guess try to determine a good position for a new item in absolute/grid layouts
     * @method addLayoutItem
     * @param {Object} config
     * @param {String} config.visualizationId The id for a visualization which already has a configuration in the definition
     * @param {Object} config.vizContract Metadata defining the default size properties for a viz. Usually defined by presets.
     */
    addLayoutItem({ visualizationId, vizContract, }?: AddLayoutItemArgs): DashboardDefinition;
    /**
     * Parses out all static tokens defined in defaults, and removes any in reserved namespaces
     * @param {Set} reservedNamespaces The list of namespaces the user may NOT override
     * @returns {ResolvedTokenNamespaces} a tokenBinding
     */
    getDefaultStaticTokens(reservedNamespaces?: Set<string>): ResolvedTokenNamespaces;
}
export default DashboardDefinition;
//# sourceMappingURL=DashboardDefinition.d.ts.map
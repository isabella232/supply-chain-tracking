/*!
 * Copyright © 2018 Splunk Inc.
 * SPLUNK CONFIDENTIAL – Use or disclosure of this material in whole or
 * in part without a valid written license from Splunk Inc. is PROHIBITED.
 */
module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 3);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = __webpack_require__(1);

var __rest = this && this.__rest || function (s, e) {
  var t = {};

  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.otherValueReplacements = exports.migrateChartingOptions = exports.migrateBaseChartingVizDefinition = void 0;

var encoding_1 = __webpack_require__(2);
/**
 *  map of splunk charting based @splunk/dashboard-visualization option names
 *  to updated @splunk/visualization option names
 */


var optionRenames = {
  'axisTitleX.text': 'xAxisTitleText',
  'axisTitleY.text': 'yAxisTitleText',
  'axisTitleY2.text': 'y2AxisTitleText',
  'axisTitleX.visibility': 'xAxisTitleVisibility',
  'axisTitleY.visibility': 'yAxisTitleVisibility',
  'axisTitleY2.visibility': 'y2AxisTitleVisibility',
  'axisLabelsX.majorLabelStyle.rotation': 'xAxisLabelRotation',
  'axisLabelsX.majorLabelVisibility': 'xAxisLabelVisibility',
  'axisLabelsY.majorLabelVisibility': 'yAxisLabelVisibility',
  'axisLabelsY2.majorLabelVisibility': 'y2AxisLabelVisibility',
  'axisLabelsX.majorTickVisibility': 'xAxisMajorTickVisibility',
  'axisLabelsY.majorTickVisibility': 'yAxisMajorTickVisibility',
  'axisLabelsY2.majorTickVisibility': 'y2AxisMajorTickVisibility',
  'axisLabelsX.minorTickVisibility': 'xAxisMinorTickVisibility',
  'axisLabelsY.minorTickVisibility': 'yAxisMinorTickVisibility',
  'axisLabelsY2.minorTickVisibility': 'y2AxisMinorTickVisibility',
  'axisLabelsX.majorTickSize': 'xAxisMajorTickSize',
  'axisLabelsY.majorTickSize': 'yAxisMajorTickSize',
  'axisLabelsY2.majorTickSize': 'y2AxisMajorTickSize',
  'axisLabelsX.minorTickSize': 'xAxisMinorTickSize',
  'axisLabelsY.minorTickSize': 'yAxisMinorTickSize',
  'axisLabelsY2.minorTickSize': 'y2AxisMinorTickSize',
  'axisLabelsX.majorUnit': 'xAxisMajorTickInterval',
  'axisLabelsY.majorUnit': 'yAxisMajorTickInterval',
  'axisLabelsY2.majorUnit': 'y2AxisMajorTickInterval',
  'axisX.abbreviation': 'xAxisAbbreviation',
  'axisY.abbreviation': 'yAxisAbbreviation',
  'axisY2.abbreviation': 'y2AxisAbbreviation',
  'axisLabelsX.integerUnits': 'showRoundedXAxisLabels',
  'axisLabelsY2.integerUnits': 'showRoundedY2AxisLabels',
  'axisLabelsX.maxLabelParts': 'xAxisMaxLabelParts',
  'axisLabelsX.axisVisibility': 'xAxisLineVisibility',
  'axisLabelsY.axisVisibility': 'yAxisLineVisibility',
  'axisLabelsY2.axisVisibility': 'y2AxisLineVisibility',
  'gridLinesX.showMajorLines': 'showXMajorGridLines',
  'gridLinesY.showMajorLines': 'showYMajorGridLines',
  'gridLinesX.showMinorLines': 'showXMinorGridLines',
  'gridLinesY.showMinorLines': 'showYMinorGridLines',
  'gridLinesY2.showMajorLines': 'showY2MajorGridLines',
  'gridLinesY2.showMinorLines': 'showY2MinorGridLines',
  'axisX.scale': 'xAxisScale',
  'axisY.scale': 'yAxisScale',
  'axisY2.scale': 'y2AxisScale',
  'axisX.maximumNumber': 'xAxisMax',
  'axisY.maximumNumber': 'yAxisMax',
  'axisY2.maximumNumber': 'y2AxisMax',
  'axisX.minimumNumber': 'xAxisMin',
  'axisY.minimumNumber': 'yAxisMin',
  'axisY2.minimumNumber': 'y2AxisMin',
  'axisX.includeZero': 'showXAxisWithZero',
  'axisY.includeZero': 'showYAxisWithZero',
  'axisY2.includeZero': 'showY2AxisWithZero',
  'axisLabelsX.extendsAxisRange': 'showXAxisExtendedRange',
  'axisLabelsY.extendsAxisRange': 'showYAxisExtendedRange',
  'layout.splitSeries': 'showSplitSeries',
  'layout.splitSeries.allowIndependentYRanges': 'showIndependentYRanges',
  'axisY2.enabled': 'showOverlayY2Axis',
  'axisY2.fields': 'y2Fields',
  'chart.overlayFields': 'overlayFields',
  'legend.labels': 'legendLabels',
  'legend.labelStyle.overflowMode': 'legendTruncation',
  'legend.mode': 'legendMode',
  'legend.placement': 'legendDisplay',
  'chart.nullValueMode': 'nullValueDisplay',
  'chart.showDataLabels': 'dataValuesDisplay',
  fieldColors: 'seriesColorsByField',
  'chart.resultTruncationLimit': 'resultLimit',
  'chart.stackMode': 'stackMode',
  'chart.barSpacing': 'barSpacing',
  'chart.columnSpacing': 'columnSpacing',
  'chart.seriesSpacing': 'seriesSpacing',
  'chart.sliceCollapsingLabel': 'collapseLabel',
  'chart.sliceCollapsingThreshold': 'collapseThreshold',
  hasDonutHole: 'showDonutHole',
  // area specific mapped options
  areaFillOpacity: 'areaOpacity',
  'chart.showLines': 'showLines',
  // bubble specific mapped options
  'chart.bubbleMinimumSize': 'bubbleSizeMin',
  'chart.bubbleMaximumSize': 'bubbleSizeMax',
  'chart.bubbleSizeBy': 'bubbleSizeMethod',
  // line specific mapped options
  fieldDashStyles: 'lineDashStylesByField',
  'chart.showMarkers': 'markerDisplay',
  // scatter-specific options
  'chart.markerSize': 'markerSize'
};
var visibilityEnumReplacements = {
  visible: 'show',
  collapsed: 'hide'
};
var modeEnumReplacements = {
  none: 'off'
};
/**
 * for some options the valid values changed.
 * this maps enum values that need to be changed
 */

var enumReplacements = {
  xAxisTitleVisibility: visibilityEnumReplacements,
  yAxisTitleVisibility: visibilityEnumReplacements,
  y2AxisTitleVisibility: visibilityEnumReplacements,
  xAxisAbbreviation: modeEnumReplacements,
  yAxisAbbreviation: modeEnumReplacements,
  y2AxisAbbreviation: modeEnumReplacements,
  dataValuesDisplay: modeEnumReplacements,
  legendDisplay: modeEnumReplacements,
  legendTruncation: {
    ellipsisNone: 'ellipsisOff'
  },
  stackMode: {
    default: 'auto'
  }
}; // splits a string with multiple fields separated by comma
// returns the same value if it's already an array

var splitValue = function splitValue(oldValue) {
  return Array.isArray(oldValue) ? oldValue : oldValue.split(',');
};
/**
 * converts stringified objects into plain objects
 *
 * @param {string | Object} oldValue stringified object to parse
 * @returns {Object}
 */


var parseObjects = function parseObjects(oldValue) {
  if (_typeof(oldValue) === 'object' && !Array.isArray(oldValue)) {
    return oldValue;
  }

  var nuValue = {};

  try {
    nuValue = JSON.parse(oldValue);
  } catch (e) {
    /* noop */
  }

  return nuValue;
};
/**
 * some option values require special processing
 * (e.g. if the type of the updated option changed)
 * "legendLabels": "test,test2" => "legendLabels": ["test", "test2"]
 */


var otherValueReplacements = {
  y2Fields: splitValue,
  overlayFields: splitValue,
  legendLabels: splitValue,
  seriesColorsByField: parseObjects,
  lineDashStylesByField: parseObjects,

  /**
   * the original markerDisplay was only exposed as `chart.showMarkers`
   * setting chart.showMarkers to true is the equivalent of `markerDisplay: 'outlined'`
   */
  markerDisplay: function markerDisplay(oldValue) {
    if (oldValue === false) return 'off';else if (oldValue === true) return 'outlined';
    return oldValue;
  }
};
exports.otherValueReplacements = otherValueReplacements;
/**
 * migrateChartingOptions
 * - renames option keys
 * - checks if enum values have changed for new options, replaces it
 * - checks if other replacements are necessary and applies them
 * @param {object} options dashboard-viz charting options
 * @returns {object} migratedOptions viz charting options
 */

var migrateChartingOptions = function migrateChartingOptions(options) {
  var migratedOptions = {};
  Object.keys(options).forEach(function (key) {
    var _a, _b, _c;

    var value = options[key];
    var updatedKey = (_a = optionRenames[key]) !== null && _a !== void 0 ? _a : key;
    var updatedValue = (_c = (_b = enumReplacements === null || enumReplacements === void 0 ? void 0 : enumReplacements[updatedKey]) === null || _b === void 0 ? void 0 : _b[value]) !== null && _c !== void 0 ? _c : value;

    if (otherValueReplacements[updatedKey]) {
      updatedValue = otherValueReplacements[updatedKey](updatedValue);
    }

    migratedOptions[updatedKey] = updatedValue;
  });
  return migratedOptions;
};

exports.migrateChartingOptions = migrateChartingOptions;
/**
 * helper that encapsulates shared migration logic across most charting-based viz
 * @param {Object} defaultChanges - map consistsing of default value changes from viz.* to splunk.*
 * @param {Object} validOptions - the list of options that the new splunk.* viz supports
 * @param {VisualizationDefinition} vizDefinition - the viz definition to migrate
 * @param {String} vizType - the value of splunk.*
 */

var migrateBaseChartingVizDefinition = function migrateBaseChartingVizDefinition(_ref) {
  var defaultChanges = _ref.defaultChanges,
      validOptions = _ref.validOptions,
      vizDefinition = _ref.vizDefinition,
      vizType = _ref.vizType;

  var _vizDefinition$encodi = vizDefinition.encoding,
      encoding = _vizDefinition$encodi === void 0 ? {} : _vizDefinition$encodi,
      _vizDefinition$option = vizDefinition.options,
      options = _vizDefinition$option === void 0 ? {} : _vizDefinition$option,
      otherDefinitionParts = __rest(vizDefinition, ["encoding", "options"]);

  var migratedDefinition = Object.assign(Object.assign({}, otherDefinitionParts), {
    type: vizType,
    options: {},
    context: {}
  }); // translate encoding to dynamic options equivalent

  var _encoding_1$encodingT = encoding_1.encodingToDynamicOptionsDSL(encoding),
      dataOptions = _encoding_1$encodingT.options,
      dataContext = _encoding_1$encodingT.context;

  var migratedOptions = Object.assign(Object.assign(Object.assign({}, defaultChanges), migrateChartingOptions(options)), dataOptions); // remove invalid options

  Object.keys(migratedOptions).forEach(function (key) {
    if (!validOptions[key]) {
      delete migratedOptions[key];
    }
  });
  migratedDefinition.options = migratedOptions;
  migratedDefinition.context = dataContext;
  return migratedDefinition;
};

exports.migrateBaseChartingVizDefinition = migrateBaseChartingVizDefinition;

/***/ }),
/* 1 */
/***/ (function(module, exports) {

module.exports = require("@babel/runtime/helpers/typeof");

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function get() {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __exportStar = this && this.__exportStar || function (m, exports) {
  for (var p in m) {
    if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
  }
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

__exportStar(__webpack_require__(7), exports);

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function get() {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __exportStar = this && this.__exportStar || function (m, exports) {
  for (var p in m) {
    if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
  }
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

__exportStar(__webpack_require__(4), exports);

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.inferToType = exports.canMigrate = exports.migrate = void 0;

var visualizations_1 = __webpack_require__(5);

var supportedMigrations = {
  'viz.area': {
    'splunk.area': visualizations_1.migrateVizToSplunkArea
  },
  'viz.bar': {
    'splunk.bar': visualizations_1.migrateVizToSplunkBar
  },
  'viz.bubble': {
    'splunk.bubble': visualizations_1.migrateVizToSplunkBubble
  },
  'viz.column': {
    'splunk.column': visualizations_1.migrateVizToSplunkColumn
  },
  'viz.line': {
    'splunk.line': visualizations_1.migrateVizToSplunkLine
  },
  'viz.pie': {
    'splunk.pie': visualizations_1.migrateVizToSplunkPie
  },
  'viz.scatter': {
    'splunk.scatter': visualizations_1.migrateVizToSplunkScatter
  }
};

var inferToType = function inferToType(typeFromDefinition) {
  if (typeFromDefinition === 'viz.img') {
    return 'splunk.image';
  }

  return typeFromDefinition.replace(/^viz\./, 'splunk.');
};

exports.inferToType = inferToType;

var migrate = function migrate(_ref) {
  var definition = _ref.definition,
      toTypeFromParams = _ref.toType;

  var _a;

  var toType = toTypeFromParams !== null && toTypeFromParams !== void 0 ? toTypeFromParams : inferToType(definition.type);

  if (!((_a = supportedMigrations === null || supportedMigrations === void 0 ? void 0 : supportedMigrations[definition === null || definition === void 0 ? void 0 : definition.type]) === null || _a === void 0 ? void 0 : _a[toType])) {
    throw new Error('Migration currently not supported');
  }

  return supportedMigrations[definition.type][toType](definition);
};

exports.migrate = migrate;

var canMigrate = function canMigrate(_ref2) {
  var fromType = _ref2.fromType,
      toType = _ref2.toType;

  var _a;

  if ((_a = supportedMigrations === null || supportedMigrations === void 0 ? void 0 : supportedMigrations[fromType]) === null || _a === void 0 ? void 0 : _a[toType]) {
    return true;
  }

  return false;
};

exports.canMigrate = canMigrate;

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function get() {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __exportStar = this && this.__exportStar || function (m, exports) {
  for (var p in m) {
    if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
  }
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

__exportStar(__webpack_require__(6), exports);

__exportStar(__webpack_require__(10), exports);

__exportStar(__webpack_require__(12), exports);

__exportStar(__webpack_require__(14), exports);

__exportStar(__webpack_require__(16), exports);

__exportStar(__webpack_require__(18), exports);

__exportStar(__webpack_require__(20), exports);

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.migrateVizToSplunkArea = void 0;

var splunk_charting_1 = __webpack_require__(0);

var Area_1 = __webpack_require__(9);

var validOptions = Object.assign({}, Area_1.config.optionsSchema); // old default configurations should be retained in migrated configuration

var defaultChanges = {
  yAxisAbbreviation: 'off',
  y2AxisAbbreviation: 'off',
  showRoundedY2AxisLabels: false,
  legendTruncation: 'ellipsisMiddle',
  showY2MajorGridLines: true
};

var migrateVizToSplunkArea = function migrateVizToSplunkArea(vizDefinition) {
  return splunk_charting_1.migrateBaseChartingVizDefinition({
    defaultChanges: defaultChanges,
    validOptions: validOptions,
    vizDefinition: vizDefinition,
    vizType: 'splunk.area'
  });
};

exports.migrateVizToSplunkArea = migrateVizToSplunkArea;

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = __webpack_require__(1);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.encodingToDynamicOptionsDSL = void 0;

var Base_1 = __webpack_require__(8); // @TODO(pwied): move the parsing helpers so we can deprecate visualization-encoding-parsers package
// index based references are defined by <dataSource>[<index>]
// this regex matches <text with numbers>[<anything>]
// the "[" "]" part makes it an index based reference


var indexBasedRegx = /^[A-Za-z0-9_]+\[.*\].*$/; // name based references are defined by <dataSource>.<columnName>
// the "." access makes it a name based reference

var nameBasedRegx = /^[A-Za-z0-9_]+\..*$/;

var isIndexBasedReference = function isIndexBasedReference(ref) {
  return indexBasedRegx.test(ref);
};

var isNameBasedReference = function isNameBasedReference(ref) {
  return nameBasedRegx.test(ref);
};
/**
 * Translates encoding data selections in array format
 *
 * Note:
 * 'frameBySeriesIndexes' only supports positive indexes
 *
 * Examples:
 * 1. all index based selection
 * ['primary[0]', 'primary[1]'] => '> primary | frameBySeriesIndexes(0,1)'
 *
 * 2. all name based selection
 * ['primary.foo', 'primary.bar'] => '> primary | frameBySeriesNames("foo","bar")'
 *
 * 3. index or name based selections
 * ['primary.foo', 'primary[1]'] => '> primary | frameBySeriesNamesOrIndexes("foo",1)'
 */


var translateArrayFormatDataReference = function translateArrayFormatDataReference(encodingDataReference) {
  if (encodingDataReference.length === 0) {
    return;
  }

  var allIndexBased = encodingDataReference.every(isIndexBasedReference);
  var allNameBased = encodingDataReference.every(isNameBasedReference);

  if (allIndexBased) {
    var _Base_1$parseIndexBas = Base_1.parseIndexBasedFieldReference(encodingDataReference[0]),
        dataSourceName = _Base_1$parseIndexBas.dataSourceName;

    var indexesStr = encodingDataReference.map(function (ref) {
      var _a;

      return (_a = Base_1.parseIndexBasedFieldReference(ref)) === null || _a === void 0 ? void 0 : _a.fieldIndex;
    }).join(',');
    return "> ".concat(dataSourceName, " | frameBySeriesIndexes(").concat(indexesStr, ")");
  } else if (allNameBased) {
    var _Base_1$parseNameBase = Base_1.parseNameBasedFieldReference(encodingDataReference[0]),
        _dataSourceName = _Base_1$parseNameBase.dataSourceName;

    var namesStr = encodingDataReference.map(function (ref) {
      var _a;

      return '"' + ((_a = Base_1.parseNameBasedFieldReference(ref)) === null || _a === void 0 ? void 0 : _a.fieldName) + '"';
    }).join(',');
    return "> ".concat(_dataSourceName, " | frameBySeriesNames(").concat(namesStr, ")");
  } else {
    // it's a mix of name and index based references
    // get the first ref to extract the dataSource
    var firstEntry = encodingDataReference[0];

    var _ref = isIndexBasedReference(firstEntry) ? Base_1.parseIndexBasedFieldReference(firstEntry) : Base_1.parseNameBasedFieldReference(firstEntry),
        _dataSourceName2 = _ref.dataSourceName;

    var paramStr = encodingDataReference.map(function (ref) {
      var _a, _b;

      return isIndexBasedReference(ref) ? (_a = Base_1.parseIndexBasedFieldReference(ref)) === null || _a === void 0 ? void 0 : _a.fieldIndex : '"' + ((_b = Base_1.parseNameBasedFieldReference(ref)) === null || _b === void 0 ? void 0 : _b.fieldName) + '"';
    }).join(',');
    return "> ".concat(_dataSourceName2, " | frameBySeriesNamesOrIndexes(").concat(paramStr, ")");
  }
};
/**
 * Translates an encoding data selection string to a dynamic options data selection
 *
 * Index based column selection
 * 'primary[0]' => '> primary | seriesByIndex(0)'
 *
 * Index range based column selection
 * 'primary[1:]' => '> primary | frameBySeriesIndexRange(1)'
 * 'primary[0:3]' => '> primary | frameBySeriesIndexRange(0,2)'
 *
 * Name based column selection
 * 'primary.foo' => '> primary | seriesByName("foo")'
 *
 * Encoding references
 * 'encoding.x' => '> x'
 */


var translateDataReference = function translateDataReference(encodingDataReference) {
  if (encodingDataReference.indexOf('encoding.') === 0) {
    return "> ".concat(encodingDataReference.replace('encoding.', ''));
  }

  var isIndexBasedRef = isIndexBasedReference(encodingDataReference);
  var isNameBasedRef = isNameBasedReference(encodingDataReference);

  if (!isIndexBasedRef && !isNameBasedRef) {
    console.warn('Unable to parse the encoding. Please verify the encoding format is correct');
    return;
  }

  if (isNameBasedRef) {
    var _Base_1$parseNameBase2 = Base_1.parseNameBasedFieldReference(encodingDataReference),
        dataSourceName = _Base_1$parseNameBase2.dataSourceName,
        fieldName = _Base_1$parseNameBase2.fieldName,
        columnIndex = _Base_1$parseNameBase2.columnIndex;

    var returnString = "> ".concat(dataSourceName, " | seriesByName(\"").concat(fieldName, "\")");

    if (columnIndex) {
      returnString += " | pointByIndex(".concat(columnIndex, ")");
    }

    return returnString;
  }

  if (isIndexBasedRef) {
    var _Base_1$parseIndexBas2 = Base_1.parseIndexBasedFieldReference(encodingDataReference),
        _dataSourceName3 = _Base_1$parseIndexBas2.dataSourceName,
        fieldIndex = _Base_1$parseIndexBas2.fieldIndex,
        _columnIndex = _Base_1$parseIndexBas2.columnIndex,
        isFieldIndexRange = _Base_1$parseIndexBas2.isFieldIndexRange,
        fromFieldIndex = _Base_1$parseIndexBas2.fromFieldIndex,
        toFieldIndex = _Base_1$parseIndexBas2.toFieldIndex;

    if (isFieldIndexRange) {
      var dslToIndexString;

      if (toFieldIndex === -1) {
        dslToIndexString = '';
      } else {
        // adjust index, DSL is using default slice behavior whereas encoding behaved differently
        dslToIndexString = ",".concat(toFieldIndex + 1);
      }

      return "> ".concat(_dataSourceName3, " | frameBySeriesIndexRange(").concat(fromFieldIndex).concat(dslToIndexString, ")");
    } else {
      var _returnString = "> ".concat(_dataSourceName3, " | seriesByIndex(").concat(fieldIndex, ")");

      if (_columnIndex) {
        _returnString += " | pointByIndex(".concat(_columnIndex, ")");
      }

      return _returnString;
    }
  }
};
/**
 * An encoding configuration can come in various different forms:
 *
 * 1. Simple data selection (either index or name based)
 * {
 *    x: 'primary[0]',
 *    y: 'primary.count'
 * }
 *
 * 2. Multi column selection in array format
 * {
 *    x: 'primary[0]',
 * 	  y: ['primary.count', 'primary.count2']
 * }
 *
 * 3. Advanced Encoding Configuration (for data selection and formatting)
 * {
 *    x: {
 * 	     field: 'primary[0]',
 * 	  },
 *    y: {
 * 	     field: 'primary[1]',
 *       format: {},
 *    }
 * }
 */


var encodingToDynamicOptionsDSL = function encodingToDynamicOptionsDSL(encoding) {
  var dynamicOptions = {
    options: {},
    context: {}
  };
  var translatedOptions = {};
  Object.keys(encoding).forEach(function (key) {
    var fieldReference = encoding[key];
    var fieldReferenceStr = fieldReference;

    if (_typeof(fieldReference) === 'object' && !Array.isArray(fieldReference)) {
      var field = fieldReference.field;

      if (field && !Array.isArray(field)) {
        fieldReferenceStr = field;
      }
    }

    var translatedValue; // field reference is either in form of array or string

    if (Array.isArray(fieldReference)) {
      translatedValue = translateArrayFormatDataReference(fieldReference);
    } else {
      translatedValue = translateDataReference(fieldReferenceStr);
    } // omit if translated value is not set


    if (translatedValue) {
      translatedOptions[key] = translatedValue;
    }
  });
  dynamicOptions.options = translatedOptions;
  return dynamicOptions;
};

exports.encodingToDynamicOptionsDSL = encodingToDynamicOptionsDSL;

/***/ }),
/* 8 */
/***/ (function(module, exports) {

module.exports = require("@splunk/visualization-encoding-parsers/Base");

/***/ }),
/* 9 */
/***/ (function(module, exports) {

module.exports = require("@splunk/visualizations/Area");

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.migrateVizToSplunkBar = void 0;

var splunk_charting_1 = __webpack_require__(0);

var Bar_1 = __webpack_require__(11);

var validOptions = Object.assign({}, Bar_1.config.optionsSchema); // old default configurations should be retained in migrated configuration

var defaultChanges = {
  yAxisAbbreviation: 'off',
  y2AxisAbbreviation: 'off',
  showRoundedY2AxisLabels: false,
  legendTruncation: 'ellipsisMiddle',
  showY2MajorGridLines: true
};

var migrateVizToSplunkBar = function migrateVizToSplunkBar(vizDefinition) {
  return splunk_charting_1.migrateBaseChartingVizDefinition({
    defaultChanges: defaultChanges,
    validOptions: validOptions,
    vizDefinition: vizDefinition,
    vizType: 'splunk.bar'
  });
};

exports.migrateVizToSplunkBar = migrateVizToSplunkBar;

/***/ }),
/* 11 */
/***/ (function(module, exports) {

module.exports = require("@splunk/visualizations/Bar");

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.migrateVizToSplunkBubble = void 0;

var splunk_charting_1 = __webpack_require__(0);

var Bubble_1 = __webpack_require__(13);

var validOptions = Object.assign({}, Bubble_1.config.optionsSchema); // old default configurations should be retained in migrated configuration

var defaultChanges = {
  yAxisAbbreviation: 'off',
  legendTruncation: 'ellipsisMiddle'
};

var migrateVizToSplunkBubble = function migrateVizToSplunkBubble(vizDefinition) {
  return splunk_charting_1.migrateBaseChartingVizDefinition({
    defaultChanges: defaultChanges,
    validOptions: validOptions,
    vizDefinition: vizDefinition,
    vizType: 'splunk.bubble'
  });
};

exports.migrateVizToSplunkBubble = migrateVizToSplunkBubble;

/***/ }),
/* 13 */
/***/ (function(module, exports) {

module.exports = require("@splunk/visualizations/Bubble");

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.migrateVizToSplunkColumn = void 0;

var splunk_charting_1 = __webpack_require__(0);

var Column_1 = __webpack_require__(15);

var validOptions = Object.assign({}, Column_1.config.optionsSchema); // old default configurations should be retained in migrated configuration

var defaultChanges = {
  yAxisAbbreviation: 'off',
  y2AxisAbbreviation: 'off',
  showRoundedY2AxisLabels: false,
  legendTruncation: 'ellipsisMiddle',
  showY2MajorGridLines: true
};

var migrateVizToSplunkColumn = function migrateVizToSplunkColumn(vizDefinition) {
  return splunk_charting_1.migrateBaseChartingVizDefinition({
    defaultChanges: defaultChanges,
    validOptions: validOptions,
    vizDefinition: vizDefinition,
    vizType: 'splunk.column'
  });
};

exports.migrateVizToSplunkColumn = migrateVizToSplunkColumn;

/***/ }),
/* 15 */
/***/ (function(module, exports) {

module.exports = require("@splunk/visualizations/Column");

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.migrateVizToSplunkLine = void 0;

var splunk_charting_1 = __webpack_require__(0);

var Line_1 = __webpack_require__(17);

var validOptions = Object.assign({}, Line_1.config.optionsSchema); // old default configurations should be retained in migrated configuration

var defaultChanges = {
  yAxisAbbreviation: 'off',
  y2AxisAbbreviation: 'off',
  showRoundedY2AxisLabels: false,
  legendTruncation: 'ellipsisMiddle',
  showY2MajorGridLines: true,
  markerDisplay: 'outlined'
};

var migrateVizToSplunkLine = function migrateVizToSplunkLine(vizDefinition) {
  return splunk_charting_1.migrateBaseChartingVizDefinition({
    defaultChanges: defaultChanges,
    validOptions: validOptions,
    vizDefinition: vizDefinition,
    vizType: 'splunk.line'
  });
};

exports.migrateVizToSplunkLine = migrateVizToSplunkLine;

/***/ }),
/* 17 */
/***/ (function(module, exports) {

module.exports = require("@splunk/visualizations/Line");

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __rest = this && this.__rest || function (s, e) {
  var t = {};

  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.migrateVizToSplunkPie = void 0;

var encoding_1 = __webpack_require__(2);

var splunk_charting_1 = __webpack_require__(0);

var Pie_1 = __webpack_require__(19);

var validOptions = Object.assign({}, Pie_1.config.optionsSchema);

var migratePieChartLabelAndPercent = function migratePieChartLabelAndPercent(options) {
  // if neither chart.showLabels or chart.showPercent is specified in viz.pie,
  // splunk.pie use the default labelDisplay value
  if (!('chart.showLabels' in options) && !('chart.showPercent' in options)) {
    return {};
  } // if only chart.showPercent is specified in viz.pie


  if (!('chart.showLabels' in options) && 'chart.showPercent' in options) {
    return {
      labelDisplay: options['chart.showPercent'] ? 'valuesAndPercentage' : 'values'
    };
  } // if only chart.showLabels is specified in viz.pie


  if ('chart.showLabels' in options && !('chart.showPercent' in options)) {
    return {
      labelDisplay: options['chart.showLabels'] ? 'values' : 'off'
    };
  } // if both chart.showLabels and chart.showPercent are specified in viz.pie


  var labelOption = {
    labelDisplay: 'values'
  };

  if (options['chart.showLabels'] && options['chart.showPercent']) {
    labelOption.labelDisplay = 'valuesAndPercentage';
  }

  if (!options['chart.showLabels']) {
    labelOption.labelDisplay = 'off';
  }

  return labelOption;
};

var migrateFieldColors = function migrateFieldColors(options) {
  if ('fieldColors' in options) {
    return {
      seriesColorsByValue: splunk_charting_1.otherValueReplacements.seriesColorsByField(options.fieldColors)
    };
  } else {
    return {};
  }
};

var migrateVizToSplunkPie = function migrateVizToSplunkPie(vizDefinition) {
  var _vizDefinition$encodi = vizDefinition.encoding,
      encoding = _vizDefinition$encodi === void 0 ? {} : _vizDefinition$encodi,
      _vizDefinition$option = vizDefinition.options,
      options = _vizDefinition$option === void 0 ? {} : _vizDefinition$option,
      otherDefinitionParts = __rest(vizDefinition, ["encoding", "options"]);

  var migratedDefinition = Object.assign(Object.assign({}, otherDefinitionParts), {
    type: 'splunk.pie',
    options: {},
    context: {}
  }); // translate encoding to dynamic options equivalent

  var _encoding_1$encodingT = encoding_1.encodingToDynamicOptionsDSL(encoding),
      dataOptions = _encoding_1$encodingT.options,
      dataContext = _encoding_1$encodingT.context;

  var migratedOptions = Object.assign(Object.assign(Object.assign(Object.assign({}, migratePieChartLabelAndPercent(options)), splunk_charting_1.migrateChartingOptions(options)), migrateFieldColors(options)), dataOptions); // remove invalid options

  Object.keys(migratedOptions).forEach(function (key) {
    if (!validOptions[key]) {
      delete migratedOptions[key];
    }
  });
  migratedDefinition.options = migratedOptions;
  migratedDefinition.context = dataContext;
  return migratedDefinition;
};

exports.migrateVizToSplunkPie = migrateVizToSplunkPie;

/***/ }),
/* 19 */
/***/ (function(module, exports) {

module.exports = require("@splunk/visualizations/Pie");

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.migrateVizToSplunkScatter = void 0;

var splunk_charting_1 = __webpack_require__(0);

var Scatter_1 = __webpack_require__(21);

var validOptions = Object.assign({}, Scatter_1.config.optionsSchema); // old default configurations should be retained in migrated configuration

var defaultChanges = {
  yAxisAbbreviation: 'off',
  legendTruncation: 'ellipsisMiddle'
};

var migrateVizToSplunkScatter = function migrateVizToSplunkScatter(vizDefinition) {
  return splunk_charting_1.migrateBaseChartingVizDefinition({
    defaultChanges: defaultChanges,
    validOptions: validOptions,
    vizDefinition: vizDefinition,
    vizType: 'splunk.scatter'
  });
};

exports.migrateVizToSplunkScatter = migrateVizToSplunkScatter;

/***/ }),
/* 21 */
/***/ (function(module, exports) {

module.exports = require("@splunk/visualizations/Scatter");

/***/ })
/******/ ]);
//# sourceMappingURL=index.js.map
import type { ExtendableDataSourceDefinition } from '@splunk/dashboard-types';
import type { Observable, Subscriber, Observer } from 'rxjs';
import type { RequestParams, ObservableData } from './types';
/**
 * Base class of a DataSource
 */
export default class DataSource {
    options: Record<string, unknown>;
    context: Record<string, unknown>;
    meta: Record<string, unknown>;
    baseChainModel: Record<string, ExtendableDataSourceDefinition>;
    /**
     * Create a new DataSource Instance
     * @param {Object} options DataSource options such as search string, earliest/latest time
     * @param {Object} context contextual information such as api key or scope
     * @param {Object} meta metadata of this datasource
     * @param {Object} baseChainModel base chain definition
     */
    constructor(options?: {}, context?: {}, meta?: {}, baseChainModel?: {});
    /**
     * setup the DataSource, this is the place where you can setup your connection or create the search job.
     * setup will be called only once per DataSource.
     * @return {Promise}
     * @public
     */
    setup(): Promise<string | null>;
    /**
     * Request a Data Stream represent by an Observable.
     * Once the Observable was created and returned,
     * it's the DataSource itself responsible for 'pushing' the data out via Observable.next() function.
     * Override this function to implement your own data fetching logic.
     *
     * @param {Object} [requestParams] RequestParams
     * @param {Number} [requestParams.offset] result offset
     * @param {Number} [requestParams.count] result count, use with offset to return data in pages
     * @param {Object} [requestParams.sort] result sorting, key indicate the sorting fields and value must be one of ['none', 'asc', 'desc']
     * @param {Boolean} [requestParams.requireTotalCount] true if TotalCount is required in meta
     * @param {Boolean} [requestParams.progress] true to emit progress data, false to only return data when search is finalized
     * @return {Observable}
     * @public
     */
    request(requestParams?: RequestParams): Observable<ObservableData> | ((observer?: Subscriber<ObservableData>) => () => void);
    /**
     * teardown the DataSource, clear up connection or other resources
     * @return {Promise}
     * @public
     */
    teardown(): Promise<null>;
    /**
     * @param {DataSource} another another DataSource to compare with
     * @return {Boolean} true if the these two DataSources are considered equal.
     * @public
     */
    equals(another: InstanceType<typeof DataSource>): boolean;
    /**
     * return an observer that can be used to chain with other data source
     * @return {Object}
     * @public
     */
    getObserver(): Observer<ObservableData>;
    /**
     * flag used to show if the subscription for this data source should be refresh
     * @return {Boolean}
     * @public
     */
    shouldRefreshSubscription(): boolean;
}
//# sourceMappingURL=DataSource.d.ts.map
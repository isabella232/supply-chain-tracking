## DataSource APIs

DataSource is a set of javascript modules that retrieve 2 dimensional data.

They all extends from the following base class.

```js
/**
 * Base class of a DataSource
 */
export default class DataSource {
    /**
     * Create a new DataSource Instance
     * @param {Object} options DataSoure options such as search string, earliest/latest time
     * @param {Object} context contextual information such as api key or scope
     */
    constructor(options = {}, context = {}) {
        this.options = options;
        this.context = context;
    }
    /**
     * setup the DataSource, this is the place where you can setup your connection or create the search job.
     * setup will be called only once per DataSource.
     * @return {Promise}
     * @public
     */
    setup() {
        return Promise.resolve();
    }
    /**
     * Request a Data Stream represent by an Observable.
     * Once the Observable was created and returned,
     * it's the DataSource itself responsible for 'pushing' the data out via Observable.next() function.
     * Override this function to implement your own data fetching logic.
     *
     * @param {Object} [requestParams] RequestParams
     * @param {Number} [requestParams.offset] result offset
     * @param {Number} [requestParams.count] result count, use with offset to return data in pages
     * @param {Object} [requestParams.sort] result sorting, key indicate the sorting fields and value must be one of ['none', 'asc', 'desc']
     * @param {String} [requestParams.source] one of ['results_preview' | 'results' | 'events' ] for splunk search powered DataSource
     * @param {Boolean} [requestParams.requireTotalCount] true if TotalCount is required in meta
     * @return {Observable}
     * @public
     */
    request(requestParams = {}) {
        return (observer) => {
            observer.complete();
            return () => {
                // cleanup when observer no longer subscribe to this Observable
            };
        };
    }
    /**
     * teardown the DataSource, clear up connetion or other resources
     * @return {Promise}
     * @public
     */
    teardown() {
        return Promise.resolve();
    }
    /**
     * @param {DataSource} another another DataSource to compare with
     * @return {Boolean} true if the 2 DataSource are considered equal.
     * @public
     */
    equals(another) {
        return (
            this.constructor === another.constructor &&
            isEqual(this.options, another.options)
        );
    }
}
```

### DataSource.setup and teardown

setup and teardown will be called only once per DataSource. Override these function to provide your own implementation such as establish and destory connections.

For example

```js
import DataSource from '@splunk/datasources/DataSource';

class MyDataSource extends DataSource {
    setup() {
        this.searchJob = this.createSearchJob();
    }
    teardown() {
        this.searchJob.destroy()
        delete this.searchJob;
    }
    createSearchJob() {
        ...
    }
}
```

### DataSource.request

Actual data fetching logic will be implemented here. An Observable must be returned for each request() call. DataSource itself will then be responsible for 'pushing' the data to the Observer(whoever subscribe/listen on this Observable) via observer.next function.

For Example, a DataSource that always returns empty data.

```js
import DataSource from '@splunk/datasources/DataSource';
import DataSet from '@splunk/datasource-utils/DataSet';

class MyDataSource extends DataSource {
    request(requestParams = {}) {
        return (observer) => {
            observer.next({
                data: DataSet.empty(),
            });
            observer.complete();
            return () => {
                // do nothing
            };
        };
    }
}
```

Besides data, DataSource can also communicate error and meta (extra information) out.

```js
import DataSource from '@splunk/datasources/DataSource';

class MyDataSource extends DataSource {
    request(requestParams = {}) {
        return (observer) => {
            observer.error({
                level: 'error', // oneOf ['info', 'warning', 'error']
                message: 'help!!',
            });
            return () => {
                // do nothing
            };
        };
    }
}

class MyDataSource extends DataSource {
    request(requestParams = {}) {
        return (observer) => {
            observer.next({
                data: DataSet.empty(),
                meta: {
                    totalCount: 0,
                },
            });
            observer.complete();
            return () => {
                // do nothing
            };
        };
    }
}
```

Async fetch can be implemented easily:

```js
import DataSource from '@splunk/datasources/DataSource';

class MyDataSource extends DataSource {
    request(requestParams={}) {
        return observer => {
            const interval = setInterval(() => {
                observer.next({
                    data: DataSet.fromJSONCols(
                        [{ name: 'x' }, { name: 'y' }, { name: 'z' }],
                        [['a', 'b', 'c'], [4, 5, 6], [70, 80, 90]];
                    ),
                });
            }, 5000);
            return () => {
                clearInterval(interval);
            };
        };
    }
}
```

### RequestParams

RequestParams defines how does the client wants the data, it usually contains following params:

#### count

The maximum number of results to return.

#### offset

The first result (inclusive) from which to begin returning data.This value is 0-indexed.

Use offset and count together to implement result pagination.

#### sort

Sorting of the results. Express as an object.

For example, sort '\_time' field in desc order.

```js
{
    sort: {
        '_time' : 'desc',
    }
}
```

#### requireTotalCount

True if TotalCount has to be returned as part of meta. This is often required in table/events viewer

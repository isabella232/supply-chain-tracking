{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/DataSource.ts","webpack:///external \"lodash/isEqual\"","webpack:///external \"lodash/isEmpty\"","webpack:///external \"@splunk/dashboard-utils/deprecated\"","webpack:///external \"lodash/get\"","webpack:///external \"@splunk/ui-utils/i18n\"","webpack:///external \"rxjs\"","webpack:///external \"lodash/pick\"","webpack:///external \"@splunk/datasource-utils/DataSet\"","webpack:///external \"@splunk/splunk-utils/config\"","webpack:///external \"@splunk/moment\"","webpack:///external \"@splunk/dashboard-utils/console\"","webpack:///external \"@splunk/search-job\"","webpack:///./src/utils/SplunkSearchUtils.js","webpack:///./src/SplunkSavedSearchOptionsSchema.js","webpack:///./src/SplunkSavedSearch.js","webpack:///external \"@splunk/splunk-utils/savedSearch\""],"names":[],"mappings":"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","file":"SplunkSavedSearch.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 35);\n","/* eslint-disable class-methods-use-this,no-unused-vars, @typescript-eslint/no-unused-vars, @typescript-eslint/no-empty-function */\nimport isEqual from 'lodash/isEqual';\nimport isEmpty from 'lodash/isEmpty';\nimport type { ExtendableDataSourceDefinition } from '@splunk/dashboard-types';\nimport type { Observable, Subscriber, Observer } from 'rxjs';\nimport deprecated from '@splunk/dashboard-utils/deprecated';\nimport type { RequestParams, ObservableData } from './types';\n\n/**\n * Base class of a DataSource\n */\nexport default class DataSource {\n    options: Record<string, unknown>;\n\n    context: Record<string, unknown>;\n\n    // deprecated property\n    meta: Record<string, unknown>;\n\n    // deprecated property\n    baseChainModel: Record<string, ExtendableDataSourceDefinition>;\n\n    /**\n     * Create a new DataSource Instance\n     * @param {Object} options DataSource options such as search string, earliest/latest time\n     * @param {Object} context contextual information such as api key or scope\n     * @param {Object} meta metadata of this datasource\n     * @param {Object} baseChainModel base chain definition\n     */\n    constructor(options = {}, context = {}, meta = {}, baseChainModel = {}) {\n        this.options = options;\n        this.context = context;\n        this.meta = meta;\n        this.baseChainModel = baseChainModel;\n        if (!isEmpty(meta)) {\n            deprecated('Property \"meta\" has been deprecated');\n        }\n        if (!isEmpty(baseChainModel)) {\n            deprecated('Property \"baseChainModel\" has been deprecated');\n        }\n    }\n\n    /**\n     * setup the DataSource, this is the place where you can setup your connection or create the search job.\n     * setup will be called only once per DataSource.\n     * @return {Promise}\n     * @public\n     */\n    setup(): Promise<string | null> {\n        return Promise.resolve(null);\n    }\n\n    /**\n     * Request a Data Stream represent by an Observable.\n     * Once the Observable was created and returned,\n     * it's the DataSource itself responsible for 'pushing' the data out via Observable.next() function.\n     * Override this function to implement your own data fetching logic.\n     *\n     * @param {Object} [requestParams] RequestParams\n     * @param {Number} [requestParams.offset] result offset\n     * @param {Number} [requestParams.count] result count, use with offset to return data in pages\n     * @param {Object} [requestParams.sort] result sorting, key indicate the sorting fields and value must be one of ['none', 'asc', 'desc']\n     * @param {Boolean} [requestParams.requireTotalCount] true if TotalCount is required in meta\n     * @param {Boolean} [requestParams.progress] true to emit progress data, false to only return data when search is finalized\n     * @return {Observable}\n     * @public\n     */\n    request(\n        requestParams?: RequestParams\n    ):\n        | Observable<ObservableData>\n        | ((observer?: Subscriber<ObservableData>) => () => void) {\n        return (observer) => {\n            if (observer) {\n                observer.complete();\n            }\n            return () => {\n                // cleanup\n            };\n        };\n    }\n\n    /**\n     * teardown the DataSource, clear up connection or other resources\n     * @return {Promise}\n     * @public\n     */\n    teardown(): Promise<null> {\n        return Promise.resolve(null);\n    }\n\n    /**\n     * @param {DataSource} another another DataSource to compare with\n     * @return {Boolean} true if the these two DataSources are considered equal.\n     * @public\n     */\n    equals(another: InstanceType<typeof DataSource>): boolean {\n        return (\n            this.constructor === another.constructor &&\n            isEqual(this.options, another.options)\n        );\n    }\n\n    /**\n     * return an observer that can be used to chain with other data source\n     * @return {Object}\n     * @public\n     */\n    getObserver(): Observer<ObservableData> {\n        return {\n            next({ requestParams, data, meta }) {\n                // next\n            },\n            error({ level, message }) {\n                // error\n            },\n            complete() {\n                // complete\n            },\n        };\n    }\n\n    /**\n     * flag used to show if the subscription for this data source should be refresh\n     * @return {Boolean}\n     * @public\n     */\n    shouldRefreshSubscription(): boolean {\n        return false;\n    }\n}\n","module.exports = require(\"lodash/isEqual\");","module.exports = require(\"lodash/isEmpty\");","module.exports = require(\"@splunk/dashboard-utils/deprecated\");","module.exports = require(\"lodash/get\");","module.exports = require(\"@splunk/ui-utils/i18n\");","module.exports = require(\"rxjs\");","module.exports = require(\"lodash/pick\");","module.exports = require(\"@splunk/datasource-utils/DataSet\");","module.exports = require(\"@splunk/splunk-utils/config\");","module.exports = require(\"@splunk/moment\");","module.exports = require(\"@splunk/dashboard-utils/console\");","module.exports = require(\"@splunk/search-job\");","import pick from 'lodash/pick';\nimport get from 'lodash/get';\nimport { Observable } from 'rxjs';\nimport { _ } from '@splunk/ui-utils/i18n';\nimport DataSet from '@splunk/datasource-utils/DataSet';\nimport moment from '@splunk/moment';\nimport { app } from '@splunk/splunk-utils/config';\n\n/**\n * Get status message based on search job properties\n * @param {String} status the status returned by the search job\n * @param {Boolean} isRealTimeSearch\n * @param {Number} totalCount the total number of search results retrieved\n * @returns {String} status message\n */\nexport const getStatusMessage = ({ status, isRealTimeSearch, totalCount }) => {\n    if (status === 'running') {\n        if (isRealTimeSearch) {\n            return _('Real-time search is running');\n        }\n        if (totalCount === 0) {\n            return _(\n                'Search is running, but not enough data to render visualization'\n            );\n        }\n    }\n    if (status === 'queued') {\n        return _('Search is not yet running, queued on server');\n    }\n    if (status === 'parsing') {\n        return _('Search is not yet running, queued on server');\n    }\n    if (status === 'done' && totalCount === 0) {\n        return _('Search ran successfully, but no results were returned');\n    }\n\n    return '';\n};\n\n// this is a list of properties that will be removed or normalized in the future. Refer to the RFC 2020_05_05-search_job_metadata.md\nconst deprecatedSearchMetas = ['resultCount', 'isDone', 'dispatchState'];\n\n/**\n * Formats the results of a Splunk SearchJob to use in UDF\n * @param {Object} results search results object\n * @param {Object} progress search progress object\n * @param {String} search search query\n * @returns {Object} Formatted data and metadata\n */\nexport const projectFunc = (results, progress, search) => {\n    const { fields, columns, post_process_count: postProcessCount } = results;\n    const {\n        isRealTimeSearch,\n        resultPreviewCount,\n        resultCount,\n    } = progress.content;\n\n    // totalCount is required for pagination.\n    let totalCount;\n    if (postProcessCount != null) {\n        // for post process searches, the totalCount is post_process_count in the results, NOT the resultPreviewCount/resultCount in the jobProperties.\n        totalCount = postProcessCount;\n    } else if (resultPreviewCount != null) {\n        // we look at resultPreviewCount since that is always set when preview = true.\n        // when search job is done, resultPreviewCount can be null,\n        // see https://splunk.slack.com/archives/C8YPWKC4U/p1591290195175900 for more context.\n        totalCount = resultPreviewCount;\n    } else {\n        totalCount = resultCount;\n    }\n    const status = progress.content.dispatchState.toLowerCase();\n\n    return {\n        data: new DataSet(fields, columns),\n        meta: {\n            ...pick(progress.content, deprecatedSearchMetas),\n            sid: progress.content.sid,\n            totalCount,\n            status,\n            statusMessage: getStatusMessage({\n                status,\n                isRealTimeSearch,\n                totalCount,\n            }),\n            // need to manually convert progress from [0, 1] to [0, 100]\n            percentComplete:\n                status === 'done'\n                    ? 100\n                    : Math.round(progress.content.doneProgress * 100),\n            isRealTimeSearch,\n            lastUpdated: moment(progress.published)\n                .add(pick(progress.content, 'runDuration'), 'seconds')\n                .toISOString(),\n            search,\n        },\n    };\n};\n\n/**\n * return an Observable that will emit intermediate search result\n * @param {Observable} resultsObservable observable for the search results\n * @param {Observable} progressObservable observable for the search progress so far\n * @param {Function} callback project function to transform the values emitted by the Observable\n */\nexport const combineResultWhenProgress = (\n    resultsObservable,\n    progressObservable,\n    callback\n) => Observable.combineLatest(resultsObservable, progressObservable, callback);\n\n/**\n * return an Observable that will emit final search result\n * @param {Observable} resultsObservable observable for the search results\n * @param {Observable} progressObservable observable for the search progress so far\n * @param {Function} callback project function to transform the values emitted by the Observable\n */\nexport const combineResultWhenFinalized = (\n    resultsObservable,\n    progressObservable,\n    callback\n) => Observable.forkJoin(resultsObservable, progressObservable, callback);\n\n/**\n * Wraps the observer to improve the error handling\n * @param {Observer} observer the observer to be wrapped\n * @param {string} search the search query\n * @returns {Observer} the wrapped observer\n */\nexport const transformObserver = (observer, search) => ({\n    next: (response) => observer.next(response),\n    error: (err) =>\n        observer.error({\n            level: 'error',\n            message: err.message,\n            meta: {\n                search,\n            },\n        }),\n    complete: () => observer.complete(),\n});\n\n/**\n * Determine if a fetch is needed based on the given search preview state\n * @param {Object} searchState search preview state\n * @returns {Boolean}\n */\nexport const previewFetchPredicate = (searchState) => {\n    if (get(searchState, ['content', 'isRealTimeSearch'], false)) {\n        return true;\n    }\n    // we do a fetch when\n    // 1. result count > 0\n    // 2. search is done so we can make sure we always return the result\n    return (\n        get(searchState, ['content', 'resultPreviewCount'], 0) > 0 ||\n        !!get(searchState, ['content', 'isDone'])\n    );\n};\n\n/**\n * Provides common options for splunk search dispatch options\n * @param {Object} context Object containing any configurable dispatchOptions from splunk/search-job\n * @returns {Object}\n */\nexport const getEnterpriseSearchContext = (context) => {\n    return { keepAlive: true, cache: false, app, ...context };\n};\n","export default {\n    ref: {\n        type: 'string',\n        description:\n            'The name of the saved search to retrieve the results from.',\n    },\n    app: {\n        type: 'string',\n        description: 'The name of the app that the saved search belongs to.',\n    },\n    refresh: {\n        type: ['number', 'string'],\n        description:\n            'Specify the refresh interval in seconds or with a time expression. Ignored if saved search is scheduled.',\n    },\n    refreshType: {\n        type: 'string',\n        enum: ['delay', 'interval'],\n        default: 'delay',\n        description:\n            'Indicate the starting time for counting down to a refresh. Use delay to start counting when the search is done. Use interval to count down when the search is dispatched. Ignored if saved search is scheduled.',\n    },\n};\n","import get from 'lodash/get';\nimport { _ } from '@splunk/ui-utils/i18n';\nimport console from '@splunk/dashboard-utils/console';\nimport SearchJob from '@splunk/search-job';\nimport {\n    username as CURRENT_USER,\n    app as CURRENT_APP,\n} from '@splunk/splunk-utils/config';\nimport {\n    get as getSavedSearch,\n    dispatch as dispatchSavedSearch,\n    getLatest as getLatestSavedSearch,\n} from '@splunk/splunk-utils/savedSearch';\nimport moment from '@splunk/moment';\nimport DataSource from './DataSource';\nimport SplunkSavedSearchOptionsSchema from './SplunkSavedSearchOptionsSchema';\nimport {\n    combineResultWhenProgress,\n    combineResultWhenFinalized,\n    previewFetchPredicate,\n    projectFunc,\n    transformObserver,\n    getEnterpriseSearchContext,\n} from './utils/SplunkSearchUtils';\n\nexport const ownRequestParams = {\n    output_mode: 'json_cols',\n};\n\nexport const defaultParams = {\n    // Note: if preview is changed to false, we will not get resultPreviewCount below and\n    // may break search status icon behavior\n    preview: true,\n};\n\nexport const defaultRequestParams = {\n    count: 0,\n    offset: 0,\n    progress: true,\n};\n\nexport const getSecondsBetweenDates = (date1, date2) => {\n    if (!(date1 instanceof moment) || !(date2 instanceof moment)) {\n        throw Error('Parameters must be @splunk/moment types');\n    }\n    return Math.ceil((date2 - date1) / 1000);\n};\n\nexport const calculateRefreshTime = (nextScheduledTime) => {\n    // SCP-39715\n    // `nextScheduledTime` is in the format like '2021-05-05 01:32:00 CEST' where CEST is a non-standard abbreviation which cannot be recognized by moment() or Date().\n    // To handle this issue, we remove the timezone from the timestamp and let `.newSplunkTime()` handle it.\n    // Note the timezone depends on Splunk Enterprise user settings, it could be CEST, UTC or some other timezone abbreviations.\n    const nextScheduledTimeWithoutTimezone = nextScheduledTime\n        .split(' ')\n        .slice(0, -1)\n        .join(' ');\n\n    const timeOfSavedSearchRetrieval = moment.newSplunkTime();\n    const secondsUntilNextSchedule = getSecondsBetweenDates(\n        timeOfSavedSearchRetrieval,\n        moment.newSplunkTime({ time: nextScheduledTimeWithoutTimezone })\n    );\n    // Give a slight buffer of 5 seconds to allow the scheduled job to kick off in an ideal environment,\n    // making it less likely to require multiple calls to retrieve the newest job.\n    return secondsUntilNextSchedule + 5;\n};\n\n/**\n * A DataSource that talks to splunk enterprise\n * @param {Object} options\n * @param {String} options.ref name of saved search\n * @param {String} options.app name of app saved search belongs to\n * @param {Object} context See [search-job api](https://splunkui.sv.splunk.com/Packages/search-job/API) dispatchOptions object\n * @param {Boolean} [context.keepAlive=true] If true, keep the job alive before teardown\n * @param {Boolean} [context.cache=false] If true, will try and reuse an existing search job if it has the same request params.\n * @param {String} [context.app] The current app in use as defined in the page url and @splunk/splunk-utils/Config\n * @param {String} [context.splunkdPath] splunk rest endpoint path\n * @param {String} [context.sessionKey] current session key\n * @param {String} [context.auditProvenance] provenance value to appear in the splunk audit log\n * @param {String} [context.id] ID of the dashboard performing the query\n * @returns {SplunkSavedSearch} A new SplunkSavedSearch datasource instance.\n * @public\n */\nclass SplunkSavedSearch extends DataSource {\n    static schema = SplunkSavedSearchOptionsSchema;\n\n    constructor(options = {}, context = {}) {\n        super(options, context);\n        if (!this.options.ref) {\n            throw Error('saved search ref is required!');\n        }\n        this.context = getEnterpriseSearchContext(this.context);\n    }\n\n    /**\n     * Creates a search job and returns sid once the job is created on the server.\n     * @returns {Promise} The sid of the created job.\n     * @public\n     */\n    async setup() {\n        try {\n            /**\n             * SearchJob can only modify config and fetch params globally.\n             */\n            const { splunkdPath, sessionKey } = this.context;\n            if (splunkdPath) {\n                SearchJob.setSplunkConfig({\n                    splunkdPath,\n                });\n            }\n            if (sessionKey) {\n                SearchJob.setBaseFetchInit({\n                    headers: {\n                        Authorization: `Splunk ${sessionKey}`,\n                    },\n                });\n            }\n            const { app, ref } = this.options;\n            const savedSearchParams = {\n                name: ref,\n                app: app || CURRENT_APP,\n                owner: CURRENT_USER,\n            };\n            const requestParams = {\n                'dispatch.check_risky_command': this.options.checkRiskyCommand,\n                'dispatch.label': this.context.id,\n            };\n            if (this.context.auditProvenance) {\n                requestParams[\n                    'dispatch.provenance'\n                ] = this.context.auditProvenance;\n            }\n            let sid = null;\n\n            // fetch report definition\n            this.savedSearch = await getSavedSearch(savedSearchParams);\n            const isScheduled = get(this.savedSearch, [\n                'entry',\n                0,\n                'content',\n                'is_scheduled',\n            ]);\n            this.searchQuery = get(this.savedSearch, [\n                'entry',\n                0,\n                'content',\n                'search',\n            ]);\n            if (isScheduled) {\n                const params = { search: 'isScheduled=true' };\n                const lastSearchJob = await getLatestSavedSearch(\n                    savedSearchParams,\n                    params,\n                    SearchJob.splunkConfig,\n                    SearchJob.baseFetchInit\n                );\n                sid = get(lastSearchJob, ['name'], null);\n                if (!sid) {\n                    ({ sid } = await dispatchSavedSearch(\n                        savedSearchParams,\n                        requestParams,\n                        SearchJob.splunkConfig,\n                        SearchJob.baseFetchInit\n                    ));\n                }\n            } else {\n                ({ sid } = await dispatchSavedSearch(\n                    savedSearchParams,\n                    requestParams,\n                    SearchJob.splunkConfig,\n                    SearchJob.baseFetchInit\n                ));\n            }\n\n            this.searchJob = SearchJob.fromSid(sid);\n            return sid;\n        } catch (e) {\n            console.error('failed to retrieve search job:', e);\n            this.setupError = e;\n            return null;\n        }\n    }\n\n    /**\n     * Returns an Observable that emits job information and search results.\n     *\n     * @param requestParams {Object} - [See documentation for available parameters.\n     * ](http://docs.splunk.com/Documentation/Splunk/latest/RESTREF/RESTsearch#search.2Fjobs.2F.7Bsearch_id.7D.2Fresults)\n     * @returns {Observable}\n     * @public\n     */\n    request(requestParams = {}) {\n        if (this.setupError) {\n            return (observer) => {\n                observer.error({\n                    level: 'error',\n                    message: this.setupError.message,\n                    meta: {\n                        search: this.searchQuery,\n                    },\n                });\n\n                return () => {};\n            };\n        }\n\n        const params = {\n            ...defaultRequestParams,\n            ...requestParams,\n            ...ownRequestParams,\n        };\n\n        if (params.sort) {\n            Object.keys(params.sort).forEach((sortKey) => {\n                const sortDir = params.sort[sortKey];\n                if (sortDir) {\n                    if (!params.search) {\n                        params.search = '| sort 0';\n                    }\n                    if (sortDir === 'desc') {\n                        params.search += ` -\"${sortKey}\"`;\n                    } else if (sortDir === 'asc') {\n                        params.search += ` +\"${sortKey}\"`;\n                    }\n                }\n            });\n\n            delete params.sort;\n        }\n\n        const progressObservable = this.searchJob.getProgress();\n        const result = params.progress\n            ? combineResultWhenProgress(\n                  this.searchJob.getResultsPreview(params, {\n                      fetchPredicate: previewFetchPredicate,\n                  }),\n                  progressObservable,\n                  projectFunc\n              )\n            : combineResultWhenFinalized(\n                  this.searchJob.getResults(params),\n                  progressObservable,\n                  projectFunc\n              );\n\n        return (observer) => {\n            // note: due to the nature that 'data' and 'meta' are from two different endpoints, there's no\n            // way to guarantee that they always match. But they'll eventually match when search is done.\n\n            const subscription = result.subscribe(transformObserver(observer));\n\n            return () => {\n                subscription.unsubscribe();\n            };\n        };\n    }\n\n    getRefreshConfig() {\n        let refresh = get(this.options, 'refresh');\n        let refreshType = get(this.options, 'refreshType');\n        if (this.savedSearch) {\n            const isScheduled = get(this.savedSearch, [\n                'entry',\n                0,\n                'content',\n                'is_scheduled',\n            ]);\n            if (isScheduled) {\n                const nextScheduledTime = get(this.savedSearch, [\n                    'entry',\n                    0,\n                    'content',\n                    'next_scheduled_time',\n                ]);\n                refresh = `${calculateRefreshTime(nextScheduledTime)}s`;\n                refreshType = 'interval';\n            }\n        }\n        return {\n            refresh,\n            refreshType,\n        };\n    }\n\n    getMetaData() {\n        const {\n            author,\n            updated,\n            acl: { app, sharing } = {},\n            content: {\n                is_scheduled: isScheduled,\n                next_scheduled_time: nextScheduledTime,\n                search: savedSearchQuery,\n                'dispatch.earliest_time': earliestTime,\n                'dispatch.latest_time': latestTime,\n            } = {},\n        } = get(this.savedSearch, ['entry', 0], {});\n\n        return {\n            author,\n            updated,\n            app,\n            sharing,\n            isScheduled,\n            nextScheduledTime,\n            savedSearchQuery,\n            earliestTime,\n            latestTime,\n        };\n    }\n\n    /**\n     * Cancel the search job and returns the server response.\n     * Job will not be cancelled if `context.cache` is true.\n     * @returns {Promise}\n     * @public\n     */\n    async teardown() {\n        const { cache } = this.context;\n        if (!cache && this.searchJob) {\n            this.searchJob = null;\n            this.savedSearch = null;\n        }\n        return null;\n    }\n}\n\nSplunkSavedSearch.config = {\n    title: _('Saved Search'),\n    displayDataSourceItemListByDefault: true,\n    canCreateDataSource: false,\n    dataSourceRemoveVerb: 'remove',\n    isDataSourceNameEditable: false,\n    getDataSourceName: ({ dataSource }) =>\n        get(dataSource, ['options', 'ref']) ||\n        get(dataSource, 'name', _('Unnamed')),\n    defaultOptions: {},\n    editorConfig: [],\n    optionsSchema: SplunkSavedSearchOptionsSchema,\n};\n\nexport default SplunkSavedSearch;\n","module.exports = require(\"@splunk/splunk-utils/savedSearch\");"],"sourceRoot":""}
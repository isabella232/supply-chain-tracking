{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/utils/SplunkSearchUtils.js","webpack:///external \"lodash/pick\"","webpack:///external \"lodash/get\"","webpack:///external \"rxjs\"","webpack:///external \"@splunk/ui-utils/i18n\"","webpack:///external \"@splunk/datasource-utils/DataSet\"","webpack:///external \"@splunk/moment\"","webpack:///external \"@splunk/splunk-utils/config\""],"names":[],"mappings":"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","file":"SplunkSearchUtils.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 5);\n","import pick from 'lodash/pick';\nimport get from 'lodash/get';\nimport { Observable } from 'rxjs';\nimport { _ } from '@splunk/ui-utils/i18n';\nimport DataSet from '@splunk/datasource-utils/DataSet';\nimport moment from '@splunk/moment';\nimport { app } from '@splunk/splunk-utils/config';\n\n/**\n * Get status message based on search job properties\n * @param {String} status the status returned by the search job\n * @param {Boolean} isRealTimeSearch\n * @param {Number} totalCount the total number of search results retrieved\n * @returns {String} status message\n */\nexport const getStatusMessage = ({ status, isRealTimeSearch, totalCount }) => {\n    if (status === 'running') {\n        if (isRealTimeSearch) {\n            return _('Real-time search is running');\n        }\n        if (totalCount === 0) {\n            return _(\n                'Search is running, but not enough data to render visualization'\n            );\n        }\n    }\n    if (status === 'queued') {\n        return _('Search is not yet running, queued on server');\n    }\n    if (status === 'parsing') {\n        return _('Search is not yet running, queued on server');\n    }\n    if (status === 'done' && totalCount === 0) {\n        return _('Search ran successfully, but no results were returned');\n    }\n\n    return '';\n};\n\n// this is a list of properties that will be removed or normalized in the future. Refer to the RFC 2020_05_05-search_job_metadata.md\nconst deprecatedSearchMetas = ['resultCount', 'isDone', 'dispatchState'];\n\n/**\n * Formats the results of a Splunk SearchJob to use in UDF\n * @param {Object} results search results object\n * @param {Object} progress search progress object\n * @param {String} search search query\n * @returns {Object} Formatted data and metadata\n */\nexport const projectFunc = (results, progress, search) => {\n    const { fields, columns, post_process_count: postProcessCount } = results;\n    const {\n        isRealTimeSearch,\n        resultPreviewCount,\n        resultCount,\n    } = progress.content;\n\n    // totalCount is required for pagination.\n    let totalCount;\n    if (postProcessCount != null) {\n        // for post process searches, the totalCount is post_process_count in the results, NOT the resultPreviewCount/resultCount in the jobProperties.\n        totalCount = postProcessCount;\n    } else if (resultPreviewCount != null) {\n        // we look at resultPreviewCount since that is always set when preview = true.\n        // when search job is done, resultPreviewCount can be null,\n        // see https://splunk.slack.com/archives/C8YPWKC4U/p1591290195175900 for more context.\n        totalCount = resultPreviewCount;\n    } else {\n        totalCount = resultCount;\n    }\n    const status = progress.content.dispatchState.toLowerCase();\n\n    return {\n        data: new DataSet(fields, columns),\n        meta: {\n            ...pick(progress.content, deprecatedSearchMetas),\n            sid: progress.content.sid,\n            totalCount,\n            status,\n            statusMessage: getStatusMessage({\n                status,\n                isRealTimeSearch,\n                totalCount,\n            }),\n            // need to manually convert progress from [0, 1] to [0, 100]\n            percentComplete:\n                status === 'done'\n                    ? 100\n                    : Math.round(progress.content.doneProgress * 100),\n            isRealTimeSearch,\n            lastUpdated: moment(progress.published)\n                .add(pick(progress.content, 'runDuration'), 'seconds')\n                .toISOString(),\n            search,\n        },\n    };\n};\n\n/**\n * return an Observable that will emit intermediate search result\n * @param {Observable} resultsObservable observable for the search results\n * @param {Observable} progressObservable observable for the search progress so far\n * @param {Function} callback project function to transform the values emitted by the Observable\n */\nexport const combineResultWhenProgress = (\n    resultsObservable,\n    progressObservable,\n    callback\n) => Observable.combineLatest(resultsObservable, progressObservable, callback);\n\n/**\n * return an Observable that will emit final search result\n * @param {Observable} resultsObservable observable for the search results\n * @param {Observable} progressObservable observable for the search progress so far\n * @param {Function} callback project function to transform the values emitted by the Observable\n */\nexport const combineResultWhenFinalized = (\n    resultsObservable,\n    progressObservable,\n    callback\n) => Observable.forkJoin(resultsObservable, progressObservable, callback);\n\n/**\n * Wraps the observer to improve the error handling\n * @param {Observer} observer the observer to be wrapped\n * @param {string} search the search query\n * @returns {Observer} the wrapped observer\n */\nexport const transformObserver = (observer, search) => ({\n    next: (response) => observer.next(response),\n    error: (err) =>\n        observer.error({\n            level: 'error',\n            message: err.message,\n            meta: {\n                search,\n            },\n        }),\n    complete: () => observer.complete(),\n});\n\n/**\n * Determine if a fetch is needed based on the given search preview state\n * @param {Object} searchState search preview state\n * @returns {Boolean}\n */\nexport const previewFetchPredicate = (searchState) => {\n    if (get(searchState, ['content', 'isRealTimeSearch'], false)) {\n        return true;\n    }\n    // we do a fetch when\n    // 1. result count > 0\n    // 2. search is done so we can make sure we always return the result\n    return (\n        get(searchState, ['content', 'resultPreviewCount'], 0) > 0 ||\n        !!get(searchState, ['content', 'isDone'])\n    );\n};\n\n/**\n * Provides common options for splunk search dispatch options\n * @param {Object} context Object containing any configurable dispatchOptions from splunk/search-job\n * @returns {Object}\n */\nexport const getEnterpriseSearchContext = (context) => {\n    return { keepAlive: true, cache: false, app, ...context };\n};\n","module.exports = require(\"lodash/pick\");","module.exports = require(\"lodash/get\");","module.exports = require(\"rxjs\");","module.exports = require(\"@splunk/ui-utils/i18n\");","module.exports = require(\"@splunk/datasource-utils/DataSet\");","module.exports = require(\"@splunk/moment\");","module.exports = require(\"@splunk/splunk-utils/config\");"],"sourceRoot":""}
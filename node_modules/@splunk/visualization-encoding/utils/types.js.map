{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/DataPoint.ts","webpack:///external \"@babel/runtime/helpers/classCallCheck\"","webpack:///external \"@babel/runtime/helpers/createClass\"","webpack:///external \"lodash\"","webpack:///./src/utils/types.ts","webpack:///./src/TypeSafeValue.ts","webpack:///external \"@splunk/visualizations-shared/colorUtils\"","webpack:///external \"@splunk/moment\"","webpack:///external \"@babel/runtime/helpers/slicedToArray\""],"names":[],"mappings":"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","file":"types.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 6);\n","import { DataPrimitive, TypedValue, DataType, IDataPoint } from './DataPrimitive';\nimport { TypeSafeValue } from './TypeSafeValue';\n\n/**\n * Base DataPoint class and associated DataPoint selectors\n * @implements {DataPrimitive}\n * @implements {IDataPoint}\n */\nexport class DataPoint<T extends DataType = DataType> implements DataPrimitive<T>, IDataPoint<T> {\n    private value: TypeSafeValue<T>;\n    public field: string;\n\n    static isDataPoint(o: any): o is DataPoint {\n        return o instanceof DataPoint;\n    }\n\n    static fromRaw(value): DataPoint {\n        return new DataPoint('', TypeSafeValue.fromRaw(value));\n    }\n\n    /**\n     *\n     * @param {string} field data field\n     * @param {object} value data value + it's type (number, string, time or color)\n     * @param {object} meta meta data (value + type) associated with the data point\n     */\n    public constructor(field: string, value: TypedValue<T>) {\n        this.field = field;\n        this.setValue(value);\n    }\n\n    getValue(): TypeSafeValue<T> {\n        return this.value;\n    }\n\n    /**\n     * sets the data point's value to a static TypedValue\n     * @param {TypedValue} v\n     */\n    setValue(v: TypedValue<T>): void {\n        this.value = TypeSafeValue.from(v);\n    }\n\n    /**\n     * get only value of the data point\n     * @returns {string|number|null}\n     */\n    getRawValue(): string | number | null {\n        return this.value.toRawValue();\n    }\n\n    /**\n     * Returns the datatype of the point\n     * @public\n     * @returns {DataPoint<'string'>}\n     */\n    getField(): DataPoint<'string'> {\n        return DataPoint.fromRaw(this.field) as DataPoint<'string'>;\n    }\n}\n","module.exports = require(\"@babel/runtime/helpers/classCallCheck\");","module.exports = require(\"@babel/runtime/helpers/createClass\");","module.exports = require(\"lodash\");","import moment from '@splunk/moment';\nimport { isNumber as lodashIsNumber, isBoolean, isFinite, isObject, isEmpty, memoize } from 'lodash';\nimport { isColor } from '@splunk/visualizations-shared/colorUtils';\nimport { DataType } from '../DataPrimitive';\nimport { DataPoint } from '../DataPoint';\n\n/**\n * returns true if this dataPoint is a finite number\n * @param dataPoint\n * @returns {*}\n */\nexport function isNumber(dataPoint): boolean {\n    return (\n        dataPoint !== null &&\n        !isBoolean(dataPoint) &&\n        dataPoint !== '' &&\n        isFinite(+dataPoint) &&\n        lodashIsNumber(+dataPoint)\n    );\n}\n\n/**\n *returns OK if data is time\n * @param dataPoint\n * @returns {boolean}\n */\nexport function isTime(dataPoint): boolean {\n    if (!dataPoint) {\n        return false;\n    }\n\n    // only support time string in following format: https://www.w3.org/TR/NOTE-datetime\n    const supportedDateFormats = [\n        'YYYY-MM-DD', // HTML5 date\n        moment.ISO_8601,\n        'YYYY-MM-DDTHH:mm', // HTML5 date local\n        'YYYY-MM-DDTHH:mm:ss.SSS', // HTML5 date local milliseconds\n        'YYYY-MM-DDTHH:mm:ss', // HTML5 date local seconds\n        'YYYY-MM-DD HH:MM',\n        'YYYY-MM-DD HH:MM:SS',\n        'YYYY-MM-DD HH:MM:SS.SSS',\n    ];\n    return typeof dataPoint === 'string'\n        ? moment(dataPoint, supportedDateFormats, true).isValid()\n        : moment(dataPoint).isValid();\n}\n\n/**\n * returns OK if data is string\n * @param dataPoint\n * @returns {boolean}\n */\nexport function isString(dataPoint): boolean {\n    return typeof dataPoint === 'string';\n}\n\n/**\n * getDataTypeForPoint\n * naive implementation of checking for the data type of a single data point\n * number > time > string > unknown\n * starting with number because a Date.parse(number) is a valid date\n *\n * @param {any} dataPoint\n * @param {object} metaData meta data about the data field\n * @return {string} type\n */\nexport const getDataTypeForPoint = <T>(dataPoint?: T, metaData?: { fieldName: string }): DataType => {\n    if (canInferTypeFromMeta(metaData)) {\n        return getDataTypeForMeta(metaData);\n    }\n    return memoizedGetDataTypeForValue(dataPoint);\n};\n\nconst getDataTypeForValue = <T>(dataPoint?: T): DataType => {\n    if (Array.isArray(dataPoint)) {\n        if (dataPoint.length > 1 && dataPoint[0] === '##__SPARKLINE__##') {\n            return 'sparkline';\n        }\n        return 'array';\n    } else if (isObject(dataPoint)) {\n        return 'unknown';\n    } else if (isNumber(dataPoint)) {\n        return 'number';\n    } else if (isColor(dataPoint)) {\n        return 'color';\n    } else if (isTime(dataPoint)) {\n        return 'time';\n    } else if (isString(dataPoint)) {\n        return 'string';\n    } else if (dataPoint === null) {\n        return 'null';\n    }\n    // objects, etc\n    return 'unknown';\n};\nconst memoizedGetDataTypeForValue = memoize(getDataTypeForValue);\n\nexport interface MetaData {\n    fieldName?: string;\n}\n/**\n * canInferTypeFromMeta\n * verifies whether a data type can be inferred from meta data\n * @param {object} metaData\n * @return {boolean} whether the data type can be inferred from meta\n */\nexport const canInferTypeFromMeta = (metaData: MetaData = {}): boolean => {\n    const { fieldName } = metaData;\n    return fieldName === '_time';\n};\n/**\n * getDataTypeForMeta\n * returns a data type based on meta data\n * @param {object} metaData\n * @return {string} type\n */\nexport const getDataTypeForMeta = (metaData: MetaData = {}): DataType => {\n    const { fieldName } = metaData;\n    if (fieldName === '_time') {\n        return 'time';\n    }\n    // this case should never be reached\n    return 'unknown';\n};\n\n/**\n * inferDataTypeFromSample\n * based on a number of data points this function determines the data type for all of them\n * and returns the most common data type (naive type inference)\n *\n * @param {Array} dataSample an array of arbitrary size containing data points of any data type\n * @return {string} type the most common type in the sample\n */\nexport const inferDataTypeFromSample = <T>(dataSample: T[]): DataType => {\n    const typeMatches: { [k in DataType]: number } = {\n        time: 0,\n        number: 0,\n        string: 0,\n        color: 0,\n        unknown: 0,\n        array: 0,\n        sparkline: 0,\n        null: 0,\n    };\n    dataSample.forEach((point): void => {\n        typeMatches[getDataTypeForPoint(point)] += 1;\n    });\n    let typeCount = 0;\n    let returnType = 'unknown';\n    Object.keys(typeMatches).forEach((key: DataType): void => {\n        if (typeMatches[key] > typeCount) {\n            typeCount = typeMatches[key];\n            returnType = key;\n        }\n    });\n    return returnType as DataType;\n};\n\n/**\n * based on a data array (e.g. one data column) this function returns a tiny sample of it\n * @TODO: very naive approach. there's papers with more advanced techniques but for now this should be very fast\n *\n * @param {Array} data to draw a sample from\n * @return {Array} a sample of the passed data\n */\nexport const drawSample = <T>(data: T[]): T[] => {\n    let sampleData: T[] = [];\n    if (data.length > 2) {\n        sampleData = [data[0], data[Math.floor(data.length / 2)], data[data.length - 1]];\n    } else {\n        sampleData = data;\n    }\n    return sampleData.map((point: T) =>\n        DataPoint.isDataPoint(point) ? point.getValue().originalValue : point\n    );\n};\n\n/**\n *\n * @param {*} data\n */\nexport const inferDataTypeFromData = <T>(data: T[]): DataType => inferDataTypeFromSample(drawSample(data));\n","import { isColor } from '@splunk/visualizations-shared/colorUtils';\nimport { DataType, TypedValue } from './DataPrimitive';\nimport { isNumber, isString, isTime, getDataTypeForPoint } from '../src/utils/types';\nimport moment from '@splunk/moment';\n\n/**\n * @implements {TypedValue}\n * TypeSafeValue implements the TypedValue interface, and adds additional methods 'isOk' which can be used to determine\n * if the value was properly coerced into the expected type. When isOk is false, it means that coerced value cannot\n * be relied upon. For example, if the type is 'time' but isOk is false, it is possible that the coerced value could be NaN.\n * A field named originalValue can be used for user-facing error messages in situations where isOk is false. For example:\n * \"'cat' was not an OK value for a 'time' field\". This class's fields are all immutable.\n */\nexport class TypeSafeValue<T extends DataType> implements TypedValue<T> {\n    /**\n     * isTypeSafe. This is a marker field. The presence of this field can be used at runtime to determine if TypedValue is rigorous,\n     * loose. Loose TypedValue such as {type:'number', value:'cat'} are handy for testing, but can lie. Obviously 'cat'\n     * is not a number. If the isTypeSafe field is present then the instance is a TypeSafeValue\n     * @type {boolean}\n     */\n    readonly isTypeSafe: boolean = true;\n    /**\n     * isOk. This field tells if the original value passed into this's constructor honored its type contract.\n     * @type {boolean}\n     */\n    readonly isOk: boolean = true;\n    /**\n     * originalValue. This field retains the original value prior to coercion. It can be used to show a user which values\n     * failed to comply with the expected type.\n     */\n    readonly originalValue: any;\n\n    readonly type: T;\n    readonly value: any;\n\n    constructor(type: T, value: any, isOk: boolean, originalValue: any) {\n        this.type = type;\n        this.value = value;\n        this.isOk = isOk;\n        this.originalValue = originalValue;\n    }\n\n    /**\n     * returns a TypeSafeValue, either by converting the non TypeSafeValue to\n     * a TypeSafeValue, or by simply returning the passed-in TypeSafeValue\n     * @param {TypedValue<T>} typedValue\n     * @returns {TypeSafeValue<T>}\n     */\n    public static from<T extends DataType = DataType>(typedValue: TypedValue<T>): TypeSafeValue<T> {\n        if ((typedValue as any).isTypeSafe) {\n            return typedValue as TypeSafeValue<T>; // just return what was passed in since it is already TypeSafeValue\n        } else {\n            const { value: originalValue, type } = typedValue;\n            const [value, isOk] = TypeSafeValue.coerceValue<T>(typedValue);\n            return new TypeSafeValue<T>(type, value, isOk, originalValue);\n        }\n    }\n\n    /**\n     * Creates a TypeSafeValue from a raw value\n     * @param value\n     * @returns {TypeSafeValue<DataType>}\n     */\n    public static fromRaw(value): TypeSafeValue<DataType> {\n        const type: DataType = getDataTypeForPoint(value);\n        return new TypeSafeValue(type, value, true, value);\n    }\n\n    /**\n     * attempts to coerce the provided value to the provided type. Returns tuple\n     * of the coerced value and a boolean telling if the coercion was clean (true)\n     * or if the coercion was likely produced an unusable result, such as NaN for\n     * a number, or '' for a color.\n     * @param {TypedValue<T>} typedValue\n     * @returns {[any, boolean]}\n     */\n    private static coerceValue<T extends DataType = DataType>(typedValue: TypedValue<T>): [any, boolean] {\n        const { type, value } = typedValue;\n        let coercedVal = null;\n        let isOk: boolean;\n        let acceptableType = true;\n        try {\n            switch (type) {\n                case 'number': {\n                    isOk = isNumber(value);\n                    coercedVal = Number(value);\n                    break;\n                }\n                case 'time': {\n                    isOk = isTime(value);\n                    if (value instanceof Date) {\n                        coercedVal = value;\n                    } else {\n                        // for case like `VM-203`, It will be convereted to a Date.\n                        coercedVal = isOk ? new Date(value) : 'Invalid Date';\n                    }\n\n                    break;\n                }\n                case 'string': {\n                    isOk = isString(value);\n                    coercedVal = value.toString();\n                    break;\n                }\n                case 'color': {\n                    isOk = isColor(value);\n                    coercedVal = value;\n                    break;\n                }\n                case 'sparkline': {\n                    isOk = Array.isArray(value) && value[0] === '##__SPARKLINE__##';\n                    coercedVal = value;\n                    break;\n                }\n                case 'array': {\n                    isOk = Array.isArray(value);\n                    coercedVal = value;\n                    break;\n                }\n                case 'null': {\n                    isOk = value === null;\n                    coercedVal = value;\n                    break;\n                }\n                default: {\n                    acceptableType = false;\n                }\n            }\n        } catch (e) {\n            isOk = false;\n        }\n        if (!acceptableType) {\n            throw new Error(`unknown type: '${type}'`);\n        }\n        return [coercedVal, isOk];\n    }\n\n    toRawValue(): string | number | null {\n        switch (this.type) {\n            case 'time':\n                return moment(this.value).format();\n            case 'sparkline':\n            case 'array':\n            case 'number':\n            case 'string':\n            case 'color':\n            default:\n                return this.value;\n        }\n    }\n}\n","module.exports = require(\"@splunk/visualizations-shared/colorUtils\");","module.exports = require(\"@splunk/moment\");","module.exports = require(\"@babel/runtime/helpers/slicedToArray\");"],"sourceRoot":""}
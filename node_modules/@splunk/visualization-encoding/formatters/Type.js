/*!
 * Copyright © 2018 Splunk Inc.
 * SPLUNK CONFIDENTIAL – Use or disclosure of this material in whole or
 * in part without a valid written license from Splunk Inc. is PROHIBITED.
 */
module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 24);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

module.exports = require("@babel/runtime/helpers/classCallCheck");

/***/ }),
/* 1 */
/***/ (function(module, exports) {

module.exports = require("@babel/runtime/helpers/createClass");

/***/ }),
/* 2 */,
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _classCallCheck = __webpack_require__(0);

var _createClass = __webpack_require__(1);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DataPoint = void 0;

var TypeSafeValue_1 = __webpack_require__(10);
/**
 * Base DataPoint class and associated DataPoint selectors
 * @implements {DataPrimitive}
 * @implements {IDataPoint}
 */


var DataPoint = /*#__PURE__*/function () {
  /**
   *
   * @param {string} field data field
   * @param {object} value data value + it's type (number, string, time or color)
   * @param {object} meta meta data (value + type) associated with the data point
   */
  function DataPoint(field, value) {
    _classCallCheck(this, DataPoint);

    this.field = field;
    this.setValue(value);
  }

  _createClass(DataPoint, [{
    key: "getValue",
    value: function getValue() {
      return this.value;
    }
    /**
     * sets the data point's value to a static TypedValue
     * @param {TypedValue} v
     */

  }, {
    key: "setValue",
    value: function setValue(v) {
      this.value = TypeSafeValue_1.TypeSafeValue.from(v);
    }
    /**
     * get only value of the data point
     * @returns {string|number|null}
     */

  }, {
    key: "getRawValue",
    value: function getRawValue() {
      return this.value.toRawValue();
    }
    /**
     * Returns the datatype of the point
     * @public
     * @returns {DataPoint<'string'>}
     */

  }, {
    key: "getField",
    value: function getField() {
      return DataPoint.fromRaw(this.field);
    }
  }], [{
    key: "isDataPoint",
    value: function isDataPoint(o) {
      return o instanceof DataPoint;
    }
  }, {
    key: "fromRaw",
    value: function fromRaw(value) {
      return new DataPoint('', TypeSafeValue_1.TypeSafeValue.fromRaw(value));
    }
  }]);

  return DataPoint;
}();

exports.DataPoint = DataPoint;

/***/ }),
/* 4 */
/***/ (function(module, exports) {

module.exports = require("@babel/runtime/helpers/inherits");

/***/ }),
/* 5 */
/***/ (function(module, exports) {

module.exports = require("@babel/runtime/helpers/possibleConstructorReturn");

/***/ }),
/* 6 */
/***/ (function(module, exports) {

module.exports = require("@babel/runtime/helpers/getPrototypeOf");

/***/ }),
/* 7 */
/***/ (function(module, exports) {

module.exports = require("lodash");

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _classCallCheck = __webpack_require__(0);

var _createClass = __webpack_require__(1);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AbstractFormatter = void 0;

var DataFrame_1 = __webpack_require__(11);

var DataSeries_1 = __webpack_require__(9);

var DataPoint_1 = __webpack_require__(3);

var AbstractFormatter = /*#__PURE__*/function () {
  function AbstractFormatter() {
    _classCallCheck(this, AbstractFormatter);
  }

  _createClass(AbstractFormatter, [{
    key: "format",
    value: function format(dataPrimitive) {
      var _this = this;

      if (dataPrimitive instanceof DataFrame_1.DataFrame) {
        var newSeries = [];
        dataPrimitive.series.forEach(function (dataSeries, i) {
          newSeries.push(_this.formatSeries(dataSeries, i));
        });
        return new DataFrame_1.DataFrame(newSeries);
      } else if (dataPrimitive instanceof DataSeries_1.DataSeries) {
        return this.formatSeries(dataPrimitive);
      } else {
        return this.formatPoint(dataPrimitive);
      }
    }
  }, {
    key: "formatSeries",
    value: function formatSeries(s) {
      var _this2 = this;

      var i = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var newPoints = [];
      s.points.forEach(function (dataPoint, j) {
        newPoints.push(_this2.formatPoint(dataPoint, s, i, j));
      });
      return new DataSeries_1.DataSeries(newPoints); // new DataSeries must have the type of the formatter's output
    }
  }, {
    key: "formatPoint",
    value: function formatPoint(p, s) {
      var i = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var j = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      var field = p.field;
      var tmp = this.formatTypedValue(p, s, i, j);
      return new DataPoint_1.DataPoint(field, tmp);
    }
  }, {
    key: "makeArrays2D",
    value: function makeArrays2D(a) {
      if (Array.isArray(a)) {
        if (Array.isArray(a[0])) {
          return a;
        } else {
          return [a];
        }
      }

      throw new Error("argument wasn't array");
    }
  }]);

  return AbstractFormatter;
}();

exports.AbstractFormatter = AbstractFormatter;

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _classCallCheck = __webpack_require__(0);

var _createClass = __webpack_require__(1);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DataSeries = void 0;

var DataPoint_1 = __webpack_require__(3);
/**
 * DataSeries class and associated DataSeries selectors
 * @implements {DataPrimitive}
 */


var DataSeries = /*#__PURE__*/function () {
  /**
   *
   * @param {array} points list of data points
   */
  function DataSeries() {
    var points = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

    _classCallCheck(this, DataSeries);

    this.points = points;

    if (points.length > 0) {
      this.field = points[0].field; // the field is an immutable property of the series
    }
  }

  _createClass(DataSeries, [{
    key: "firstPoint",
    value:
    /**
     * return first dataPoint in series
     * @public
     * @returns {DataPoint}
     */
    function firstPoint() {
      return this.points[0];
    }
    /**
     * return last dataPoint in series
     * @public
     * @returns {DataPoint}
     */

  }, {
    key: "lastPoint",
    value: function lastPoint() {
      return this.points.slice(-1)[0];
    }
    /**
     * finds dataPoint(s) in DataSeries by index(es)
     * @public
     * @param {...number} indexes
     * @returns {DataSeries}
     */

  }, {
    key: "pointsByIndexes",
    value: function pointsByIndexes() {
      var _this = this;

      var indexedPoints = [];

      for (var _len = arguments.length, indexes = new Array(_len), _key = 0; _key < _len; _key++) {
        indexes[_key] = arguments[_key];
      }

      indexes.forEach(function (index) {
        var dp = _this.points[index]; // should we allow negative indexes?

        if (dp != null) {
          indexedPoints.push(dp);
        }
      });
      return new DataSeries(indexedPoints);
    }
    /**
     * finds and returns the individual dataPoint at the given index
     * @public
     * @param {number} index
     * @returns {DataPoint}
     */

  }, {
    key: "pointByIndex",
    value: function pointByIndex(indexIn) {
      var index = indexIn;

      if (index < 0) {
        index = this.points.length + index;
      }

      if (index < 0 || index >= this.points.length) {
        // will handle out-of-range indexes for the time being by returning null
        return null;
      }

      var dp = this.points[index];
      var field = dp.field;

      var _dp$getValue = dp.getValue(),
          type = _dp$getValue.type,
          value = _dp$getValue.value;

      return new DataPoint_1.DataPoint(field, {
        type: type,
        value: value
      });
    }
    /**
     * finds the delta between the last point and point at the given index.
     * a negative index can be used, indicating an offset from the end of the sequence
     * @public
     * @param {number} index
     * @returns {DataPoint}
     */

  }, {
    key: "delta",
    value: function delta(index) {
      var dp1 = this.lastPoint();

      if (dp1 === undefined) {
        return undefined;
      }

      var field = dp1.field;

      var _dp1$getValue = dp1.getValue(),
          type = _dp1$getValue.type,
          val1 = _dp1$getValue.value;

      if (type !== 'number') {
        console.warn("delta cannot be computed for non-numerical data series of type ".concat(type)); // Throw an error and catch in pipeline executor?
      }

      var dp2 = null; // use undefined as default, because null values will be coerced to 0 (thus invalid indexes return a delta of 0)
      // for aggregate SPL queries like `stats count`, we want no trend value rather than 0 as the trend value

      var delta;

      if (index >= 0) {
        dp2 = this.points[index];
      } else {
        dp2 = this.points.slice().reverse()[Math.abs(index) - 1];
      }

      if (dp2 == null) {
        console.warn('invalid index'); // Throw an error and catch in pipeline executor?
      } else {
        var _dp2$getValue = dp2.getValue(),
            val2 = _dp2$getValue.value;

        delta = val1 - val2;
      }

      return new DataPoint_1.DataPoint(field, {
        type: type,
        value: delta
      }); // create a new data point since we don't want meta data to carry over
    }
    /**
     * sets all the values in the Data Series to a static TypedValue
     * @param {TypedValue} v
     */

  }, {
    key: "setValue",
    value: function setValue(v) {
      this.points.forEach(function (p) {
        p.setValue(v);
      });
    }
    /**
     * gets all the values + their type in the Data Series
     * @returns {TypedValue[]}
     */

  }, {
    key: "getValue",
    value: function getValue() {
      var values = [];
      this.points.forEach(function (p) {
        values.push(p.getValue());
      });
      return values;
    }
    /**
     * gets all the values (only) in the Data Series
     * @returns {array}
     */

  }, {
    key: "getRawValue",
    value: function getRawValue() {
      var values = [];
      this.points.forEach(function (p) {
        values.push(p.getRawValue());
      });
      return values;
    }
    /**
     * Returns the uniform type of the series
     * @public
     * @returns {DataPoint<'string'>}
     */

  }, {
    key: "getField",
    value: function getField() {
      var dp1 = this.lastPoint();
      return dp1.getField();
    }
    /**
     * returns the minimum DataPoint in the series or undefined if no numbers in series
     * @public
     * @returns {DataPoint<T>}
     */

  }, {
    key: "min",
    value: function min() {
      return this.reduce(function (v1, v2) {
        return v1 < v2;
      });
    }
    /**
     * returns the maximum DataPoint in the series
     * @public
     * @returns {DataPoint<T>}
     */

  }, {
    key: "max",
    value: function max() {
      return this.reduce(function (v1, v2) {
        return v1 > v2;
      });
    }
  }, {
    key: "reduce",
    value: function reduce(comparator) {
      return this.points.reduce(function (agg, cur) {
        // note: cannot use agg.getRawValue here instead of agg.value.value as that limits returned value to string|number
        return !agg || comparator(cur.getValue().value, agg.getValue().value) ? cur : agg;
      }, undefined);
    }
  }], [{
    key: "isDataSeries",
    value: function isDataSeries(o) {
      return o instanceof DataSeries;
    }
  }, {
    key: "fromRaw",
    value: function fromRaw(pts) {
      return new DataSeries(pts.map(function (p) {
        return DataPoint_1.DataPoint.fromRaw(p);
      }));
    }
  }]);

  return DataSeries;
}();

exports.DataSeries = DataSeries;

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _slicedToArray = __webpack_require__(23);

var _classCallCheck = __webpack_require__(0);

var _createClass = __webpack_require__(1);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TypeSafeValue = void 0;

var colorUtils_1 = __webpack_require__(15);

var types_1 = __webpack_require__(13);

var moment_1 = __webpack_require__(14);
/**
 * @implements {TypedValue}
 * TypeSafeValue implements the TypedValue interface, and adds additional methods 'isOk' which can be used to determine
 * if the value was properly coerced into the expected type. When isOk is false, it means that coerced value cannot
 * be relied upon. For example, if the type is 'time' but isOk is false, it is possible that the coerced value could be NaN.
 * A field named originalValue can be used for user-facing error messages in situations where isOk is false. For example:
 * "'cat' was not an OK value for a 'time' field". This class's fields are all immutable.
 */


var TypeSafeValue = /*#__PURE__*/function () {
  function TypeSafeValue(type, value, isOk, originalValue) {
    _classCallCheck(this, TypeSafeValue);

    /**
     * isTypeSafe. This is a marker field. The presence of this field can be used at runtime to determine if TypedValue is rigorous,
     * loose. Loose TypedValue such as {type:'number', value:'cat'} are handy for testing, but can lie. Obviously 'cat'
     * is not a number. If the isTypeSafe field is present then the instance is a TypeSafeValue
     * @type {boolean}
     */
    this.isTypeSafe = true;
    /**
     * isOk. This field tells if the original value passed into this's constructor honored its type contract.
     * @type {boolean}
     */

    this.isOk = true;
    this.type = type;
    this.value = value;
    this.isOk = isOk;
    this.originalValue = originalValue;
  }
  /**
   * returns a TypeSafeValue, either by converting the non TypeSafeValue to
   * a TypeSafeValue, or by simply returning the passed-in TypeSafeValue
   * @param {TypedValue<T>} typedValue
   * @returns {TypeSafeValue<T>}
   */


  _createClass(TypeSafeValue, [{
    key: "toRawValue",
    value: function toRawValue() {
      switch (this.type) {
        case 'time':
          return moment_1.default(this.value).format();

        case 'sparkline':
        case 'array':
        case 'number':
        case 'string':
        case 'color':
        default:
          return this.value;
      }
    }
  }], [{
    key: "from",
    value: function from(typedValue) {
      if (typedValue.isTypeSafe) {
        return typedValue; // just return what was passed in since it is already TypeSafeValue
      } else {
        var originalValue = typedValue.value,
            type = typedValue.type;

        var _TypeSafeValue$coerce = TypeSafeValue.coerceValue(typedValue),
            _TypeSafeValue$coerce2 = _slicedToArray(_TypeSafeValue$coerce, 2),
            value = _TypeSafeValue$coerce2[0],
            isOk = _TypeSafeValue$coerce2[1];

        return new TypeSafeValue(type, value, isOk, originalValue);
      }
    }
    /**
     * Creates a TypeSafeValue from a raw value
     * @param value
     * @returns {TypeSafeValue<DataType>}
     */

  }, {
    key: "fromRaw",
    value: function fromRaw(value) {
      var type = types_1.getDataTypeForPoint(value);
      return new TypeSafeValue(type, value, true, value);
    }
    /**
     * attempts to coerce the provided value to the provided type. Returns tuple
     * of the coerced value and a boolean telling if the coercion was clean (true)
     * or if the coercion was likely produced an unusable result, such as NaN for
     * a number, or '' for a color.
     * @param {TypedValue<T>} typedValue
     * @returns {[any, boolean]}
     */

  }, {
    key: "coerceValue",
    value: function coerceValue(typedValue) {
      var type = typedValue.type,
          value = typedValue.value;
      var coercedVal = null;
      var isOk;
      var acceptableType = true;

      try {
        switch (type) {
          case 'number':
            {
              isOk = types_1.isNumber(value);
              coercedVal = Number(value);
              break;
            }

          case 'time':
            {
              isOk = types_1.isTime(value);

              if (value instanceof Date) {
                coercedVal = value;
              } else {
                // for case like `VM-203`, It will be convereted to a Date.
                coercedVal = isOk ? new Date(value) : 'Invalid Date';
              }

              break;
            }

          case 'string':
            {
              isOk = types_1.isString(value);
              coercedVal = value.toString();
              break;
            }

          case 'color':
            {
              isOk = colorUtils_1.isColor(value);
              coercedVal = value;
              break;
            }

          case 'sparkline':
            {
              isOk = Array.isArray(value) && value[0] === '##__SPARKLINE__##';
              coercedVal = value;
              break;
            }

          case 'array':
            {
              isOk = Array.isArray(value);
              coercedVal = value;
              break;
            }

          case 'null':
            {
              isOk = value === null;
              coercedVal = value;
              break;
            }

          default:
            {
              acceptableType = false;
            }
        }
      } catch (e) {
        isOk = false;
      }

      if (!acceptableType) {
        throw new Error("unknown type: '".concat(type, "'"));
      }

      return [coercedVal, isOk];
    }
  }]);

  return TypeSafeValue;
}();

exports.TypeSafeValue = TypeSafeValue;

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _classCallCheck = __webpack_require__(0);

var _createClass = __webpack_require__(1);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DataFrame = void 0;

var DataPoint_1 = __webpack_require__(3);

var DataSeries_1 = __webpack_require__(9);

var types_1 = __webpack_require__(13);
/**
 * Base DataFrame class and associated DataFrame selectors
 * @implements {DataPrimitive}
 */


var DataFrame = /*#__PURE__*/function () {
  /**
   * @param {array} series list of data series
   */
  function DataFrame(series) {
    _classCallCheck(this, DataFrame);

    this.series = Array.isArray(series) ? series : [series];
  }
  /**
   * @param {any} o
   * @returns {boolean}
   */


  _createClass(DataFrame, [{
    key: "frameBySeriesIndexes",
    value:
    /**
     * finds series in DataFrame by index(es)
     * @public
     * @param {number[]} indexes
     * @returns {DataFrame}
     */
    function frameBySeriesIndexes() {
      var _this = this;

      var indexedSeries = [];

      for (var _len = arguments.length, indexes = new Array(_len), _key = 0; _key < _len; _key++) {
        indexes[_key] = arguments[_key];
      }

      indexes.forEach(function (index) {
        var ds = _this.series[index]; // should we allow negative indexes?

        if (ds != null) {
          indexedSeries.push(ds);
        }
      });
      return new DataFrame(indexedSeries);
    }
    /**
     *  Returns the data series at the given index
     * @public
     * @param {number} index
     * @returns {DataSeries<T>}
     */

  }, {
    key: "seriesByIndex",
    value: function seriesByIndex(index) {
      return this.series[index];
    }
    /**
     * Returns a DataFrame that is a slice of this DataFrame's series from  [start, end)
     * @public
     * @param {int} start (inclusive)
     * @param {int} end (optional, exclusive)
     * @returns {DataFrame<T>}
     */

  }, {
    key: "frameBySeriesIndexRange",
    value: function frameBySeriesIndexRange(start, end) {
      return new DataFrame(this.series.slice(start, end));
    }
    /**
     * Returns a DataFrame having only the DataSeries matching the provided names
     * @public
     * @param {string[]} names
     * @returns {DataFrame<T>}
     */

  }, {
    key: "frameBySeriesNames",
    value: function frameBySeriesNames() {
      var _this2 = this;

      var namedSeries = [];

      for (var _len2 = arguments.length, names = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        names[_key2] = arguments[_key2];
      }

      names.forEach(function (name) {
        var found = _this2.seriesByName(name);

        found && namedSeries.push(found);
      });
      return new DataFrame(namedSeries);
    }
    /**
     * Returns a DataFrame having the DataSeries matching provided names or indexes
     * @public
     * @param {...(string|number)} namesOrIndexes
     * @returns {DataFrame<T>}
     */

  }, {
    key: "frameBySeriesNamesOrIndexes",
    value: function frameBySeriesNamesOrIndexes() {
      var _this3 = this;

      var mixedSeries = [];

      for (var _len3 = arguments.length, mixed = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        mixed[_key3] = arguments[_key3];
      }

      mixed.forEach(function (nameOrIndex) {
        var asNumber = Number(nameOrIndex);

        if (Number.isNaN(asNumber)) {
          var found = _this3.seriesByName(nameOrIndex);

          found && mixedSeries.push(found);
        } else {
          var _found = _this3.series[asNumber];
          _found && mixedSeries.push(_found);
        }
      });
      return new DataFrame(mixedSeries);
    }
    /**
     * Returns a DataFrame containing DataSeries that match only the provided types
     * @public
     * @param {T[]} types
     * @returns {DataFrame<T>}
     */

  }, {
    key: "frameBySeriesTypes",
    value: function frameBySeriesTypes() {
      for (var _len4 = arguments.length, types = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        types[_key4] = arguments[_key4];
      }

      return new DataFrame(this.series.filter(function (s) {
        return types.includes(s.firstPoint().getValue().type);
      }) //fixme todo we should have a getType() method on a series. SHould not make 'decision' about what type the series is from outside the series
      );
    }
    /**
     * finds series in DataFrame by field name
     * @public
     * @param {string} field
     * @returns {DataSeries<T>}
     */

  }, {
    key: "seriesByName",
    value: function seriesByName(field) {
      return this.series.find(function (dataSeries) {
        return field === dataSeries.field;
      });
    }
    /**
     * finds series in DataFrame by first data type match
     * @public
     * @param {T} type
     * @returns {DataSeries<T>}
     */

  }, {
    key: "seriesByType",
    value: function seriesByType(type) {
      return this.series.find(function (dataSeries) {
        var dataType = types_1.inferDataTypeFromData(dataSeries.points);
        return dataType === type;
      });
    }
    /**
     * finds series in DataFrame with the providing prioritized types
     * @public
     * @param {T[]} types T extends from DataType, which is 'number' | 'string' | 'color' | 'time' | 'unknown' | 'sparkline' | 'array' | 'null'
     * @returns {DataSeries<T>}
     */

  }, {
    key: "seriesByPrioritizedTypes",
    value: function seriesByPrioritizedTypes() {
      var _a;

      for (var _len5 = arguments.length, types = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
        types[_key5] = arguments[_key5];
      }

      for (var _i = 0, _types = types; _i < _types.length; _i++) {
        var type = _types[_i];
        var matchedSeries = this.seriesByType(type);

        if (Array.isArray(matchedSeries === null || matchedSeries === void 0 ? void 0 : matchedSeries.points) && ((_a = matchedSeries === null || matchedSeries === void 0 ? void 0 : matchedSeries.points) === null || _a === void 0 ? void 0 : _a.length)) {
          return matchedSeries;
        }
      }

      return this.series[0];
    }
    /**
     * sets all the values in the DataFrame to a static TypedValue
     * @public
     * @param {TypedValue} v
     */

  }, {
    key: "setValue",
    value: function setValue(v) {
      this.series.forEach(function (s) {
        return s.setValue(v);
      });
    }
    /**
     * gets all the values (only) in the Data Frame
     * @public
     * @returns {array}
     */

  }, {
    key: "getRawValue",
    value: function getRawValue() {
      var values = [];
      this.series.forEach(function (s) {
        values.push(s.getRawValue());
      });
      return values;
    }
    /**
     * gets all the values + their types in the Data Frame
     * @public
     * @returns {TypedValue[][]}
     */

  }, {
    key: "getValue",
    value: function getValue() {
      var values = [];
      this.series.forEach(function (s) {
        values.push(s.getValue());
      });
      return values;
    }
    /**
     * Get the field names of each series in frame
     * @public
     * @returns {DataSeries<'string'>}
     */

  }, {
    key: "getField",
    value: function getField() {
      var points = this.series.map(function (s) {
        return s.getField();
      });
      return new DataSeries_1.DataSeries(points);
    }
    /**
     * finds the global minimum value (from all numerical series) in the Data Frame
     * @public
     * @returns {number}
     */

  }, {
    key: "min",
    value: function min() {
      return this.minOrMax('min');
    }
    /**
     * finds the global maximum value (from all numerical series) in the Data Frame
     * @public
     * @returns {number}
     */

  }, {
    key: "max",
    value: function max() {
      return this.minOrMax('max');
    }
    /**
     * runs result of min or max function over all the series and returns the data point
     * points
     * @param {string} aggName
     * @returns {DataPoint<T>}
     */

  }, {
    key: "minOrMax",
    value: function minOrMax(funcName) {
      var overallSeries = new DataSeries_1.DataSeries();
      this.series.forEach(function (s) {
        var m = s[funcName]();
        m && overallSeries.points.push(m);
      });
      return overallSeries[funcName]();
    }
  }], [{
    key: "isDataFrame",
    value: function isDataFrame(o) {
      return o instanceof DataFrame;
    }
    /**
     * Loads ColumnarData into a DataFrame
     * @param {ColumnarData} columnarData
     * @returns {DataFrame<T>}
     */

  }, {
    key: "fromJsonCols",
    value: function fromJsonCols(columnarData) {
      if (!columnarData || columnarData.data === null) {
        return new DataFrame([]);
      } // fixme todo why do we expect an object like {data:{fields, columns}}? Why don't we just expect something like {fields, columns}? The nesting inside 'data' feels useless


      var _columnarData$data = columnarData.data,
          _columnarData$data$fi = _columnarData$data.fields,
          fields = _columnarData$data$fi === void 0 ? [] : _columnarData$data$fi,
          _columnarData$data$co = _columnarData$data.columns,
          columns = _columnarData$data$co === void 0 ? [] : _columnarData$data$co;

      if (columns.length !== fields.length) {
        throw new Error("number of columns (".concat(columns.length, ") does not match number of fields (").concat(fields.length, ")"));
      }

      var dataSeries = [];
      columns.forEach(function (data, idx) {
        var dataPoints = [];
        var fieldInfo = fields[idx];
        var fieldName = fieldInfo.name || fieldInfo;
        data.forEach(function (value) {
          var dataType = types_1.getDataTypeForPoint(value, {
            fieldName: fieldName
          });
          dataPoints.push(new DataPoint_1.DataPoint(fieldName, {
            value: value,
            type: dataType
          }));
        });
        dataSeries.push(new DataSeries_1.DataSeries(dataPoints));
      });
      return new DataFrame(dataSeries);
    }
  }, {
    key: "fromRaw",
    value: function fromRaw(f) {
      var series = [];
      f.forEach(function (s) {
        series.push(DataSeries_1.DataSeries.fromRaw(s));
      });
      return new DataFrame(series);
    }
  }, {
    key: "fromDataPrimitive",
    value: function fromDataPrimitive(dp) {
      if (DataFrame.isDataFrame(dp)) {
        return dp;
      } else if (DataSeries_1.DataSeries.isDataSeries(dp)) {
        return new DataFrame([dp]);
      } else if (DataPoint_1.DataPoint.isDataPoint(dp)) {
        return new DataFrame([new DataSeries_1.DataSeries([dp])]);
      }
    }
  }]);

  return DataFrame;
}();

exports.DataFrame = DataFrame;

/***/ }),
/* 12 */,
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.inferDataTypeFromData = exports.drawSample = exports.inferDataTypeFromSample = exports.getDataTypeForMeta = exports.canInferTypeFromMeta = exports.getDataTypeForPoint = exports.isString = exports.isTime = exports.isNumber = void 0;

var moment_1 = __webpack_require__(14);

var lodash_1 = __webpack_require__(7);

var colorUtils_1 = __webpack_require__(15);

var DataPoint_1 = __webpack_require__(3);
/**
 * returns true if this dataPoint is a finite number
 * @param dataPoint
 * @returns {*}
 */


function isNumber(dataPoint) {
  return dataPoint !== null && !lodash_1.isBoolean(dataPoint) && dataPoint !== '' && lodash_1.isFinite(+dataPoint) && lodash_1.isNumber(+dataPoint);
}

exports.isNumber = isNumber;
/**
 *returns OK if data is time
 * @param dataPoint
 * @returns {boolean}
 */

function isTime(dataPoint) {
  if (!dataPoint) {
    return false;
  } // only support time string in following format: https://www.w3.org/TR/NOTE-datetime


  var supportedDateFormats = ['YYYY-MM-DD', moment_1.default.ISO_8601, 'YYYY-MM-DDTHH:mm', 'YYYY-MM-DDTHH:mm:ss.SSS', 'YYYY-MM-DDTHH:mm:ss', 'YYYY-MM-DD HH:MM', 'YYYY-MM-DD HH:MM:SS', 'YYYY-MM-DD HH:MM:SS.SSS'];
  return typeof dataPoint === 'string' ? moment_1.default(dataPoint, supportedDateFormats, true).isValid() : moment_1.default(dataPoint).isValid();
}

exports.isTime = isTime;
/**
 * returns OK if data is string
 * @param dataPoint
 * @returns {boolean}
 */

function isString(dataPoint) {
  return typeof dataPoint === 'string';
}

exports.isString = isString;
/**
 * getDataTypeForPoint
 * naive implementation of checking for the data type of a single data point
 * number > time > string > unknown
 * starting with number because a Date.parse(number) is a valid date
 *
 * @param {any} dataPoint
 * @param {object} metaData meta data about the data field
 * @return {string} type
 */

var getDataTypeForPoint = function getDataTypeForPoint(dataPoint, metaData) {
  if (exports.canInferTypeFromMeta(metaData)) {
    return exports.getDataTypeForMeta(metaData);
  }

  return memoizedGetDataTypeForValue(dataPoint);
};

exports.getDataTypeForPoint = getDataTypeForPoint;

var getDataTypeForValue = function getDataTypeForValue(dataPoint) {
  if (Array.isArray(dataPoint)) {
    if (dataPoint.length > 1 && dataPoint[0] === '##__SPARKLINE__##') {
      return 'sparkline';
    }

    return 'array';
  } else if (lodash_1.isObject(dataPoint)) {
    return 'unknown';
  } else if (isNumber(dataPoint)) {
    return 'number';
  } else if (colorUtils_1.isColor(dataPoint)) {
    return 'color';
  } else if (isTime(dataPoint)) {
    return 'time';
  } else if (isString(dataPoint)) {
    return 'string';
  } else if (dataPoint === null) {
    return 'null';
  } // objects, etc


  return 'unknown';
};

var memoizedGetDataTypeForValue = lodash_1.memoize(getDataTypeForValue);
/**
 * canInferTypeFromMeta
 * verifies whether a data type can be inferred from meta data
 * @param {object} metaData
 * @return {boolean} whether the data type can be inferred from meta
 */

var canInferTypeFromMeta = function canInferTypeFromMeta() {
  var metaData = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var fieldName = metaData.fieldName;
  return fieldName === '_time';
};

exports.canInferTypeFromMeta = canInferTypeFromMeta;
/**
 * getDataTypeForMeta
 * returns a data type based on meta data
 * @param {object} metaData
 * @return {string} type
 */

var getDataTypeForMeta = function getDataTypeForMeta() {
  var metaData = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var fieldName = metaData.fieldName;

  if (fieldName === '_time') {
    return 'time';
  } // this case should never be reached


  return 'unknown';
};

exports.getDataTypeForMeta = getDataTypeForMeta;
/**
 * inferDataTypeFromSample
 * based on a number of data points this function determines the data type for all of them
 * and returns the most common data type (naive type inference)
 *
 * @param {Array} dataSample an array of arbitrary size containing data points of any data type
 * @return {string} type the most common type in the sample
 */

var inferDataTypeFromSample = function inferDataTypeFromSample(dataSample) {
  var typeMatches = {
    time: 0,
    number: 0,
    string: 0,
    color: 0,
    unknown: 0,
    array: 0,
    sparkline: 0,
    null: 0
  };
  dataSample.forEach(function (point) {
    typeMatches[exports.getDataTypeForPoint(point)] += 1;
  });
  var typeCount = 0;
  var returnType = 'unknown';
  Object.keys(typeMatches).forEach(function (key) {
    if (typeMatches[key] > typeCount) {
      typeCount = typeMatches[key];
      returnType = key;
    }
  });
  return returnType;
};

exports.inferDataTypeFromSample = inferDataTypeFromSample;
/**
 * based on a data array (e.g. one data column) this function returns a tiny sample of it
 * @TODO: very naive approach. there's papers with more advanced techniques but for now this should be very fast
 *
 * @param {Array} data to draw a sample from
 * @return {Array} a sample of the passed data
 */

var drawSample = function drawSample(data) {
  var sampleData = [];

  if (data.length > 2) {
    sampleData = [data[0], data[Math.floor(data.length / 2)], data[data.length - 1]];
  } else {
    sampleData = data;
  }

  return sampleData.map(function (point) {
    return DataPoint_1.DataPoint.isDataPoint(point) ? point.getValue().originalValue : point;
  });
};

exports.drawSample = drawSample;
/**
 *
 * @param {*} data
 */

var inferDataTypeFromData = function inferDataTypeFromData(data) {
  return exports.inferDataTypeFromSample(exports.drawSample(data));
};

exports.inferDataTypeFromData = inferDataTypeFromData;

/***/ }),
/* 14 */
/***/ (function(module, exports) {

module.exports = require("@splunk/moment");

/***/ }),
/* 15 */
/***/ (function(module, exports) {

module.exports = require("@splunk/visualizations-shared/colorUtils");

/***/ }),
/* 16 */,
/* 17 */,
/* 18 */,
/* 19 */,
/* 20 */,
/* 21 */,
/* 22 */,
/* 23 */
/***/ (function(module, exports) {

module.exports = require("@babel/runtime/helpers/slicedToArray");

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _classCallCheck = __webpack_require__(0);

var _createClass = __webpack_require__(1);

var _inherits = __webpack_require__(4);

var _possibleConstructorReturn = __webpack_require__(5);

var _getPrototypeOf = __webpack_require__(6);

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Type = void 0;

var Formatter_1 = __webpack_require__(8);

var TypeSafeValue_1 = __webpack_require__(10);
/**
 * Formatter that returns the DataType for each element within the given DataSeries.
 *
 * ```js
 * <SampleViz
 *     options={{
 *         option1: '> primary | seriesByIndex(0) | type()' // returns ['number', 'number', 'number']
 *         option2: '> primary | seriesByIndex(1) | type()' // returns ['string', 'string', 'string']
 *     }}
 *     dataSources={{
 *         data: {
 *             primary: {
 *                 columns: [[100, 200, 300], ['string1', 'string2', 'string3']]
 *                 fields: [{ name: 'foo' }, { name: 'bar' }]
 *             }
 *         }
 *     }}
 * />
 * ```
 */


var Type = /*#__PURE__*/function (_Formatter_1$Abstract) {
  _inherits(Type, _Formatter_1$Abstract);

  var _super = _createSuper(Type);

  function Type() {
    _classCallCheck(this, Type);

    return _super.apply(this, arguments);
  }

  _createClass(Type, [{
    key: "formatTypedValue",
    value: function formatTypedValue(p) {
      return TypeSafeValue_1.TypeSafeValue.fromRaw(TypeSafeValue_1.TypeSafeValue.fromRaw(p.getRawValue()).type);
    }
  }]);

  return Type;
}(Formatter_1.AbstractFormatter);

exports.Type = Type;

/***/ })
/******/ ]);
//# sourceMappingURL=Type.js.map
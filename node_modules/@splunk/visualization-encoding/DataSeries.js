/*!
 * Copyright © 2018 Splunk Inc.
 * SPLUNK CONFIDENTIAL – Use or disclosure of this material in whole or
 * in part without a valid written license from Splunk Inc. is PROHIBITED.
 */
module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 9);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

module.exports = require("@babel/runtime/helpers/classCallCheck");

/***/ }),
/* 1 */
/***/ (function(module, exports) {

module.exports = require("@babel/runtime/helpers/createClass");

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _classCallCheck = __webpack_require__(0);

var _createClass = __webpack_require__(1);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DataPoint = void 0;

var TypeSafeValue_1 = __webpack_require__(10);
/**
 * Base DataPoint class and associated DataPoint selectors
 * @implements {DataPrimitive}
 * @implements {IDataPoint}
 */


var DataPoint = /*#__PURE__*/function () {
  /**
   *
   * @param {string} field data field
   * @param {object} value data value + it's type (number, string, time or color)
   * @param {object} meta meta data (value + type) associated with the data point
   */
  function DataPoint(field, value) {
    _classCallCheck(this, DataPoint);

    this.field = field;
    this.setValue(value);
  }

  _createClass(DataPoint, [{
    key: "getValue",
    value: function getValue() {
      return this.value;
    }
    /**
     * sets the data point's value to a static TypedValue
     * @param {TypedValue} v
     */

  }, {
    key: "setValue",
    value: function setValue(v) {
      this.value = TypeSafeValue_1.TypeSafeValue.from(v);
    }
    /**
     * get only value of the data point
     * @returns {string|number|null}
     */

  }, {
    key: "getRawValue",
    value: function getRawValue() {
      return this.value.toRawValue();
    }
    /**
     * Returns the datatype of the point
     * @public
     * @returns {DataPoint<'string'>}
     */

  }, {
    key: "getField",
    value: function getField() {
      return DataPoint.fromRaw(this.field);
    }
  }], [{
    key: "isDataPoint",
    value: function isDataPoint(o) {
      return o instanceof DataPoint;
    }
  }, {
    key: "fromRaw",
    value: function fromRaw(value) {
      return new DataPoint('', TypeSafeValue_1.TypeSafeValue.fromRaw(value));
    }
  }]);

  return DataPoint;
}();

exports.DataPoint = DataPoint;

/***/ }),
/* 3 */,
/* 4 */
/***/ (function(module, exports) {

module.exports = require("lodash");

/***/ }),
/* 5 */,
/* 6 */,
/* 7 */,
/* 8 */,
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _classCallCheck = __webpack_require__(0);

var _createClass = __webpack_require__(1);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DataSeries = void 0;

var DataPoint_1 = __webpack_require__(2);
/**
 * DataSeries class and associated DataSeries selectors
 * @implements {DataPrimitive}
 */


var DataSeries = /*#__PURE__*/function () {
  /**
   *
   * @param {array} points list of data points
   */
  function DataSeries() {
    var points = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

    _classCallCheck(this, DataSeries);

    this.points = points;

    if (points.length > 0) {
      this.field = points[0].field; // the field is an immutable property of the series
    }
  }

  _createClass(DataSeries, [{
    key: "firstPoint",
    value:
    /**
     * return first dataPoint in series
     * @public
     * @returns {DataPoint}
     */
    function firstPoint() {
      return this.points[0];
    }
    /**
     * return last dataPoint in series
     * @public
     * @returns {DataPoint}
     */

  }, {
    key: "lastPoint",
    value: function lastPoint() {
      return this.points.slice(-1)[0];
    }
    /**
     * finds dataPoint(s) in DataSeries by index(es)
     * @public
     * @param {...number} indexes
     * @returns {DataSeries}
     */

  }, {
    key: "pointsByIndexes",
    value: function pointsByIndexes() {
      var _this = this;

      var indexedPoints = [];

      for (var _len = arguments.length, indexes = new Array(_len), _key = 0; _key < _len; _key++) {
        indexes[_key] = arguments[_key];
      }

      indexes.forEach(function (index) {
        var dp = _this.points[index]; // should we allow negative indexes?

        if (dp != null) {
          indexedPoints.push(dp);
        }
      });
      return new DataSeries(indexedPoints);
    }
    /**
     * finds and returns the individual dataPoint at the given index
     * @public
     * @param {number} index
     * @returns {DataPoint}
     */

  }, {
    key: "pointByIndex",
    value: function pointByIndex(indexIn) {
      var index = indexIn;

      if (index < 0) {
        index = this.points.length + index;
      }

      if (index < 0 || index >= this.points.length) {
        // will handle out-of-range indexes for the time being by returning null
        return null;
      }

      var dp = this.points[index];
      var field = dp.field;

      var _dp$getValue = dp.getValue(),
          type = _dp$getValue.type,
          value = _dp$getValue.value;

      return new DataPoint_1.DataPoint(field, {
        type: type,
        value: value
      });
    }
    /**
     * finds the delta between the last point and point at the given index.
     * a negative index can be used, indicating an offset from the end of the sequence
     * @public
     * @param {number} index
     * @returns {DataPoint}
     */

  }, {
    key: "delta",
    value: function delta(index) {
      var dp1 = this.lastPoint();

      if (dp1 === undefined) {
        return undefined;
      }

      var field = dp1.field;

      var _dp1$getValue = dp1.getValue(),
          type = _dp1$getValue.type,
          val1 = _dp1$getValue.value;

      if (type !== 'number') {
        console.warn("delta cannot be computed for non-numerical data series of type ".concat(type)); // Throw an error and catch in pipeline executor?
      }

      var dp2 = null; // use undefined as default, because null values will be coerced to 0 (thus invalid indexes return a delta of 0)
      // for aggregate SPL queries like `stats count`, we want no trend value rather than 0 as the trend value

      var delta;

      if (index >= 0) {
        dp2 = this.points[index];
      } else {
        dp2 = this.points.slice().reverse()[Math.abs(index) - 1];
      }

      if (dp2 == null) {
        console.warn('invalid index'); // Throw an error and catch in pipeline executor?
      } else {
        var _dp2$getValue = dp2.getValue(),
            val2 = _dp2$getValue.value;

        delta = val1 - val2;
      }

      return new DataPoint_1.DataPoint(field, {
        type: type,
        value: delta
      }); // create a new data point since we don't want meta data to carry over
    }
    /**
     * sets all the values in the Data Series to a static TypedValue
     * @param {TypedValue} v
     */

  }, {
    key: "setValue",
    value: function setValue(v) {
      this.points.forEach(function (p) {
        p.setValue(v);
      });
    }
    /**
     * gets all the values + their type in the Data Series
     * @returns {TypedValue[]}
     */

  }, {
    key: "getValue",
    value: function getValue() {
      var values = [];
      this.points.forEach(function (p) {
        values.push(p.getValue());
      });
      return values;
    }
    /**
     * gets all the values (only) in the Data Series
     * @returns {array}
     */

  }, {
    key: "getRawValue",
    value: function getRawValue() {
      var values = [];
      this.points.forEach(function (p) {
        values.push(p.getRawValue());
      });
      return values;
    }
    /**
     * Returns the uniform type of the series
     * @public
     * @returns {DataPoint<'string'>}
     */

  }, {
    key: "getField",
    value: function getField() {
      var dp1 = this.lastPoint();
      return dp1.getField();
    }
    /**
     * returns the minimum DataPoint in the series or undefined if no numbers in series
     * @public
     * @returns {DataPoint<T>}
     */

  }, {
    key: "min",
    value: function min() {
      return this.reduce(function (v1, v2) {
        return v1 < v2;
      });
    }
    /**
     * returns the maximum DataPoint in the series
     * @public
     * @returns {DataPoint<T>}
     */

  }, {
    key: "max",
    value: function max() {
      return this.reduce(function (v1, v2) {
        return v1 > v2;
      });
    }
  }, {
    key: "reduce",
    value: function reduce(comparator) {
      return this.points.reduce(function (agg, cur) {
        // note: cannot use agg.getRawValue here instead of agg.value.value as that limits returned value to string|number
        return !agg || comparator(cur.getValue().value, agg.getValue().value) ? cur : agg;
      }, undefined);
    }
  }], [{
    key: "isDataSeries",
    value: function isDataSeries(o) {
      return o instanceof DataSeries;
    }
  }, {
    key: "fromRaw",
    value: function fromRaw(pts) {
      return new DataSeries(pts.map(function (p) {
        return DataPoint_1.DataPoint.fromRaw(p);
      }));
    }
  }]);

  return DataSeries;
}();

exports.DataSeries = DataSeries;

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _slicedToArray = __webpack_require__(16);

var _classCallCheck = __webpack_require__(0);

var _createClass = __webpack_require__(1);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TypeSafeValue = void 0;

var colorUtils_1 = __webpack_require__(13);

var types_1 = __webpack_require__(11);

var moment_1 = __webpack_require__(14);
/**
 * @implements {TypedValue}
 * TypeSafeValue implements the TypedValue interface, and adds additional methods 'isOk' which can be used to determine
 * if the value was properly coerced into the expected type. When isOk is false, it means that coerced value cannot
 * be relied upon. For example, if the type is 'time' but isOk is false, it is possible that the coerced value could be NaN.
 * A field named originalValue can be used for user-facing error messages in situations where isOk is false. For example:
 * "'cat' was not an OK value for a 'time' field". This class's fields are all immutable.
 */


var TypeSafeValue = /*#__PURE__*/function () {
  function TypeSafeValue(type, value, isOk, originalValue) {
    _classCallCheck(this, TypeSafeValue);

    /**
     * isTypeSafe. This is a marker field. The presence of this field can be used at runtime to determine if TypedValue is rigorous,
     * loose. Loose TypedValue such as {type:'number', value:'cat'} are handy for testing, but can lie. Obviously 'cat'
     * is not a number. If the isTypeSafe field is present then the instance is a TypeSafeValue
     * @type {boolean}
     */
    this.isTypeSafe = true;
    /**
     * isOk. This field tells if the original value passed into this's constructor honored its type contract.
     * @type {boolean}
     */

    this.isOk = true;
    this.type = type;
    this.value = value;
    this.isOk = isOk;
    this.originalValue = originalValue;
  }
  /**
   * returns a TypeSafeValue, either by converting the non TypeSafeValue to
   * a TypeSafeValue, or by simply returning the passed-in TypeSafeValue
   * @param {TypedValue<T>} typedValue
   * @returns {TypeSafeValue<T>}
   */


  _createClass(TypeSafeValue, [{
    key: "toRawValue",
    value: function toRawValue() {
      switch (this.type) {
        case 'time':
          return moment_1.default(this.value).format();

        case 'sparkline':
        case 'array':
        case 'number':
        case 'string':
        case 'color':
        default:
          return this.value;
      }
    }
  }], [{
    key: "from",
    value: function from(typedValue) {
      if (typedValue.isTypeSafe) {
        return typedValue; // just return what was passed in since it is already TypeSafeValue
      } else {
        var originalValue = typedValue.value,
            type = typedValue.type;

        var _TypeSafeValue$coerce = TypeSafeValue.coerceValue(typedValue),
            _TypeSafeValue$coerce2 = _slicedToArray(_TypeSafeValue$coerce, 2),
            value = _TypeSafeValue$coerce2[0],
            isOk = _TypeSafeValue$coerce2[1];

        return new TypeSafeValue(type, value, isOk, originalValue);
      }
    }
    /**
     * Creates a TypeSafeValue from a raw value
     * @param value
     * @returns {TypeSafeValue<DataType>}
     */

  }, {
    key: "fromRaw",
    value: function fromRaw(value) {
      var type = types_1.getDataTypeForPoint(value);
      return new TypeSafeValue(type, value, true, value);
    }
    /**
     * attempts to coerce the provided value to the provided type. Returns tuple
     * of the coerced value and a boolean telling if the coercion was clean (true)
     * or if the coercion was likely produced an unusable result, such as NaN for
     * a number, or '' for a color.
     * @param {TypedValue<T>} typedValue
     * @returns {[any, boolean]}
     */

  }, {
    key: "coerceValue",
    value: function coerceValue(typedValue) {
      var type = typedValue.type,
          value = typedValue.value;
      var coercedVal = null;
      var isOk;
      var acceptableType = true;

      try {
        switch (type) {
          case 'number':
            {
              isOk = types_1.isNumber(value);
              coercedVal = Number(value);
              break;
            }

          case 'time':
            {
              isOk = types_1.isTime(value);

              if (value instanceof Date) {
                coercedVal = value;
              } else {
                // for case like `VM-203`, It will be convereted to a Date.
                coercedVal = isOk ? new Date(value) : 'Invalid Date';
              }

              break;
            }

          case 'string':
            {
              isOk = types_1.isString(value);
              coercedVal = value.toString();
              break;
            }

          case 'color':
            {
              isOk = colorUtils_1.isColor(value);
              coercedVal = value;
              break;
            }

          case 'sparkline':
            {
              isOk = Array.isArray(value) && value[0] === '##__SPARKLINE__##';
              coercedVal = value;
              break;
            }

          case 'array':
            {
              isOk = Array.isArray(value);
              coercedVal = value;
              break;
            }

          case 'null':
            {
              isOk = value === null;
              coercedVal = value;
              break;
            }

          default:
            {
              acceptableType = false;
            }
        }
      } catch (e) {
        isOk = false;
      }

      if (!acceptableType) {
        throw new Error("unknown type: '".concat(type, "'"));
      }

      return [coercedVal, isOk];
    }
  }]);

  return TypeSafeValue;
}();

exports.TypeSafeValue = TypeSafeValue;

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.inferDataTypeFromData = exports.drawSample = exports.inferDataTypeFromSample = exports.getDataTypeForMeta = exports.canInferTypeFromMeta = exports.getDataTypeForPoint = exports.isString = exports.isTime = exports.isNumber = void 0;

var moment_1 = __webpack_require__(14);

var lodash_1 = __webpack_require__(4);

var colorUtils_1 = __webpack_require__(13);

var DataPoint_1 = __webpack_require__(2);
/**
 * returns true if this dataPoint is a finite number
 * @param dataPoint
 * @returns {*}
 */


function isNumber(dataPoint) {
  return dataPoint !== null && !lodash_1.isBoolean(dataPoint) && dataPoint !== '' && lodash_1.isFinite(+dataPoint) && lodash_1.isNumber(+dataPoint);
}

exports.isNumber = isNumber;
/**
 *returns OK if data is time
 * @param dataPoint
 * @returns {boolean}
 */

function isTime(dataPoint) {
  if (!dataPoint) {
    return false;
  } // only support time string in following format: https://www.w3.org/TR/NOTE-datetime


  var supportedDateFormats = ['YYYY-MM-DD', moment_1.default.ISO_8601, 'YYYY-MM-DDTHH:mm', 'YYYY-MM-DDTHH:mm:ss.SSS', 'YYYY-MM-DDTHH:mm:ss', 'YYYY-MM-DD HH:MM', 'YYYY-MM-DD HH:MM:SS', 'YYYY-MM-DD HH:MM:SS.SSS'];
  return typeof dataPoint === 'string' ? moment_1.default(dataPoint, supportedDateFormats, true).isValid() : moment_1.default(dataPoint).isValid();
}

exports.isTime = isTime;
/**
 * returns OK if data is string
 * @param dataPoint
 * @returns {boolean}
 */

function isString(dataPoint) {
  return typeof dataPoint === 'string';
}

exports.isString = isString;
/**
 * getDataTypeForPoint
 * naive implementation of checking for the data type of a single data point
 * number > time > string > unknown
 * starting with number because a Date.parse(number) is a valid date
 *
 * @param {any} dataPoint
 * @param {object} metaData meta data about the data field
 * @return {string} type
 */

var getDataTypeForPoint = function getDataTypeForPoint(dataPoint, metaData) {
  if (exports.canInferTypeFromMeta(metaData)) {
    return exports.getDataTypeForMeta(metaData);
  }

  return memoizedGetDataTypeForValue(dataPoint);
};

exports.getDataTypeForPoint = getDataTypeForPoint;

var getDataTypeForValue = function getDataTypeForValue(dataPoint) {
  if (Array.isArray(dataPoint)) {
    if (dataPoint.length > 1 && dataPoint[0] === '##__SPARKLINE__##') {
      return 'sparkline';
    }

    return 'array';
  } else if (lodash_1.isObject(dataPoint)) {
    return 'unknown';
  } else if (isNumber(dataPoint)) {
    return 'number';
  } else if (colorUtils_1.isColor(dataPoint)) {
    return 'color';
  } else if (isTime(dataPoint)) {
    return 'time';
  } else if (isString(dataPoint)) {
    return 'string';
  } else if (dataPoint === null) {
    return 'null';
  } // objects, etc


  return 'unknown';
};

var memoizedGetDataTypeForValue = lodash_1.memoize(getDataTypeForValue);
/**
 * canInferTypeFromMeta
 * verifies whether a data type can be inferred from meta data
 * @param {object} metaData
 * @return {boolean} whether the data type can be inferred from meta
 */

var canInferTypeFromMeta = function canInferTypeFromMeta() {
  var metaData = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var fieldName = metaData.fieldName;
  return fieldName === '_time';
};

exports.canInferTypeFromMeta = canInferTypeFromMeta;
/**
 * getDataTypeForMeta
 * returns a data type based on meta data
 * @param {object} metaData
 * @return {string} type
 */

var getDataTypeForMeta = function getDataTypeForMeta() {
  var metaData = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var fieldName = metaData.fieldName;

  if (fieldName === '_time') {
    return 'time';
  } // this case should never be reached


  return 'unknown';
};

exports.getDataTypeForMeta = getDataTypeForMeta;
/**
 * inferDataTypeFromSample
 * based on a number of data points this function determines the data type for all of them
 * and returns the most common data type (naive type inference)
 *
 * @param {Array} dataSample an array of arbitrary size containing data points of any data type
 * @return {string} type the most common type in the sample
 */

var inferDataTypeFromSample = function inferDataTypeFromSample(dataSample) {
  var typeMatches = {
    time: 0,
    number: 0,
    string: 0,
    color: 0,
    unknown: 0,
    array: 0,
    sparkline: 0,
    null: 0
  };
  dataSample.forEach(function (point) {
    typeMatches[exports.getDataTypeForPoint(point)] += 1;
  });
  var typeCount = 0;
  var returnType = 'unknown';
  Object.keys(typeMatches).forEach(function (key) {
    if (typeMatches[key] > typeCount) {
      typeCount = typeMatches[key];
      returnType = key;
    }
  });
  return returnType;
};

exports.inferDataTypeFromSample = inferDataTypeFromSample;
/**
 * based on a data array (e.g. one data column) this function returns a tiny sample of it
 * @TODO: very naive approach. there's papers with more advanced techniques but for now this should be very fast
 *
 * @param {Array} data to draw a sample from
 * @return {Array} a sample of the passed data
 */

var drawSample = function drawSample(data) {
  var sampleData = [];

  if (data.length > 2) {
    sampleData = [data[0], data[Math.floor(data.length / 2)], data[data.length - 1]];
  } else {
    sampleData = data;
  }

  return sampleData.map(function (point) {
    return DataPoint_1.DataPoint.isDataPoint(point) ? point.getValue().originalValue : point;
  });
};

exports.drawSample = drawSample;
/**
 *
 * @param {*} data
 */

var inferDataTypeFromData = function inferDataTypeFromData(data) {
  return exports.inferDataTypeFromSample(exports.drawSample(data));
};

exports.inferDataTypeFromData = inferDataTypeFromData;

/***/ }),
/* 12 */,
/* 13 */
/***/ (function(module, exports) {

module.exports = require("@splunk/visualizations-shared/colorUtils");

/***/ }),
/* 14 */
/***/ (function(module, exports) {

module.exports = require("@splunk/moment");

/***/ }),
/* 15 */,
/* 16 */
/***/ (function(module, exports) {

module.exports = require("@babel/runtime/helpers/slicedToArray");

/***/ })
/******/ ]);
//# sourceMappingURL=DataSeries.js.map
{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///external \"@splunk/ui-utils/i18n\"","webpack:///external \"@babel/runtime/regenerator\"","webpack:///external \"@babel/runtime/helpers/classCallCheck\"","webpack:///external \"@babel/runtime/helpers/createClass\"","webpack:///external \"@babel/runtime/helpers/asyncToGenerator\"","webpack:///external \"@babel/runtime/helpers/getPrototypeOf\"","webpack:///external \"@splunk/visualization-context/Provider\"","webpack:///external \"@babel/runtime/helpers/inherits\"","webpack:///external \"@babel/runtime/helpers/possibleConstructorReturn\"","webpack:///external \"@babel/runtime/helpers/slicedToArray\"","webpack:///./src/BaseRegistry.js","webpack:///./src/GeoRegistry.js"],"names":["BaseRegistry","provider","_","console","cachedProvider","providerType","type","isDefault","url","id","obj","options","offset","count","ids","GeoRegistry","geoId","storageType","mapId","geoJson"],"mappings":"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","file":"GeoRegistry.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 21);\n","module.exports = require(\"@splunk/ui-utils/i18n\");","module.exports = require(\"@babel/runtime/regenerator\");","module.exports = require(\"@babel/runtime/helpers/classCallCheck\");","module.exports = require(\"@babel/runtime/helpers/createClass\");","module.exports = require(\"@babel/runtime/helpers/asyncToGenerator\");","module.exports = require(\"@babel/runtime/helpers/getPrototypeOf\");","module.exports = require(\"@splunk/visualization-context/Provider\");","module.exports = require(\"@babel/runtime/helpers/inherits\");","module.exports = require(\"@babel/runtime/helpers/possibleConstructorReturn\");","module.exports = require(\"@babel/runtime/helpers/slicedToArray\");","/* eslint-disable class-methods-use-this */\nimport { _ } from '@splunk/ui-utils/i18n';\nimport Provider from '@splunk/visualization-context/Provider';\n\n/**\n * Base Registry\n */\nclass BaseRegistry {\n    constructor() {\n        this.cachedProviders = {};\n        this.defaultProvider = null;\n    }\n\n    static create() {\n        return new BaseRegistry();\n    }\n\n    /**\n     * check whether user defined provider extends the base provider\n     * @param {Provider} provider\n     * @returns {Boolean}\n     */\n    isValidProvider(provider) {\n        if (provider instanceof Provider) {\n            return true;\n        }\n        throw new Error(_('Invalid Provider'));\n    }\n\n    /**\n     * add default provider to cache\n     * @param {Provider} provider\n     */\n    addDefaultProvider(provider) {\n        if (this.isValidProvider(provider)) {\n            this.addProvider(provider);\n            this.defaultProvider = provider;\n        }\n    }\n\n    /**\n     * add provider to cache\n     * @param {Provider} provider\n     */\n    addProvider(provider) {\n        if (this.isValidProvider(provider)) {\n            if (this.cachedProviders[provider.getType()]) {\n                // eslint-disable-next-line\n                console.warn(`The provider \"${provider.getType()}\" existed already.`);\n            }\n            this.cachedProviders[provider.getType()] = provider;\n        }\n    }\n\n    /**\n     * delete provider\n     * @param {String} providerType\n     */\n    deleteProvider(providerType) {\n        const cachedProvider = this.cachedProviders[providerType];\n        if (!cachedProvider) {\n            // eslint-disable-next-line\n            console.warn(`The provider \"${providerType}\" does not existed`);\n            return;\n        }\n\n        if (this.defaultProvider && providerType === this.defaultProvider.getType()) {\n            this.defaultProvider = null;\n        }\n        delete this.cachedProviders[providerType];\n    }\n\n    /**\n     * find provider from cache\n     * @param {String} type\n     * @returns {Provider} provider\n     */\n    findProvider(type) {\n        const provider = this.cachedProviders[type];\n        if (provider) {\n            return provider;\n        }\n        throw new Error(_('Provider not found'));\n    }\n\n    /**\n     * list all providers\n     * @return {Object} provider = { type: 'local', isDefault: true }\n     */\n    listProviders() {\n        return Object.keys(this.cachedProviders).map(type => ({\n            type,\n            isDefault: type === this.defaultProvider.getType(),\n        }));\n    }\n\n    /**\n     * check whether src is a http url or a url used for icon/image-registry (e.g. 'kvstore://image123')\n     */\n    isResourceURL(url) {\n        if (!url || url.indexOf('://') < 0) {\n            return false;\n        }\n\n        const { type } = this.parseURL(url);\n        return type !== 'http' && type !== 'https';\n    }\n\n    /**\n     * parse provider type and id from the url\n     * @params {String} url     'kvstore://image123'\n     * @returns {Object} obj\n     * @returns {String} obj.type   'kvstore'\n     * @returns {String} obj.id     'image123'\n     */\n    parseURL(url) {\n        if (url) {\n            const [type, id] = url.split('://');\n\n            if (type && id) {\n                return { type, id };\n            }\n        }\n        throw new Error(_('Invalid url'));\n    }\n\n    /**\n     * upload\n     * @param {DataURI} dataURI\n     * @param {Object} metaData\n     * @param {String} providerType      e.g. 'kvstore' or 'sui' or 'local'\n     * @returns {String} id               e.g. 'kvstore://image123'\n     */\n    async upload(dataURI, metaData, providerType) {\n        if (providerType == null && this.defaultProvider == null) {\n            throw new Error(_('No valid provider was found. Please add a provider'));\n        }\n        const provider = providerType ? this.findProvider(providerType) : this.defaultProvider;\n        const id = await provider.upload(dataURI, metaData);\n        return `${provider.getType()}://${id}`;\n    }\n\n    /**\n     * get object by url\n     * @param {String} url     'kvstore://image123'\n     * @returns {Object} obj    e.g. an image object or icon\n     */\n    async getByURL(url) {\n        const { type, id } = this.parseURL(url);\n        const provider = this.findProvider(type);\n        const obj = await provider.getById(id);\n        return obj;\n    }\n\n    /**\n     * delete object by url\n     * @param {String} url     'kvstore://image123' || 'sui://icon123'\n     * @returns {Object} obj    e.g. an image object or icon\n     */\n    async deleteByURL(url) {\n        const { type, id } = this.parseURL(url);\n        const provider = this.findProvider(type);\n        const obj = await provider.deleteById(id);\n        return obj;\n    }\n\n    /**\n     * list all object ids\n     * @params {String} providerType       e.g. 'kvstore' or 'sui'\n     * @params {Object} options\n     * @returns {Array} ids\n     */\n    async listIds(providerType, options = { offset: 0, count: 100 }) {\n        const provider = this.findProvider(providerType);\n        const ids = await provider.listIds(options);\n        return ids;\n    }\n}\n\nexport default BaseRegistry;\n","/* eslint-disable class-methods-use-this */\nimport { _ } from '@splunk/ui-utils/i18n';\nimport BaseRegistry from './BaseRegistry';\n\nclass GeoRegistry extends BaseRegistry {\n    static create() {\n        return new GeoRegistry();\n    }\n\n    /*\n     * parse url\n     * @params {String} url  the valid url should be geo://default/us\n     * @return {Object}\n     *         {String} providerType  'geo'\n     *         {String} storageType 'default' for now // todo: add more in the future if geojson are allowed to save in other storages such as 'kvstore'\n     *         {String} mapId 'us' or 'world' for now\n     */\n    parseURL(url) {\n        if (!/.+:\\/\\/.*\\/.+/.test(url)) {\n            throw new Error(_('Invalid url.'));\n        }\n\n        const [providerType, geoId] = url.split('://');\n        const [storageType, mapId] = geoId.split('/');\n        return { providerType, storageType, mapId };\n    }\n\n    /*\n     * get geoJson by url\n     * @params {String} url  e.g. geo://default/us\n     * @return {Json} geoJson\n     */\n    getByURL(url) {\n        try {\n            const { providerType, storageType, mapId } = this.parseURL(url);\n            const provider = this.findProvider(providerType);\n            const geoJson = provider.getById({ storageType, mapId });\n            return geoJson;\n        } catch (error) {\n            throw new Error(_('Cannot get geoJson data.'));\n        }\n    }\n\n    // Todo: return map ids from storage\n    /*\n     * list all available geojson ids\n     * @params {Object}\n     * @params {String} providerType\n     * @params {Object} options\n     * @return {Array} ids [{id: \"us\", url: 'geo://default/us'}, {id: 'world', url: 'geo://default/world'}]\n     */\n    listIds({ providerType = 'geo', options = { offset: 0, count: 100 } }) {\n        const provider = this.findProvider(providerType);\n        const ids = provider.listIds(options);\n        return ids;\n    }\n\n    // Todo: be able to upload geoJson in the future\n    upload() {}\n\n    // Todo: be able to delete geoJson in the future\n    deleteByURL() {}\n}\n\nexport default GeoRegistry;\n"],"sourceRoot":""}
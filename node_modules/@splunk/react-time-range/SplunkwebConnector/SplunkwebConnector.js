"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _react = _interopRequireWildcard(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _lodash = require("lodash");

var _promise = require("@splunk/ui-utils/promise");

var _presets = require("@splunk/time-range-utils/presets");

var _timeParser = require("@splunk/time-range-utils/timeParser");

var _config = require("@splunk/splunk-utils/config");

var _convertSplunkTimezone = _interopRequireDefault(require("@splunk/moment/convertSplunkTimezone"));

var _Message = _interopRequireDefault(require("@splunk/react-ui/Message"));

var _jsxFileName = "/builds/swp/ui-platform/projects/lib/search-components/react-time-range/src/SplunkwebConnector/SplunkwebConnector.tsx";

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

class SplunkwebConnector extends _react.Component {
  static hashCode(str) {
    let hash = 0;

    if (str.length === 0) {
      return hash;
    }

    for (let i = 0; i < str.length; i += 1) {
      const char = str.charCodeAt(i);
      hash = (hash << 5) - hash + char; // eslint-disable-line no-bitwise

      hash &= hash; // eslint-disable-line no-bitwise
    }

    return hash;
  }

  constructor(props, ...rest) {
    super(props, ...rest);
    (0, _defineProperty2.default)(this, "handleRequestParseEarliest", time => {
      if (this.cancelableEarliestTimeParser) {
        this.cancelableEarliestTimeParser.cancel();
      }

      this.cancelableEarliestTimeParser = (0, _promise.makeCancelable)((0, _timeParser.getISO)(time));
      this.cancelableEarliestTimeParser.promise.then(data => {
        this.setState({
          parseEarliest: _objectSpread({
            error: null,
            time
          }, data)
        });
      }).catch(error => {
        this.setState({
          parseEarliest: {
            error,
            time
          }
        });
      });
    });
    (0, _defineProperty2.default)(this, "handleRequestParseLatest", time => {
      if (this.cancelableLatestTimeParser) {
        this.cancelableLatestTimeParser.cancel();
      }

      this.cancelableLatestTimeParser = (0, _promise.makeCancelable)((0, _timeParser.getISO)(time));
      this.cancelableLatestTimeParser.promise.then(data => {
        this.setState({
          parseLatest: _objectSpread({
            error: null,
            time
          }, data)
        });
      }).catch(error => {
        this.setState({
          parseLatest: {
            error,
            time
          }
        });
      });
    });
    let momentTimeZone = null;

    if (_config.isAvailable) {
      const convertedMomentTimeZone = (0, _convertSplunkTimezone.default)(_config.serverTimezoneInfo, 'temporary');
      const id = SplunkwebConnector.hashCode(convertedMomentTimeZone.abbrs + convertedMomentTimeZone.offsets + convertedMomentTimeZone.untils);
      momentTimeZone = (0, _convertSplunkTimezone.default)(_config.serverTimezoneInfo, id.toString());
    }

    this.state = {
      presets: SplunkwebConnector.sharedPresets,
      momentTimeZone
    };
    SplunkwebConnector.instances.push(this);
  }

  componentWillUnmount() {
    const index = SplunkwebConnector.instances.indexOf(this);
    SplunkwebConnector.instances.splice(index, 1);
  }

  updatePresets() {
    this.setState({
      presets: SplunkwebConnector.sharedPresets
    });
  }

  render() {
    const {
      children,
      presetsTransform
    } = this.props;

    if (!_config.isAvailable) {
      return /*#__PURE__*/_react.default.createElement(_Message.default, {
        type: "error",
        __self: this,
        __source: {
          fileName: _jsxFileName,
          lineNumber: 150,
          columnNumber: 20
        }
      }, "Cannot access splunkweb.");
    }

    return /*#__PURE__*/(0, _react.cloneElement)(children, {
      presets: presetsTransform((0, _lodash.cloneDeep)(this.state.presets)),
      onRequestParseEarliest: this.handleRequestParseEarliest,
      onRequestParseLatest: this.handleRequestParseLatest,
      parseEarliest: this.state.parseEarliest,
      parseLatest: this.state.parseLatest,
      momentTimeZone: this.state.momentTimeZone
    });
  }

}

(0, _defineProperty2.default)(SplunkwebConnector, "propTypes", {
  /**
   * Must be either a Time Range `Dialog` or `Dropdown`.
   */
  children: _propTypes.default.element.isRequired,

  /**
   * A function to transform presets before they are passed to the wrapped component.
   * Should accept and return a presets array.
   */
  presetsTransform: _propTypes.default.func
});
(0, _defineProperty2.default)(SplunkwebConnector, "defaultProps", {
  presetsTransform: presets => presets
});
(0, _defineProperty2.default)(SplunkwebConnector, "instances", []);
(0, _defineProperty2.default)(SplunkwebConnector, "sharedPresets", []);

if (_config.isAvailable) {
  (0, _presets.getPresets)().then(data => {
    data.forEach(preset => SplunkwebConnector.sharedPresets.push(preset));
    SplunkwebConnector.instances.forEach(instance => instance.updatePresets());
  }).catch(() => {
    // eslint-disable-next-line no-console, max-len
    console.log('Time presets could not be loaded from splunkweb.');
  });
}

var _default = SplunkwebConnector;
exports.default = _default;
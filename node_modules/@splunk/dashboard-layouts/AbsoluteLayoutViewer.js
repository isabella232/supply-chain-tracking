/*!
 * Copyright © 2020 Splunk Inc.
 * SPLUNK CONFIDENTIAL – Use or disclosure of this material in whole or
 * in part without a valid written license from Splunk Inc. is PROHIBITED.
 */
module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 68);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

module.exports = require("react");

/***/ }),
/* 1 */
/***/ (function(module, exports) {

module.exports = require("styled-components");

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.scaleGridLayoutStructureByWidth = exports.computeRelativePosition = exports.shiftViewportOnZoom = exports.cloneLine = exports.cloneBlockItem = exports.getAllCollisions = exports.resolveCompactionCollision = exports.bottom = exports.computeLineRelativePosition = exports.computeLineBoxPosition = exports.updateLineAbsPosition = exports.connectLine = exports.disconnectLine = exports.isLineConnected = exports.moveLayoutItem = exports.computeScaleToFit = exports.createOffset = exports.updateBlockItemPosition = exports.updateBlockItemSize = exports.snapOffsetToWH = exports.snapOffsetToXY = exports.snapOffset = exports.findTopBlockItemByPosition = exports.filterBlockItemsByBoundary = exports.positionsToBoundary = exports.considerMoved = exports.getOffset = exports.getClientPosition = exports.positionToStyleString = exports.positionToStyle = exports.removeInvalidItems = exports.isLinePositionValid = exports.isValidConnection = exports.isBlockPositionValid = exports.computeMaxHeight = void 0;
var findLast_1 = __importDefault(__webpack_require__(17));
var get_1 = __importDefault(__webpack_require__(10));
var isNumber_1 = __importDefault(__webpack_require__(18));
var reduce_1 = __importDefault(__webpack_require__(19));
var pullAt_1 = __importDefault(__webpack_require__(20));
var cloneDeep_1 = __importDefault(__webpack_require__(21));
var sortBy_1 = __importDefault(__webpack_require__(22));
var console_1 = __importDefault(__webpack_require__(5));
var layout_1 = __webpack_require__(6);
var edgeUtils_1 = __webpack_require__(11);
// export for gridLayout/legacyGridLayout
exports.computeMaxHeight = layout_1.computeMaxHeight;
/**
 *  check if a position is valid
 * @param {Object} position
 */
var isBlockPositionValid = function (position) {
    return !!(position &&
        Number.isInteger(position.x) &&
        Number.isInteger(position.y) &&
        Number.isInteger(position.w) &&
        Number.isInteger(position.h));
};
exports.isBlockPositionValid = isBlockPositionValid;
var isValidConnection = function (connection) {
    if ('x' in connection &&
        'y' in connection &&
        Number.isInteger(connection.x) &&
        Number.isInteger(connection.y)) {
        return true;
    }
    if ('item' in connection &&
        'port' in connection &&
        connection.item != null &&
        connection.port != null) {
        return true;
    }
    return false;
};
exports.isValidConnection = isValidConnection;
/**
 * a line should has from and to
 */
var isLinePositionValid = function (position) {
    if (position.from != null && position.to != null) {
        return (exports.isValidConnection(position.from) && exports.isValidConnection(position.to));
    }
    return false;
};
exports.isLinePositionValid = isLinePositionValid;
/**
 * filter invalid position
 * @param {Object[]} layoutStructure - Array of items (viz, edges, lines)
 * @returns {Object[]} - Returns filtered array
 */
var removeInvalidItems = function (layoutStructure) {
    if (layoutStructure === void 0) { layoutStructure = []; }
    return layoutStructure.filter(function (structure) {
        if (structure.type === 'line') {
            return exports.isLinePositionValid(structure.position);
        }
        return exports.isBlockPositionValid(structure.position);
    });
};
exports.removeInvalidItems = removeInvalidItems;
/**
 * convert position to css object
 */
var positionToStyle = function (pos) { return ({
    width: pos.w + "px",
    height: pos.h + "px",
    transform: "translate(" + pos.x + "px, " + pos.y + "px)",
}); };
exports.positionToStyle = positionToStyle;
/**
 * convert position to css string
 */
var positionToStyleString = function (pos) {
    var style = exports.positionToStyle(pos);
    return reduce_1.default(style, function (result, v, k) { return result + " " + k + ":" + v + ";"; }, '');
};
exports.positionToStyleString = positionToStyleString;
/**
 * get client position for given event with scale factor
 */
var getClientPosition = function (e, scaleFactor) {
    if (scaleFactor === void 0) { scaleFactor = 1; }
    return ({
        x: Math.round(e.clientX / scaleFactor),
        y: Math.round(e.clientY / scaleFactor),
    });
};
exports.getClientPosition = getClientPosition;
/**
 * compute offset from 2 positions
 */
var getOffset = function (currentPosition, startPosition) { return ({
    offsetX: currentPosition.x - startPosition.x,
    offsetY: currentPosition.y - startPosition.y,
}); };
exports.getOffset = getOffset;
/**
 * check if a given offset can be considered as 'move'
 * @param {Object} config
 * @param {Number} config.offsetX
 * @param {Number} config.offsetY
 */
var considerMoved = function (_a) {
    var offsetX = _a.offsetX, offsetY = _a.offsetY;
    return offsetX !== 0 || offsetY !== 0;
};
exports.considerMoved = considerMoved;
/**
 * return a boundary for 2 positions
 * @param {Coordinate} startPos
 * @param {Coordinate} endPos
 */
var positionsToBoundary = function (startPos, endPos) { return ({
    x: Math.min(startPos.x, endPos.x),
    y: Math.min(startPos.y, endPos.y),
    w: Math.abs(startPos.x - endPos.x),
    h: Math.abs(startPos.y - endPos.y),
}); };
exports.positionsToBoundary = positionsToBoundary;
/**
 * filter abs items within a boundary
 * @param {Array} items
 * @param {Object} boundary
 */
var filterBlockItemsByBoundary = function (items, boundary) {
    return items.filter(function (item) {
        var itemPosition = item.position;
        return !(boundary.x > itemPosition.x + itemPosition.w ||
            boundary.x + boundary.w < itemPosition.x ||
            boundary.y > itemPosition.y + itemPosition.h ||
            boundary.y + boundary.h < itemPosition.y);
    });
};
exports.filterBlockItemsByBoundary = filterBlockItemsByBoundary;
/**
 * find the first item that contains the pos.
 */
var findTopBlockItemByPosition = function (items, pos, padding) {
    if (padding === void 0) { padding = 0; }
    return findLast_1.default(items, function (item) {
        var itemPosition = padding
            ? edgeUtils_1.applyVizPadding({ item: item, padding: padding }).position
            : item.position;
        return (itemPosition.x <= pos.x &&
            itemPosition.x + itemPosition.w >= pos.x &&
            itemPosition.y <= pos.y &&
            itemPosition.y + itemPosition.h >= pos.y);
    });
};
exports.findTopBlockItemByPosition = findTopBlockItemByPosition;
/**
 * Compute the new offset so current + new offset will be the multiple of snapTo unit
 * For examples:
 * (5, 2, 5) => 0, user moved less than half of the snapTo unit, return 0 so 5 + 0 = 5
 * (5, 3, 5) => 5, user moved more than half of the snapTo unit, return 5 so 5 + 5 = 5 * 2
 * (5, 12, 5) => 10
 * (5, 13, 5) => 15
 * @param {Number} current
 * @param {Number} offset
 * @param {Number} snapTo
 */
var snapOffset = function (current, offset, snapTo) {
    // return a new offset
    var remainder = (current + offset) % snapTo;
    var newOffset = remainder > snapTo / 2
        ? offset + (snapTo - remainder)
        : offset - remainder;
    return newOffset;
};
exports.snapOffset = snapOffset;
/**
 * snap item with its top-left corner (represent by x, y)
 * @param {Object} position
 * @param {Object} offset
 * @param {Number} gridWidth
 * @param {Number} gridHeight
 * @param {Number} spacing
 */
var snapOffsetToXY = function (_a) {
    var position = _a.position, offset = _a.offset, gridWidth = _a.gridWidth, gridHeight = _a.gridHeight, _b = _a.spacing, spacing = _b === void 0 ? 0 : _b, _c = _a.padding, padding = _c === void 0 ? 0 : _c;
    var offsetX = offset.offsetX, offsetY = offset.offsetY;
    offsetX = exports.snapOffset(position.x, offsetX, gridWidth + spacing) + padding;
    offsetY = exports.snapOffset(position.y, offsetY, gridHeight + spacing) + padding;
    return {
        offsetX: offsetX,
        offsetY: offsetY,
    };
};
exports.snapOffsetToXY = snapOffsetToXY;
/**
 * snap item with its size (represent by w, h)
 * @param {Object} position
 * @param {Object} offset
 * @param {Number} gridWidth
 * @param {Number} gridHeight
 * @param {Number} spacing
 */
var snapOffsetToWH = function (_a) {
    var position = _a.position, offset = _a.offset, gridWidth = _a.gridWidth, gridHeight = _a.gridHeight, _b = _a.spacing, spacing = _b === void 0 ? 0 : _b, _c = _a.padding, padding = _c === void 0 ? 0 : _c;
    var offsetX = offset.offsetX, offsetY = offset.offsetY;
    offsetX =
        exports.snapOffset(position.x + position.w, offsetX, gridWidth + spacing) +
            (padding - spacing);
    offsetY =
        exports.snapOffset(position.y + position.h, offsetY, gridHeight + spacing) +
            (padding - spacing);
    return {
        offsetX: offsetX,
        offsetY: offsetY,
    };
};
exports.snapOffsetToWH = snapOffsetToWH;
/**
 * Mutate item coordinates and/or dimensions.
 * This mutation's new dimensions and coordinates are bounded within the original block item real estate.
 * @param {Object} item
 * @param {Object} offset
 * @param {String} dir Cartesian direction to shift item towards.
 * @param {Object} options
 */
var updateBlockItemSize = function (_a) {
    var item = _a.item, offset = _a.offset, dir = _a.dir, _b = _a.options, _c = _b === void 0 ? {} : _b, _d = _c.minWidth, minWidth = _d === void 0 ? 0 : _d, _e = _c.minHeight, minHeight = _e === void 0 ? 0 : _e;
    var _f = item.position, w = _f.w, h = _f.h;
    var offsetX = offset.offsetX, offsetY = offset.offsetY;
    var updatedPosition = __assign({}, item.position);
    // resizing from north
    if (['n', 'ne', 'nw'].includes(dir)) {
        updatedPosition.y += Math.min(h - minHeight, offsetY);
        updatedPosition.h -= offsetY;
    }
    // resizing from the south
    if (['s', 'se', 'sw'].includes(dir)) {
        updatedPosition.h += offsetY;
    }
    // resizing from the east
    if (['e', 'ne', 'se'].includes(dir)) {
        updatedPosition.w += offsetX;
    }
    // resizing from west
    if (['w', 'nw', 'sw'].includes(dir)) {
        updatedPosition.x += Math.min(w - minWidth, offsetX);
        updatedPosition.w -= offsetX;
    }
    updatedPosition.w = Math.max(minWidth, updatedPosition.w);
    updatedPosition.h = Math.max(minHeight, updatedPosition.h);
    return __assign(__assign({}, item), { position: updatedPosition });
};
exports.updateBlockItemSize = updateBlockItemSize;
var updateBlockItemPosition = function (item, offset) {
    var offsetX = offset.offsetX, offsetY = offset.offsetY;
    return __assign(__assign({}, item), { position: __assign(__assign({}, item.position), { x: item.position.x + offsetX, y: item.position.y + offsetY }) });
};
exports.updateBlockItemPosition = updateBlockItemPosition;
/**
 * create offset based on dir, x and y
 * @method createOffset
 * @param {String} dir
 * @param {Number} x
 * @param {Number} y
 * @returns {Object} offset
 */
var createOffset = function (dir, x, y) {
    switch (dir) {
        case 'n':
            return {
                offsetX: 0,
                offsetY: -y,
            };
        case 's':
            return {
                offsetX: 0,
                offsetY: y,
            };
        case 'w':
            return {
                offsetX: -x,
                offsetY: 0,
            };
        case 'e':
            return {
                offsetX: x,
                offsetY: 0,
            };
        default:
            return {
                offsetX: 0,
                offsetY: 0,
            };
    }
};
exports.createOffset = createOffset;
/**
 * compute scale factor
 * @param {Number} actualWidth
 * @param {Number} canvasWidth
 */
var computeScaleToFit = function (actualWidth, canvasWidth) {
    if (!(isNumber_1.default(canvasWidth) &&
        canvasWidth > 0 &&
        isNumber_1.default(actualWidth) &&
        actualWidth > 0)) {
        console_1.default.warn("Failed to calculate layout scale: containerWidth=" + actualWidth + ", width=" + canvasWidth + "; falling back to scale=1");
        return 1;
    }
    return actualWidth / canvasWidth;
};
exports.computeScaleToFit = computeScaleToFit;
/**
 *
 * @param {Array} items
 * @param {Number} from  target item index
 * @param {Number} to    where does this item move to
 */
var moveLayoutItem = function (items, from, to) {
    var structure = __spread(items);
    var removed = pullAt_1.default(structure, [from]);
    structure.splice(to, 0, removed[0]);
    return structure;
};
exports.moveLayoutItem = moveLayoutItem;
/**
 * check if a line is connected
 */
var isLineConnected = function (_a) {
    var line = _a.line, dir = _a.dir;
    return 'item' in line.position[dir];
};
exports.isLineConnected = isLineConnected;
/**
 *  disconnect a line from item and set it to abs position
 */
var disconnectLine = function (_a) {
    var _b;
    var line = _a.line, dir = _a.dir, absPos = _a.absPos;
    var updatePosition = __assign(__assign({}, line.position), (_b = {}, _b[dir] = __assign({}, absPos), _b));
    return __assign(__assign({}, line), { position: updatePosition });
};
exports.disconnectLine = disconnectLine;
/**
 * connect a line with an item and port
 */
var connectLine = function (_a) {
    var _b;
    var line = _a.line, dir = _a.dir, itemId = _a.itemId, port = _a.port;
    var position = line.position;
    var updatedPosition = __assign(__assign({}, position), (_b = {}, _b[dir] = {
        item: itemId,
        port: port,
    }, _b));
    return __assign(__assign({}, line), { position: updatedPosition });
};
exports.connectLine = connectLine;
/**
 * update line absolute position
 */
var updateLineAbsPosition = function (_a) {
    var _b;
    var line = _a.line, dir = _a.dir, offset = _a.offset;
    var offsetX = offset.offsetX, offsetY = offset.offsetY;
    var position = line.position;
    if (!('x' in position[dir])) {
        throw Error("line item " + line.item + " does not have x value for its direction " + dir);
    }
    if (!('y' in position[dir])) {
        throw Error("line item " + line.item + " does not have y value for its direction " + dir);
    }
    var _c = position[dir], x = _c.x, y = _c.y;
    return __assign(__assign({}, line), { position: __assign(__assign({}, position), (_b = {}, _b[dir] = {
            x: x + offsetX,
            y: y + offsetY,
        }, _b)) });
};
exports.updateLineAbsPosition = updateLineAbsPosition;
/**
 *
 * @param {Object} from
 * @param {Object} to
 */
var computeLineBoxPosition = function (from, to) { return ({
    x: Math.min(from.x, to.x),
    y: Math.min(from.y, to.y),
}); };
exports.computeLineBoxPosition = computeLineBoxPosition;
/**
 *
 * @param {Object} from
 * @param {Object} to
 * @param {Object} box
 */
var computeLineRelativePosition = function (from, to, box) { return ({
    from: {
        x: from.x - box.x,
        y: from.y - box.y,
    },
    to: {
        x: to.x - box.x,
        y: to.y - box.y,
    },
}); };
exports.computeLineRelativePosition = computeLineRelativePosition;
/**
 * Return the bottom coordinate of the layout.
 *
 * @param  {Array} layout Layout array.
 * @return {Number}       Bottom coordinate.
 */
var bottom = function (layout) {
    return layout.length > 0
        ? Math.max.apply(Math, __spread(layout.map(function (_a) {
            var position = _a.position;
            return position.y + position.h;
        }))) : 1;
};
exports.bottom = bottom;
/**
 * Before moving item down, it will check if the movement will cause collisions
 * and move those items down before.
 * @method resolveCompactionCollision
 * @param {Array} layout
 * @param {Object} itemToMove current item which need to be moved to solve the collision
 * @param {Number} moveToCoord the destination coordination of y axis
 * @returns {Array} [newLayout, newItem]
 */
var resolveCompactionCollision = function (layout, itemToMove, moveToCoord) {
    var _a;
    var axisVal = itemToMove.position.y;
    axisVal += 1;
    var newLayout = cloneDeep_1.default(layout);
    var itemIndex = newLayout.findIndex(function (layoutItem) { return layoutItem.item === itemToMove.item; });
    var newItem = cloneDeep_1.default(itemToMove);
    newItem.position.y = axisVal;
    // Go through each item we collide with.
    // If there is a collision, we will move this collision down, otherwise set y = moveToCoord and return
    for (var i = itemIndex + 1; i < layout.length; i += 1) {
        // Optimization: we can break early if we know we're past this el
        // We can do this b/c it's a sorted layout
        if (newLayout[i].position.y > newItem.position.y + newItem.position.h) {
            break;
        }
        if (layout_1.collides(newItem, newLayout[i])) {
            _a = __read(exports.resolveCompactionCollision(layout, layout[i], moveToCoord + newItem.position.h), 2), newLayout = _a[0], newLayout[i] = _a[1];
        }
    }
    newItem.position.y = moveToCoord;
    newLayout[itemIndex] = newItem;
    return [newLayout, newItem];
};
exports.resolveCompactionCollision = resolveCompactionCollision;
/**
 * get all collisions given an item and current layout
 * @method getAllCollisions
 * @param {Array} layout
 * @param {Object} layoutItem
 * @returns {Array} sorted layout
 */
var getAllCollisions = function (layout, layoutItem) {
    return layout.filter(function (item) { return layout_1.collides(item, layoutItem); });
};
exports.getAllCollisions = getAllCollisions;
/**
 * clone a block item
 * @param {Number} id
 * @param {Object} item
 * @param {Number} offsetMultiplier
 */
var cloneBlockItem = function (_a) {
    var id = _a.id, item = _a.item, offsetMultiplier = _a.offsetMultiplier;
    var copiedPosition = item.position;
    return __assign(__assign({}, item), { item: id, position: {
            x: copiedPosition.x + 20 * offsetMultiplier,
            y: copiedPosition.y + 20 * offsetMultiplier,
            w: copiedPosition.w,
            h: copiedPosition.h,
        } });
};
exports.cloneBlockItem = cloneBlockItem;
/**
 * clone an line, it assume the line is not connected
 * @param {Number} id
 * @param {Object} item
 * @param {Number} offsetMultiplier
 */
var cloneLine = function (_a) {
    var id = _a.id, item = _a.item, offsetMultiplier = _a.offsetMultiplier;
    var copiedPosition = item.position;
    return __assign(__assign({}, item), { item: id, position: {
            from: {
                x: copiedPosition.from.x +
                    20 * offsetMultiplier,
                y: copiedPosition.from.y +
                    20 * offsetMultiplier,
            },
            to: {
                x: copiedPosition.to.x + 20 * offsetMultiplier,
                y: copiedPosition.to.y + 20 * offsetMultiplier,
            },
        } });
};
exports.cloneLine = cloneLine;
/**
 * Calculates new viewport position after a zoom event to keep the previous central point in the center of
 * the scaled canvas. See MR #2030 for algorithm details.
 * @param {Number} scrollLeft viewport left edge offset relative to canvas
 * @param {Number} scrollTop viewport top edge offset relative to canvas
 * @param {Number} offsetWidth viewport width
 * @param {Number} offsetHeight viewport height
 * @param {Number} scaleRatio new scale to old scale ratio
 * @returns {Object} object containing new scrollLeft and scrollTop values
 */
var shiftViewportOnZoom = function (_a) {
    var scrollLeft = _a.scrollLeft, scrollTop = _a.scrollTop, offsetWidth = _a.offsetWidth, offsetHeight = _a.offsetHeight, scaleRatio = _a.scaleRatio;
    var middleOffsetWidth = offsetWidth / 2;
    var middleOffsetHeight = offsetHeight / 2;
    return {
        scrollLeft: (scrollLeft + middleOffsetWidth) * scaleRatio - middleOffsetWidth,
        scrollTop: (scrollTop + middleOffsetHeight) * scaleRatio - middleOffsetHeight,
    };
};
exports.shiftViewportOnZoom = shiftViewportOnZoom;
/**
 * return position relative to the canvas rect
 */
var computeRelativePosition = function (e, canvasRef, scale) {
    if (scale === void 0) { scale = 1; }
    var pos = exports.getClientPosition(e, scale);
    var canvasDomNode = get_1.default(canvasRef, ['current']);
    var rect = canvasDomNode && canvasDomNode.getBoundingClientRect();
    if (pos && rect) {
        return {
            x: pos.x - rect.left / scale,
            y: pos.y - rect.top / scale,
        };
    }
    return pos;
};
exports.computeRelativePosition = computeRelativePosition;
/**
 * Scales a GridLayout by stretching the width of each item by the scale factor
 * @param {AbsoluteBlockItem[]} items items to scale
 * @param {Number} scale how much to scale
 */
var scaleGridLayoutStructureByWidth = function (_a) {
    var layout = _a.layout, _b = _a.scale, scale = _b === void 0 ? 1 : _b;
    if (scale === 1) {
        return layout;
    }
    // Compute the edges of the existing layout. Since we're scaling
    // just the X and width we only care about vertical edges.
    var edges = edgeUtils_1.getAllEdges(layout);
    var verticalEdges = sortBy_1.default(edges.filter(function (edge) { return edge.orientation === 'vertical'; }), ['edgeStart.x']);
    // Scale the vertical edges and than align the
    // left and right items to the scaled edge position
    var newLayout = [];
    verticalEdges.forEach(function (edge) {
        var visualizations = edge.visualizations, x = edge.edgeStart.x;
        var scaledEdgeX = Math.round(x * scale);
        var left = visualizations.filter(function (viz) { return viz.position.x < x; });
        var right = visualizations.filter(function (viz) { return viz.position.x >= x; });
        // Update the Width of the layout items using the difference between the
        // newly scaled edge and the existing x
        left.forEach(function (layoutItem) {
            var newLayoutItem = newLayout.find(function (_a) {
                var id = _a.item;
                return layoutItem.item === id;
            });
            if (newLayoutItem) {
                newLayoutItem.position.w =
                    scaledEdgeX - newLayoutItem.position.x;
            }
        });
        // Since we walk the edges from the left to the right we
        // ALWAYS have to create the new layout item here but won't
        // ever need to update it.
        right.forEach(function (layoutItem) {
            newLayout.push(__assign(__assign({}, layoutItem), { position: __assign(__assign({}, layoutItem.position), { x: scaledEdgeX }) }));
        });
    });
    return newLayout;
};
exports.scaleGridLayoutStructureByWidth = scaleGridLayoutStructureByWidth;


/***/ }),
/* 3 */
/***/ (function(module, exports) {

module.exports = require("prop-types");

/***/ }),
/* 4 */
/***/ (function(module, exports) {

module.exports = require("@splunk/themes");

/***/ }),
/* 5 */
/***/ (function(module, exports) {

module.exports = require("@splunk/dashboard-utils/console");

/***/ }),
/* 6 */
/***/ (function(module, exports) {

module.exports = require("@splunk/dashboard-utils/layout");

/***/ }),
/* 7 */
/***/ (function(module, exports) {

module.exports = require("@splunk/dashboard-ui/customThemeVariables");

/***/ }),
/* 8 */
/***/ (function(module, exports) {

module.exports = require("@splunk/themes/mixins");

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.gridLayoutOptions = exports.absoluteLayoutOptions = void 0;
var layout_1 = __webpack_require__(6);
exports.absoluteLayoutOptions = {
    width: layout_1.DEFAULT_CANVAS_WIDTH,
    height: layout_1.DEFAULT_CANVAS_HEIGHT,
    display: 'actual-size',
};
exports.gridLayoutOptions = {
    width: layout_1.DEFAULT_CANVAS_WIDTH,
    gutterSize: 8,
};


/***/ }),
/* 10 */
/***/ (function(module, exports) {

module.exports = require("lodash/get");

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.findEdgesInBoundary = exports.findSnappableEdges = exports.moveVerticalEdge = exports.moveHorizontalEdge = exports.getHorizontalBoundaries = exports.getVerticalBoundaries = exports.applyVizPadding = exports.formatEdge = exports.computeEdges = exports.getAllEdges = void 0;
var uniqueId_1 = __webpack_require__(12);
var nextEdgeId = function () { return "edge_" + uniqueId_1.uniqueId(); };
/**
 * generate edge id
 */
var getNextEdgeId = function () {
    return nextEdgeId();
};
/**
 * Returns a 2D array of every viz corner, indicating which visualizations touch which node(corner)
 * @param {Object} layoutStructure - Array of visualizations from definition
 * @returns {Object[][]} - {x: { y: [vizList] } }
 */
var getNodes = function (layoutStructure) {
    if (layoutStructure.length === 0) {
        return null;
    }
    var nodes = {};
    layoutStructure.forEach(function (viz) {
        var _a = viz.position, x = _a.x, y = _a.y, w = _a.w, h = _a.h;
        var corners = [
            { x: x, y: y },
            { x: x + w, y: y },
            { x: x, y: y + h },
            { x: x + w, y: y + h },
        ];
        corners.forEach(function (corner) {
            if (nodes[corner.x] === undefined) {
                nodes[corner.x] = {};
            }
            if (nodes[corner.x][corner.y] === undefined) {
                nodes[corner.x][corner.y] = [];
            }
            nodes[corner.x][corner.y].push(viz);
        });
    });
    return nodes;
};
var isTopEdge = function (edge) {
    return edge.orientation === 'horizontal' && edge.edgeStart.y === 0;
};
var isBottomEdge = function (edge, canvasHeight) {
    return edge.orientation === 'horizontal' && edge.edgeStart.y === canvasHeight;
};
var isLeftEdge = function (edge) {
    return edge.orientation === 'vertical' && edge.edgeStart.x === 0;
};
var isRightEdge = function (edge, canvasWidth) {
    return edge.orientation === 'vertical' && edge.edgeStart.x === canvasWidth;
};
/**
 * Returns all the visualizations along a vertical edge
 * @param {Object} param - Param object needed to traverse along vertical edge
 * @param {num} param.x - x-coordinate of the edge
 * @param {num} param.yStart - y-coordinate of the edge start
 * @param {num} param.yEnd - y-coordinate of the edge end
 * @param {num} param.yCurrent - Current y in recursion
 * @param {num} param.nodes - The map of x,y coordinates to visualizations that touch that (x,y)
 * @param {num} param.visualizations - the list to add visualizations to, and then return
 * @returns {Set<Object>} - Set of unique visualizations along the edge
 */
var findVizAlongVerticalEdge = function (_a) {
    var x = _a.x, yStart = _a.yStart, yEnd = _a.yEnd, _b = _a.yCurrent, yCurrent = _b === void 0 ? yStart : _b, nodes = _a.nodes, _c = _a.visualizations, visualizations = _c === void 0 ? new Set() : _c;
    nodes[x][yCurrent].forEach(function (viz) {
        if (viz.position.y >= yStart && viz.position.y < yEnd) {
            visualizations.add(viz);
        }
        if (viz.position.y >= yCurrent && yCurrent + viz.position.h <= yEnd) {
            findVizAlongVerticalEdge({
                x: x,
                yStart: yStart,
                yEnd: yEnd,
                yCurrent: yCurrent + viz.position.h,
                nodes: nodes,
                visualizations: visualizations,
            });
        }
    });
    return visualizations;
};
/**
 * Returns all the visualizations along a horizontal edge
 * @param {Object} param - Param object needed to traverse along horizontal edge
 * @param {num} param.y - x-coordinate of the edge
 * @param {num} param.xStart - x-coordinate of the edge start
 * @param {num} param.xEnd - x-coordinate of the edge end
 * @param {num} param.xCurrent - Current x in recursion
 * @param {num} param.nodes - The map of x,y coordinates to visualizations that touch that (x,y)
 * @param {num} param.visualizations - the list to add visualizations to, and then return
 * @returns {Set<Object>} - Set of unique visualizations along the edge
 */
var findVizAlongHorizontalEdge = function (_a) {
    var y = _a.y, xStart = _a.xStart, xEnd = _a.xEnd, _b = _a.xCurrent, xCurrent = _b === void 0 ? xStart : _b, nodes = _a.nodes, _c = _a.visualizations, visualizations = _c === void 0 ? new Set() : _c;
    nodes[xCurrent][y].forEach(function (viz) {
        if (viz.position.x >= xStart && viz.position.x < xEnd) {
            visualizations.add(viz);
        }
        if (viz.position.x >= xCurrent && xCurrent + viz.position.w <= xEnd) {
            findVizAlongHorizontalEdge({
                y: y,
                xStart: xStart,
                xEnd: xEnd,
                xCurrent: xCurrent + viz.position.w,
                nodes: nodes,
                visualizations: visualizations,
            });
        }
    });
    return visualizations;
};
/**
 * Add edge to the provided list
 * @param {Object} param - Params containing edge info
 * @param {num} param.edges - the list to add the edge to
 * @param {Object} param.edgeStart - the start of the edge
 * @param {Object} param.edgeEnd - the end of the edge
 * @param {Object[][]} param.nodes - The map of x,y coordinates to visualizations that touch that (x,y)
 */
var addEdge = function (_a) {
    var edges = _a.edges, edgeStart = _a.edgeStart, edgeEnd = _a.edgeEnd, nodes = _a.nodes;
    var orientation = edgeStart.y === edgeEnd.y ? 'horizontal' : 'vertical';
    // Find all visualizations that are affected by this edge
    var visualizations = orientation === 'vertical'
        ? findVizAlongVerticalEdge({
            x: edgeStart.x,
            yStart: edgeStart.y,
            yEnd: edgeEnd.y,
            nodes: nodes,
        })
        : findVizAlongHorizontalEdge({
            y: edgeStart.y,
            xStart: edgeStart.x,
            xEnd: edgeEnd.x,
            nodes: nodes,
        });
    edges.push({
        item: getNextEdgeId(),
        edgeStart: edgeStart,
        edgeEnd: edgeEnd,
        visualizations: Array.from(visualizations),
        orientation: orientation,
    });
};
/**
 * If there is no incoming edge from the top, return true
 * @param {num} y - Current y position to compare against
 * @param {Object[]} visualizations - Array of visualizations attached to the node at (x, y). Length will be 1 to 4.
 * @returns {boolean}
 */
var shouldTraverseDown = function (y, visualizations) {
    return visualizations.every(function (viz) { return viz.position.y >= y; });
};
/**
 * If there is no incoming edge from the left, return true
 * @param {num} x - Current x position to compare against
 * @param {Object[]} visualizations - Array of visualizations attached to the node at (x, y). Length will be 1 to 4.
 * @returns {boolean}
 */
var shouldTraverseRight = function (x, visualizations) {
    return visualizations.every(function (viz) { return viz.position.x >= x; });
};
/**
 * Find the offset to the next node.
 * @param {Object} param - Param object to find offset to next node
 * @param {Number} param.x - The x co-ordinate of the current position to find offset from
 * @param {Number} param.y - The y co-ordinate of the current position to find offset from
 * @param {Object[]} param.visualizations - Array of visualizations attached to the node at (x, y). Length will be 1 to 4.
 * @param {Object} param.visualizations[].position - Position information of the visualization
 * @param {String} param.type - The type of co-ordinate. One of 'w' or 'h'.
 * @returns {number}
 */
var findOffset = function (_a) {
    var x = _a.x, y = _a.y, visualizations = _a.visualizations, type = _a.type;
    for (var i = 0; i < visualizations.length; i += 1) {
        var position = visualizations[i].position;
        if (position.y === y && position.x === x) {
            return position[type];
        }
    }
    // This for-loop is only for finding the bottom canvas edge and the right canvas edge
    for (var i = 0; i < visualizations.length; i += 1) {
        var position = visualizations[i].position;
        if (type === 'w' && position.x === x) {
            // horizontal canvas edge
            return position.w;
        }
        if (type === 'h' && position.y === y) {
            // vertical canvas edge
            return position.h;
        }
    }
    return 0;
};
/**
 * Traverse right along nodes, creating or extending edges
 * @param {Object} param - Param object to traverse right along layout
 * @param {Object[][]} param.nodes - An object that maps {x, y} coord to an array of visualizations. Indexed as nodes[x][y].
 * @param {Object[]} param.edges - The resulting array of edges that gets mutated
 * @param {Number} param.x - x coordinate of current node
 * @param {Number} param.y - y coordinate of current node
 * @param {Object} param.edgeStart - The { x, y } coordinates of start of edge
 * @param {Boolean} param.canTraverseDown - Used to prevent loops during indirect recursion
 */
function traverseRight(_a) {
    var x = _a.x, y = _a.y, nodes = _a.nodes, edges = _a.edges, edgeStart = _a.edgeStart, _b = _a.canTraverseDown, canTraverseDown = _b === void 0 ? true : _b;
    // Check if we should traverse down (if there is no incoming edge)
    // canTraverseRight must be false to avoid endless loop
    if (canTraverseDown && shouldTraverseDown(y, nodes[x][y])) {
        // eslint-disable-next-line @typescript-eslint/no-use-before-define
        traverseDown({
            x: x,
            y: y,
            nodes: nodes,
            edges: edges,
            edgeStart: { x: x, y: y },
            canTraverseRight: false,
        });
    }
    // Check if horizontal edge ends here
    // 'w' signifies we want width offset returned as opposed to height
    var offset = findOffset({ x: x, y: y, visualizations: nodes[x][y], type: 'w' });
    // Case 1 for ending edge: can't go right anymore (hit a viz OR end of dashboard), create edge up to this point.
    if (!offset) {
        addEdge({ edges: edges, edgeStart: edgeStart, edgeEnd: { x: x, y: y }, nodes: nodes });
        return;
    }
    // Case 2 for ending edge: reached window, need to create edge and start new one to avoid merging across window
    var isWindow = nodes[x][y].length === 4; // 4-way intersection
    if (isWindow) {
        addEdge({ edges: edges, edgeStart: edgeStart, edgeEnd: { x: x, y: y }, nodes: nodes });
        // Continue traversing right, starting with a new edge from current position
        traverseRight({
            x: x + offset,
            y: y,
            nodes: nodes,
            edges: edges,
            edgeStart: { x: x, y: y },
        });
        return;
    }
    // Continue traversing right, merging the past edge with the next
    traverseRight({
        x: x + offset,
        y: y,
        nodes: nodes,
        edges: edges,
        edgeStart: edgeStart,
    });
}
/**
 * Traverse right along nodes, creating or extending edges
 * @param {Object} param - Param object to traverse down along layout
 * @param {Object[][]} param.nodes - An object that maps {x, y} coord to an array of visualizations. Indexed as nodes[x][y].
 * @param {Object[]} param.edges - The resulting array of edges that gets mutated
 * @param {Number} param.x - x coordinate of current node
 * @param {Number} param.y - y coordinate of current node
 * @param {Object} param.edgeStart - The { x, y } coordinates of start of edge
 * @param {Boolean} param.canTraverseRight - Used to prevent loops during indirect recursion
 */
function traverseDown(_a) {
    var x = _a.x, y = _a.y, nodes = _a.nodes, edges = _a.edges, edgeStart = _a.edgeStart, _b = _a.canTraverseRight, canTraverseRight = _b === void 0 ? true : _b;
    if (canTraverseRight && shouldTraverseRight(x, nodes[x][y])) {
        traverseRight({
            x: x,
            y: y,
            nodes: nodes,
            edges: edges,
            edgeStart: { x: x, y: y },
            canTraverseDown: false,
        });
    }
    // Check if vertical edge ends here
    var offset = findOffset({ x: x, y: y, visualizations: nodes[x][y], type: 'h' });
    // Case 1 for ending edge: can't go down anymore (hit a viz OR end of dashboard), create edge up to this point.
    if (!offset) {
        addEdge({ edges: edges, edgeStart: edgeStart, edgeEnd: { x: x, y: y }, nodes: nodes });
        return;
    }
    // Case 2 for ending edge: reached window, need to create edge and start new one to avoid merging across window
    var isWindow = nodes[x][y].length === 4;
    if (isWindow) {
        addEdge({ edges: edges, edgeStart: edgeStart, edgeEnd: { x: x, y: y }, nodes: nodes });
        // Start a new edge from current position
        traverseDown({
            x: x,
            y: y + offset,
            nodes: nodes,
            edges: edges,
            edgeStart: { x: x, y: y },
        });
        return;
    }
    // Continue traversing, thus "merging" edges
    traverseDown({
        x: x,
        y: y + offset,
        nodes: nodes,
        edges: edges,
        edgeStart: edgeStart,
    });
}
/**
 * Compute the vertical edges for every canvas row - a row that spans the entire width of the canvas
 * @param {Object} param
 * @param {AbsoluteBlockItem[]} param.layout - Layout structure
 * @param {EdgeItem[]} param.edges - The resulting array of edges that gets mutated
 * @param {Number} param.canvasWidth - Canvas width
 */
var computeVerticalCanvasEdges = function (_a) {
    var edges = _a.edges, canvasWidth = _a.canvasWidth, layout = _a.layout;
    var nodes = getNodes(layout);
    if (nodes == null) {
        return;
    }
    // get all the horizontal edges that span the entire canvas width
    var sortedRowEdges = edges
        .filter(function (edge) {
        return edge.orientation === 'horizontal' &&
            edge.edgeStart.x === 0 &&
            edge.edgeEnd.x === canvasWidth;
    })
        .sort(function (a, b) { return a.edgeStart.y - b.edgeStart.y; });
    /**
     * iterate through the sorted horizontal edges to get their start and end coordinates
     * vertical edges between canvas row A and canvas row B will span from edgeStartA to edgeStartB and edgeEndA to edgeEndB
     */
    for (var i = 0; i < sortedRowEdges.length - 1; i += 1) {
        var _b = sortedRowEdges[i], edgeStartA = _b.edgeStart, edgeEndA = _b.edgeEnd;
        var _c = sortedRowEdges[i + 1], edgeStartB = _c.edgeStart, edgeEndB = _c.edgeEnd;
        addEdge({
            edges: edges,
            edgeStart: edgeStartA,
            edgeEnd: edgeStartB,
            nodes: nodes,
        });
        addEdge({
            edges: edges,
            edgeStart: edgeEndA,
            edgeEnd: edgeEndB,
            nodes: nodes,
        });
    }
};
/**
 * Gets all the edges given a layout of AbsoluteBlockItems
 * @param {AbsoluteBlockItem[]} layout - Array of AbsoluteBlockItems
 * @returns {EdgeItem[]} - Array of computed edges
 */
var getAllEdges = function (layout) {
    var edges = [];
    var nodes = getNodes(layout);
    if (nodes === null || nodes[0] === undefined || nodes[0][0] === undefined) {
        // When no visualizations in the layout structure
        // OR when there is no visualization at (0,0), which this algorithm assumes
        return [];
    }
    // run the algorithm
    traverseRight({
        x: 0,
        y: 0,
        nodes: nodes,
        edges: edges,
        edgeStart: { x: 0, y: 0 },
    });
    return edges;
};
exports.getAllEdges = getAllEdges;
/**
 * Compute edges given a valid layout, canvasHeight, and canvasWidth
 * @param {Object} param - Param object containing layout, canvasHeight, canvasWidth
 * @param {Object[]} param.layout - Array of visualizations from the dashboard layout definition
 * @param {Number} param.canvasHeight - Canvas height
 * @param {Number} param.canvasWidth - Canvas width
 * @returns {Object[]} - Array of computed edges
 */
var computeEdges = function (_a) {
    var layout = _a.layout, canvasHeight = _a.canvasHeight, canvasWidth = _a.canvasWidth;
    if (layout === undefined) {
        return [];
    }
    var edges = exports.getAllEdges(layout);
    // remove the computed left and right vertical canvas edges as they span the entire height of the canvas
    edges = edges.filter(function (edge) {
        return !(isLeftEdge(edge) || isRightEdge(edge, canvasWidth));
    });
    // recompute the vertical canvas edges for each canvas row where the row spans the entire width of the canvas
    computeVerticalCanvasEdges({ edges: edges, layout: layout, canvasWidth: canvasWidth });
    // Additionally, the top and bottom edge are there, but set to hidden
    edges = edges.map(function (edge) {
        var isCanvasEdge = false;
        if (isTopEdge(edge) ||
            isRightEdge(edge, canvasWidth) ||
            isBottomEdge(edge, canvasHeight) ||
            isLeftEdge(edge)) {
            isCanvasEdge = true;
        }
        return __assign(__assign({}, edge), { isCanvasEdge: isCanvasEdge });
    });
    return edges;
};
exports.computeEdges = computeEdges;
/**
 * Format edge according to a given padding and edge thickness
 * @param {Object} param - Param object containing edge, padding, and edgeThickness
 * @param {Object} param.edge - Edge object
 * @param {Number} param.padding - Layout padding
 * @param {Number} param.edgeThickness - Thickness of edge
 * @returns {Object} - Returns formatted edge object
 */
var formatEdge = function (_a) {
    var edge = _a.edge, _b = _a.padding, padding = _b === void 0 ? 0 : _b, _c = _a.edgeThickness, edgeThickness = _c === void 0 ? 0 : _c;
    // Formatted edges are centered between visualizations and respect the padding (gutter-size) between them
    var formattedEdgeStart = __assign({}, edge.edgeStart);
    var formattedEdgeEnd = __assign({}, edge.edgeEnd);
    if (edge.orientation === 'horizontal') {
        formattedEdgeStart.x += padding;
        formattedEdgeStart.y -= edgeThickness / 2;
        formattedEdgeEnd.x -= padding;
        formattedEdgeEnd.y -= edgeThickness / 2;
    }
    else {
        formattedEdgeStart.y += padding;
        formattedEdgeStart.x -= edgeThickness / 2;
        formattedEdgeEnd.y -= padding;
        formattedEdgeEnd.x -= edgeThickness / 2;
    }
    return __assign(__assign({}, edge), { edgeStart: formattedEdgeStart, edgeEnd: formattedEdgeEnd });
};
exports.formatEdge = formatEdge;
/**
 * Format visualization according to a given padding
 * @param {Object} param - Param object containing item and padding
 * @param {Object} param.item - Visualization object
 * @param {Number} param.padding - Layout padding
 * @returns {AbsoluteBlockItem} - Returns formatted edge object
 */
var applyVizPadding = function (_a) {
    var item = _a.item, _b = _a.padding, padding = _b === void 0 ? 0 : _b;
    var _c = item.position, x = _c.x, y = _c.y, w = _c.w, h = _c.h;
    return __assign(__assign({}, item), { position: {
            x: x + padding,
            y: y + padding,
            w: w - 2 * padding,
            h: h - 2 * padding,
        } });
};
exports.applyVizPadding = applyVizPadding;
/**
 * Determines Upper and Lower boundaries of an edge given its visualizations around it
 * @param {Object[]} visualizations - The visualizations surrounding the edge
 * @param {Number} y - The y position of the selected edge
 * @param {Number} minHeight - minimum Item Height Value
 * @param {Boolean} isFullWidthEdge - If the edge we are getting boundaries of is the size of canvas width
 * @returns {Object} - returns the boundaries in an object
 */
var getVerticalBoundaries = function (_a) {
    var visualizations = _a.visualizations, y = _a.y, minHeight = _a.minHeight, _b = _a.isFullWidthEdge, isFullWidthEdge = _b === void 0 ? false : _b;
    var boundaries = {
        upperBoundary: Number.NEGATIVE_INFINITY,
        lowerBoundary: Number.POSITIVE_INFINITY,
    };
    var comparePosition = function (position) {
        // If viz is below of the edge
        // When the edge is a full width edge, there is no lower boundary
        //  since dragging down increases canvas size
        if (position.y >= y && !isFullWidthEdge) {
            boundaries.lowerBoundary = Math.min(boundaries.lowerBoundary, position.y + position.h - minHeight);
        }
        // If viz is above the edge
        if (position.y < y) {
            boundaries.upperBoundary = Math.max(boundaries.upperBoundary, position.y + minHeight);
        }
    };
    visualizations.forEach(function (viz) { return comparePosition(viz.position); });
    return boundaries;
};
exports.getVerticalBoundaries = getVerticalBoundaries;
/**
 * Determines Left and Right boundaries of an edge given its visualizations around it
 * @param {Object[]} visualizations - The visualizations surrounding the edge
 * @param {Number} x - The x position of the selected edge
 * @param {Number} minWidth - minimum Item Width Value
 * @returns {Object} - returns the boundaries in an object
 */
var getHorizontalBoundaries = function (_a) {
    var visualizations = _a.visualizations, x = _a.x, minWidth = _a.minWidth;
    var boundaries = {
        rightBoundary: Number.POSITIVE_INFINITY,
        leftBoundary: Number.NEGATIVE_INFINITY,
    };
    var comparePosition = function (position) {
        if (position.x >= x) {
            // If viz is to the right of the edge
            boundaries.rightBoundary = Math.min(boundaries.rightBoundary, position.x + position.w - minWidth);
        }
        if (position.x < x) {
            // If viz is to the left of the edge
            boundaries.leftBoundary = Math.max(boundaries.leftBoundary, position.x + minWidth);
        }
    };
    visualizations.forEach(function (viz) { return comparePosition(viz.position); });
    return boundaries;
};
exports.getHorizontalBoundaries = getHorizontalBoundaries;
/**
 * Determines the next edge position for movement up and down of a horizontal edge
 * @param {Object} edge - the current moving edge
 * @param {Number} offset - offset to move edge
 * @param {Object} options.edgeBoundaries Object with lower/upper boundaries
 * @returns {Object} - returns edge with updated position
 */
var moveHorizontalEdge = function (_a) {
    var edge = _a.edge, offset = _a.offset, _b = _a.edgeBoundaries, upperBoundary = _b.upperBoundary, lowerBoundary = _b.lowerBoundary;
    // Update edge to either the offset value,
    // or the defined maximum/minimum based on min viz height/width
    var updatedY = offset < 0
        ? Math.max(upperBoundary, edge.edgeStart.y + offset)
        : Math.min(lowerBoundary, edge.edgeStart.y + offset);
    return __assign(__assign({}, edge), { edgeStart: {
            x: edge.edgeStart.x,
            y: updatedY,
        }, edgeEnd: {
            x: edge.edgeEnd.x,
            y: updatedY,
        } });
};
exports.moveHorizontalEdge = moveHorizontalEdge;
/**
 * Determines the next edge position for movement left and right of a vertical edge
 * @param {Object} edge - the current moving edge
 * @param {Number} offset - offset to move edge
 * @param {Object} options.edgeBoundaries Object with left/right boundaries
 * @returns {Object} - returns edge with updated position
 */
var moveVerticalEdge = function (_a) {
    var edge = _a.edge, offset = _a.offset, _b = _a.edgeBoundaries, leftBoundary = _b.leftBoundary, rightBoundary = _b.rightBoundary;
    var updatedX = offset < 0
        ? Math.max(leftBoundary, edge.edgeStart.x + offset)
        : Math.min(rightBoundary, edge.edgeStart.x + offset);
    return __assign(__assign({}, edge), { edgeStart: {
            x: updatedX,
            y: edge.edgeStart.y,
        }, edgeEnd: {
            x: updatedX,
            y: edge.edgeEnd.y,
        } });
};
exports.moveVerticalEdge = moveVerticalEdge;
/**
 * find edges that the given edge should snap to, according to the snap range
 * @param {Object} options
 * @param {Object} options.edge the edge being dragged, edge has the structure
 * @param {array}  options.edges all the edges that are parallel to target edge and within the boundary
 * @param {Number} options.snapRange the range within which that triggers snapping
 * @returns {Object} updatedEdge and snappableEdges
 */
var findSnappableEdges = function (_a) {
    var _b, _c;
    var edge = _a.edge, edges = _a.edges, snapRange = _a.snapRange;
    var coordinate = edge.orientation === 'horizontal' ? 'y' : 'x';
    var snappableEdges = edges.reduce(function (currentSnappableEdges, nextEdge) {
        var nextEdgeDistance = Math.abs(nextEdge.edgeStart[coordinate] - edge.edgeStart[coordinate]);
        // nextEdge is in range
        if (nextEdgeDistance <= snapRange) {
            if (currentSnappableEdges.length === 0) {
                return [nextEdge];
            }
            var lastEdge = currentSnappableEdges[currentSnappableEdges.length - 1];
            var lastEdgeDistance = Math.abs(lastEdge.edgeStart[coordinate] - edge.edgeStart[coordinate]);
            // find new closest snappable edge
            if (nextEdgeDistance < lastEdgeDistance) {
                return [nextEdge];
            }
            // it is possible there are several snappable edges having the same x or y value
            if (nextEdgeDistance === lastEdgeDistance) {
                return __spread(currentSnappableEdges, [nextEdge]);
            }
        }
        // nextEdge is out of range
        return __spread(currentSnappableEdges);
    }, []);
    // if no snappable edge, snap to itself
    var firstSnappableEdge = snappableEdges.length > 0 ? snappableEdges[0] : edge;
    return {
        updatedEdge: __assign(__assign({}, edge), { edgeStart: __assign(__assign({}, edge.edgeStart), (_b = {}, _b[coordinate] = firstSnappableEdge.edgeStart[coordinate], _b)), edgeEnd: __assign(__assign({}, edge.edgeEnd), (_c = {}, _c[coordinate] = firstSnappableEdge.edgeEnd[coordinate], _c)) }),
        snappableEdges: snappableEdges,
    };
};
exports.findSnappableEdges = findSnappableEdges;
/**
 * Find all the edges that could be snapped to, given the limitations enforced by the surrounding visualizations.
 * @param {Object} options
 * @param {Object} options.edge the edge being dragged
 * @param {array}  options.edges all the edges on canvas
 * @param {Object} options.edgeBoundaries Object with either lower/upper or left/right boundaries
 * @returns {array} the edges that are within the boundary of the edge being moved
 */
var findEdgesInBoundary = function (_a) {
    var edge = _a.edge, edges = _a.edges, edgeBoundaries = _a.edgeBoundaries;
    var orientation = edge.orientation;
    if (orientation === 'horizontal') {
        return edges.filter(function (e) {
            return e.orientation === 'horizontal' &&
                e.edgeStart.y >=
                    edgeBoundaries.upperBoundary &&
                e.edgeStart.y <=
                    edgeBoundaries.lowerBoundary &&
                e !== edge;
        });
    }
    if (orientation === 'vertical') {
        return edges.filter(function (e) {
            return e.orientation === 'vertical' &&
                e.edgeStart.x >=
                    edgeBoundaries.leftBoundary &&
                e.edgeStart.x <=
                    edgeBoundaries.rightBoundary &&
                e !== edge;
        });
    }
    // can't match any edge because the orientation is invalid, this shouldn't happen.
    return [];
};
exports.findEdgesInBoundary = findEdgesInBoundary;


/***/ }),
/* 12 */
/***/ (function(module, exports) {

module.exports = require("@splunk/dashboard-utils/uniqueId");

/***/ }),
/* 13 */,
/* 14 */
/***/ (function(module, exports) {

module.exports = require("@splunk/dashboard-context");

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateBackgroundImage = exports.getImageDimension = exports.invalidImageSizeType = exports.validImageWidthHeight = exports.validImagePos = exports.isFromImageRegistry = void 0;
var console_1 = __importDefault(__webpack_require__(5));
var isEmpty_1 = __importDefault(__webpack_require__(25));
// /**
//  * Check whether image src url is valid or not
//  * @method validImageSrc
//  * @param {String} src
//  */
// export const validImageSrc = src => {
//     const img = new Image();
//     img.onerror = () => {
//         console.error(`Background image url ${src} is invalid`);
//     };
//     img.src = src
// };
/**
 * check if an image is from Image Registry
 * @param {*} src
 */
var isFromImageRegistry = function (src) {
    if (src === void 0) { src = ''; }
    var _a = __read(src.split('://'), 1), type = _a[0];
    return (src.indexOf('://') > -1 &&
        type !== 'http' &&
        type !== 'https' &&
        type !== 'ftp' &&
        type !== 'file');
};
exports.isFromImageRegistry = isFromImageRegistry;
/**
 * Check whether image position is valid or not
 * @method validImagePos
 * @param {Number} x
 * @param {Number} y
 * @param {Number} canvasWidth
 * @param {Number} canvasHeight
 * @returns {Boolean}
 */
var validImagePos = function (_a) {
    var x = _a.x, y = _a.y, canvasWidth = _a.canvasWidth, canvasHeight = _a.canvasHeight;
    return !!(x != null &&
        Number.isInteger(x) &&
        y != null &&
        Number.isInteger(y) &&
        x <= canvasWidth &&
        y <= canvasHeight &&
        x >= 0 &&
        y >= 0);
};
exports.validImagePos = validImagePos;
/**
 * Check whether image width and height is valid or not
 * @method validImageWidthHeight
 * @param {Number} imageWidth //Defaulted to 1 because w can't be undefined
 * @param {Number} imageHeight //Defaulted to 1 because h can't be undefined
 * @param {Number} canvasWidth
 * @param {Number} canvasHeight
 * @returns {Boolean}
 */
var validImageWidthHeight = function (imageWidth, imageHeight) {
    if (imageWidth === void 0) { imageWidth = 1; }
    if (imageHeight === void 0) { imageHeight = 1; }
    return !!(Number.isInteger(imageWidth) &&
        Number.isInteger(imageHeight) &&
        imageWidth > 0 &&
        imageHeight > 0);
};
exports.validImageWidthHeight = validImageWidthHeight;
/**
 * Check whether image size type is valid or not (cover/auto/contain/undefined)
 * @method invalidImageSizeType
 * @param {String} sizeType
 * @returns {Boolean}
 */
var invalidImageSizeType = function (sizeType) {
    return !!(sizeType !== 'cover' &&
        sizeType !== 'contain' &&
        sizeType !== 'auto' &&
        sizeType !== undefined);
};
exports.invalidImageSizeType = invalidImageSizeType;
/**
 * Return the original width and height of a valid image
 * @method getImageWidthHeight
 * @param {String} imgSrc
 * @returns {Number. Number} Image width and height
 */
var getImageDimension = function (imgSrc) {
    var img = new Image();
    try {
        img.src = imgSrc;
        img.style.position = 'absolute';
        img.style.left = '-9999'; // Image width must not exceed 9999 pixels
        img.style.visibility = 'hidden';
        document.body.appendChild(img);
        var height = img.naturalHeight;
        var width = img.naturalWidth;
        return { width: width, height: height };
    }
    catch (ex) {
        return { width: 0, height: 0 };
    }
    finally {
        if (document.body.contains(img)) {
            document.body.removeChild(img); // Removes the image from the DOM
        }
    }
};
exports.getImageDimension = getImageDimension;
/**
 * Check whether background image options are valid or not. Default to x:0, y:0, w:0, h:0 and sizeType:'auto'
 * @method validateBackgroundImage
 * @param {Object} backgroundImage
 * @param {String} backgroundImage.src
 * @param {Number} backgroundImage.x
 * @param {Number} backgroundImage.y
 * @param {Number} backgroundImage.w
 * @param {Number} backgroundImage.h
 * @param {String} backgroundImage.sizeType
 * @param {Number} width
 * @param {Number} height
 * @returns {Object}
 */
var validateBackgroundImage = function (_a) {
    var _b = _a.backgroundImage, backgroundImage = _b === void 0 ? {} : _b, canvasWidth = _a.canvasWidth, canvasHeight = _a.canvasHeight;
    var src = backgroundImage.src;
    var x = backgroundImage.x, y = backgroundImage.y, w = backgroundImage.w, h = backgroundImage.h, sizeType = backgroundImage.sizeType;
    if (isEmpty_1.default(backgroundImage)) {
        return { src: src, x: x, y: y, w: w, h: h, sizeType: sizeType };
    }
    if (src == null) {
        return { src: src, x: x, y: y, w: w, h: h, sizeType: sizeType };
    }
    // validImageSrc(src); make no sense to validate but not display errors.
    if (!exports.validImagePos({ x: x, y: y, canvasWidth: canvasWidth, canvasHeight: canvasHeight })) {
        console_1.default.warn("Invalid background image position, x: " + x + " y: " + y + ". Defaulting to x: 0, y: 0");
        x = 0;
        y = 0;
    }
    if (w == null &&
        h == null &&
        (sizeType == null || exports.invalidImageSizeType(sizeType))) {
        console_1.default.warn("Invalid background image sizeType, " + sizeType + ". Defaulting to contain");
        sizeType = 'contain';
    }
    else if ((sizeType == null || exports.invalidImageSizeType(sizeType)) &&
        ((w != null && h == null) ||
            (w == null && h != null) ||
            !exports.validImageWidthHeight(w, h))) {
        console_1.default.warn("Invalid background image width and height, w: " + w + " h: " + h + ". Defaulting to image original size");
        w = w || 0;
        h = h || 0;
    }
    return { src: src, x: x, y: y, w: w, h: h, sizeType: sizeType };
};
exports.validateBackgroundImage = validateBackgroundImage;


/***/ }),
/* 16 */
/***/ (function(module, exports) {

module.exports = require("lodash/noop");

/***/ }),
/* 17 */
/***/ (function(module, exports) {

module.exports = require("lodash/findLast");

/***/ }),
/* 18 */
/***/ (function(module, exports) {

module.exports = require("lodash/isNumber");

/***/ }),
/* 19 */
/***/ (function(module, exports) {

module.exports = require("lodash/reduce");

/***/ }),
/* 20 */
/***/ (function(module, exports) {

module.exports = require("lodash/pullAt");

/***/ }),
/* 21 */
/***/ (function(module, exports) {

module.exports = require("lodash/cloneDeep");

/***/ }),
/* 22 */
/***/ (function(module, exports) {

module.exports = require("lodash/sortBy");

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.getBlockItem = exports.computePortPosition = exports.getAllBlockItems = exports.findSelectedBlockItems = void 0;
var findSelectedBlockItems = function (_a) {
    var layoutStructure = _a.layoutStructure, selectedItems = _a.selectedItems;
    return layoutStructure.filter(function (_a) {
        var item = _a.item, type = _a.type;
        return selectedItems.findIndex(function (_a) {
            var id = _a.id;
            return item === id && (type === 'block' || !type);
        }) >= 0;
    });
};
exports.findSelectedBlockItems = findSelectedBlockItems;
var getAllBlockItems = function (_a) {
    var layoutStructure = _a.layoutStructure, _b = _a.layoutStructureState, layoutStructureState = _b === void 0 ? {} : _b;
    return layoutStructure
        .map(function (item) { var _a; return (_a = layoutStructureState[item.item]) !== null && _a !== void 0 ? _a : item; })
        .filter(function (_a) {
        var type = _a.type;
        return type === 'block' || !type;
    });
};
exports.getAllBlockItems = getAllBlockItems;
/**
 * compute port position for a given block item
 * @param {Object} blockItem
 * @param {String} port
 */
var computePortPosition = function (blockItem, port) {
    var blockPosition = blockItem.position;
    switch (port) {
        case 'n':
            return {
                x: Math.round(blockPosition.x + blockPosition.w / 2),
                y: blockPosition.y,
            };
        case 'w':
            return {
                x: blockPosition.x,
                y: Math.round(blockPosition.y + blockPosition.h / 2),
            };
        case 'e':
            return {
                x: blockPosition.x + blockPosition.w,
                y: Math.round(blockPosition.y + blockPosition.h / 2),
            };
        case 's':
        default:
            return {
                x: Math.round(blockPosition.x + blockPosition.w / 2),
                y: blockPosition.y + blockPosition.h,
            };
    }
};
exports.computePortPosition = computePortPosition;
var getBlockItem = function (_a) {
    var layoutStructure = _a.layoutStructure, id = _a.id;
    var blockItem = layoutStructure.find(function (_a) {
        var item = _a.item;
        return item === id;
    });
    if (!blockItem || blockItem.type === 'line') {
        throw Error(id + " refers to an invalid block item");
    }
    return blockItem;
};
exports.getBlockItem = getBlockItem;


/***/ }),
/* 24 */,
/* 25 */
/***/ (function(module, exports) {

module.exports = require("lodash/isEmpty");

/***/ }),
/* 26 */,
/* 27 */,
/* 28 */,
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.getAllLineItems = exports.handleSingleLineDragStart = exports.handleSingleLineMove = exports.findSelectedLineItems = exports.computeLineAbsPosition = void 0;
var layoutUtils_1 = __webpack_require__(2);
var blockUtils_1 = __webpack_require__(23);
var computeLineAbsPosition = function (_a) {
    var layoutStructure = _a.layoutStructure, position = _a.position;
    var from = position.from, to = position.to;
    if ('item' in from && 'port' in from) {
        var blockItem = blockUtils_1.getBlockItem({ layoutStructure: layoutStructure, id: from.item });
        from = blockUtils_1.computePortPosition(blockItem, from.port);
    }
    if ('item' in to && 'port' in to) {
        var blockItem = blockUtils_1.getBlockItem({ layoutStructure: layoutStructure, id: to.item });
        to = blockUtils_1.computePortPosition(blockItem, to.port);
    }
    return {
        from: from,
        to: to,
    };
};
exports.computeLineAbsPosition = computeLineAbsPosition;
var findSelectedLineItems = function (_a) {
    var layoutStructure = _a.layoutStructure, selectedItems = _a.selectedItems;
    return layoutStructure.filter(function (_a) {
        var item = _a.item, type = _a.type;
        return selectedItems.findIndex(function (_a) {
            var id = _a.id;
            return item === id && type === 'line';
        }) >= 0;
    });
};
exports.findSelectedLineItems = findSelectedLineItems;
var handleSingleLineMove = function (_a) {
    var lineId = _a.lineId, offset = _a.offset, layoutStructure = _a.layoutStructure;
    var line = layoutStructure.find(function (item) { return item.item === lineId; });
    var linePosition = exports.computeLineAbsPosition({
        layoutStructure: layoutStructure,
        position: line.position,
    });
    if (layoutUtils_1.isLineConnected({ line: line, dir: 'from' })) {
        line = layoutUtils_1.disconnectLine({
            line: line,
            dir: 'from',
            absPos: linePosition.from,
        });
    }
    if (layoutUtils_1.isLineConnected({ line: line, dir: 'to' })) {
        line = layoutUtils_1.disconnectLine({
            line: line,
            dir: 'to',
            absPos: linePosition.to,
        });
    }
    line = layoutUtils_1.updateLineAbsPosition({
        line: line,
        dir: 'from',
        offset: offset,
    });
    line = layoutUtils_1.updateLineAbsPosition({
        line: line,
        dir: 'to',
        offset: offset,
    });
    return line;
};
exports.handleSingleLineMove = handleSingleLineMove;
var handleSingleLineDragStart = function (_a) {
    var lineId = _a.lineId, layoutStructure = _a.layoutStructure, lineDir = _a.lineDir;
    var line = layoutStructure.find(function (item) { return item.item === lineId; });
    var linePosition = exports.computeLineAbsPosition({
        layoutStructure: layoutStructure,
        position: line.position,
    });
    if (layoutUtils_1.isLineConnected({
        line: line,
        dir: lineDir,
    })) {
        line = layoutUtils_1.disconnectLine({
            line: line,
            dir: lineDir,
            absPos: linePosition[lineDir],
        });
    }
    return line;
};
exports.handleSingleLineDragStart = handleSingleLineDragStart;
var getAllLineItems = function (_a) {
    var layoutStructure = _a.layoutStructure, _b = _a.layoutStructureState, layoutStructureState = _b === void 0 ? {} : _b;
    return layoutStructure
        .map(function (item) { var _a; return (_a = layoutStructureState[item.item]) !== null && _a !== void 0 ? _a : item; })
        .filter(function (_a) {
        var type = _a.type;
        return type === 'line';
    });
};
exports.getAllLineItems = getAllLineItems;


/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var react_1 = __importStar(__webpack_require__(0));
var styled_components_1 = __importDefault(__webpack_require__(1));
var mixins_1 = __webpack_require__(8);
var themes_1 = __webpack_require__(4);
var style_1 = __webpack_require__(31);
var colorUtils_1 = __webpack_require__(32);
var customThemeVariables_1 = __webpack_require__(7);
var imageUtils_1 = __webpack_require__(15);
var useBackgroundImage_1 = __webpack_require__(33);
var GRID_LINE_OPACITY = 0.1;
/**
 * logic for background image size css.
 * @param {BackgroundProps} props
 */
var toBackgroundImageSize = function (props) {
    var _a;
    var _b = imageUtils_1.getImageDimension((_a = props.bgImageSrc) !== null && _a !== void 0 ? _a : ''), width = _b.width, height = _b.height;
    if (props.bgImageWidth && props.bgImageHeight) {
        return style_1.toPx(props.bgImageWidth) + " " + style_1.toPx(props.bgImageHeight);
    }
    if (props.bgImageWidth || props.bgImageHeight) {
        return style_1.toPx(props.bgImageWidth || width) + " " + style_1.toPx(props.bgImageHeight || height);
    }
    if (props.bgImageSizeType) {
        return props.bgImageSizeType;
    }
    return 'contain';
};
/**
 * make sure to only include image related css when backgroundImageSrc is specified.
 * @param {BackgroundProps} props
 */
var toBackgroundImage = function (props) {
    if (props.bgImageSrc) {
        return "\n            background-repeat: no-repeat;\n            background-image: url(\"" + props.bgImageSrc + "\");\n            background-size: " + toBackgroundImageSize(props) + ";\n            background-position:\n                " + style_1.toPx(props.bgImagePositionX) + " " + style_1.toPx(props.bgImagePositionY) + ";\n        ";
    }
    return '';
};
var toScale = function (scale) {
    if (scale) {
        return "\n            transform: scale(" + scale + ");\n            transform-origin: 0 0;\n        ";
    }
    return '';
};
var CanvasContainer = styled_components_1.default.div(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n    ", ";\n    ", ";\n    overflow: ", ";\n    user-select: ", ";\n    position: relative;\n"], ["\n    ", ";\n    ", ";\n    overflow: ", ";\n    user-select: ", ";\n    position: relative;\n"])), mixins_1.reset('block'), function (prop) { return style_1.toDimension({ width: prop.width, height: prop.height }); }, function (prop) { return (prop.showOverflowContent ? 'visible' : 'hidden'); }, function (prop) { return (prop.userSelect ? 'text' : 'none'); });
/**
 * A layer that renders canvas with background color/image
 */
var Background = styled_components_1.default.div(templateObject_2 || (templateObject_2 = __makeTemplateObject(["\n    ", ";\n    ", ";\n    position: relative;\n    background: ", ";\n    ", ";\n    ", ";\n"], ["\n    ", ";\n    ", ";\n    position: relative;\n    background: ",
    ";\n    ", ";\n    ", ";\n"])), mixins_1.reset('inline-block'), function (prop) { return style_1.toDimension({ width: prop.width, height: prop.height }); }, function (prop) {
    return prop.bgColor ||
        // NOTE: this needs to match packages/dashboard-editors/src/layouts/AbsoluteLayoutEditor.jsx
        customThemeVariables_1.customThemeVariables.dashboardBackgroundColor;
}, function (prop) { return toBackgroundImage(prop); }, function (prop) { return toScale(prop.scale); });
/**
 * A layer that renders border
 */
var Border = styled_components_1.default.div(templateObject_3 || (templateObject_3 = __makeTemplateObject(["\n    position: absolute;\n    box-sizing: border-box;\n    border: 2px dashed\n        ", ";\n    left: 0px;\n    top: 0px;\n    right: 0px;\n    bottom: 0px;\n    ", ";\n"], ["\n    position: absolute;\n    box-sizing: border-box;\n    border: 2px dashed\n        ",
    ";\n    left: 0px;\n    top: 0px;\n    right: 0px;\n    bottom: 0px;\n    ", ";\n"])), themes_1.pick({
    enterprise: {
        light: themes_1.variables.gray80,
        dark: themes_1.variables.gray30,
    },
    prisma: themes_1.variables.interactiveColorBorder,
}), function (prop) { return style_1.toDimension({ width: prop.width, height: prop.height }); });
var getGridLineColor = function (props) {
    return props.gridLineColor ||
        themes_1.pick({
            light: '#D8D8D8',
            dark: '#9B9B9B',
        });
};
/**
 * A layer that renders grid
 */
var GridLines = styled_components_1.default.div(templateObject_4 || (templateObject_4 = __makeTemplateObject(["\n    position: absolute;\n    box-sizing: border-box;\n    left: 0px;\n    top: 0px;\n    right: 0px;\n    bottom: 0px;\n    opacity: ", ";\n    ", ";\n    background-size: ", "px\n        ", "px;\n    background-image: repeating-linear-gradient(\n            0deg,\n            ", ",\n            ", " ", ",\n            transparent ", "px,\n            transparent ", "px\n        ),\n        repeating-linear-gradient(\n            -90deg,\n            ", ",\n            ", " ", ",\n            transparent ", "px,\n            transparent ", "px\n        );\n"], ["\n    position: absolute;\n    box-sizing: border-box;\n    left: 0px;\n    top: 0px;\n    right: 0px;\n    bottom: 0px;\n    opacity: ", ";\n    ", ";\n    background-size: ", "px\n        ", "px;\n    background-image: repeating-linear-gradient(\n            0deg,\n            ", ",\n            ", " ", ",\n            transparent ", "px,\n            transparent ", "px\n        ),\n        repeating-linear-gradient(\n            -90deg,\n            ", ",\n            ", " ", ",\n            transparent ", "px,\n            transparent ", "px\n        );\n"])), function (prop) { return prop.gridLineOpacity || GRID_LINE_OPACITY; }, function (prop) { return style_1.toDimension({ width: prop.width, height: prop.height }); }, function (prop) { return prop.gridWidth + prop.gridLineWidth; }, function (prop) { return prop.gridHeight + prop.gridLineWidth; }, getGridLineColor, getGridLineColor, function (prop) { return style_1.toPx(prop.gridLineWidth); }, function (prop) { return prop.gridLineWidth; }, function (prop) { return prop.gridHeight + prop.gridLineWidth; }, getGridLineColor, getGridLineColor, function (prop) { return style_1.toPx(prop.gridLineWidth); }, function (prop) { return prop.gridLineWidth; }, function (prop) { return prop.gridWidth + prop.gridLineWidth; });
/**
 * Canvas is a component that render background for a layout.
 * All visualizations will be displayed on top of a canvas
 */
var Canvas = function (_a, canvasRef) {
    var width = _a.width, height = _a.height, scale = _a.scale, _b = _a.backgroundColor, unsanitizedBgColor = _b === void 0 ? '' : _b, backgroundImageSrc = _a.backgroundImageSrc, backgroundImageSizeType = _a.backgroundImageSizeType, backgroundImageWidth = _a.backgroundImageWidth, backgroundImageHeight = _a.backgroundImageHeight, backgroundImagePositionX = _a.backgroundImagePositionX, backgroundImagePositionY = _a.backgroundImagePositionY, gridLineOpacity = _a.gridLineOpacity, children = _a.children, _c = _a.showOverflowContent, showOverflowContent = _c === void 0 ? false : _c, _d = _a.userSelect, userSelect = _d === void 0 ? false : _d, _e = _a.showGrid, showGrid = _e === void 0 ? false : _e, _f = _a.gridPadding, gridPadding = _f === void 0 ? 0 : _f, _g = _a.gridLineWidth, gridLineWidth = _g === void 0 ? 1 : _g, gridLineColor = _a.gridLineColor, _h = _a.gridWidth, gridWidth = _h === void 0 ? 9 : _h, _j = _a.gridHeight, gridHeight = _j === void 0 ? 9 : _j, _k = _a.showBorder, showBorder = _k === void 0 ? false : _k, _l = _a.cssScaling, cssScaling = _l === void 0 ? true : _l, others = __rest(_a, ["width", "height", "scale", "backgroundColor", "backgroundImageSrc", "backgroundImageSizeType", "backgroundImageWidth", "backgroundImageHeight", "backgroundImagePositionX", "backgroundImagePositionY", "gridLineOpacity", "children", "showOverflowContent", "userSelect", "showGrid", "gridPadding", "gridLineWidth", "gridLineColor", "gridWidth", "gridHeight", "showBorder", "cssScaling"]);
    var imageSrc = useBackgroundImage_1.useBackgroundImage(backgroundImageSrc);
    var containerWidth = scale != null ? width * scale : width;
    var containerHeight = scale != null && cssScaling ? height * scale : height;
    var backgroundColor = colorUtils_1.sanitizeColor(unsanitizedBgColor);
    return (react_1.default.createElement(CanvasContainer, __assign({ "data-test": "canvas-container", "data-width": containerWidth, "data-height": containerHeight, width: cssScaling ? containerWidth : width, height: containerHeight, showOverflowContent: showOverflowContent, userSelect: userSelect, ref: canvasRef }, others),
        react_1.default.createElement(Background, { "data-test": "canvas", "data-width": width, "data-height": height, "data-scale": scale, width: cssScaling ? width : containerWidth, height: height, scale: cssScaling ? scale : undefined, bgColor: backgroundColor, bgImageSrc: imageSrc, bgImageSizeType: backgroundImageSizeType, bgImageWidth: backgroundImageWidth, bgImageHeight: backgroundImageHeight, bgImagePositionX: backgroundImagePositionX, bgImagePositionY: backgroundImagePositionY },
            showBorder && react_1.default.createElement(Border, { width: width, height: height }),
            showGrid && (react_1.default.createElement(GridLines, { width: width, height: height, gridLineOpacity: gridLineOpacity, gridPadding: gridPadding, gridLineWidth: gridLineWidth, gridLineColor: gridLineColor, gridWidth: gridWidth, gridHeight: gridHeight })),
            children)));
};
exports.default = react_1.forwardRef(Canvas);
var templateObject_1, templateObject_2, templateObject_3, templateObject_4;


/***/ }),
/* 31 */
/***/ (function(module, exports) {

module.exports = require("@splunk/dashboard-utils/style");

/***/ }),
/* 32 */
/***/ (function(module, exports) {

module.exports = require("@splunk/dashboard-ui/utils/colorUtils");

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.useBackgroundImage = void 0;
var react_1 = __webpack_require__(0);
var dashboard_context_1 = __importDefault(__webpack_require__(14));
var console_1 = __importDefault(__webpack_require__(5));
var useBackgroundImage = function (backgroundImageSrc) {
    var _a = __read(react_1.useState(''), 2), imageSrc = _a[0], setImageSrc = _a[1];
    var imageRegistry = react_1.useContext(dashboard_context_1.default).imageRegistry;
    /**
     * Check whether backgroundImage src is a remote image url or stored in the image registry. Fetch if its the latter
     * @param string backgroundImageSrc
     */
    var fetchBackgroundImage = function (registry, bgImageSrc) { return __awaiter(void 0, void 0, void 0, function () {
        var imageObject, error_1;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    _a.trys.push([0, 6, , 7]);
                    if (!registry) return [3 /*break*/, 4];
                    if (!registry.isResourceURL(bgImageSrc)) return [3 /*break*/, 2];
                    return [4 /*yield*/, registry.getByURL(bgImageSrc)];
                case 1:
                    imageObject = _a.sent();
                    setImageSrc(imageObject.dataURI);
                    return [3 /*break*/, 3];
                case 2:
                    setImageSrc(bgImageSrc);
                    _a.label = 3;
                case 3: return [3 /*break*/, 5];
                case 4:
                    setImageSrc(bgImageSrc);
                    _a.label = 5;
                case 5: return [3 /*break*/, 7];
                case 6:
                    error_1 = _a.sent();
                    console_1.default.error(error_1); // TODO Refactor error display
                    return [3 /*break*/, 7];
                case 7: return [2 /*return*/];
            }
        });
    }); };
    react_1.useEffect(function () {
        if (backgroundImageSrc) {
            fetchBackgroundImage(imageRegistry, backgroundImageSrc);
        }
    }, [imageRegistry, backgroundImageSrc]);
    return imageSrc;
};
exports.useBackgroundImage = useBackgroundImage;


/***/ }),
/* 34 */,
/* 35 */,
/* 36 */,
/* 37 */,
/* 38 */,
/* 39 */,
/* 40 */,
/* 41 */,
/* 42 */,
/* 43 */,
/* 44 */,
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var noop_1 = __importDefault(__webpack_require__(16));
var react_1 = __importStar(__webpack_require__(0));
var styled_components_1 = __importDefault(__webpack_require__(1));
var themes_1 = __webpack_require__(4);
var layoutUtils_1 = __webpack_require__(2);
var LineBox = styled_components_1.default.div(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n    position: absolute;\n    pointer-events: none;\n"], ["\n    position: absolute;\n    pointer-events: none;\n"])));
var AdjustHandle = styled_components_1.default.a.attrs(function (_a) {
    var x = _a.x, y = _a.y;
    return ({
        style: {
            transform: "translate(" + x + "px, " + y + "px)",
        },
    });
})(templateObject_2 || (templateObject_2 = __makeTemplateObject(["\n    width: 10px;\n    height: 10px;\n    left: -5px;\n    top: -5px;\n    background-color: ", ";\n    border-radius: 50%;\n    position: absolute;\n    z-index: 999;\n    pointer-events: auto;\n    cursor: move;\n    user-select: none;\n"], ["\n    width: 10px;\n    height: 10px;\n    left: -5px;\n    top: -5px;\n    background-color: ",
    ";\n    border-radius: 50%;\n    position: absolute;\n    z-index: 999;\n    pointer-events: auto;\n    cursor: move;\n    user-select: none;\n"])), themes_1.pick({
    enterprise: themes_1.variables.accentColorL10,
    prisma: themes_1.variables.interactiveColorPrimary,
}));
var ResponsiveLine = function (_a) {
    var fromX = _a.fromX, fromY = _a.fromY, fromItem = _a.fromItem, fromPort = _a.fromPort, toX = _a.toX, toY = _a.toY, toItem = _a.toItem, toPort = _a.toPort, lineId = _a.lineId, _b = _a.scale, scale = _b === void 0 ? 1 : _b, _c = _a.selectable, selectable = _c === void 0 ? false : _c, _d = _a.editable, editable = _d === void 0 ? false : _d, renderLayoutItem = _a.renderLayoutItem, _e = _a.onItemSelected, onItemSelected = _e === void 0 ? noop_1.default : _e, _f = _a.onLineDragStart, onLineDragStart = _f === void 0 ? noop_1.default : _f, _g = _a.onLineMove, onLineMove = _g === void 0 ? noop_1.default : _g, _h = _a.onLineMoved, onLineMoved = _h === void 0 ? noop_1.default : _h, _j = _a.onLineDrag, onLineDrag = _j === void 0 ? noop_1.default : _j, _k = _a.onLineDragged, onLineDragged = _k === void 0 ? noop_1.default : _k;
    var _l = __read(react_1.useState(null), 2), startPosition = _l[0], setStartPosition = _l[1];
    var _m = __read(react_1.useState(null), 2), action = _m[0], setAction = _m[1];
    var handleLineSelected = react_1.useCallback(function (e) {
        e.stopPropagation();
        setStartPosition(layoutUtils_1.getClientPosition(e, scale));
        setAction('move');
        onItemSelected(e, [{ id: lineId, type: 'line' }]);
    }, [lineId, onItemSelected, scale]);
    var handleMouseDownFrom = react_1.useCallback(function (e) {
        e.stopPropagation();
        setStartPosition(layoutUtils_1.getClientPosition(e, scale));
        setAction('drag');
        onLineDragStart(e, 'from');
    }, [onLineDragStart, scale]);
    var handleMouseDownTo = react_1.useCallback(function (e) {
        e.stopPropagation();
        setStartPosition(layoutUtils_1.getClientPosition(e, scale));
        setAction('drag');
        onLineDragStart(e, 'to');
    }, [onLineDragStart, scale]);
    var handleMouseMove = react_1.useCallback(function (e) {
        if (startPosition == null || action == null) {
            return;
        }
        e.preventDefault();
        var currentPosition = layoutUtils_1.getClientPosition(e, scale);
        var offset = layoutUtils_1.getOffset(currentPosition, startPosition);
        switch (action) {
            case 'drag':
                onLineDrag(e, offset);
                break;
            case 'move':
                onLineMove(e, offset);
                break;
            default:
                break;
        }
    }, [action, onLineDrag, onLineMove, scale, startPosition]);
    var handleMouseUp = react_1.useCallback(function (e) {
        if (startPosition == null || action == null) {
            return;
        }
        setStartPosition(null);
        var currentPosition = layoutUtils_1.getClientPosition(e, scale);
        var offset = layoutUtils_1.getOffset(currentPosition, startPosition);
        switch (action) {
            case 'drag':
                onLineDragged(e, offset);
                break;
            case 'move':
                onLineMoved(e, offset);
                break;
            default:
                break;
        }
    }, [action, onLineDragged, onLineMoved, scale, startPosition]);
    var from = { x: fromX, y: fromY };
    var to = { x: toX, y: toY };
    var boxPos = layoutUtils_1.computeLineBoxPosition(from, to);
    var relativePos = layoutUtils_1.computeLineRelativePosition(from, to, boxPos);
    var lineBoxStyle = react_1.useMemo(function () { return ({
        transform: "translate(" + boxPos.x + "px, " + boxPos.y + "px)",
    }); }, [boxPos.x, boxPos.y]);
    var fromHandleElement = react_1.useMemo(function () {
        if (!editable) {
            return null;
        }
        return (react_1.default.createElement(AdjustHandle, { "data-test": "line-handle-from", "data-test-item": fromItem, "data-test-port": fromPort, x: relativePos.from.x, y: relativePos.from.y, onMouseDown: handleMouseDownFrom }));
    }, [
        editable,
        fromItem,
        fromPort,
        relativePos.from.x,
        relativePos.from.y,
        handleMouseDownFrom,
    ]);
    var tohandleElement = react_1.useMemo(function () {
        if (!editable) {
            return null;
        }
        return (react_1.default.createElement(AdjustHandle, { "data-test": "line-handle-to", "data-test-item": toItem, "data-test-port": toPort, x: relativePos.to.x, y: relativePos.to.y, onMouseDown: handleMouseDownTo }));
    }, [
        editable,
        toItem,
        toPort,
        relativePos.to.x,
        relativePos.to.y,
        handleMouseDownTo,
    ]);
    var lineElement = react_1.useMemo(function () {
        return renderLayoutItem(lineId, {
            from: {
                x: relativePos.from.x,
                y: relativePos.from.y,
            },
            to: {
                x: relativePos.to.x,
                y: relativePos.to.y,
            },
            // todo: this is inconsistent with the ResponsiveBlockitem which accepts the `onSelect` callback as the 4th argument of `renderLayoutItem`.
            onLineSelect: selectable ? handleLineSelected : noop_1.default,
        }, 'line');
    }, [
        handleLineSelected,
        lineId,
        relativePos.from.x,
        relativePos.from.y,
        relativePos.to.x,
        relativePos.to.y,
        renderLayoutItem,
        selectable,
    ]);
    react_1.useEffect(function () {
        if (editable) {
            document.addEventListener('mousemove', handleMouseMove);
            document.addEventListener('mouseup', handleMouseUp);
        }
        return function () {
            document.removeEventListener('mousemove', handleMouseMove);
            document.removeEventListener('mouseup', handleMouseUp);
        };
    }, [editable, handleMouseMove, handleMouseUp]);
    return (react_1.default.createElement(LineBox, { "data-test": "line-box", style: lineBoxStyle, "data-viz-type": "abslayout.line", "data-id": lineId, "data-test-line-position": from.x + "," + from.y + "-" + to.x + "," + to.y },
        fromHandleElement,
        tohandleElement,
        lineElement));
};
exports.default = ResponsiveLine;
var templateObject_1, templateObject_2;


/***/ }),
/* 46 */,
/* 47 */,
/* 48 */,
/* 49 */,
/* 50 */,
/* 51 */,
/* 52 */,
/* 53 */,
/* 54 */,
/* 55 */,
/* 56 */,
/* 57 */,
/* 58 */,
/* 59 */,
/* 60 */,
/* 61 */,
/* 62 */,
/* 63 */,
/* 64 */,
/* 65 */,
/* 66 */,
/* 67 */,
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var react_1 = __importStar(__webpack_require__(0));
var Canvas_1 = __importDefault(__webpack_require__(30));
var AbsoluteItem_1 = __importDefault(__webpack_require__(69));
var layoutUtils_1 = __webpack_require__(2);
var imageUtils_1 = __webpack_require__(15);
var lineUtils_1 = __webpack_require__(29);
var DefaultOptions_1 = __webpack_require__(9);
var ResponsiveLine_1 = __importDefault(__webpack_require__(45));
var AbsoluteLayoutViewer = function (_a) {
    var containerWidth = _a.containerWidth, _b = _a.layoutStructure, layoutStructure = _b === void 0 ? [] : _b, renderLayoutItem = _a.renderLayoutItem, _c = _a.options, options = _c === void 0 ? {} : _c;
    var _d = __assign(__assign({}, DefaultOptions_1.absoluteLayoutOptions), options), width = _d.width, height = _d.height, backgroundColor = _d.backgroundColor, _e = _d.backgroundImage, backgroundImage = _e === void 0 ? {} : _e, _f = _d.display, display = _f === void 0 ? 'actual-size' : _f;
    var scale = display === 'auto-scale' ? layoutUtils_1.computeScaleToFit(containerWidth, width) : 1;
    var image = react_1.useMemo(function () {
        return backgroundImage
            ? imageUtils_1.validateBackgroundImage({
                backgroundImage: backgroundImage,
                canvasWidth: width,
                canvasHeight: height,
            })
            : {};
    }, [backgroundImage, height, width]);
    var renderLines = react_1.useMemo(function () {
        // TODO: replace with getAllLineItems() from lineUtils after AbsLayout refactor is merged
        var lineItems = layoutStructure.filter(function (_a) {
            var type = _a.type;
            return type === 'line';
        });
        return lineItems.map(function (_a) {
            var item = _a.item, position = _a.position;
            var absPosition = lineUtils_1.computeLineAbsPosition({
                layoutStructure: layoutStructure,
                position: position,
            });
            return (react_1.default.createElement(ResponsiveLine_1.default, { key: item, lineId: item, scale: scale, fromX: absPosition.from.x, toX: absPosition.to.x, fromY: absPosition.from.y, toY: absPosition.to.y, renderLayoutItem: renderLayoutItem }));
        });
    }, [layoutStructure, scale, renderLayoutItem]);
    var renderBlockItems = react_1.useMemo(function () {
        // TODO: replace with getAllBlockItems() from lineUtils after AbsLayout refactor is merged
        var blockItems = layoutStructure.filter(function (_a) {
            var type = _a.type;
            return type !== 'line';
        });
        return blockItems.map(function (_a) {
            var item = _a.item, position = _a.position;
            var x = position.x, y = position.y, w = position.w, h = position.h;
            return (react_1.default.createElement(AbsoluteItem_1.default, { itemId: item, key: item, x: x, y: y, w: w, h: h, renderLayoutItem: renderLayoutItem }));
        });
    }, [renderLayoutItem, layoutStructure]);
    return (react_1.default.createElement(Canvas_1.default, { "data-layout-type": "absolute", width: width, height: height, scale: scale, showGrid: false, backgroundColor: backgroundColor, backgroundImageSrc: image.src, backgroundImageSizeType: image.sizeType, backgroundImageWidth: image.w, backgroundImageHeight: image.h, backgroundImagePositionX: image.x, backgroundImagePositionY: image.y },
        renderBlockItems,
        renderLines));
};
exports.default = AbsoluteLayoutViewer;


/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var react_1 = __importDefault(__webpack_require__(0));
var styled_components_1 = __importDefault(__webpack_require__(1));
var prop_types_1 = __importDefault(__webpack_require__(3));
var AbsoluteDiv = styled_components_1.default.div.attrs(function (_a) {
    var x = _a.x, y = _a.y, w = _a.w, h = _a.h;
    return ({
        style: {
            width: w,
            height: h,
            top: y + "px",
            left: x + "px",
        },
    });
})(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n    display: block;\n    position: absolute;\n    background: transparent;\n"], ["\n    display: block;\n    position: absolute;\n    background: transparent;\n"])));
/**
 * Absolute positioned item
 * @param {*} param0
 */
var AbsoluteItem = function (_a) {
    var itemId = _a.itemId, x = _a.x, y = _a.y, w = _a.w, h = _a.h, renderLayoutItem = _a.renderLayoutItem;
    return (react_1.default.createElement(AbsoluteDiv, { x: x, y: y, w: w, h: h, "data-test": "absolute-item", "data-x": x, "data-y": y, "data-w": w, "data-h": h }, renderLayoutItem(itemId, {
        width: w,
        height: h,
    }, 'block')));
};
AbsoluteItem.propTypes = {
    itemId: prop_types_1.default.string.isRequired,
    x: prop_types_1.default.number.isRequired,
    y: prop_types_1.default.number.isRequired,
    w: prop_types_1.default.number.isRequired,
    h: prop_types_1.default.number.isRequired,
    renderLayoutItem: prop_types_1.default.func.isRequired,
};
exports.default = AbsoluteItem;
var templateObject_1;


/***/ })
/******/ ]);
//# sourceMappingURL=AbsoluteLayoutViewer.js.map
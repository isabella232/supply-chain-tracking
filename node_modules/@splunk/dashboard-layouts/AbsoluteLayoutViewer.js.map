{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///external \"react\"","webpack:///external \"styled-components\"","webpack:///./src/utils/layoutUtils.ts","webpack:///external \"prop-types\"","webpack:///external \"@splunk/themes\"","webpack:///external \"@splunk/dashboard-utils/console\"","webpack:///external \"@splunk/dashboard-utils/layout\"","webpack:///external \"@splunk/dashboard-ui/customThemeVariables\"","webpack:///external \"@splunk/themes/mixins\"","webpack:///./src/DefaultOptions.ts","webpack:///external \"lodash/get\"","webpack:///./src/utils/edgeUtils.ts","webpack:///external \"@splunk/dashboard-utils/uniqueId\"","webpack:///external \"@splunk/dashboard-context\"","webpack:///./src/utils/imageUtils.ts","webpack:///external \"lodash/noop\"","webpack:///external \"lodash/findLast\"","webpack:///external \"lodash/isNumber\"","webpack:///external \"lodash/reduce\"","webpack:///external \"lodash/pullAt\"","webpack:///external \"lodash/cloneDeep\"","webpack:///external \"lodash/sortBy\"","webpack:///./src/utils/blockUtils.ts","webpack:///external \"lodash/isEmpty\"","webpack:///./src/utils/lineUtils.ts","webpack:///./src/components/Canvas.tsx","webpack:///external \"@splunk/dashboard-utils/style\"","webpack:///external \"@splunk/dashboard-ui/utils/colorUtils\"","webpack:///./src/hooks/useBackgroundImage.ts","webpack:///./src/components/ResponsiveLine.tsx","webpack:///./src/AbsoluteLayoutViewer.tsx","webpack:///./src/components/AbsoluteItem.jsx"],"names":[],"mappings":"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","file":"AbsoluteLayoutViewer.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 68);\n","module.exports = require(\"react\");","module.exports = require(\"styled-components\");","import findLast from 'lodash/findLast';\nimport get from 'lodash/get';\nimport isNumber from 'lodash/isNumber';\nimport reduce from 'lodash/reduce';\nimport pullAt from 'lodash/pullAt';\nimport cloneDeep from 'lodash/cloneDeep';\nimport sortBy from 'lodash/sortBy';\nimport console from '@splunk/dashboard-utils/console';\nimport {\n    collides,\n    computeMaxHeight as utilsComputeMaxHeight,\n} from '@splunk/dashboard-utils/layout';\nimport type {\n    Coordinate,\n    ConnectedPosition,\n    AbsolutePosition,\n    Port,\n    ConnectedLineItem,\n    ConnectedLinePosition,\n    AbsoluteLayoutStructure,\n    AbsoluteBlockItem,\n    AbsoluteLayoutItem,\n    GridLayoutStructure,\n} from '@splunk/dashboard-types';\nimport { applyVizPadding, getAllEdges } from './edgeUtils';\nimport type { Offset, LineDirection, HandleDirection } from '../types';\n\n// export for gridLayout/legacyGridLayout\nexport const computeMaxHeight = utilsComputeMaxHeight;\n\n/**\n *  check if a position is valid\n * @param {Object} position\n */\nexport const isBlockPositionValid = (position: AbsolutePosition): boolean =>\n    !!(\n        position &&\n        Number.isInteger(position.x) &&\n        Number.isInteger(position.y) &&\n        Number.isInteger(position.w) &&\n        Number.isInteger(position.h)\n    );\n\nexport const isValidConnection = (\n    connection: Coordinate | ConnectedPosition\n): boolean => {\n    if (\n        'x' in connection &&\n        'y' in connection &&\n        Number.isInteger(connection.x) &&\n        Number.isInteger(connection.y)\n    ) {\n        return true;\n    }\n    if (\n        'item' in connection &&\n        'port' in connection &&\n        connection.item != null &&\n        connection.port != null\n    ) {\n        return true;\n    }\n    return false;\n};\n\n/**\n * a line should has from and to\n */\nexport const isLinePositionValid = (\n    position: ConnectedLinePosition\n): boolean => {\n    if (position.from != null && position.to != null) {\n        return (\n            isValidConnection(position.from) && isValidConnection(position.to)\n        );\n    }\n    return false;\n};\n\n/**\n * filter invalid position\n * @param {Object[]} layoutStructure - Array of items (viz, edges, lines)\n * @returns {Object[]} - Returns filtered array\n */\nexport const removeInvalidItems = (\n    layoutStructure: AbsoluteLayoutStructure = []\n): AbsoluteLayoutStructure =>\n    layoutStructure.filter((structure) => {\n        if (structure.type === 'line') {\n            return isLinePositionValid(structure.position);\n        }\n        return isBlockPositionValid(structure.position);\n    });\n\ninterface PositionStyle {\n    width: string;\n    height: string;\n    transform: string;\n}\n\n/**\n * convert position to css object\n */\nexport const positionToStyle = (pos: AbsolutePosition): PositionStyle => ({\n    width: `${pos.w}px`,\n    height: `${pos.h}px`,\n    transform: `translate(${pos.x}px, ${pos.y}px)`,\n});\n\n/**\n * convert position to css string\n */\nexport const positionToStyleString = (pos: AbsolutePosition): string => {\n    const style = positionToStyle(pos);\n    return reduce(style, (result, v, k) => `${result} ${k}:${v};`, '');\n};\n\n/**\n * get client position for given event with scale factor\n */\nexport const getClientPosition = (\n    e: {\n        clientX: number;\n        clientY: number;\n    },\n    scaleFactor = 1\n): Coordinate => ({\n    x: Math.round(e.clientX / scaleFactor),\n    y: Math.round(e.clientY / scaleFactor),\n});\n\n/**\n * compute offset from 2 positions\n */\nexport const getOffset = (\n    currentPosition: Coordinate,\n    startPosition: Coordinate\n): Offset => ({\n    offsetX: currentPosition.x - startPosition.x,\n    offsetY: currentPosition.y - startPosition.y,\n});\n\n/**\n * check if a given offset can be considered as 'move'\n * @param {Object} config\n * @param {Number} config.offsetX\n * @param {Number} config.offsetY\n */\nexport const considerMoved = ({\n    offsetX,\n    offsetY,\n}: {\n    offsetX: number;\n    offsetY: number;\n}): boolean => offsetX !== 0 || offsetY !== 0;\n\n/**\n * return a boundary for 2 positions\n * @param {Coordinate} startPos\n * @param {Coordinate} endPos\n */\nexport const positionsToBoundary = (\n    startPos: Coordinate,\n    endPos: Coordinate\n): AbsolutePosition => ({\n    x: Math.min(startPos.x, endPos.x),\n    y: Math.min(startPos.y, endPos.y),\n    w: Math.abs(startPos.x - endPos.x),\n    h: Math.abs(startPos.y - endPos.y),\n});\n\n/**\n * filter abs items within a boundary\n * @param {Array} items\n * @param {Object} boundary\n */\nexport const filterBlockItemsByBoundary = (\n    items: AbsoluteBlockItem[],\n    boundary: AbsolutePosition\n): AbsoluteBlockItem[] =>\n    items.filter((item) => {\n        const itemPosition = item.position;\n        return !(\n            boundary.x > itemPosition.x + itemPosition.w ||\n            boundary.x + boundary.w < itemPosition.x ||\n            boundary.y > itemPosition.y + itemPosition.h ||\n            boundary.y + boundary.h < itemPosition.y\n        );\n    });\n\n/**\n * find the first item that contains the pos.\n */\nexport const findTopBlockItemByPosition = (\n    items: AbsoluteBlockItem[],\n    pos: Coordinate,\n    padding = 0\n): AbsoluteBlockItem | undefined =>\n    findLast(items, (item) => {\n        const itemPosition = padding\n            ? applyVizPadding({ item, padding }).position\n            : item.position;\n        return (\n            itemPosition.x <= pos.x &&\n            itemPosition.x + itemPosition.w >= pos.x &&\n            itemPosition.y <= pos.y &&\n            itemPosition.y + itemPosition.h >= pos.y\n        );\n    });\n\n/**\n * Compute the new offset so current + new offset will be the multiple of snapTo unit\n * For examples:\n * (5, 2, 5) => 0, user moved less than half of the snapTo unit, return 0 so 5 + 0 = 5\n * (5, 3, 5) => 5, user moved more than half of the snapTo unit, return 5 so 5 + 5 = 5 * 2\n * (5, 12, 5) => 10\n * (5, 13, 5) => 15\n * @param {Number} current\n * @param {Number} offset\n * @param {Number} snapTo\n */\nexport const snapOffset = (\n    current: number,\n    offset: number,\n    snapTo: number\n): number => {\n    // return a new offset\n    const remainder = (current + offset) % snapTo;\n    const newOffset =\n        remainder > snapTo / 2\n            ? offset + (snapTo - remainder)\n            : offset - remainder;\n    return newOffset;\n};\n\ninterface SnapOffsetToXYArgs {\n    position: AbsolutePosition;\n    offset: Offset;\n    gridWidth: number;\n    gridHeight: number;\n    spacing?: number;\n    padding?: number;\n}\n\n/**\n * snap item with its top-left corner (represent by x, y)\n * @param {Object} position\n * @param {Object} offset\n * @param {Number} gridWidth\n * @param {Number} gridHeight\n * @param {Number} spacing\n */\nexport const snapOffsetToXY = ({\n    position,\n    offset,\n    gridWidth,\n    gridHeight,\n    spacing = 0,\n    padding = 0,\n}: SnapOffsetToXYArgs): Offset => {\n    let { offsetX, offsetY } = offset;\n    offsetX = snapOffset(position.x, offsetX, gridWidth + spacing) + padding;\n    offsetY = snapOffset(position.y, offsetY, gridHeight + spacing) + padding;\n    return {\n        offsetX,\n        offsetY,\n    };\n};\n\ntype SnapOffsetToWHArgs = SnapOffsetToXYArgs;\n\n/**\n * snap item with its size (represent by w, h)\n * @param {Object} position\n * @param {Object} offset\n * @param {Number} gridWidth\n * @param {Number} gridHeight\n * @param {Number} spacing\n */\nexport const snapOffsetToWH = ({\n    position,\n    offset,\n    gridWidth,\n    gridHeight,\n    spacing = 0,\n    padding = 0,\n}: SnapOffsetToWHArgs): Offset => {\n    let { offsetX, offsetY } = offset;\n    offsetX =\n        snapOffset(position.x + position.w, offsetX, gridWidth + spacing) +\n        (padding - spacing);\n    offsetY =\n        snapOffset(position.y + position.h, offsetY, gridHeight + spacing) +\n        (padding - spacing);\n    return {\n        offsetX,\n        offsetY,\n    };\n};\n\ninterface UpdateBlockItemSizeArgs {\n    item: AbsoluteBlockItem;\n    offset: Offset;\n    dir: HandleDirection;\n    options?: {\n        minWidth?: number;\n        minHeight?: number;\n    };\n}\n\n/**\n * Mutate item coordinates and/or dimensions.\n * This mutation's new dimensions and coordinates are bounded within the original block item real estate.\n * @param {Object} item\n * @param {Object} offset\n * @param {String} dir Cartesian direction to shift item towards.\n * @param {Object} options\n */\nexport const updateBlockItemSize = ({\n    item,\n    offset,\n    dir,\n    options: { minWidth = 0, minHeight = 0 } = {},\n}: UpdateBlockItemSizeArgs): AbsoluteBlockItem => {\n    const { w, h } = item.position;\n    const { offsetX, offsetY } = offset;\n    const updatedPosition = { ...item.position };\n\n    // resizing from north\n    if (['n', 'ne', 'nw'].includes(dir)) {\n        updatedPosition.y += Math.min(h - minHeight, offsetY);\n        updatedPosition.h -= offsetY;\n    }\n    // resizing from the south\n    if (['s', 'se', 'sw'].includes(dir)) {\n        updatedPosition.h += offsetY;\n    }\n    // resizing from the east\n    if (['e', 'ne', 'se'].includes(dir)) {\n        updatedPosition.w += offsetX;\n    }\n    // resizing from west\n    if (['w', 'nw', 'sw'].includes(dir)) {\n        updatedPosition.x += Math.min(w - minWidth, offsetX);\n        updatedPosition.w -= offsetX;\n    }\n\n    updatedPosition.w = Math.max(minWidth, updatedPosition.w);\n    updatedPosition.h = Math.max(minHeight, updatedPosition.h);\n    return {\n        ...item,\n        position: updatedPosition,\n    };\n};\n\nexport const updateBlockItemPosition = (\n    item: AbsoluteBlockItem,\n    offset: Offset\n): AbsoluteBlockItem => {\n    const { offsetX, offsetY } = offset;\n    return {\n        ...item,\n        position: {\n            ...item.position,\n            x: item.position.x + offsetX,\n            y: item.position.y + offsetY,\n        },\n    };\n};\n\n/**\n * create offset based on dir, x and y\n * @method createOffset\n * @param {String} dir\n * @param {Number} x\n * @param {Number} y\n * @returns {Object} offset\n */\nexport const createOffset = (\n    dir: HandleDirection,\n    x: number,\n    y: number\n): Offset => {\n    switch (dir) {\n        case 'n':\n            return {\n                offsetX: 0,\n                offsetY: -y,\n            };\n        case 's':\n            return {\n                offsetX: 0,\n                offsetY: y,\n            };\n        case 'w':\n            return {\n                offsetX: -x,\n                offsetY: 0,\n            };\n        case 'e':\n            return {\n                offsetX: x,\n                offsetY: 0,\n            };\n        default:\n            return {\n                offsetX: 0,\n                offsetY: 0,\n            };\n    }\n};\n\n/**\n * compute scale factor\n * @param {Number} actualWidth\n * @param {Number} canvasWidth\n */\n\nexport const computeScaleToFit = (\n    actualWidth: number,\n    canvasWidth: number\n): number => {\n    if (\n        !(\n            isNumber(canvasWidth) &&\n            canvasWidth > 0 &&\n            isNumber(actualWidth) &&\n            actualWidth > 0\n        )\n    ) {\n        console.warn(\n            `Failed to calculate layout scale: containerWidth=${actualWidth}, width=${canvasWidth}; falling back to scale=1`\n        );\n        return 1;\n    }\n    return actualWidth / canvasWidth;\n};\n\n/**\n *\n * @param {Array} items\n * @param {Number} from  target item index\n * @param {Number} to    where does this item move to\n */\nexport const moveLayoutItem = (\n    items: AbsoluteLayoutItem[],\n    from: number,\n    to: number\n): AbsoluteLayoutItem[] => {\n    const structure = [...items];\n    const removed = pullAt(structure, [from]);\n    structure.splice(to, 0, removed[0]);\n    return structure;\n};\n\ninterface IsLineConnectedArgs {\n    line: ConnectedLineItem;\n    dir: LineDirection;\n}\n\n/**\n * check if a line is connected\n */\nexport const isLineConnected = ({ line, dir }: IsLineConnectedArgs): boolean =>\n    'item' in line.position[dir];\n\ninterface DisconnectLineArgs {\n    line: ConnectedLineItem;\n    dir: LineDirection;\n    absPos: Coordinate;\n}\n\n/**\n *  disconnect a line from item and set it to abs position\n */\nexport const disconnectLine = ({\n    line,\n    dir,\n    absPos,\n}: DisconnectLineArgs): ConnectedLineItem => {\n    const updatePosition = {\n        ...line.position,\n        [dir]: {\n            ...absPos,\n        },\n    };\n    return {\n        ...line,\n        position: updatePosition,\n    };\n};\n\ninterface ConnectLineArgs {\n    line: ConnectedLineItem;\n    dir: LineDirection;\n    itemId: string;\n    port: Port;\n}\n\n/**\n * connect a line with an item and port\n */\nexport const connectLine = ({\n    line,\n    dir,\n    itemId,\n    port,\n}: ConnectLineArgs): ConnectedLineItem => {\n    const { position } = line;\n    const updatedPosition = {\n        ...position,\n        [dir]: {\n            item: itemId,\n            port,\n        },\n    };\n    return {\n        ...line,\n        position: updatedPosition,\n    };\n};\n\ninterface UpdateLineAbsPositionArgs {\n    line: ConnectedLineItem;\n    dir: LineDirection;\n    offset: Offset;\n}\n\n/**\n * update line absolute position\n */\nexport const updateLineAbsPosition = ({\n    line,\n    dir,\n    offset,\n}: UpdateLineAbsPositionArgs): ConnectedLineItem => {\n    const { offsetX, offsetY } = offset;\n    const { position } = line;\n\n    if (!('x' in position[dir])) {\n        throw Error(\n            `line item ${line.item} does not have x value for its direction ${dir}`\n        );\n    }\n\n    if (!('y' in position[dir])) {\n        throw Error(\n            `line item ${line.item} does not have y value for its direction ${dir}`\n        );\n    }\n\n    const { x, y } = position[dir] as Coordinate;\n\n    return {\n        ...line,\n        position: {\n            ...position,\n            [dir]: {\n                x: x + offsetX,\n                y: y + offsetY,\n            },\n        },\n    };\n};\n\n/**\n *\n * @param {Object} from\n * @param {Object} to\n */\nexport const computeLineBoxPosition = (\n    from: Coordinate,\n    to: Coordinate\n): Coordinate => ({\n    x: Math.min(from.x, to.x),\n    y: Math.min(from.y, to.y),\n});\n\n/**\n *\n * @param {Object} from\n * @param {Object} to\n * @param {Object} box\n */\nexport const computeLineRelativePosition = (\n    from: Coordinate,\n    to: Coordinate,\n    box: Coordinate\n): {\n    from: {\n        x: number;\n        y: number;\n    };\n    to: {\n        x: number;\n        y: number;\n    };\n} => ({\n    from: {\n        x: from.x - box.x,\n        y: from.y - box.y,\n    },\n    to: {\n        x: to.x - box.x,\n        y: to.y - box.y,\n    },\n});\n\n/**\n * Return the bottom coordinate of the layout.\n *\n * @param  {Array} layout Layout array.\n * @return {Number}       Bottom coordinate.\n */\nexport const bottom = (layout: AbsoluteBlockItem[]): number => {\n    return layout.length > 0\n        ? Math.max(\n              ...layout.map(({ position }) => {\n                  return position.y + position.h;\n              })\n          )\n        : 1;\n};\n\n/**\n * Before moving item down, it will check if the movement will cause collisions\n * and move those items down before.\n * @method resolveCompactionCollision\n * @param {Array} layout\n * @param {Object} itemToMove current item which need to be moved to solve the collision\n * @param {Number} moveToCoord the destination coordination of y axis\n * @returns {Array} [newLayout, newItem]\n */\nexport const resolveCompactionCollision = (\n    layout: AbsoluteBlockItem[],\n    itemToMove: AbsoluteBlockItem,\n    moveToCoord: number\n): [AbsoluteBlockItem[], AbsoluteBlockItem] => {\n    let axisVal = itemToMove.position.y;\n    axisVal += 1;\n    let newLayout = cloneDeep(layout);\n    const itemIndex = newLayout.findIndex(\n        (layoutItem) => layoutItem.item === itemToMove.item\n    );\n    const newItem = cloneDeep(itemToMove);\n    newItem.position.y = axisVal;\n    // Go through each item we collide with.\n    // If there is a collision, we will move this collision down, otherwise set y = moveToCoord and return\n    for (let i = itemIndex + 1; i < layout.length; i += 1) {\n        // Optimization: we can break early if we know we're past this el\n        // We can do this b/c it's a sorted layout\n        if (newLayout[i].position.y > newItem.position.y + newItem.position.h) {\n            break;\n        }\n        if (collides(newItem, newLayout[i])) {\n            [newLayout, newLayout[i]] = resolveCompactionCollision(\n                layout,\n                layout[i],\n                moveToCoord + newItem.position.h\n            );\n        }\n    }\n\n    newItem.position.y = moveToCoord;\n    newLayout[itemIndex] = newItem;\n    return [newLayout, newItem];\n};\n\n/**\n * get all collisions given an item and current layout\n * @method getAllCollisions\n * @param {Array} layout\n * @param {Object} layoutItem\n * @returns {Array} sorted layout\n */\nexport const getAllCollisions = (\n    layout: AbsoluteBlockItem[],\n    layoutItem: AbsoluteBlockItem\n): AbsoluteBlockItem[] => {\n    return layout.filter((item) => collides(item, layoutItem));\n};\n\ninterface CloneBlockItemArgs {\n    id: string;\n    item: AbsoluteBlockItem;\n    offsetMultiplier: number;\n}\n\n/**\n * clone a block item\n * @param {Number} id\n * @param {Object} item\n * @param {Number} offsetMultiplier\n */\nexport const cloneBlockItem = ({\n    id,\n    item,\n    offsetMultiplier,\n}: CloneBlockItemArgs): AbsoluteBlockItem => {\n    const copiedPosition = item.position;\n    return {\n        ...item,\n        item: id,\n        position: {\n            x: copiedPosition.x + 20 * offsetMultiplier,\n            y: copiedPosition.y + 20 * offsetMultiplier,\n            w: copiedPosition.w,\n            h: copiedPosition.h,\n        },\n    };\n};\n\ninterface CloneLineArgs {\n    id: string;\n    item: ConnectedLineItem;\n    offsetMultiplier: number;\n}\n\n/**\n * clone an line, it assume the line is not connected\n * @param {Number} id\n * @param {Object} item\n * @param {Number} offsetMultiplier\n */\nexport const cloneLine = ({\n    id,\n    item,\n    offsetMultiplier,\n}: CloneLineArgs): ConnectedLineItem => {\n    const copiedPosition = item.position;\n    return {\n        ...item,\n        item: id,\n        position: {\n            from: {\n                x:\n                    (copiedPosition.from as Coordinate).x +\n                    20 * offsetMultiplier,\n                y:\n                    (copiedPosition.from as Coordinate).y +\n                    20 * offsetMultiplier,\n            },\n            to: {\n                x: (copiedPosition.to as Coordinate).x + 20 * offsetMultiplier,\n                y: (copiedPosition.to as Coordinate).y + 20 * offsetMultiplier,\n            },\n        },\n    };\n};\n\ninterface ShiftViewportOnZoomArgs {\n    scrollLeft: number;\n    scrollTop: number;\n    offsetWidth: number;\n    offsetHeight: number;\n    scaleRatio: number;\n}\n\n/**\n * Calculates new viewport position after a zoom event to keep the previous central point in the center of\n * the scaled canvas. See MR #2030 for algorithm details.\n * @param {Number} scrollLeft viewport left edge offset relative to canvas\n * @param {Number} scrollTop viewport top edge offset relative to canvas\n * @param {Number} offsetWidth viewport width\n * @param {Number} offsetHeight viewport height\n * @param {Number} scaleRatio new scale to old scale ratio\n * @returns {Object} object containing new scrollLeft and scrollTop values\n */\nexport const shiftViewportOnZoom = ({\n    scrollLeft,\n    scrollTop,\n    offsetWidth,\n    offsetHeight,\n    scaleRatio,\n}: ShiftViewportOnZoomArgs): {\n    scrollLeft: number;\n    scrollTop: number;\n} => {\n    const middleOffsetWidth = offsetWidth / 2;\n    const middleOffsetHeight = offsetHeight / 2;\n    return {\n        scrollLeft:\n            (scrollLeft + middleOffsetWidth) * scaleRatio - middleOffsetWidth,\n        scrollTop:\n            (scrollTop + middleOffsetHeight) * scaleRatio - middleOffsetHeight,\n    };\n};\n\n/**\n * return position relative to the canvas rect\n */\nexport const computeRelativePosition = (\n    e: {\n        clientX: number;\n        clientY: number;\n    },\n    canvasRef: unknown,\n    scale = 1\n): Coordinate => {\n    const pos = getClientPosition(e, scale);\n    const canvasDomNode = get(canvasRef, ['current']);\n    const rect = canvasDomNode && canvasDomNode.getBoundingClientRect();\n    if (pos && rect) {\n        return {\n            x: pos.x - rect.left / scale,\n            y: pos.y - rect.top / scale,\n        };\n    }\n    return pos;\n};\n\n/**\n * Scales a GridLayout by stretching the width of each item by the scale factor\n * @param {AbsoluteBlockItem[]} items items to scale\n * @param {Number} scale how much to scale\n */\nexport const scaleGridLayoutStructureByWidth = ({\n    layout,\n    scale = 1,\n}: {\n    layout: GridLayoutStructure;\n    scale?: number;\n}): AbsoluteBlockItem[] => {\n    if (scale === 1) {\n        return layout;\n    }\n\n    // Compute the edges of the existing layout. Since we're scaling\n    // just the X and width we only care about vertical edges.\n    const edges = getAllEdges(layout);\n    const verticalEdges = sortBy(\n        edges.filter((edge) => edge.orientation === 'vertical'),\n        ['edgeStart.x']\n    );\n\n    // Scale the vertical edges and than align the\n    // left and right items to the scaled edge position\n    const newLayout: AbsoluteBlockItem[] = [];\n    verticalEdges.forEach((edge) => {\n        const {\n            visualizations,\n            edgeStart: { x },\n        } = edge;\n        const scaledEdgeX = Math.round(x * scale);\n        const left = visualizations.filter((viz) => viz.position.x < x);\n        const right = visualizations.filter((viz) => viz.position.x >= x);\n\n        // Update the Width of the layout items using the difference between the\n        // newly scaled edge and the existing x\n        left.forEach((layoutItem) => {\n            const newLayoutItem = newLayout.find(\n                ({ item: id }) => layoutItem.item === id\n            );\n\n            if (newLayoutItem) {\n                newLayoutItem.position.w =\n                    scaledEdgeX - newLayoutItem.position.x;\n            }\n        });\n\n        // Since we walk the edges from the left to the right we\n        // ALWAYS have to create the new layout item here but won't\n        // ever need to update it.\n        right.forEach((layoutItem) => {\n            newLayout.push({\n                ...layoutItem,\n                position: {\n                    ...layoutItem.position,\n                    x: scaledEdgeX,\n                },\n            });\n        });\n    });\n\n    return newLayout;\n};\n","module.exports = require(\"prop-types\");","module.exports = require(\"@splunk/themes\");","module.exports = require(\"@splunk/dashboard-utils/console\");","module.exports = require(\"@splunk/dashboard-utils/layout\");","module.exports = require(\"@splunk/dashboard-ui/customThemeVariables\");","module.exports = require(\"@splunk/themes/mixins\");","import {\n    DEFAULT_CANVAS_WIDTH,\n    DEFAULT_CANVAS_HEIGHT,\n} from '@splunk/dashboard-utils/layout';\nimport type {\n    AbsoluteLayoutOptions,\n    GridLayoutOptions,\n} from '@splunk/dashboard-types';\n\nexport const absoluteLayoutOptions: Required<\n    Pick<AbsoluteLayoutOptions, 'width' | 'height' | 'display'>\n> = {\n    width: DEFAULT_CANVAS_WIDTH,\n    height: DEFAULT_CANVAS_HEIGHT,\n    display: 'actual-size',\n};\n\nexport const gridLayoutOptions: Required<\n    Pick<GridLayoutOptions, 'width' | 'gutterSize'>\n> = {\n    width: DEFAULT_CANVAS_WIDTH,\n    gutterSize: 8,\n};\n","module.exports = require(\"lodash/get\");","import { uniqueId } from '@splunk/dashboard-utils/uniqueId';\nimport type {\n    AbsoluteBlockItem,\n    AbsolutePosition,\n    Coordinate,\n} from '@splunk/dashboard-types';\nimport {\n    EdgeItem,\n    VerticalBoundaries,\n    HorizontalBoundaries,\n    EdgeBoundaries,\n} from '../types';\n\nconst nextEdgeId = () => `edge_${uniqueId()}`;\n\n/**\n * generate edge id\n */\nconst getNextEdgeId = () => {\n    return nextEdgeId();\n};\n\ntype Intersections = Record<number, Record<number, AbsoluteBlockItem[]>>;\n\n/**\n * Returns a 2D array of every viz corner, indicating which visualizations touch which node(corner)\n * @param {Object} layoutStructure - Array of visualizations from definition\n * @returns {Object[][]} - {x: { y: [vizList] } }\n */\nconst getNodes = (\n    layoutStructure: AbsoluteBlockItem[]\n): Intersections | null => {\n    if (layoutStructure.length === 0) {\n        return null;\n    }\n\n    const nodes: Intersections = {};\n    layoutStructure.forEach((viz) => {\n        const { x, y, w, h } = viz.position;\n        const corners = [\n            { x, y },\n            { x: x + w, y },\n            { x, y: y + h },\n            { x: x + w, y: y + h },\n        ];\n        corners.forEach((corner) => {\n            if (nodes[corner.x] === undefined) {\n                nodes[corner.x] = {};\n            }\n            if (nodes[corner.x][corner.y] === undefined) {\n                nodes[corner.x][corner.y] = [];\n            }\n            nodes[corner.x][corner.y].push(viz);\n        });\n    });\n    return nodes;\n};\n\nconst isTopEdge = (edge: EdgeItem): boolean =>\n    edge.orientation === 'horizontal' && edge.edgeStart.y === 0;\n\nconst isBottomEdge = (edge: EdgeItem, canvasHeight: number) =>\n    edge.orientation === 'horizontal' && edge.edgeStart.y === canvasHeight;\n\nconst isLeftEdge = (edge: EdgeItem): boolean =>\n    edge.orientation === 'vertical' && edge.edgeStart.x === 0;\n\nconst isRightEdge = (edge: EdgeItem, canvasWidth: number): boolean =>\n    edge.orientation === 'vertical' && edge.edgeStart.x === canvasWidth;\n\n/**\n * Returns all the visualizations along a vertical edge\n * @param {Object} param - Param object needed to traverse along vertical edge\n * @param {num} param.x - x-coordinate of the edge\n * @param {num} param.yStart - y-coordinate of the edge start\n * @param {num} param.yEnd - y-coordinate of the edge end\n * @param {num} param.yCurrent - Current y in recursion\n * @param {num} param.nodes - The map of x,y coordinates to visualizations that touch that (x,y)\n * @param {num} param.visualizations - the list to add visualizations to, and then return\n * @returns {Set<Object>} - Set of unique visualizations along the edge\n */\nconst findVizAlongVerticalEdge = ({\n    x,\n    yStart,\n    yEnd,\n    yCurrent = yStart,\n    nodes,\n    visualizations = new Set(),\n}: {\n    x: number;\n    yStart: number;\n    yEnd: number;\n    yCurrent?: number;\n    nodes: Intersections;\n    visualizations?: Set<AbsoluteBlockItem>;\n}) => {\n    nodes[x][yCurrent].forEach((viz) => {\n        if (viz.position.y >= yStart && viz.position.y < yEnd) {\n            visualizations.add(viz);\n        }\n        if (viz.position.y >= yCurrent && yCurrent + viz.position.h <= yEnd) {\n            findVizAlongVerticalEdge({\n                x,\n                yStart,\n                yEnd,\n                yCurrent: yCurrent + viz.position.h,\n                nodes,\n                visualizations,\n            });\n        }\n    });\n    return visualizations;\n};\n\n/**\n * Returns all the visualizations along a horizontal edge\n * @param {Object} param - Param object needed to traverse along horizontal edge\n * @param {num} param.y - x-coordinate of the edge\n * @param {num} param.xStart - x-coordinate of the edge start\n * @param {num} param.xEnd - x-coordinate of the edge end\n * @param {num} param.xCurrent - Current x in recursion\n * @param {num} param.nodes - The map of x,y coordinates to visualizations that touch that (x,y)\n * @param {num} param.visualizations - the list to add visualizations to, and then return\n * @returns {Set<Object>} - Set of unique visualizations along the edge\n */\nconst findVizAlongHorizontalEdge = ({\n    y,\n    xStart,\n    xEnd,\n    xCurrent = xStart,\n    nodes,\n    visualizations = new Set(),\n}: {\n    y: number;\n    xStart: number;\n    xEnd: number;\n    xCurrent?: number;\n    nodes: Intersections;\n    visualizations?: Set<AbsoluteBlockItem>;\n}) => {\n    nodes[xCurrent][y].forEach((viz) => {\n        if (viz.position.x >= xStart && viz.position.x < xEnd) {\n            visualizations.add(viz);\n        }\n        if (viz.position.x >= xCurrent && xCurrent + viz.position.w <= xEnd) {\n            findVizAlongHorizontalEdge({\n                y,\n                xStart,\n                xEnd,\n                xCurrent: xCurrent + viz.position.w,\n                nodes,\n                visualizations,\n            });\n        }\n    });\n    return visualizations;\n};\n\n/**\n * Add edge to the provided list\n * @param {Object} param - Params containing edge info\n * @param {num} param.edges - the list to add the edge to\n * @param {Object} param.edgeStart - the start of the edge\n * @param {Object} param.edgeEnd - the end of the edge\n * @param {Object[][]} param.nodes - The map of x,y coordinates to visualizations that touch that (x,y)\n */\nconst addEdge = ({\n    edges,\n    edgeStart,\n    edgeEnd,\n    nodes,\n}: {\n    edges: EdgeItem[];\n    edgeStart: Coordinate;\n    edgeEnd: Coordinate;\n    nodes: Intersections;\n}): void => {\n    const orientation = edgeStart.y === edgeEnd.y ? 'horizontal' : 'vertical';\n\n    // Find all visualizations that are affected by this edge\n    const visualizations =\n        orientation === 'vertical'\n            ? findVizAlongVerticalEdge({\n                  x: edgeStart.x,\n                  yStart: edgeStart.y,\n                  yEnd: edgeEnd.y,\n                  nodes,\n              })\n            : findVizAlongHorizontalEdge({\n                  y: edgeStart.y,\n                  xStart: edgeStart.x,\n                  xEnd: edgeEnd.x,\n                  nodes,\n              });\n\n    edges.push({\n        item: getNextEdgeId(),\n        edgeStart,\n        edgeEnd,\n        visualizations: Array.from(visualizations),\n        orientation,\n    });\n};\n\n/**\n * If there is no incoming edge from the top, return true\n * @param {num} y - Current y position to compare against\n * @param {Object[]} visualizations - Array of visualizations attached to the node at (x, y). Length will be 1 to 4.\n * @returns {boolean}\n */\nconst shouldTraverseDown = (\n    y: number,\n    visualizations: AbsoluteBlockItem[]\n): boolean => {\n    return visualizations.every((viz) => viz.position.y >= y);\n};\n\n/**\n * If there is no incoming edge from the left, return true\n * @param {num} x - Current x position to compare against\n * @param {Object[]} visualizations - Array of visualizations attached to the node at (x, y). Length will be 1 to 4.\n * @returns {boolean}\n */\nconst shouldTraverseRight = (\n    x: number,\n    visualizations: AbsoluteBlockItem[]\n): boolean => {\n    return visualizations.every((viz) => viz.position.x >= x);\n};\n\n/**\n * Find the offset to the next node.\n * @param {Object} param - Param object to find offset to next node\n * @param {Number} param.x - The x co-ordinate of the current position to find offset from\n * @param {Number} param.y - The y co-ordinate of the current position to find offset from\n * @param {Object[]} param.visualizations - Array of visualizations attached to the node at (x, y). Length will be 1 to 4.\n * @param {Object} param.visualizations[].position - Position information of the visualization\n * @param {String} param.type - The type of co-ordinate. One of 'w' or 'h'.\n * @returns {number}\n */\nconst findOffset = ({\n    x,\n    y,\n    visualizations,\n    type,\n}: {\n    x: number;\n    y: number;\n    visualizations: AbsoluteBlockItem[];\n    type: 'w' | 'h';\n}): number => {\n    for (let i = 0; i < visualizations.length; i += 1) {\n        const { position } = visualizations[i];\n        if (position.y === y && position.x === x) {\n            return position[type];\n        }\n    }\n\n    // This for-loop is only for finding the bottom canvas edge and the right canvas edge\n    for (let i = 0; i < visualizations.length; i += 1) {\n        const { position } = visualizations[i];\n        if (type === 'w' && position.x === x) {\n            // horizontal canvas edge\n            return position.w;\n        }\n        if (type === 'h' && position.y === y) {\n            // vertical canvas edge\n            return position.h;\n        }\n    }\n\n    return 0;\n};\n\n/**\n * Traverse right along nodes, creating or extending edges\n * @param {Object} param - Param object to traverse right along layout\n * @param {Object[][]} param.nodes - An object that maps {x, y} coord to an array of visualizations. Indexed as nodes[x][y].\n * @param {Object[]} param.edges - The resulting array of edges that gets mutated\n * @param {Number} param.x - x coordinate of current node\n * @param {Number} param.y - y coordinate of current node\n * @param {Object} param.edgeStart - The { x, y } coordinates of start of edge\n * @param {Boolean} param.canTraverseDown - Used to prevent loops during indirect recursion\n */\nfunction traverseRight({\n    x,\n    y,\n    nodes,\n    edges,\n    edgeStart,\n    canTraverseDown = true,\n}: {\n    x: number;\n    y: number;\n    nodes: Intersections;\n    edges: EdgeItem[];\n    edgeStart: Coordinate;\n    canTraverseDown?: boolean;\n}) {\n    // Check if we should traverse down (if there is no incoming edge)\n    // canTraverseRight must be false to avoid endless loop\n    if (canTraverseDown && shouldTraverseDown(y, nodes[x][y])) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        traverseDown({\n            x,\n            y,\n            nodes,\n            edges,\n            edgeStart: { x, y }, // Start new edge when changing directions\n            canTraverseRight: false,\n        });\n    }\n\n    // Check if horizontal edge ends here\n    // 'w' signifies we want width offset returned as opposed to height\n    const offset = findOffset({ x, y, visualizations: nodes[x][y], type: 'w' });\n\n    // Case 1 for ending edge: can't go right anymore (hit a viz OR end of dashboard), create edge up to this point.\n    if (!offset) {\n        addEdge({ edges, edgeStart, edgeEnd: { x, y }, nodes });\n        return;\n    }\n\n    // Case 2 for ending edge: reached window, need to create edge and start new one to avoid merging across window\n    const isWindow = nodes[x][y].length === 4; // 4-way intersection\n    if (isWindow) {\n        addEdge({ edges, edgeStart, edgeEnd: { x, y }, nodes });\n        // Continue traversing right, starting with a new edge from current position\n        traverseRight({\n            x: x + offset,\n            y,\n            nodes,\n            edges,\n            edgeStart: { x, y },\n        });\n        return;\n    }\n\n    // Continue traversing right, merging the past edge with the next\n    traverseRight({\n        x: x + offset,\n        y,\n        nodes,\n        edges,\n        edgeStart,\n    });\n}\n\n/**\n * Traverse right along nodes, creating or extending edges\n * @param {Object} param - Param object to traverse down along layout\n * @param {Object[][]} param.nodes - An object that maps {x, y} coord to an array of visualizations. Indexed as nodes[x][y].\n * @param {Object[]} param.edges - The resulting array of edges that gets mutated\n * @param {Number} param.x - x coordinate of current node\n * @param {Number} param.y - y coordinate of current node\n * @param {Object} param.edgeStart - The { x, y } coordinates of start of edge\n * @param {Boolean} param.canTraverseRight - Used to prevent loops during indirect recursion\n */\nfunction traverseDown({\n    x,\n    y,\n    nodes,\n    edges,\n    edgeStart,\n    canTraverseRight = true,\n}: {\n    x: number;\n    y: number;\n    nodes: Intersections;\n    edges: EdgeItem[];\n    edgeStart: Coordinate;\n    canTraverseRight?: boolean;\n}) {\n    if (canTraverseRight && shouldTraverseRight(x, nodes[x][y])) {\n        traverseRight({\n            x,\n            y,\n            nodes,\n            edges,\n            edgeStart: { x, y }, // Start new edge when changing directions\n            canTraverseDown: false,\n        });\n    }\n\n    // Check if vertical edge ends here\n    const offset = findOffset({ x, y, visualizations: nodes[x][y], type: 'h' });\n\n    // Case 1 for ending edge: can't go down anymore (hit a viz OR end of dashboard), create edge up to this point.\n    if (!offset) {\n        addEdge({ edges, edgeStart, edgeEnd: { x, y }, nodes });\n        return;\n    }\n\n    // Case 2 for ending edge: reached window, need to create edge and start new one to avoid merging across window\n    const isWindow = nodes[x][y].length === 4;\n    if (isWindow) {\n        addEdge({ edges, edgeStart, edgeEnd: { x, y }, nodes });\n        // Start a new edge from current position\n        traverseDown({\n            x,\n            y: y + offset,\n            nodes,\n            edges,\n            edgeStart: { x, y },\n        });\n        return;\n    }\n\n    // Continue traversing, thus \"merging\" edges\n    traverseDown({\n        x,\n        y: y + offset,\n        nodes,\n        edges,\n        edgeStart,\n    });\n}\n\n/**\n * Compute the vertical edges for every canvas row - a row that spans the entire width of the canvas\n * @param {Object} param\n * @param {AbsoluteBlockItem[]} param.layout - Layout structure\n * @param {EdgeItem[]} param.edges - The resulting array of edges that gets mutated\n * @param {Number} param.canvasWidth - Canvas width\n */\nconst computeVerticalCanvasEdges = ({\n    edges,\n    canvasWidth,\n    layout,\n}: {\n    edges: EdgeItem[];\n    canvasWidth: number;\n    layout: AbsoluteBlockItem[];\n}): void => {\n    const nodes = getNodes(layout);\n    if (nodes == null) {\n        return;\n    }\n    // get all the horizontal edges that span the entire canvas width\n    const sortedRowEdges = edges\n        .filter(\n            (edge) =>\n                edge.orientation === 'horizontal' &&\n                edge.edgeStart.x === 0 &&\n                edge.edgeEnd.x === canvasWidth\n        )\n        .sort((a, b) => a.edgeStart.y - b.edgeStart.y);\n\n    /**\n     * iterate through the sorted horizontal edges to get their start and end coordinates\n     * vertical edges between canvas row A and canvas row B will span from edgeStartA to edgeStartB and edgeEndA to edgeEndB\n     */\n    for (let i = 0; i < sortedRowEdges.length - 1; i += 1) {\n        const { edgeStart: edgeStartA, edgeEnd: edgeEndA } = sortedRowEdges[i];\n        const { edgeStart: edgeStartB, edgeEnd: edgeEndB } = sortedRowEdges[\n            i + 1\n        ];\n        addEdge({\n            edges,\n            edgeStart: edgeStartA,\n            edgeEnd: edgeStartB,\n            nodes,\n        });\n        addEdge({\n            edges,\n            edgeStart: edgeEndA,\n            edgeEnd: edgeEndB,\n            nodes,\n        });\n    }\n};\n\n/**\n * Gets all the edges given a layout of AbsoluteBlockItems\n * @param {AbsoluteBlockItem[]} layout - Array of AbsoluteBlockItems\n * @returns {EdgeItem[]} - Array of computed edges\n */\nexport const getAllEdges = (layout: AbsoluteBlockItem[]): EdgeItem[] => {\n    const edges: EdgeItem[] = [];\n    const nodes = getNodes(layout);\n\n    if (nodes === null || nodes[0] === undefined || nodes[0][0] === undefined) {\n        // When no visualizations in the layout structure\n        // OR when there is no visualization at (0,0), which this algorithm assumes\n        return [];\n    }\n    // run the algorithm\n    traverseRight({\n        x: 0,\n        y: 0,\n        nodes,\n        edges,\n        edgeStart: { x: 0, y: 0 },\n    });\n\n    return edges;\n};\n\n/**\n * Compute edges given a valid layout, canvasHeight, and canvasWidth\n * @param {Object} param - Param object containing layout, canvasHeight, canvasWidth\n * @param {Object[]} param.layout - Array of visualizations from the dashboard layout definition\n * @param {Number} param.canvasHeight - Canvas height\n * @param {Number} param.canvasWidth - Canvas width\n * @returns {Object[]} - Array of computed edges\n */\nexport const computeEdges = ({\n    layout,\n    canvasHeight,\n    canvasWidth,\n}: {\n    layout?: AbsoluteBlockItem[];\n    canvasHeight: number;\n    canvasWidth: number;\n}): EdgeItem[] => {\n    if (layout === undefined) {\n        return [];\n    }\n\n    let edges = getAllEdges(layout);\n\n    // remove the computed left and right vertical canvas edges as they span the entire height of the canvas\n    edges = edges.filter((edge) => {\n        return !(isLeftEdge(edge) || isRightEdge(edge, canvasWidth));\n    });\n\n    // recompute the vertical canvas edges for each canvas row where the row spans the entire width of the canvas\n    computeVerticalCanvasEdges({ edges, layout, canvasWidth });\n\n    // Additionally, the top and bottom edge are there, but set to hidden\n    edges = edges.map((edge) => {\n        let isCanvasEdge = false;\n        if (\n            isTopEdge(edge) ||\n            isRightEdge(edge, canvasWidth) ||\n            isBottomEdge(edge, canvasHeight) ||\n            isLeftEdge(edge)\n        ) {\n            isCanvasEdge = true;\n        }\n        return { ...edge, isCanvasEdge };\n    });\n\n    return edges;\n};\n\n/**\n * Format edge according to a given padding and edge thickness\n * @param {Object} param - Param object containing edge, padding, and edgeThickness\n * @param {Object} param.edge - Edge object\n * @param {Number} param.padding - Layout padding\n * @param {Number} param.edgeThickness - Thickness of edge\n * @returns {Object} - Returns formatted edge object\n */\nexport const formatEdge = ({\n    edge,\n    padding = 0,\n    edgeThickness = 0,\n}: {\n    edge: EdgeItem;\n    padding?: number;\n    edgeThickness?: number;\n}): EdgeItem => {\n    // Formatted edges are centered between visualizations and respect the padding (gutter-size) between them\n    const formattedEdgeStart = { ...edge.edgeStart };\n    const formattedEdgeEnd = { ...edge.edgeEnd };\n    if (edge.orientation === 'horizontal') {\n        formattedEdgeStart.x += padding;\n        formattedEdgeStart.y -= edgeThickness / 2;\n        formattedEdgeEnd.x -= padding;\n        formattedEdgeEnd.y -= edgeThickness / 2;\n    } else {\n        formattedEdgeStart.y += padding;\n        formattedEdgeStart.x -= edgeThickness / 2;\n        formattedEdgeEnd.y -= padding;\n        formattedEdgeEnd.x -= edgeThickness / 2;\n    }\n\n    return {\n        ...edge,\n        edgeStart: formattedEdgeStart,\n        edgeEnd: formattedEdgeEnd,\n    };\n};\n\n/**\n * Format visualization according to a given padding\n * @param {Object} param - Param object containing item and padding\n * @param {Object} param.item - Visualization object\n * @param {Number} param.padding - Layout padding\n * @returns {AbsoluteBlockItem} - Returns formatted edge object\n */\nexport const applyVizPadding = ({\n    item,\n    padding = 0,\n}: {\n    item: AbsoluteBlockItem;\n    padding?: number;\n}): AbsoluteBlockItem => {\n    const { x, y, w, h } = item.position;\n    return {\n        ...item,\n        position: {\n            x: x + padding,\n            y: y + padding,\n            w: w - 2 * padding,\n            h: h - 2 * padding,\n        },\n    };\n};\n\n/**\n * Determines Upper and Lower boundaries of an edge given its visualizations around it\n * @param {Object[]} visualizations - The visualizations surrounding the edge\n * @param {Number} y - The y position of the selected edge\n * @param {Number} minHeight - minimum Item Height Value\n * @param {Boolean} isFullWidthEdge - If the edge we are getting boundaries of is the size of canvas width\n * @returns {Object} - returns the boundaries in an object\n */\nexport const getVerticalBoundaries = ({\n    visualizations,\n    y,\n    minHeight,\n    isFullWidthEdge = false,\n}: {\n    visualizations: AbsoluteBlockItem[];\n    y: number;\n    minHeight: number;\n    isFullWidthEdge?: boolean;\n}): VerticalBoundaries => {\n    const boundaries = {\n        upperBoundary: Number.NEGATIVE_INFINITY,\n        lowerBoundary: Number.POSITIVE_INFINITY,\n    };\n\n    const comparePosition = (position: AbsolutePosition) => {\n        // If viz is below of the edge\n        // When the edge is a full width edge, there is no lower boundary\n        //  since dragging down increases canvas size\n        if (position.y >= y && !isFullWidthEdge) {\n            boundaries.lowerBoundary = Math.min(\n                boundaries.lowerBoundary,\n                position.y + position.h - minHeight\n            );\n        }\n        // If viz is above the edge\n        if (position.y < y) {\n            boundaries.upperBoundary = Math.max(\n                boundaries.upperBoundary,\n                position.y + minHeight\n            );\n        }\n    };\n\n    visualizations.forEach((viz) => comparePosition(viz.position));\n    return boundaries;\n};\n\n/**\n * Determines Left and Right boundaries of an edge given its visualizations around it\n * @param {Object[]} visualizations - The visualizations surrounding the edge\n * @param {Number} x - The x position of the selected edge\n * @param {Number} minWidth - minimum Item Width Value\n * @returns {Object} - returns the boundaries in an object\n */\nexport const getHorizontalBoundaries = ({\n    visualizations,\n    x,\n    minWidth,\n}: {\n    visualizations: AbsoluteBlockItem[];\n    x: number;\n    minWidth: number;\n}): HorizontalBoundaries => {\n    const boundaries = {\n        rightBoundary: Number.POSITIVE_INFINITY,\n        leftBoundary: Number.NEGATIVE_INFINITY,\n    };\n\n    const comparePosition = (position: AbsolutePosition) => {\n        if (position.x >= x) {\n            // If viz is to the right of the edge\n            boundaries.rightBoundary = Math.min(\n                boundaries.rightBoundary,\n                position.x + position.w - minWidth\n            );\n        }\n        if (position.x < x) {\n            // If viz is to the left of the edge\n            boundaries.leftBoundary = Math.max(\n                boundaries.leftBoundary,\n                position.x + minWidth\n            );\n        }\n    };\n\n    visualizations.forEach((viz) => comparePosition(viz.position));\n    return boundaries;\n};\n\n/**\n * Determines the next edge position for movement up and down of a horizontal edge\n * @param {Object} edge - the current moving edge\n * @param {Number} offset - offset to move edge\n * @param {Object} options.edgeBoundaries Object with lower/upper boundaries\n * @returns {Object} - returns edge with updated position\n */\nexport const moveHorizontalEdge = ({\n    edge,\n    offset,\n    edgeBoundaries: { upperBoundary, lowerBoundary },\n}: {\n    edge: EdgeItem;\n    offset: number;\n    edgeBoundaries: VerticalBoundaries;\n}): EdgeItem => {\n    // Update edge to either the offset value,\n    // or the defined maximum/minimum based on min viz height/width\n    const updatedY =\n        offset < 0\n            ? Math.max(upperBoundary, edge.edgeStart.y + offset)\n            : Math.min(lowerBoundary, edge.edgeStart.y + offset);\n\n    return {\n        ...edge,\n        edgeStart: {\n            x: edge.edgeStart.x,\n            y: updatedY,\n        },\n        edgeEnd: {\n            x: edge.edgeEnd.x,\n            y: updatedY,\n        },\n    };\n};\n\n/**\n * Determines the next edge position for movement left and right of a vertical edge\n * @param {Object} edge - the current moving edge\n * @param {Number} offset - offset to move edge\n * @param {Object} options.edgeBoundaries Object with left/right boundaries\n * @returns {Object} - returns edge with updated position\n */\nexport const moveVerticalEdge = ({\n    edge,\n    offset,\n    edgeBoundaries: { leftBoundary, rightBoundary },\n}: {\n    edge: EdgeItem;\n    offset: number;\n    edgeBoundaries: HorizontalBoundaries;\n}): EdgeItem => {\n    const updatedX =\n        offset < 0\n            ? Math.max(leftBoundary, edge.edgeStart.x + offset)\n            : Math.min(rightBoundary, edge.edgeStart.x + offset);\n\n    return {\n        ...edge,\n        edgeStart: {\n            x: updatedX,\n            y: edge.edgeStart.y,\n        },\n        edgeEnd: {\n            x: updatedX,\n            y: edge.edgeEnd.y,\n        },\n    };\n};\n\n/**\n * find edges that the given edge should snap to, according to the snap range\n * @param {Object} options\n * @param {Object} options.edge the edge being dragged, edge has the structure\n * @param {array}  options.edges all the edges that are parallel to target edge and within the boundary\n * @param {Number} options.snapRange the range within which that triggers snapping\n * @returns {Object} updatedEdge and snappableEdges\n */\nexport const findSnappableEdges = ({\n    edge,\n    edges,\n    snapRange,\n}: {\n    edge: EdgeItem;\n    edges: EdgeItem[];\n    snapRange: number;\n}): { updatedEdge: EdgeItem; snappableEdges: EdgeItem[] } => {\n    const coordinate = edge.orientation === 'horizontal' ? 'y' : 'x';\n\n    const snappableEdges = edges.reduce<EdgeItem[]>(\n        (currentSnappableEdges, nextEdge) => {\n            const nextEdgeDistance = Math.abs(\n                nextEdge.edgeStart[coordinate] - edge.edgeStart[coordinate]\n            );\n\n            // nextEdge is in range\n            if (nextEdgeDistance <= snapRange) {\n                if (currentSnappableEdges.length === 0) {\n                    return [nextEdge];\n                }\n\n                const lastEdge =\n                    currentSnappableEdges[currentSnappableEdges.length - 1];\n                const lastEdgeDistance = Math.abs(\n                    lastEdge.edgeStart[coordinate] - edge.edgeStart[coordinate]\n                );\n\n                // find new closest snappable edge\n                if (nextEdgeDistance < lastEdgeDistance) {\n                    return [nextEdge];\n                }\n\n                // it is possible there are several snappable edges having the same x or y value\n                if (nextEdgeDistance === lastEdgeDistance) {\n                    return [...currentSnappableEdges, nextEdge];\n                }\n            }\n\n            // nextEdge is out of range\n            return [...currentSnappableEdges];\n        },\n        []\n    );\n\n    // if no snappable edge, snap to itself\n    const firstSnappableEdge =\n        snappableEdges.length > 0 ? snappableEdges[0] : edge;\n\n    return {\n        updatedEdge: {\n            ...edge,\n            edgeStart: {\n                ...edge.edgeStart,\n                [coordinate]: firstSnappableEdge.edgeStart[coordinate],\n            },\n            edgeEnd: {\n                ...edge.edgeEnd,\n                [coordinate]: firstSnappableEdge.edgeEnd[coordinate],\n            },\n        },\n        snappableEdges,\n    };\n};\n\n/**\n * Find all the edges that could be snapped to, given the limitations enforced by the surrounding visualizations.\n * @param {Object} options\n * @param {Object} options.edge the edge being dragged\n * @param {array}  options.edges all the edges on canvas\n * @param {Object} options.edgeBoundaries Object with either lower/upper or left/right boundaries\n * @returns {array} the edges that are within the boundary of the edge being moved\n */\nexport const findEdgesInBoundary = ({\n    edge,\n    edges,\n    edgeBoundaries,\n}: {\n    edge: EdgeItem;\n    edges: EdgeItem[];\n    edgeBoundaries: EdgeBoundaries;\n}): EdgeItem[] => {\n    const { orientation } = edge;\n\n    if (orientation === 'horizontal') {\n        return edges.filter(\n            (e) =>\n                e.orientation === 'horizontal' &&\n                e.edgeStart.y >=\n                    (edgeBoundaries as VerticalBoundaries).upperBoundary &&\n                e.edgeStart.y <=\n                    (edgeBoundaries as VerticalBoundaries).lowerBoundary &&\n                e !== edge\n        );\n    }\n    if (orientation === 'vertical') {\n        return edges.filter(\n            (e) =>\n                e.orientation === 'vertical' &&\n                e.edgeStart.x >=\n                    (edgeBoundaries as HorizontalBoundaries).leftBoundary &&\n                e.edgeStart.x <=\n                    (edgeBoundaries as HorizontalBoundaries).rightBoundary &&\n                e !== edge\n        );\n    }\n    // can't match any edge because the orientation is invalid, this shouldn't happen.\n    return [];\n};\n","module.exports = require(\"@splunk/dashboard-utils/uniqueId\");","module.exports = require(\"@splunk/dashboard-context\");","import console from '@splunk/dashboard-utils/console';\nimport isEmpty from 'lodash/isEmpty';\nimport type { BackgroundImageOptions } from '@splunk/dashboard-types';\n\n// /**\n//  * Check whether image src url is valid or not\n//  * @method validImageSrc\n//  * @param {String} src\n//  */\n// export const validImageSrc = src => {\n//     const img = new Image();\n//     img.onerror = () => {\n//         console.error(`Background image url ${src} is invalid`);\n//     };\n//     img.src = src\n// };\n\n/**\n * check if an image is from Image Registry\n * @param {*} src\n */\nexport const isFromImageRegistry = (src = ''): boolean => {\n    const [type] = src.split('://');\n    return (\n        src.indexOf('://') > -1 &&\n        type !== 'http' &&\n        type !== 'https' &&\n        type !== 'ftp' &&\n        type !== 'file'\n    );\n};\n\ninterface ValidImagePosArgs {\n    x?: number;\n    y?: number;\n    canvasWidth: number;\n    canvasHeight: number;\n}\n\n/**\n * Check whether image position is valid or not\n * @method validImagePos\n * @param {Number} x\n * @param {Number} y\n * @param {Number} canvasWidth\n * @param {Number} canvasHeight\n * @returns {Boolean}\n */\nexport const validImagePos = ({\n    x,\n    y,\n    canvasWidth,\n    canvasHeight,\n}: ValidImagePosArgs): boolean =>\n    !!(\n        x != null &&\n        Number.isInteger(x) &&\n        y != null &&\n        Number.isInteger(y) &&\n        x <= canvasWidth &&\n        y <= canvasHeight &&\n        x >= 0 &&\n        y >= 0\n    );\n\n/**\n * Check whether image width and height is valid or not\n * @method validImageWidthHeight\n * @param {Number} imageWidth //Defaulted to 1 because w can't be undefined\n * @param {Number} imageHeight //Defaulted to 1 because h can't be undefined\n * @param {Number} canvasWidth\n * @param {Number} canvasHeight\n * @returns {Boolean}\n */\nexport const validImageWidthHeight = (\n    imageWidth = 1,\n    imageHeight = 1\n): boolean =>\n    !!(\n        Number.isInteger(imageWidth) &&\n        Number.isInteger(imageHeight) &&\n        imageWidth > 0 &&\n        imageHeight > 0\n    );\n\n/**\n * Check whether image size type is valid or not (cover/auto/contain/undefined)\n * @method invalidImageSizeType\n * @param {String} sizeType\n * @returns {Boolean}\n */\nexport const invalidImageSizeType = (sizeType: string): boolean =>\n    !!(\n        sizeType !== 'cover' &&\n        sizeType !== 'contain' &&\n        sizeType !== 'auto' &&\n        sizeType !== undefined\n    );\n\n/**\n * Return the original width and height of a valid image\n * @method getImageWidthHeight\n * @param {String} imgSrc\n * @returns {Number. Number} Image width and height\n */\nexport const getImageDimension = (\n    imgSrc: string\n): { width: number; height: number } => {\n    const img = new Image();\n    try {\n        img.src = imgSrc;\n        img.style.position = 'absolute';\n        img.style.left = '-9999'; // Image width must not exceed 9999 pixels\n        img.style.visibility = 'hidden';\n        document.body.appendChild(img);\n        const height = img.naturalHeight;\n        const width = img.naturalWidth;\n        return { width, height };\n    } catch (ex) {\n        return { width: 0, height: 0 };\n    } finally {\n        if (document.body.contains(img)) {\n            document.body.removeChild(img); // Removes the image from the DOM\n        }\n    }\n};\n\ninterface ValidateBackgroundImageArgs {\n    backgroundImage: BackgroundImageOptions;\n    canvasWidth: number;\n    canvasHeight: number;\n}\n\n/**\n * Check whether background image options are valid or not. Default to x:0, y:0, w:0, h:0 and sizeType:'auto'\n * @method validateBackgroundImage\n * @param {Object} backgroundImage\n * @param {String} backgroundImage.src\n * @param {Number} backgroundImage.x\n * @param {Number} backgroundImage.y\n * @param {Number} backgroundImage.w\n * @param {Number} backgroundImage.h\n * @param {String} backgroundImage.sizeType\n * @param {Number} width\n * @param {Number} height\n * @returns {Object}\n */\nexport const validateBackgroundImage = ({\n    backgroundImage = {},\n    canvasWidth,\n    canvasHeight,\n}: ValidateBackgroundImageArgs): BackgroundImageOptions => {\n    const { src } = backgroundImage;\n    let { x, y, w, h, sizeType } = backgroundImage;\n    if (isEmpty(backgroundImage)) {\n        return { src, x, y, w, h, sizeType };\n    }\n    if (src == null) {\n        return { src, x, y, w, h, sizeType };\n    }\n    // validImageSrc(src); make no sense to validate but not display errors.\n    if (!validImagePos({ x, y, canvasWidth, canvasHeight })) {\n        console.warn(\n            `Invalid background image position, x: ${x} y: ${y}. Defaulting to x: 0, y: 0`\n        );\n        x = 0;\n        y = 0;\n    }\n\n    if (\n        w == null &&\n        h == null &&\n        (sizeType == null || invalidImageSizeType(sizeType))\n    ) {\n        console.warn(\n            `Invalid background image sizeType, ${sizeType}. Defaulting to contain`\n        );\n        sizeType = 'contain';\n    } else if (\n        (sizeType == null || invalidImageSizeType(sizeType)) &&\n        ((w != null && h == null) ||\n            (w == null && h != null) ||\n            !validImageWidthHeight(w, h))\n    ) {\n        console.warn(\n            `Invalid background image width and height, w: ${w} h: ${h}. Defaulting to image original size`\n        );\n        w = w || 0;\n        h = h || 0;\n    }\n    return { src, x, y, w, h, sizeType };\n};\n","module.exports = require(\"lodash/noop\");","module.exports = require(\"lodash/findLast\");","module.exports = require(\"lodash/isNumber\");","module.exports = require(\"lodash/reduce\");","module.exports = require(\"lodash/pullAt\");","module.exports = require(\"lodash/cloneDeep\");","module.exports = require(\"lodash/sortBy\");","import type {\n    AbsoluteLayoutStructure,\n    SelectedItem,\n    AbsoluteBlockItem,\n    Port,\n    Coordinate,\n} from '@splunk/dashboard-types';\nimport type { LayoutStructureState } from '../types';\n\ninterface FindSelectedBlockItemsArgs {\n    layoutStructure: AbsoluteLayoutStructure;\n    selectedItems: SelectedItem[];\n}\n\nexport const findSelectedBlockItems = ({\n    layoutStructure,\n    selectedItems,\n}: FindSelectedBlockItemsArgs): AbsoluteBlockItem[] =>\n    layoutStructure.filter(\n        ({ item, type }) =>\n            selectedItems.findIndex(\n                ({ id }) => item === id && (type === 'block' || !type)\n            ) >= 0\n    ) as AbsoluteBlockItem[];\n\ninterface GetAllBlockItemsArgs {\n    layoutStructure: AbsoluteLayoutStructure;\n    layoutStructureState?: LayoutStructureState;\n}\n\nexport const getAllBlockItems = ({\n    layoutStructure,\n    layoutStructureState = {},\n}: GetAllBlockItemsArgs): AbsoluteBlockItem[] => {\n    return layoutStructure\n        .map((item) => layoutStructureState[item.item] ?? item)\n        .filter(({ type }) => type === 'block' || !type) as AbsoluteBlockItem[];\n};\n\n/**\n * compute port position for a given block item\n * @param {Object} blockItem\n * @param {String} port\n */\nexport const computePortPosition = (\n    blockItem: AbsoluteBlockItem,\n    port: Port\n): Coordinate => {\n    const blockPosition = blockItem.position;\n    switch (port) {\n        case 'n':\n            return {\n                x: Math.round(blockPosition.x + blockPosition.w / 2),\n                y: blockPosition.y,\n            };\n        case 'w':\n            return {\n                x: blockPosition.x,\n                y: Math.round(blockPosition.y + blockPosition.h / 2),\n            };\n        case 'e':\n            return {\n                x: blockPosition.x + blockPosition.w,\n                y: Math.round(blockPosition.y + blockPosition.h / 2),\n            };\n        case 's':\n        default:\n            return {\n                x: Math.round(blockPosition.x + blockPosition.w / 2),\n                y: blockPosition.y + blockPosition.h,\n            };\n    }\n};\n\ninterface GetBlockItemArgs {\n    layoutStructure: AbsoluteLayoutStructure;\n    id: string;\n}\n\nexport const getBlockItem = ({\n    layoutStructure,\n    id,\n}: GetBlockItemArgs): AbsoluteBlockItem => {\n    const blockItem = layoutStructure.find(({ item }) => item === id);\n\n    if (!blockItem || blockItem.type === 'line') {\n        throw Error(`${id} refers to an invalid block item`);\n    }\n\n    return blockItem;\n};\n","module.exports = require(\"lodash/isEmpty\");","import type {\n    AbsoluteLayoutStructure,\n    ConnectedLineItem,\n    Coordinate,\n    ConnectedLinePosition,\n    SelectedItem,\n} from '@splunk/dashboard-types';\nimport type { Offset, LineDirection, LayoutStructureState } from '../types';\nimport {\n    updateLineAbsPosition,\n    isLineConnected,\n    disconnectLine,\n} from './layoutUtils';\nimport { computePortPosition, getBlockItem } from './blockUtils';\n\ninterface ComputeLineAbsPositionArgs {\n    layoutStructure: AbsoluteLayoutStructure;\n    position: ConnectedLinePosition;\n}\n\nexport const computeLineAbsPosition = ({\n    layoutStructure,\n    position,\n}: ComputeLineAbsPositionArgs): {\n    from: Coordinate;\n    to: Coordinate;\n} => {\n    let { from, to } = position;\n\n    if ('item' in from && 'port' in from) {\n        const blockItem = getBlockItem({ layoutStructure, id: from.item });\n        from = computePortPosition(blockItem, from.port);\n    }\n    if ('item' in to && 'port' in to) {\n        const blockItem = getBlockItem({ layoutStructure, id: to.item });\n        to = computePortPosition(blockItem, to.port);\n    }\n    return {\n        from,\n        to,\n    };\n};\n\ninterface FindSelectedLineItemsArgs {\n    layoutStructure: AbsoluteLayoutStructure;\n    selectedItems: SelectedItem[];\n}\n\nexport const findSelectedLineItems = ({\n    layoutStructure,\n    selectedItems,\n}: FindSelectedLineItemsArgs): ConnectedLineItem[] =>\n    layoutStructure.filter(\n        ({ item, type }) =>\n            selectedItems.findIndex(\n                ({ id }) => item === id && type === 'line'\n            ) >= 0\n    ) as ConnectedLineItem[];\n\nexport interface HandleSingleLineMoveArgs {\n    offset: Offset;\n    lineId: string;\n    layoutStructure: AbsoluteLayoutStructure;\n}\n\nexport const handleSingleLineMove = ({\n    lineId,\n    offset,\n    layoutStructure,\n}: HandleSingleLineMoveArgs): ConnectedLineItem => {\n    let line = layoutStructure.find(\n        (item) => item.item === lineId\n    ) as ConnectedLineItem;\n\n    const linePosition = computeLineAbsPosition({\n        layoutStructure,\n        position: line.position,\n    });\n\n    if (isLineConnected({ line, dir: 'from' })) {\n        line = disconnectLine({\n            line,\n            dir: 'from',\n            absPos: linePosition.from,\n        });\n    }\n\n    if (isLineConnected({ line, dir: 'to' })) {\n        line = disconnectLine({\n            line,\n            dir: 'to',\n            absPos: linePosition.to,\n        });\n    }\n\n    line = updateLineAbsPosition({\n        line,\n        dir: 'from',\n        offset,\n    });\n\n    line = updateLineAbsPosition({\n        line,\n        dir: 'to',\n        offset,\n    });\n\n    return line;\n};\n\nexport interface HandleSingleLineDragStartArgs {\n    lineId: string;\n    layoutStructure: AbsoluteLayoutStructure;\n    lineDir: LineDirection;\n}\n\nexport const handleSingleLineDragStart = ({\n    lineId,\n    layoutStructure,\n    lineDir,\n}: HandleSingleLineDragStartArgs): ConnectedLineItem => {\n    let line = layoutStructure.find(\n        (item) => item.item === lineId\n    ) as ConnectedLineItem;\n\n    const linePosition = computeLineAbsPosition({\n        layoutStructure,\n        position: line.position,\n    });\n\n    if (\n        isLineConnected({\n            line,\n            dir: lineDir,\n        })\n    ) {\n        line = disconnectLine({\n            line,\n            dir: lineDir,\n            absPos: linePosition[lineDir],\n        });\n    }\n\n    return line;\n};\n\ninterface GetAllLineItemsArgs {\n    layoutStructure: AbsoluteLayoutStructure;\n    layoutStructureState?: LayoutStructureState;\n}\n\nexport const getAllLineItems = ({\n    layoutStructure,\n    layoutStructureState = {},\n}: GetAllLineItemsArgs): ConnectedLineItem[] => {\n    return layoutStructure\n        .map((item) => layoutStructureState[item.item] ?? item)\n        .filter(({ type }) => type === 'line') as ConnectedLineItem[];\n};\n","import React, { forwardRef } from 'react';\nimport styled from 'styled-components';\nimport { reset } from '@splunk/themes/mixins';\nimport { variables, pick } from '@splunk/themes';\nimport { toPx, toDimension } from '@splunk/dashboard-utils/style';\nimport { sanitizeColor } from '@splunk/dashboard-ui/utils/colorUtils';\nimport { customThemeVariables } from '@splunk/dashboard-ui/customThemeVariables';\nimport { getImageDimension } from '../utils/imageUtils';\nimport { CanvasProps } from '../types';\nimport { useBackgroundImage } from '../hooks/useBackgroundImage';\n\nconst GRID_LINE_OPACITY = 0.1;\n\ninterface BackgroundProps {\n    width: number;\n    height: number;\n    scale?: number;\n    bgColor?: string | null;\n    bgImageSrc?: string;\n    bgImageWidth?: number;\n    bgImageHeight?: number;\n    bgImageSizeType?: string;\n    bgImagePositionX?: number;\n    bgImagePositionY?: number;\n}\n\ninterface GridLinesProps {\n    width: number;\n    height: number;\n    gridWidth: number;\n    gridHeight: number;\n    gridPadding: number;\n    gridLineWidth: number;\n    gridLineColor?: string;\n    gridLineOpacity?: number;\n}\n\ninterface CanvasContainerProps {\n    width: number;\n    height: number;\n    userSelect: boolean;\n    showOverflowContent: boolean;\n}\n\n/**\n * logic for background image size css.\n * @param {BackgroundProps} props\n */\nconst toBackgroundImageSize = (props: BackgroundProps) => {\n    const { width, height } = getImageDimension(props.bgImageSrc ?? '');\n    if (props.bgImageWidth && props.bgImageHeight) {\n        return `${toPx(props.bgImageWidth)} ${toPx(props.bgImageHeight)}`;\n    }\n    if (props.bgImageWidth || props.bgImageHeight) {\n        return `${toPx(props.bgImageWidth || width)} ${toPx(\n            props.bgImageHeight || height\n        )}`;\n    }\n    if (props.bgImageSizeType) {\n        return props.bgImageSizeType;\n    }\n    return 'contain';\n};\n\n/**\n * make sure to only include image related css when backgroundImageSrc is specified.\n * @param {BackgroundProps} props\n */\nconst toBackgroundImage = (props: BackgroundProps) => {\n    if (props.bgImageSrc) {\n        return `\n            background-repeat: no-repeat;\n            background-image: url(\"${props.bgImageSrc}\");\n            background-size: ${toBackgroundImageSize(props)};\n            background-position:\n                ${toPx(props.bgImagePositionX)} ${toPx(props.bgImagePositionY)};\n        `;\n    }\n    return '';\n};\n\nconst toScale = (scale?: number) => {\n    if (scale) {\n        return `\n            transform: scale(${scale});\n            transform-origin: 0 0;\n        `;\n    }\n    return '';\n};\n\nconst CanvasContainer = styled.div<CanvasContainerProps>`\n    ${reset('block')};\n    ${(prop) => toDimension({ width: prop.width, height: prop.height })};\n    overflow: ${(prop) => (prop.showOverflowContent ? 'visible' : 'hidden')};\n    user-select: ${(prop) => (prop.userSelect ? 'text' : 'none')};\n    position: relative;\n`;\n\n/**\n * A layer that renders canvas with background color/image\n */\nconst Background = styled.div<BackgroundProps>`\n    ${reset('inline-block')};\n    ${(prop) => toDimension({ width: prop.width, height: prop.height })};\n    position: relative;\n    background: ${(prop) =>\n        prop.bgColor ||\n        // NOTE: this needs to match packages/dashboard-editors/src/layouts/AbsoluteLayoutEditor.jsx\n        customThemeVariables.dashboardBackgroundColor};\n    ${(prop) => toBackgroundImage(prop)};\n    ${(prop) => toScale(prop.scale)};\n`;\n\n/**\n * A layer that renders border\n */\nconst Border = styled.div<{ width: number; height: number }>`\n    position: absolute;\n    box-sizing: border-box;\n    border: 2px dashed\n        ${pick({\n            enterprise: {\n                light: variables.gray80,\n                dark: variables.gray30,\n            },\n            prisma: variables.interactiveColorBorder,\n        })};\n    left: 0px;\n    top: 0px;\n    right: 0px;\n    bottom: 0px;\n    ${(prop) => toDimension({ width: prop.width, height: prop.height })};\n`;\n\nconst getGridLineColor = (props: GridLinesProps) =>\n    props.gridLineColor ||\n    pick({\n        light: '#D8D8D8',\n        dark: '#9B9B9B',\n    });\n\n/**\n * A layer that renders grid\n */\nconst GridLines = styled.div<GridLinesProps>`\n    position: absolute;\n    box-sizing: border-box;\n    left: 0px;\n    top: 0px;\n    right: 0px;\n    bottom: 0px;\n    opacity: ${(prop) => prop.gridLineOpacity || GRID_LINE_OPACITY};\n    ${(prop) => toDimension({ width: prop.width, height: prop.height })};\n    background-size: ${(prop) => prop.gridWidth + prop.gridLineWidth}px\n        ${(prop) => prop.gridHeight + prop.gridLineWidth}px;\n    background-image: repeating-linear-gradient(\n            0deg,\n            ${getGridLineColor},\n            ${getGridLineColor} ${(prop) => toPx(prop.gridLineWidth)},\n            transparent ${(prop) => prop.gridLineWidth}px,\n            transparent ${(prop) => prop.gridHeight + prop.gridLineWidth}px\n        ),\n        repeating-linear-gradient(\n            -90deg,\n            ${getGridLineColor},\n            ${getGridLineColor} ${(prop) => toPx(prop.gridLineWidth)},\n            transparent ${(prop) => prop.gridLineWidth}px,\n            transparent ${(prop) => prop.gridWidth + prop.gridLineWidth}px\n        );\n`;\n\n/**\n * Canvas is a component that render background for a layout.\n * All visualizations will be displayed on top of a canvas\n */\nconst Canvas = (\n    {\n        width,\n        height,\n        scale,\n        backgroundColor: unsanitizedBgColor = '',\n        backgroundImageSrc,\n        backgroundImageSizeType,\n        backgroundImageWidth,\n        backgroundImageHeight,\n        backgroundImagePositionX,\n        backgroundImagePositionY,\n        gridLineOpacity,\n        children,\n        showOverflowContent = false,\n        userSelect = false,\n        showGrid = false,\n        gridPadding = 0,\n        gridLineWidth = 1,\n        gridLineColor,\n        gridWidth = 9,\n        gridHeight = 9,\n        showBorder = false,\n        cssScaling = true,\n        ...others\n    }: CanvasProps,\n    canvasRef: React.Ref<HTMLDivElement>\n): JSX.Element => {\n    const imageSrc = useBackgroundImage(backgroundImageSrc);\n\n    const containerWidth = scale != null ? width * scale : width;\n    const containerHeight =\n        scale != null && cssScaling ? height * scale : height;\n    const backgroundColor = sanitizeColor(unsanitizedBgColor);\n\n    return (\n        <CanvasContainer\n            data-test=\"canvas-container\"\n            data-width={containerWidth}\n            data-height={containerHeight}\n            width={cssScaling ? containerWidth : width}\n            height={containerHeight}\n            showOverflowContent={showOverflowContent}\n            userSelect={userSelect}\n            ref={canvasRef}\n            {...others}\n        >\n            <Background\n                data-test=\"canvas\"\n                data-width={width}\n                data-height={height}\n                data-scale={scale}\n                width={cssScaling ? width : containerWidth}\n                height={height}\n                scale={cssScaling ? scale : undefined}\n                bgColor={backgroundColor}\n                bgImageSrc={imageSrc}\n                bgImageSizeType={backgroundImageSizeType}\n                bgImageWidth={backgroundImageWidth}\n                bgImageHeight={backgroundImageHeight}\n                bgImagePositionX={backgroundImagePositionX}\n                bgImagePositionY={backgroundImagePositionY}\n            >\n                {showBorder && <Border width={width} height={height} />}\n                {showGrid && (\n                    <GridLines\n                        width={width}\n                        height={height}\n                        gridLineOpacity={gridLineOpacity}\n                        gridPadding={gridPadding}\n                        gridLineWidth={gridLineWidth}\n                        gridLineColor={gridLineColor}\n                        gridWidth={gridWidth}\n                        gridHeight={gridHeight}\n                    />\n                )}\n                {children}\n            </Background>\n        </CanvasContainer>\n    );\n};\n\nexport default forwardRef(Canvas);\n","module.exports = require(\"@splunk/dashboard-utils/style\");","module.exports = require(\"@splunk/dashboard-ui/utils/colorUtils\");","import { useContext, useEffect, useState } from 'react';\nimport DashboardContext from '@splunk/dashboard-context';\nimport console from '@splunk/dashboard-utils/console';\n\n// temp until the ImageRegistry is typed\ninterface ImageRegistry {\n    getByURL: (url: string) => Promise<{ dataURI: string }>;\n    isResourceURL: (imgSrc: string) => boolean;\n}\n\nexport const useBackgroundImage = (backgroundImageSrc?: string): string => {\n    const [imageSrc, setImageSrc] = useState('');\n    const { imageRegistry } = useContext(DashboardContext);\n\n    /**\n     * Check whether backgroundImage src is a remote image url or stored in the image registry. Fetch if its the latter\n     * @param string backgroundImageSrc\n     */\n    const fetchBackgroundImage = async (\n        registry: ImageRegistry,\n        bgImageSrc: string\n    ) => {\n        try {\n            // use imageRegistry to fetch the image if it's there\n            if (registry) {\n                if (registry.isResourceURL(bgImageSrc)) {\n                    const imageObject = await registry.getByURL(bgImageSrc);\n                    setImageSrc(imageObject.dataURI);\n                } else {\n                    setImageSrc(bgImageSrc);\n                }\n            } else {\n                setImageSrc(bgImageSrc);\n            }\n        } catch (error) {\n            console.error(error); // TODO Refactor error display\n        }\n    };\n\n    useEffect(() => {\n        if (backgroundImageSrc) {\n            fetchBackgroundImage(\n                imageRegistry as ImageRegistry,\n                backgroundImageSrc\n            );\n        }\n    }, [imageRegistry, backgroundImageSrc]);\n\n    return imageSrc;\n};\n","import noop from 'lodash/noop';\nimport type { MouseEvent as ReactMouseEvent } from 'react';\nimport React, { useState, useCallback, useMemo, useEffect } from 'react';\nimport styled from 'styled-components';\nimport { variables, pick } from '@splunk/themes';\nimport type { Coordinate, Port, SelectedItem } from '@splunk/dashboard-types';\nimport {\n    getOffset,\n    getClientPosition,\n    computeLineBoxPosition,\n    computeLineRelativePosition,\n} from '../utils/layoutUtils';\nimport type { RenderLayoutItem } from '../types';\n\nconst LineBox = styled.div`\n    position: absolute;\n    pointer-events: none;\n`;\n\ninterface AdjustHandleProps {\n    x: number;\n    y: number;\n}\n\nconst AdjustHandle = styled.a.attrs(({ x, y }: AdjustHandleProps) => ({\n    style: {\n        transform: `translate(${x}px, ${y}px)`,\n    },\n}))<AdjustHandleProps>`\n    width: 10px;\n    height: 10px;\n    left: -5px;\n    top: -5px;\n    background-color: ${pick({\n        enterprise: variables.accentColorL10,\n        prisma: variables.interactiveColorPrimary,\n    })};\n    border-radius: 50%;\n    position: absolute;\n    z-index: 999;\n    pointer-events: auto;\n    cursor: move;\n    user-select: none;\n`;\n\ntype HandleMouseMove = (\n    e: MouseEvent,\n    offset: ReturnType<typeof getOffset>\n) => void;\n\nexport interface ResponsiveLineProps {\n    fromX: number;\n    fromY: number;\n    fromItem?: string;\n    fromPort?: Port;\n    toX: number;\n    toY: number;\n    toItem?: string;\n    toPort?: Port;\n    lineId: string;\n    scale?: number;\n    selectable?: boolean;\n    editable?: boolean;\n    renderLayoutItem: RenderLayoutItem;\n    onItemSelected?: (e: ReactMouseEvent, items: SelectedItem[]) => void;\n    onLineDragStart?: (e: ReactMouseEvent, dir: 'from' | 'to') => void;\n    onLineMove?: HandleMouseMove;\n    onLineMoved?: HandleMouseMove;\n    onLineDrag?: HandleMouseMove;\n    onLineDragged?: HandleMouseMove;\n}\n\ntype Action = 'move' | 'drag';\n\nconst ResponsiveLine = ({\n    fromX,\n    fromY,\n    fromItem,\n    fromPort,\n    toX,\n    toY,\n    toItem,\n    toPort,\n    lineId,\n    scale = 1,\n    selectable = false,\n    editable = false,\n    renderLayoutItem,\n    onItemSelected = noop,\n    onLineDragStart = noop,\n    onLineMove = noop,\n    onLineMoved = noop,\n    onLineDrag = noop,\n    onLineDragged = noop,\n}: ResponsiveLineProps): JSX.Element => {\n    const [startPosition, setStartPosition] = useState<Coordinate | null>(null);\n    const [action, setAction] = useState<Action | null>(null);\n\n    const handleLineSelected = useCallback(\n        (e: ReactMouseEvent) => {\n            e.stopPropagation();\n\n            setStartPosition(getClientPosition(e, scale));\n            setAction('move');\n\n            onItemSelected(e, [{ id: lineId, type: 'line' }]);\n        },\n        [lineId, onItemSelected, scale]\n    );\n\n    const handleMouseDownFrom = useCallback(\n        (e: ReactMouseEvent) => {\n            e.stopPropagation();\n\n            setStartPosition(getClientPosition(e, scale));\n            setAction('drag');\n\n            onLineDragStart(e, 'from');\n        },\n        [onLineDragStart, scale]\n    );\n\n    const handleMouseDownTo = useCallback(\n        (e: ReactMouseEvent) => {\n            e.stopPropagation();\n\n            setStartPosition(getClientPosition(e, scale));\n            setAction('drag');\n\n            onLineDragStart(e, 'to');\n        },\n        [onLineDragStart, scale]\n    );\n\n    const handleMouseMove = useCallback(\n        (e: MouseEvent) => {\n            if (startPosition == null || action == null) {\n                return;\n            }\n\n            e.preventDefault();\n            const currentPosition = getClientPosition(e, scale);\n            const offset = getOffset(currentPosition, startPosition);\n            switch (action) {\n                case 'drag':\n                    onLineDrag(e, offset);\n                    break;\n                case 'move':\n                    onLineMove(e, offset);\n                    break;\n                default:\n                    break;\n            }\n        },\n        [action, onLineDrag, onLineMove, scale, startPosition]\n    );\n\n    const handleMouseUp = useCallback(\n        (e: MouseEvent) => {\n            if (startPosition == null || action == null) {\n                return;\n            }\n\n            setStartPosition(null);\n\n            const currentPosition = getClientPosition(e, scale);\n            const offset = getOffset(currentPosition, startPosition);\n\n            switch (action) {\n                case 'drag':\n                    onLineDragged(e, offset);\n                    break;\n                case 'move':\n                    onLineMoved(e, offset);\n                    break;\n                default:\n                    break;\n            }\n        },\n        [action, onLineDragged, onLineMoved, scale, startPosition]\n    );\n\n    const from = { x: fromX, y: fromY };\n    const to = { x: toX, y: toY };\n    const boxPos = computeLineBoxPosition(from, to);\n    const relativePos = computeLineRelativePosition(from, to, boxPos);\n\n    const lineBoxStyle = useMemo(\n        () => ({\n            transform: `translate(${boxPos.x}px, ${boxPos.y}px)`,\n        }),\n        [boxPos.x, boxPos.y]\n    );\n\n    const fromHandleElement = useMemo(() => {\n        if (!editable) {\n            return null;\n        }\n\n        return (\n            <AdjustHandle\n                data-test=\"line-handle-from\"\n                data-test-item={fromItem}\n                data-test-port={fromPort}\n                x={relativePos.from.x}\n                y={relativePos.from.y}\n                onMouseDown={handleMouseDownFrom}\n            />\n        );\n    }, [\n        editable,\n        fromItem,\n        fromPort,\n        relativePos.from.x,\n        relativePos.from.y,\n        handleMouseDownFrom,\n    ]);\n\n    const tohandleElement = useMemo(() => {\n        if (!editable) {\n            return null;\n        }\n\n        return (\n            <AdjustHandle\n                data-test=\"line-handle-to\"\n                data-test-item={toItem}\n                data-test-port={toPort}\n                x={relativePos.to.x}\n                y={relativePos.to.y}\n                onMouseDown={handleMouseDownTo}\n            />\n        );\n    }, [\n        editable,\n        toItem,\n        toPort,\n        relativePos.to.x,\n        relativePos.to.y,\n        handleMouseDownTo,\n    ]);\n\n    const lineElement = useMemo(\n        () =>\n            renderLayoutItem(\n                lineId,\n                {\n                    from: {\n                        x: relativePos.from.x,\n                        y: relativePos.from.y,\n                    },\n                    to: {\n                        x: relativePos.to.x,\n                        y: relativePos.to.y,\n                    },\n                    // todo: this is inconsistent with the ResponsiveBlockitem which accepts the `onSelect` callback as the 4th argument of `renderLayoutItem`.\n                    onLineSelect: selectable ? handleLineSelected : noop,\n                },\n                'line'\n            ),\n        [\n            handleLineSelected,\n            lineId,\n            relativePos.from.x,\n            relativePos.from.y,\n            relativePos.to.x,\n            relativePos.to.y,\n            renderLayoutItem,\n            selectable,\n        ]\n    );\n\n    useEffect(() => {\n        if (editable) {\n            document.addEventListener('mousemove', handleMouseMove);\n            document.addEventListener('mouseup', handleMouseUp);\n        }\n\n        return () => {\n            document.removeEventListener('mousemove', handleMouseMove);\n            document.removeEventListener('mouseup', handleMouseUp);\n        };\n    }, [editable, handleMouseMove, handleMouseUp]);\n\n    return (\n        <LineBox\n            data-test=\"line-box\"\n            style={lineBoxStyle}\n            data-viz-type=\"abslayout.line\"\n            data-id={lineId}\n            data-test-line-position={`${from.x},${from.y}-${to.x},${to.y}`}\n        >\n            {fromHandleElement}\n            {tohandleElement}\n            {lineElement}\n        </LineBox>\n    );\n};\n\nexport default ResponsiveLine;\n","import React, { useMemo } from 'react';\nimport type {\n    SelectedItem,\n    ConnectedLineItem,\n    AbsoluteBlockItem,\n    AbsoluteLayoutOptions,\n    AbsoluteLayoutStructure,\n} from '@splunk/dashboard-types';\nimport Canvas from './components/Canvas';\nimport AbsoluteLayoutApi from './apis/AbsoluteLayoutApi';\nimport AbsoluteItem from './components/AbsoluteItem';\nimport { computeScaleToFit } from './utils/layoutUtils';\nimport { validateBackgroundImage } from './utils/imageUtils';\nimport { computeLineAbsPosition } from './utils/lineUtils';\nimport { absoluteLayoutOptions } from './DefaultOptions';\nimport ResponsiveLine from './components/ResponsiveLine';\nimport type { RenderLayoutItem } from './types';\n\nexport interface AbsoluteLayoutViewerArgs extends AbsoluteLayoutArgs {\n    layoutApiRef?: (layoutApi: AbsoluteLayoutApi | null) => void;\n}\n\n// TODO: add layoutApiRef once AbsoluteLayoutApi and GridLayoutApi have been refactored\ninterface AbsoluteLayoutArgs {\n    mode?: 'edit' | 'view';\n    showGrid?: boolean;\n    containerWidth: number;\n    containerHeight: number;\n    selectedItems?: SelectedItem[];\n    renderLayoutItem: RenderLayoutItem;\n    onLayoutItemsSelect?: (selectedItems: SelectedItem[]) => void;\n    onEventTrigger?: (...args: unknown[]) => void;\n    options?: AbsoluteLayoutOptions;\n    layoutStructure?: AbsoluteLayoutStructure;\n    onLayoutStructureChange?: (\n        layoutStructure: AbsoluteLayoutStructure\n    ) => void;\n}\n\nconst AbsoluteLayoutViewer = ({\n    containerWidth,\n    layoutStructure = [],\n    renderLayoutItem,\n    options = {},\n}: AbsoluteLayoutViewerArgs): JSX.Element => {\n    const {\n        width,\n        height,\n        backgroundColor,\n        backgroundImage = {},\n        display = 'actual-size',\n    } = {\n        ...absoluteLayoutOptions,\n        ...options,\n    };\n    const scale =\n        display === 'auto-scale' ? computeScaleToFit(containerWidth, width) : 1;\n    const image = useMemo(\n        () =>\n            backgroundImage\n                ? validateBackgroundImage({\n                      backgroundImage,\n                      canvasWidth: width,\n                      canvasHeight: height,\n                  })\n                : {},\n        [backgroundImage, height, width]\n    );\n\n    const renderLines = useMemo(() => {\n        // TODO: replace with getAllLineItems() from lineUtils after AbsLayout refactor is merged\n        const lineItems = layoutStructure.filter(\n            ({ type }) => type === 'line'\n        ) as ConnectedLineItem[];\n        return lineItems.map(({ item, position }) => {\n            const absPosition = computeLineAbsPosition({\n                layoutStructure,\n                position,\n            });\n            return (\n                <ResponsiveLine\n                    key={item}\n                    lineId={item}\n                    scale={scale}\n                    fromX={absPosition.from.x}\n                    toX={absPosition.to.x}\n                    fromY={absPosition.from.y}\n                    toY={absPosition.to.y}\n                    renderLayoutItem={renderLayoutItem}\n                />\n            );\n        });\n    }, [layoutStructure, scale, renderLayoutItem]);\n\n    const renderBlockItems = useMemo(() => {\n        // TODO: replace with getAllBlockItems() from lineUtils after AbsLayout refactor is merged\n        const blockItems = layoutStructure.filter(\n            ({ type }) => type !== 'line'\n        ) as AbsoluteBlockItem[];\n        return blockItems.map(({ item, position }) => {\n            const { x, y, w, h } = position;\n            return (\n                <AbsoluteItem\n                    itemId={item}\n                    key={item}\n                    x={x}\n                    y={y}\n                    w={w}\n                    h={h}\n                    renderLayoutItem={renderLayoutItem}\n                />\n            );\n        });\n    }, [renderLayoutItem, layoutStructure]);\n\n    return (\n        <Canvas\n            data-layout-type=\"absolute\"\n            width={width}\n            height={height}\n            scale={scale}\n            showGrid={false}\n            backgroundColor={backgroundColor}\n            backgroundImageSrc={image.src}\n            backgroundImageSizeType={image.sizeType}\n            backgroundImageWidth={image.w}\n            backgroundImageHeight={image.h}\n            backgroundImagePositionX={image.x}\n            backgroundImagePositionY={image.y}\n        >\n            {renderBlockItems}\n            {renderLines}\n        </Canvas>\n    );\n};\n\nexport default AbsoluteLayoutViewer;\n","import React from 'react';\nimport styled from 'styled-components';\nimport T from 'prop-types';\n\nconst AbsoluteDiv = styled.div.attrs(({ x, y, w, h }) => ({\n    style: {\n        width: w,\n        height: h,\n        top: `${y}px`,\n        left: `${x}px`,\n    },\n}))`\n    display: block;\n    position: absolute;\n    background: transparent;\n`;\n\n/**\n * Absolute positioned item\n * @param {*} param0\n */\nconst AbsoluteItem = ({ itemId, x, y, w, h, renderLayoutItem }) => (\n    <AbsoluteDiv\n        x={x}\n        y={y}\n        w={w}\n        h={h}\n        data-test=\"absolute-item\"\n        data-x={x}\n        data-y={y}\n        data-w={w}\n        data-h={h}\n    >\n        {renderLayoutItem(\n            itemId,\n            {\n                width: w,\n                height: h,\n            },\n            'block'\n        )}\n    </AbsoluteDiv>\n);\n\nAbsoluteItem.propTypes = {\n    itemId: T.string.isRequired,\n    x: T.number.isRequired,\n    y: T.number.isRequired,\n    w: T.number.isRequired,\n    h: T.number.isRequired,\n    renderLayoutItem: T.func.isRequired,\n};\n\nexport default AbsoluteItem;\n"],"sourceRoot":""}
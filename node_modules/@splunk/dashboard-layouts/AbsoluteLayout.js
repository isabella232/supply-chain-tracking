/*!
 * Copyright © 2020 Splunk Inc.
 * SPLUNK CONFIDENTIAL – Use or disclosure of this material in whole or
 * in part without a valid written license from Splunk Inc. is PROHIBITED.
 */
module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 60);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

module.exports = require("react");

/***/ }),
/* 1 */
/***/ (function(module, exports) {

module.exports = require("styled-components");

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.scaleGridLayoutStructureByWidth = exports.computeRelativePosition = exports.shiftViewportOnZoom = exports.cloneLine = exports.cloneBlockItem = exports.getAllCollisions = exports.resolveCompactionCollision = exports.bottom = exports.computeLineRelativePosition = exports.computeLineBoxPosition = exports.updateLineAbsPosition = exports.connectLine = exports.disconnectLine = exports.isLineConnected = exports.moveLayoutItem = exports.computeScaleToFit = exports.createOffset = exports.updateBlockItemPosition = exports.updateBlockItemSize = exports.snapOffsetToWH = exports.snapOffsetToXY = exports.snapOffset = exports.findTopBlockItemByPosition = exports.filterBlockItemsByBoundary = exports.positionsToBoundary = exports.considerMoved = exports.getOffset = exports.getClientPosition = exports.positionToStyleString = exports.positionToStyle = exports.removeInvalidItems = exports.isLinePositionValid = exports.isValidConnection = exports.isBlockPositionValid = exports.computeMaxHeight = void 0;
var findLast_1 = __importDefault(__webpack_require__(17));
var get_1 = __importDefault(__webpack_require__(10));
var isNumber_1 = __importDefault(__webpack_require__(18));
var reduce_1 = __importDefault(__webpack_require__(19));
var pullAt_1 = __importDefault(__webpack_require__(20));
var cloneDeep_1 = __importDefault(__webpack_require__(21));
var sortBy_1 = __importDefault(__webpack_require__(22));
var console_1 = __importDefault(__webpack_require__(5));
var layout_1 = __webpack_require__(6);
var edgeUtils_1 = __webpack_require__(11);
// export for gridLayout/legacyGridLayout
exports.computeMaxHeight = layout_1.computeMaxHeight;
/**
 *  check if a position is valid
 * @param {Object} position
 */
var isBlockPositionValid = function (position) {
    return !!(position &&
        Number.isInteger(position.x) &&
        Number.isInteger(position.y) &&
        Number.isInteger(position.w) &&
        Number.isInteger(position.h));
};
exports.isBlockPositionValid = isBlockPositionValid;
var isValidConnection = function (connection) {
    if ('x' in connection &&
        'y' in connection &&
        Number.isInteger(connection.x) &&
        Number.isInteger(connection.y)) {
        return true;
    }
    if ('item' in connection &&
        'port' in connection &&
        connection.item != null &&
        connection.port != null) {
        return true;
    }
    return false;
};
exports.isValidConnection = isValidConnection;
/**
 * a line should has from and to
 */
var isLinePositionValid = function (position) {
    if (position.from != null && position.to != null) {
        return (exports.isValidConnection(position.from) && exports.isValidConnection(position.to));
    }
    return false;
};
exports.isLinePositionValid = isLinePositionValid;
/**
 * filter invalid position
 * @param {Object[]} layoutStructure - Array of items (viz, edges, lines)
 * @returns {Object[]} - Returns filtered array
 */
var removeInvalidItems = function (layoutStructure) {
    if (layoutStructure === void 0) { layoutStructure = []; }
    return layoutStructure.filter(function (structure) {
        if (structure.type === 'line') {
            return exports.isLinePositionValid(structure.position);
        }
        return exports.isBlockPositionValid(structure.position);
    });
};
exports.removeInvalidItems = removeInvalidItems;
/**
 * convert position to css object
 */
var positionToStyle = function (pos) { return ({
    width: pos.w + "px",
    height: pos.h + "px",
    transform: "translate(" + pos.x + "px, " + pos.y + "px)",
}); };
exports.positionToStyle = positionToStyle;
/**
 * convert position to css string
 */
var positionToStyleString = function (pos) {
    var style = exports.positionToStyle(pos);
    return reduce_1.default(style, function (result, v, k) { return result + " " + k + ":" + v + ";"; }, '');
};
exports.positionToStyleString = positionToStyleString;
/**
 * get client position for given event with scale factor
 */
var getClientPosition = function (e, scaleFactor) {
    if (scaleFactor === void 0) { scaleFactor = 1; }
    return ({
        x: Math.round(e.clientX / scaleFactor),
        y: Math.round(e.clientY / scaleFactor),
    });
};
exports.getClientPosition = getClientPosition;
/**
 * compute offset from 2 positions
 */
var getOffset = function (currentPosition, startPosition) { return ({
    offsetX: currentPosition.x - startPosition.x,
    offsetY: currentPosition.y - startPosition.y,
}); };
exports.getOffset = getOffset;
/**
 * check if a given offset can be considered as 'move'
 * @param {Object} config
 * @param {Number} config.offsetX
 * @param {Number} config.offsetY
 */
var considerMoved = function (_a) {
    var offsetX = _a.offsetX, offsetY = _a.offsetY;
    return offsetX !== 0 || offsetY !== 0;
};
exports.considerMoved = considerMoved;
/**
 * return a boundary for 2 positions
 * @param {Coordinate} startPos
 * @param {Coordinate} endPos
 */
var positionsToBoundary = function (startPos, endPos) { return ({
    x: Math.min(startPos.x, endPos.x),
    y: Math.min(startPos.y, endPos.y),
    w: Math.abs(startPos.x - endPos.x),
    h: Math.abs(startPos.y - endPos.y),
}); };
exports.positionsToBoundary = positionsToBoundary;
/**
 * filter abs items within a boundary
 * @param {Array} items
 * @param {Object} boundary
 */
var filterBlockItemsByBoundary = function (items, boundary) {
    return items.filter(function (item) {
        var itemPosition = item.position;
        return !(boundary.x > itemPosition.x + itemPosition.w ||
            boundary.x + boundary.w < itemPosition.x ||
            boundary.y > itemPosition.y + itemPosition.h ||
            boundary.y + boundary.h < itemPosition.y);
    });
};
exports.filterBlockItemsByBoundary = filterBlockItemsByBoundary;
/**
 * find the first item that contains the pos.
 */
var findTopBlockItemByPosition = function (items, pos, padding) {
    if (padding === void 0) { padding = 0; }
    return findLast_1.default(items, function (item) {
        var itemPosition = padding
            ? edgeUtils_1.applyVizPadding({ item: item, padding: padding }).position
            : item.position;
        return (itemPosition.x <= pos.x &&
            itemPosition.x + itemPosition.w >= pos.x &&
            itemPosition.y <= pos.y &&
            itemPosition.y + itemPosition.h >= pos.y);
    });
};
exports.findTopBlockItemByPosition = findTopBlockItemByPosition;
/**
 * Compute the new offset so current + new offset will be the multiple of snapTo unit
 * For examples:
 * (5, 2, 5) => 0, user moved less than half of the snapTo unit, return 0 so 5 + 0 = 5
 * (5, 3, 5) => 5, user moved more than half of the snapTo unit, return 5 so 5 + 5 = 5 * 2
 * (5, 12, 5) => 10
 * (5, 13, 5) => 15
 * @param {Number} current
 * @param {Number} offset
 * @param {Number} snapTo
 */
var snapOffset = function (current, offset, snapTo) {
    // return a new offset
    var remainder = (current + offset) % snapTo;
    var newOffset = remainder > snapTo / 2
        ? offset + (snapTo - remainder)
        : offset - remainder;
    return newOffset;
};
exports.snapOffset = snapOffset;
/**
 * snap item with its top-left corner (represent by x, y)
 * @param {Object} position
 * @param {Object} offset
 * @param {Number} gridWidth
 * @param {Number} gridHeight
 * @param {Number} spacing
 */
var snapOffsetToXY = function (_a) {
    var position = _a.position, offset = _a.offset, gridWidth = _a.gridWidth, gridHeight = _a.gridHeight, _b = _a.spacing, spacing = _b === void 0 ? 0 : _b, _c = _a.padding, padding = _c === void 0 ? 0 : _c;
    var offsetX = offset.offsetX, offsetY = offset.offsetY;
    offsetX = exports.snapOffset(position.x, offsetX, gridWidth + spacing) + padding;
    offsetY = exports.snapOffset(position.y, offsetY, gridHeight + spacing) + padding;
    return {
        offsetX: offsetX,
        offsetY: offsetY,
    };
};
exports.snapOffsetToXY = snapOffsetToXY;
/**
 * snap item with its size (represent by w, h)
 * @param {Object} position
 * @param {Object} offset
 * @param {Number} gridWidth
 * @param {Number} gridHeight
 * @param {Number} spacing
 */
var snapOffsetToWH = function (_a) {
    var position = _a.position, offset = _a.offset, gridWidth = _a.gridWidth, gridHeight = _a.gridHeight, _b = _a.spacing, spacing = _b === void 0 ? 0 : _b, _c = _a.padding, padding = _c === void 0 ? 0 : _c;
    var offsetX = offset.offsetX, offsetY = offset.offsetY;
    offsetX =
        exports.snapOffset(position.x + position.w, offsetX, gridWidth + spacing) +
            (padding - spacing);
    offsetY =
        exports.snapOffset(position.y + position.h, offsetY, gridHeight + spacing) +
            (padding - spacing);
    return {
        offsetX: offsetX,
        offsetY: offsetY,
    };
};
exports.snapOffsetToWH = snapOffsetToWH;
/**
 * Mutate item coordinates and/or dimensions.
 * This mutation's new dimensions and coordinates are bounded within the original block item real estate.
 * @param {Object} item
 * @param {Object} offset
 * @param {String} dir Cartesian direction to shift item towards.
 * @param {Object} options
 */
var updateBlockItemSize = function (_a) {
    var item = _a.item, offset = _a.offset, dir = _a.dir, _b = _a.options, _c = _b === void 0 ? {} : _b, _d = _c.minWidth, minWidth = _d === void 0 ? 0 : _d, _e = _c.minHeight, minHeight = _e === void 0 ? 0 : _e;
    var _f = item.position, w = _f.w, h = _f.h;
    var offsetX = offset.offsetX, offsetY = offset.offsetY;
    var updatedPosition = __assign({}, item.position);
    // resizing from north
    if (['n', 'ne', 'nw'].includes(dir)) {
        updatedPosition.y += Math.min(h - minHeight, offsetY);
        updatedPosition.h -= offsetY;
    }
    // resizing from the south
    if (['s', 'se', 'sw'].includes(dir)) {
        updatedPosition.h += offsetY;
    }
    // resizing from the east
    if (['e', 'ne', 'se'].includes(dir)) {
        updatedPosition.w += offsetX;
    }
    // resizing from west
    if (['w', 'nw', 'sw'].includes(dir)) {
        updatedPosition.x += Math.min(w - minWidth, offsetX);
        updatedPosition.w -= offsetX;
    }
    updatedPosition.w = Math.max(minWidth, updatedPosition.w);
    updatedPosition.h = Math.max(minHeight, updatedPosition.h);
    return __assign(__assign({}, item), { position: updatedPosition });
};
exports.updateBlockItemSize = updateBlockItemSize;
var updateBlockItemPosition = function (item, offset) {
    var offsetX = offset.offsetX, offsetY = offset.offsetY;
    return __assign(__assign({}, item), { position: __assign(__assign({}, item.position), { x: item.position.x + offsetX, y: item.position.y + offsetY }) });
};
exports.updateBlockItemPosition = updateBlockItemPosition;
/**
 * create offset based on dir, x and y
 * @method createOffset
 * @param {String} dir
 * @param {Number} x
 * @param {Number} y
 * @returns {Object} offset
 */
var createOffset = function (dir, x, y) {
    switch (dir) {
        case 'n':
            return {
                offsetX: 0,
                offsetY: -y,
            };
        case 's':
            return {
                offsetX: 0,
                offsetY: y,
            };
        case 'w':
            return {
                offsetX: -x,
                offsetY: 0,
            };
        case 'e':
            return {
                offsetX: x,
                offsetY: 0,
            };
        default:
            return {
                offsetX: 0,
                offsetY: 0,
            };
    }
};
exports.createOffset = createOffset;
/**
 * compute scale factor
 * @param {Number} actualWidth
 * @param {Number} canvasWidth
 */
var computeScaleToFit = function (actualWidth, canvasWidth) {
    if (!(isNumber_1.default(canvasWidth) &&
        canvasWidth > 0 &&
        isNumber_1.default(actualWidth) &&
        actualWidth > 0)) {
        console_1.default.warn("Failed to calculate layout scale: containerWidth=" + actualWidth + ", width=" + canvasWidth + "; falling back to scale=1");
        return 1;
    }
    return actualWidth / canvasWidth;
};
exports.computeScaleToFit = computeScaleToFit;
/**
 *
 * @param {Array} items
 * @param {Number} from  target item index
 * @param {Number} to    where does this item move to
 */
var moveLayoutItem = function (items, from, to) {
    var structure = __spread(items);
    var removed = pullAt_1.default(structure, [from]);
    structure.splice(to, 0, removed[0]);
    return structure;
};
exports.moveLayoutItem = moveLayoutItem;
/**
 * check if a line is connected
 */
var isLineConnected = function (_a) {
    var line = _a.line, dir = _a.dir;
    return 'item' in line.position[dir];
};
exports.isLineConnected = isLineConnected;
/**
 *  disconnect a line from item and set it to abs position
 */
var disconnectLine = function (_a) {
    var _b;
    var line = _a.line, dir = _a.dir, absPos = _a.absPos;
    var updatePosition = __assign(__assign({}, line.position), (_b = {}, _b[dir] = __assign({}, absPos), _b));
    return __assign(__assign({}, line), { position: updatePosition });
};
exports.disconnectLine = disconnectLine;
/**
 * connect a line with an item and port
 */
var connectLine = function (_a) {
    var _b;
    var line = _a.line, dir = _a.dir, itemId = _a.itemId, port = _a.port;
    var position = line.position;
    var updatedPosition = __assign(__assign({}, position), (_b = {}, _b[dir] = {
        item: itemId,
        port: port,
    }, _b));
    return __assign(__assign({}, line), { position: updatedPosition });
};
exports.connectLine = connectLine;
/**
 * update line absolute position
 */
var updateLineAbsPosition = function (_a) {
    var _b;
    var line = _a.line, dir = _a.dir, offset = _a.offset;
    var offsetX = offset.offsetX, offsetY = offset.offsetY;
    var position = line.position;
    if (!('x' in position[dir])) {
        throw Error("line item " + line.item + " does not have x value for its direction " + dir);
    }
    if (!('y' in position[dir])) {
        throw Error("line item " + line.item + " does not have y value for its direction " + dir);
    }
    var _c = position[dir], x = _c.x, y = _c.y;
    return __assign(__assign({}, line), { position: __assign(__assign({}, position), (_b = {}, _b[dir] = {
            x: x + offsetX,
            y: y + offsetY,
        }, _b)) });
};
exports.updateLineAbsPosition = updateLineAbsPosition;
/**
 *
 * @param {Object} from
 * @param {Object} to
 */
var computeLineBoxPosition = function (from, to) { return ({
    x: Math.min(from.x, to.x),
    y: Math.min(from.y, to.y),
}); };
exports.computeLineBoxPosition = computeLineBoxPosition;
/**
 *
 * @param {Object} from
 * @param {Object} to
 * @param {Object} box
 */
var computeLineRelativePosition = function (from, to, box) { return ({
    from: {
        x: from.x - box.x,
        y: from.y - box.y,
    },
    to: {
        x: to.x - box.x,
        y: to.y - box.y,
    },
}); };
exports.computeLineRelativePosition = computeLineRelativePosition;
/**
 * Return the bottom coordinate of the layout.
 *
 * @param  {Array} layout Layout array.
 * @return {Number}       Bottom coordinate.
 */
var bottom = function (layout) {
    return layout.length > 0
        ? Math.max.apply(Math, __spread(layout.map(function (_a) {
            var position = _a.position;
            return position.y + position.h;
        }))) : 1;
};
exports.bottom = bottom;
/**
 * Before moving item down, it will check if the movement will cause collisions
 * and move those items down before.
 * @method resolveCompactionCollision
 * @param {Array} layout
 * @param {Object} itemToMove current item which need to be moved to solve the collision
 * @param {Number} moveToCoord the destination coordination of y axis
 * @returns {Array} [newLayout, newItem]
 */
var resolveCompactionCollision = function (layout, itemToMove, moveToCoord) {
    var _a;
    var axisVal = itemToMove.position.y;
    axisVal += 1;
    var newLayout = cloneDeep_1.default(layout);
    var itemIndex = newLayout.findIndex(function (layoutItem) { return layoutItem.item === itemToMove.item; });
    var newItem = cloneDeep_1.default(itemToMove);
    newItem.position.y = axisVal;
    // Go through each item we collide with.
    // If there is a collision, we will move this collision down, otherwise set y = moveToCoord and return
    for (var i = itemIndex + 1; i < layout.length; i += 1) {
        // Optimization: we can break early if we know we're past this el
        // We can do this b/c it's a sorted layout
        if (newLayout[i].position.y > newItem.position.y + newItem.position.h) {
            break;
        }
        if (layout_1.collides(newItem, newLayout[i])) {
            _a = __read(exports.resolveCompactionCollision(layout, layout[i], moveToCoord + newItem.position.h), 2), newLayout = _a[0], newLayout[i] = _a[1];
        }
    }
    newItem.position.y = moveToCoord;
    newLayout[itemIndex] = newItem;
    return [newLayout, newItem];
};
exports.resolveCompactionCollision = resolveCompactionCollision;
/**
 * get all collisions given an item and current layout
 * @method getAllCollisions
 * @param {Array} layout
 * @param {Object} layoutItem
 * @returns {Array} sorted layout
 */
var getAllCollisions = function (layout, layoutItem) {
    return layout.filter(function (item) { return layout_1.collides(item, layoutItem); });
};
exports.getAllCollisions = getAllCollisions;
/**
 * clone a block item
 * @param {Number} id
 * @param {Object} item
 * @param {Number} offsetMultiplier
 */
var cloneBlockItem = function (_a) {
    var id = _a.id, item = _a.item, offsetMultiplier = _a.offsetMultiplier;
    var copiedPosition = item.position;
    return __assign(__assign({}, item), { item: id, position: {
            x: copiedPosition.x + 20 * offsetMultiplier,
            y: copiedPosition.y + 20 * offsetMultiplier,
            w: copiedPosition.w,
            h: copiedPosition.h,
        } });
};
exports.cloneBlockItem = cloneBlockItem;
/**
 * clone an line, it assume the line is not connected
 * @param {Number} id
 * @param {Object} item
 * @param {Number} offsetMultiplier
 */
var cloneLine = function (_a) {
    var id = _a.id, item = _a.item, offsetMultiplier = _a.offsetMultiplier;
    var copiedPosition = item.position;
    return __assign(__assign({}, item), { item: id, position: {
            from: {
                x: copiedPosition.from.x +
                    20 * offsetMultiplier,
                y: copiedPosition.from.y +
                    20 * offsetMultiplier,
            },
            to: {
                x: copiedPosition.to.x + 20 * offsetMultiplier,
                y: copiedPosition.to.y + 20 * offsetMultiplier,
            },
        } });
};
exports.cloneLine = cloneLine;
/**
 * Calculates new viewport position after a zoom event to keep the previous central point in the center of
 * the scaled canvas. See MR #2030 for algorithm details.
 * @param {Number} scrollLeft viewport left edge offset relative to canvas
 * @param {Number} scrollTop viewport top edge offset relative to canvas
 * @param {Number} offsetWidth viewport width
 * @param {Number} offsetHeight viewport height
 * @param {Number} scaleRatio new scale to old scale ratio
 * @returns {Object} object containing new scrollLeft and scrollTop values
 */
var shiftViewportOnZoom = function (_a) {
    var scrollLeft = _a.scrollLeft, scrollTop = _a.scrollTop, offsetWidth = _a.offsetWidth, offsetHeight = _a.offsetHeight, scaleRatio = _a.scaleRatio;
    var middleOffsetWidth = offsetWidth / 2;
    var middleOffsetHeight = offsetHeight / 2;
    return {
        scrollLeft: (scrollLeft + middleOffsetWidth) * scaleRatio - middleOffsetWidth,
        scrollTop: (scrollTop + middleOffsetHeight) * scaleRatio - middleOffsetHeight,
    };
};
exports.shiftViewportOnZoom = shiftViewportOnZoom;
/**
 * return position relative to the canvas rect
 */
var computeRelativePosition = function (e, canvasRef, scale) {
    if (scale === void 0) { scale = 1; }
    var pos = exports.getClientPosition(e, scale);
    var canvasDomNode = get_1.default(canvasRef, ['current']);
    var rect = canvasDomNode && canvasDomNode.getBoundingClientRect();
    if (pos && rect) {
        return {
            x: pos.x - rect.left / scale,
            y: pos.y - rect.top / scale,
        };
    }
    return pos;
};
exports.computeRelativePosition = computeRelativePosition;
/**
 * Scales a GridLayout by stretching the width of each item by the scale factor
 * @param {AbsoluteBlockItem[]} items items to scale
 * @param {Number} scale how much to scale
 */
var scaleGridLayoutStructureByWidth = function (_a) {
    var layout = _a.layout, _b = _a.scale, scale = _b === void 0 ? 1 : _b;
    if (scale === 1) {
        return layout;
    }
    // Compute the edges of the existing layout. Since we're scaling
    // just the X and width we only care about vertical edges.
    var edges = edgeUtils_1.getAllEdges(layout);
    var verticalEdges = sortBy_1.default(edges.filter(function (edge) { return edge.orientation === 'vertical'; }), ['edgeStart.x']);
    // Scale the vertical edges and than align the
    // left and right items to the scaled edge position
    var newLayout = [];
    verticalEdges.forEach(function (edge) {
        var visualizations = edge.visualizations, x = edge.edgeStart.x;
        var scaledEdgeX = Math.round(x * scale);
        var left = visualizations.filter(function (viz) { return viz.position.x < x; });
        var right = visualizations.filter(function (viz) { return viz.position.x >= x; });
        // Update the Width of the layout items using the difference between the
        // newly scaled edge and the existing x
        left.forEach(function (layoutItem) {
            var newLayoutItem = newLayout.find(function (_a) {
                var id = _a.item;
                return layoutItem.item === id;
            });
            if (newLayoutItem) {
                newLayoutItem.position.w =
                    scaledEdgeX - newLayoutItem.position.x;
            }
        });
        // Since we walk the edges from the left to the right we
        // ALWAYS have to create the new layout item here but won't
        // ever need to update it.
        right.forEach(function (layoutItem) {
            newLayout.push(__assign(__assign({}, layoutItem), { position: __assign(__assign({}, layoutItem.position), { x: scaledEdgeX }) }));
        });
    });
    return newLayout;
};
exports.scaleGridLayoutStructureByWidth = scaleGridLayoutStructureByWidth;


/***/ }),
/* 3 */
/***/ (function(module, exports) {

module.exports = require("prop-types");

/***/ }),
/* 4 */
/***/ (function(module, exports) {

module.exports = require("@splunk/themes");

/***/ }),
/* 5 */
/***/ (function(module, exports) {

module.exports = require("@splunk/dashboard-utils/console");

/***/ }),
/* 6 */
/***/ (function(module, exports) {

module.exports = require("@splunk/dashboard-utils/layout");

/***/ }),
/* 7 */
/***/ (function(module, exports) {

module.exports = require("@splunk/dashboard-ui/customThemeVariables");

/***/ }),
/* 8 */
/***/ (function(module, exports) {

module.exports = require("@splunk/themes/mixins");

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.gridLayoutOptions = exports.absoluteLayoutOptions = void 0;
var layout_1 = __webpack_require__(6);
exports.absoluteLayoutOptions = {
    width: layout_1.DEFAULT_CANVAS_WIDTH,
    height: layout_1.DEFAULT_CANVAS_HEIGHT,
    display: 'actual-size',
};
exports.gridLayoutOptions = {
    width: layout_1.DEFAULT_CANVAS_WIDTH,
    gutterSize: 8,
};


/***/ }),
/* 10 */
/***/ (function(module, exports) {

module.exports = require("lodash/get");

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.findEdgesInBoundary = exports.findSnappableEdges = exports.moveVerticalEdge = exports.moveHorizontalEdge = exports.getHorizontalBoundaries = exports.getVerticalBoundaries = exports.applyVizPadding = exports.formatEdge = exports.computeEdges = exports.getAllEdges = void 0;
var uniqueId_1 = __webpack_require__(12);
var nextEdgeId = function () { return "edge_" + uniqueId_1.uniqueId(); };
/**
 * generate edge id
 */
var getNextEdgeId = function () {
    return nextEdgeId();
};
/**
 * Returns a 2D array of every viz corner, indicating which visualizations touch which node(corner)
 * @param {Object} layoutStructure - Array of visualizations from definition
 * @returns {Object[][]} - {x: { y: [vizList] } }
 */
var getNodes = function (layoutStructure) {
    if (layoutStructure.length === 0) {
        return null;
    }
    var nodes = {};
    layoutStructure.forEach(function (viz) {
        var _a = viz.position, x = _a.x, y = _a.y, w = _a.w, h = _a.h;
        var corners = [
            { x: x, y: y },
            { x: x + w, y: y },
            { x: x, y: y + h },
            { x: x + w, y: y + h },
        ];
        corners.forEach(function (corner) {
            if (nodes[corner.x] === undefined) {
                nodes[corner.x] = {};
            }
            if (nodes[corner.x][corner.y] === undefined) {
                nodes[corner.x][corner.y] = [];
            }
            nodes[corner.x][corner.y].push(viz);
        });
    });
    return nodes;
};
var isTopEdge = function (edge) {
    return edge.orientation === 'horizontal' && edge.edgeStart.y === 0;
};
var isBottomEdge = function (edge, canvasHeight) {
    return edge.orientation === 'horizontal' && edge.edgeStart.y === canvasHeight;
};
var isLeftEdge = function (edge) {
    return edge.orientation === 'vertical' && edge.edgeStart.x === 0;
};
var isRightEdge = function (edge, canvasWidth) {
    return edge.orientation === 'vertical' && edge.edgeStart.x === canvasWidth;
};
/**
 * Returns all the visualizations along a vertical edge
 * @param {Object} param - Param object needed to traverse along vertical edge
 * @param {num} param.x - x-coordinate of the edge
 * @param {num} param.yStart - y-coordinate of the edge start
 * @param {num} param.yEnd - y-coordinate of the edge end
 * @param {num} param.yCurrent - Current y in recursion
 * @param {num} param.nodes - The map of x,y coordinates to visualizations that touch that (x,y)
 * @param {num} param.visualizations - the list to add visualizations to, and then return
 * @returns {Set<Object>} - Set of unique visualizations along the edge
 */
var findVizAlongVerticalEdge = function (_a) {
    var x = _a.x, yStart = _a.yStart, yEnd = _a.yEnd, _b = _a.yCurrent, yCurrent = _b === void 0 ? yStart : _b, nodes = _a.nodes, _c = _a.visualizations, visualizations = _c === void 0 ? new Set() : _c;
    nodes[x][yCurrent].forEach(function (viz) {
        if (viz.position.y >= yStart && viz.position.y < yEnd) {
            visualizations.add(viz);
        }
        if (viz.position.y >= yCurrent && yCurrent + viz.position.h <= yEnd) {
            findVizAlongVerticalEdge({
                x: x,
                yStart: yStart,
                yEnd: yEnd,
                yCurrent: yCurrent + viz.position.h,
                nodes: nodes,
                visualizations: visualizations,
            });
        }
    });
    return visualizations;
};
/**
 * Returns all the visualizations along a horizontal edge
 * @param {Object} param - Param object needed to traverse along horizontal edge
 * @param {num} param.y - x-coordinate of the edge
 * @param {num} param.xStart - x-coordinate of the edge start
 * @param {num} param.xEnd - x-coordinate of the edge end
 * @param {num} param.xCurrent - Current x in recursion
 * @param {num} param.nodes - The map of x,y coordinates to visualizations that touch that (x,y)
 * @param {num} param.visualizations - the list to add visualizations to, and then return
 * @returns {Set<Object>} - Set of unique visualizations along the edge
 */
var findVizAlongHorizontalEdge = function (_a) {
    var y = _a.y, xStart = _a.xStart, xEnd = _a.xEnd, _b = _a.xCurrent, xCurrent = _b === void 0 ? xStart : _b, nodes = _a.nodes, _c = _a.visualizations, visualizations = _c === void 0 ? new Set() : _c;
    nodes[xCurrent][y].forEach(function (viz) {
        if (viz.position.x >= xStart && viz.position.x < xEnd) {
            visualizations.add(viz);
        }
        if (viz.position.x >= xCurrent && xCurrent + viz.position.w <= xEnd) {
            findVizAlongHorizontalEdge({
                y: y,
                xStart: xStart,
                xEnd: xEnd,
                xCurrent: xCurrent + viz.position.w,
                nodes: nodes,
                visualizations: visualizations,
            });
        }
    });
    return visualizations;
};
/**
 * Add edge to the provided list
 * @param {Object} param - Params containing edge info
 * @param {num} param.edges - the list to add the edge to
 * @param {Object} param.edgeStart - the start of the edge
 * @param {Object} param.edgeEnd - the end of the edge
 * @param {Object[][]} param.nodes - The map of x,y coordinates to visualizations that touch that (x,y)
 */
var addEdge = function (_a) {
    var edges = _a.edges, edgeStart = _a.edgeStart, edgeEnd = _a.edgeEnd, nodes = _a.nodes;
    var orientation = edgeStart.y === edgeEnd.y ? 'horizontal' : 'vertical';
    // Find all visualizations that are affected by this edge
    var visualizations = orientation === 'vertical'
        ? findVizAlongVerticalEdge({
            x: edgeStart.x,
            yStart: edgeStart.y,
            yEnd: edgeEnd.y,
            nodes: nodes,
        })
        : findVizAlongHorizontalEdge({
            y: edgeStart.y,
            xStart: edgeStart.x,
            xEnd: edgeEnd.x,
            nodes: nodes,
        });
    edges.push({
        item: getNextEdgeId(),
        edgeStart: edgeStart,
        edgeEnd: edgeEnd,
        visualizations: Array.from(visualizations),
        orientation: orientation,
    });
};
/**
 * If there is no incoming edge from the top, return true
 * @param {num} y - Current y position to compare against
 * @param {Object[]} visualizations - Array of visualizations attached to the node at (x, y). Length will be 1 to 4.
 * @returns {boolean}
 */
var shouldTraverseDown = function (y, visualizations) {
    return visualizations.every(function (viz) { return viz.position.y >= y; });
};
/**
 * If there is no incoming edge from the left, return true
 * @param {num} x - Current x position to compare against
 * @param {Object[]} visualizations - Array of visualizations attached to the node at (x, y). Length will be 1 to 4.
 * @returns {boolean}
 */
var shouldTraverseRight = function (x, visualizations) {
    return visualizations.every(function (viz) { return viz.position.x >= x; });
};
/**
 * Find the offset to the next node.
 * @param {Object} param - Param object to find offset to next node
 * @param {Number} param.x - The x co-ordinate of the current position to find offset from
 * @param {Number} param.y - The y co-ordinate of the current position to find offset from
 * @param {Object[]} param.visualizations - Array of visualizations attached to the node at (x, y). Length will be 1 to 4.
 * @param {Object} param.visualizations[].position - Position information of the visualization
 * @param {String} param.type - The type of co-ordinate. One of 'w' or 'h'.
 * @returns {number}
 */
var findOffset = function (_a) {
    var x = _a.x, y = _a.y, visualizations = _a.visualizations, type = _a.type;
    for (var i = 0; i < visualizations.length; i += 1) {
        var position = visualizations[i].position;
        if (position.y === y && position.x === x) {
            return position[type];
        }
    }
    // This for-loop is only for finding the bottom canvas edge and the right canvas edge
    for (var i = 0; i < visualizations.length; i += 1) {
        var position = visualizations[i].position;
        if (type === 'w' && position.x === x) {
            // horizontal canvas edge
            return position.w;
        }
        if (type === 'h' && position.y === y) {
            // vertical canvas edge
            return position.h;
        }
    }
    return 0;
};
/**
 * Traverse right along nodes, creating or extending edges
 * @param {Object} param - Param object to traverse right along layout
 * @param {Object[][]} param.nodes - An object that maps {x, y} coord to an array of visualizations. Indexed as nodes[x][y].
 * @param {Object[]} param.edges - The resulting array of edges that gets mutated
 * @param {Number} param.x - x coordinate of current node
 * @param {Number} param.y - y coordinate of current node
 * @param {Object} param.edgeStart - The { x, y } coordinates of start of edge
 * @param {Boolean} param.canTraverseDown - Used to prevent loops during indirect recursion
 */
function traverseRight(_a) {
    var x = _a.x, y = _a.y, nodes = _a.nodes, edges = _a.edges, edgeStart = _a.edgeStart, _b = _a.canTraverseDown, canTraverseDown = _b === void 0 ? true : _b;
    // Check if we should traverse down (if there is no incoming edge)
    // canTraverseRight must be false to avoid endless loop
    if (canTraverseDown && shouldTraverseDown(y, nodes[x][y])) {
        // eslint-disable-next-line @typescript-eslint/no-use-before-define
        traverseDown({
            x: x,
            y: y,
            nodes: nodes,
            edges: edges,
            edgeStart: { x: x, y: y },
            canTraverseRight: false,
        });
    }
    // Check if horizontal edge ends here
    // 'w' signifies we want width offset returned as opposed to height
    var offset = findOffset({ x: x, y: y, visualizations: nodes[x][y], type: 'w' });
    // Case 1 for ending edge: can't go right anymore (hit a viz OR end of dashboard), create edge up to this point.
    if (!offset) {
        addEdge({ edges: edges, edgeStart: edgeStart, edgeEnd: { x: x, y: y }, nodes: nodes });
        return;
    }
    // Case 2 for ending edge: reached window, need to create edge and start new one to avoid merging across window
    var isWindow = nodes[x][y].length === 4; // 4-way intersection
    if (isWindow) {
        addEdge({ edges: edges, edgeStart: edgeStart, edgeEnd: { x: x, y: y }, nodes: nodes });
        // Continue traversing right, starting with a new edge from current position
        traverseRight({
            x: x + offset,
            y: y,
            nodes: nodes,
            edges: edges,
            edgeStart: { x: x, y: y },
        });
        return;
    }
    // Continue traversing right, merging the past edge with the next
    traverseRight({
        x: x + offset,
        y: y,
        nodes: nodes,
        edges: edges,
        edgeStart: edgeStart,
    });
}
/**
 * Traverse right along nodes, creating or extending edges
 * @param {Object} param - Param object to traverse down along layout
 * @param {Object[][]} param.nodes - An object that maps {x, y} coord to an array of visualizations. Indexed as nodes[x][y].
 * @param {Object[]} param.edges - The resulting array of edges that gets mutated
 * @param {Number} param.x - x coordinate of current node
 * @param {Number} param.y - y coordinate of current node
 * @param {Object} param.edgeStart - The { x, y } coordinates of start of edge
 * @param {Boolean} param.canTraverseRight - Used to prevent loops during indirect recursion
 */
function traverseDown(_a) {
    var x = _a.x, y = _a.y, nodes = _a.nodes, edges = _a.edges, edgeStart = _a.edgeStart, _b = _a.canTraverseRight, canTraverseRight = _b === void 0 ? true : _b;
    if (canTraverseRight && shouldTraverseRight(x, nodes[x][y])) {
        traverseRight({
            x: x,
            y: y,
            nodes: nodes,
            edges: edges,
            edgeStart: { x: x, y: y },
            canTraverseDown: false,
        });
    }
    // Check if vertical edge ends here
    var offset = findOffset({ x: x, y: y, visualizations: nodes[x][y], type: 'h' });
    // Case 1 for ending edge: can't go down anymore (hit a viz OR end of dashboard), create edge up to this point.
    if (!offset) {
        addEdge({ edges: edges, edgeStart: edgeStart, edgeEnd: { x: x, y: y }, nodes: nodes });
        return;
    }
    // Case 2 for ending edge: reached window, need to create edge and start new one to avoid merging across window
    var isWindow = nodes[x][y].length === 4;
    if (isWindow) {
        addEdge({ edges: edges, edgeStart: edgeStart, edgeEnd: { x: x, y: y }, nodes: nodes });
        // Start a new edge from current position
        traverseDown({
            x: x,
            y: y + offset,
            nodes: nodes,
            edges: edges,
            edgeStart: { x: x, y: y },
        });
        return;
    }
    // Continue traversing, thus "merging" edges
    traverseDown({
        x: x,
        y: y + offset,
        nodes: nodes,
        edges: edges,
        edgeStart: edgeStart,
    });
}
/**
 * Compute the vertical edges for every canvas row - a row that spans the entire width of the canvas
 * @param {Object} param
 * @param {AbsoluteBlockItem[]} param.layout - Layout structure
 * @param {EdgeItem[]} param.edges - The resulting array of edges that gets mutated
 * @param {Number} param.canvasWidth - Canvas width
 */
var computeVerticalCanvasEdges = function (_a) {
    var edges = _a.edges, canvasWidth = _a.canvasWidth, layout = _a.layout;
    var nodes = getNodes(layout);
    if (nodes == null) {
        return;
    }
    // get all the horizontal edges that span the entire canvas width
    var sortedRowEdges = edges
        .filter(function (edge) {
        return edge.orientation === 'horizontal' &&
            edge.edgeStart.x === 0 &&
            edge.edgeEnd.x === canvasWidth;
    })
        .sort(function (a, b) { return a.edgeStart.y - b.edgeStart.y; });
    /**
     * iterate through the sorted horizontal edges to get their start and end coordinates
     * vertical edges between canvas row A and canvas row B will span from edgeStartA to edgeStartB and edgeEndA to edgeEndB
     */
    for (var i = 0; i < sortedRowEdges.length - 1; i += 1) {
        var _b = sortedRowEdges[i], edgeStartA = _b.edgeStart, edgeEndA = _b.edgeEnd;
        var _c = sortedRowEdges[i + 1], edgeStartB = _c.edgeStart, edgeEndB = _c.edgeEnd;
        addEdge({
            edges: edges,
            edgeStart: edgeStartA,
            edgeEnd: edgeStartB,
            nodes: nodes,
        });
        addEdge({
            edges: edges,
            edgeStart: edgeEndA,
            edgeEnd: edgeEndB,
            nodes: nodes,
        });
    }
};
/**
 * Gets all the edges given a layout of AbsoluteBlockItems
 * @param {AbsoluteBlockItem[]} layout - Array of AbsoluteBlockItems
 * @returns {EdgeItem[]} - Array of computed edges
 */
var getAllEdges = function (layout) {
    var edges = [];
    var nodes = getNodes(layout);
    if (nodes === null || nodes[0] === undefined || nodes[0][0] === undefined) {
        // When no visualizations in the layout structure
        // OR when there is no visualization at (0,0), which this algorithm assumes
        return [];
    }
    // run the algorithm
    traverseRight({
        x: 0,
        y: 0,
        nodes: nodes,
        edges: edges,
        edgeStart: { x: 0, y: 0 },
    });
    return edges;
};
exports.getAllEdges = getAllEdges;
/**
 * Compute edges given a valid layout, canvasHeight, and canvasWidth
 * @param {Object} param - Param object containing layout, canvasHeight, canvasWidth
 * @param {Object[]} param.layout - Array of visualizations from the dashboard layout definition
 * @param {Number} param.canvasHeight - Canvas height
 * @param {Number} param.canvasWidth - Canvas width
 * @returns {Object[]} - Array of computed edges
 */
var computeEdges = function (_a) {
    var layout = _a.layout, canvasHeight = _a.canvasHeight, canvasWidth = _a.canvasWidth;
    if (layout === undefined) {
        return [];
    }
    var edges = exports.getAllEdges(layout);
    // remove the computed left and right vertical canvas edges as they span the entire height of the canvas
    edges = edges.filter(function (edge) {
        return !(isLeftEdge(edge) || isRightEdge(edge, canvasWidth));
    });
    // recompute the vertical canvas edges for each canvas row where the row spans the entire width of the canvas
    computeVerticalCanvasEdges({ edges: edges, layout: layout, canvasWidth: canvasWidth });
    // Additionally, the top and bottom edge are there, but set to hidden
    edges = edges.map(function (edge) {
        var isCanvasEdge = false;
        if (isTopEdge(edge) ||
            isRightEdge(edge, canvasWidth) ||
            isBottomEdge(edge, canvasHeight) ||
            isLeftEdge(edge)) {
            isCanvasEdge = true;
        }
        return __assign(__assign({}, edge), { isCanvasEdge: isCanvasEdge });
    });
    return edges;
};
exports.computeEdges = computeEdges;
/**
 * Format edge according to a given padding and edge thickness
 * @param {Object} param - Param object containing edge, padding, and edgeThickness
 * @param {Object} param.edge - Edge object
 * @param {Number} param.padding - Layout padding
 * @param {Number} param.edgeThickness - Thickness of edge
 * @returns {Object} - Returns formatted edge object
 */
var formatEdge = function (_a) {
    var edge = _a.edge, _b = _a.padding, padding = _b === void 0 ? 0 : _b, _c = _a.edgeThickness, edgeThickness = _c === void 0 ? 0 : _c;
    // Formatted edges are centered between visualizations and respect the padding (gutter-size) between them
    var formattedEdgeStart = __assign({}, edge.edgeStart);
    var formattedEdgeEnd = __assign({}, edge.edgeEnd);
    if (edge.orientation === 'horizontal') {
        formattedEdgeStart.x += padding;
        formattedEdgeStart.y -= edgeThickness / 2;
        formattedEdgeEnd.x -= padding;
        formattedEdgeEnd.y -= edgeThickness / 2;
    }
    else {
        formattedEdgeStart.y += padding;
        formattedEdgeStart.x -= edgeThickness / 2;
        formattedEdgeEnd.y -= padding;
        formattedEdgeEnd.x -= edgeThickness / 2;
    }
    return __assign(__assign({}, edge), { edgeStart: formattedEdgeStart, edgeEnd: formattedEdgeEnd });
};
exports.formatEdge = formatEdge;
/**
 * Format visualization according to a given padding
 * @param {Object} param - Param object containing item and padding
 * @param {Object} param.item - Visualization object
 * @param {Number} param.padding - Layout padding
 * @returns {AbsoluteBlockItem} - Returns formatted edge object
 */
var applyVizPadding = function (_a) {
    var item = _a.item, _b = _a.padding, padding = _b === void 0 ? 0 : _b;
    var _c = item.position, x = _c.x, y = _c.y, w = _c.w, h = _c.h;
    return __assign(__assign({}, item), { position: {
            x: x + padding,
            y: y + padding,
            w: w - 2 * padding,
            h: h - 2 * padding,
        } });
};
exports.applyVizPadding = applyVizPadding;
/**
 * Determines Upper and Lower boundaries of an edge given its visualizations around it
 * @param {Object[]} visualizations - The visualizations surrounding the edge
 * @param {Number} y - The y position of the selected edge
 * @param {Number} minHeight - minimum Item Height Value
 * @param {Boolean} isFullWidthEdge - If the edge we are getting boundaries of is the size of canvas width
 * @returns {Object} - returns the boundaries in an object
 */
var getVerticalBoundaries = function (_a) {
    var visualizations = _a.visualizations, y = _a.y, minHeight = _a.minHeight, _b = _a.isFullWidthEdge, isFullWidthEdge = _b === void 0 ? false : _b;
    var boundaries = {
        upperBoundary: Number.NEGATIVE_INFINITY,
        lowerBoundary: Number.POSITIVE_INFINITY,
    };
    var comparePosition = function (position) {
        // If viz is below of the edge
        // When the edge is a full width edge, there is no lower boundary
        //  since dragging down increases canvas size
        if (position.y >= y && !isFullWidthEdge) {
            boundaries.lowerBoundary = Math.min(boundaries.lowerBoundary, position.y + position.h - minHeight);
        }
        // If viz is above the edge
        if (position.y < y) {
            boundaries.upperBoundary = Math.max(boundaries.upperBoundary, position.y + minHeight);
        }
    };
    visualizations.forEach(function (viz) { return comparePosition(viz.position); });
    return boundaries;
};
exports.getVerticalBoundaries = getVerticalBoundaries;
/**
 * Determines Left and Right boundaries of an edge given its visualizations around it
 * @param {Object[]} visualizations - The visualizations surrounding the edge
 * @param {Number} x - The x position of the selected edge
 * @param {Number} minWidth - minimum Item Width Value
 * @returns {Object} - returns the boundaries in an object
 */
var getHorizontalBoundaries = function (_a) {
    var visualizations = _a.visualizations, x = _a.x, minWidth = _a.minWidth;
    var boundaries = {
        rightBoundary: Number.POSITIVE_INFINITY,
        leftBoundary: Number.NEGATIVE_INFINITY,
    };
    var comparePosition = function (position) {
        if (position.x >= x) {
            // If viz is to the right of the edge
            boundaries.rightBoundary = Math.min(boundaries.rightBoundary, position.x + position.w - minWidth);
        }
        if (position.x < x) {
            // If viz is to the left of the edge
            boundaries.leftBoundary = Math.max(boundaries.leftBoundary, position.x + minWidth);
        }
    };
    visualizations.forEach(function (viz) { return comparePosition(viz.position); });
    return boundaries;
};
exports.getHorizontalBoundaries = getHorizontalBoundaries;
/**
 * Determines the next edge position for movement up and down of a horizontal edge
 * @param {Object} edge - the current moving edge
 * @param {Number} offset - offset to move edge
 * @param {Object} options.edgeBoundaries Object with lower/upper boundaries
 * @returns {Object} - returns edge with updated position
 */
var moveHorizontalEdge = function (_a) {
    var edge = _a.edge, offset = _a.offset, _b = _a.edgeBoundaries, upperBoundary = _b.upperBoundary, lowerBoundary = _b.lowerBoundary;
    // Update edge to either the offset value,
    // or the defined maximum/minimum based on min viz height/width
    var updatedY = offset < 0
        ? Math.max(upperBoundary, edge.edgeStart.y + offset)
        : Math.min(lowerBoundary, edge.edgeStart.y + offset);
    return __assign(__assign({}, edge), { edgeStart: {
            x: edge.edgeStart.x,
            y: updatedY,
        }, edgeEnd: {
            x: edge.edgeEnd.x,
            y: updatedY,
        } });
};
exports.moveHorizontalEdge = moveHorizontalEdge;
/**
 * Determines the next edge position for movement left and right of a vertical edge
 * @param {Object} edge - the current moving edge
 * @param {Number} offset - offset to move edge
 * @param {Object} options.edgeBoundaries Object with left/right boundaries
 * @returns {Object} - returns edge with updated position
 */
var moveVerticalEdge = function (_a) {
    var edge = _a.edge, offset = _a.offset, _b = _a.edgeBoundaries, leftBoundary = _b.leftBoundary, rightBoundary = _b.rightBoundary;
    var updatedX = offset < 0
        ? Math.max(leftBoundary, edge.edgeStart.x + offset)
        : Math.min(rightBoundary, edge.edgeStart.x + offset);
    return __assign(__assign({}, edge), { edgeStart: {
            x: updatedX,
            y: edge.edgeStart.y,
        }, edgeEnd: {
            x: updatedX,
            y: edge.edgeEnd.y,
        } });
};
exports.moveVerticalEdge = moveVerticalEdge;
/**
 * find edges that the given edge should snap to, according to the snap range
 * @param {Object} options
 * @param {Object} options.edge the edge being dragged, edge has the structure
 * @param {array}  options.edges all the edges that are parallel to target edge and within the boundary
 * @param {Number} options.snapRange the range within which that triggers snapping
 * @returns {Object} updatedEdge and snappableEdges
 */
var findSnappableEdges = function (_a) {
    var _b, _c;
    var edge = _a.edge, edges = _a.edges, snapRange = _a.snapRange;
    var coordinate = edge.orientation === 'horizontal' ? 'y' : 'x';
    var snappableEdges = edges.reduce(function (currentSnappableEdges, nextEdge) {
        var nextEdgeDistance = Math.abs(nextEdge.edgeStart[coordinate] - edge.edgeStart[coordinate]);
        // nextEdge is in range
        if (nextEdgeDistance <= snapRange) {
            if (currentSnappableEdges.length === 0) {
                return [nextEdge];
            }
            var lastEdge = currentSnappableEdges[currentSnappableEdges.length - 1];
            var lastEdgeDistance = Math.abs(lastEdge.edgeStart[coordinate] - edge.edgeStart[coordinate]);
            // find new closest snappable edge
            if (nextEdgeDistance < lastEdgeDistance) {
                return [nextEdge];
            }
            // it is possible there are several snappable edges having the same x or y value
            if (nextEdgeDistance === lastEdgeDistance) {
                return __spread(currentSnappableEdges, [nextEdge]);
            }
        }
        // nextEdge is out of range
        return __spread(currentSnappableEdges);
    }, []);
    // if no snappable edge, snap to itself
    var firstSnappableEdge = snappableEdges.length > 0 ? snappableEdges[0] : edge;
    return {
        updatedEdge: __assign(__assign({}, edge), { edgeStart: __assign(__assign({}, edge.edgeStart), (_b = {}, _b[coordinate] = firstSnappableEdge.edgeStart[coordinate], _b)), edgeEnd: __assign(__assign({}, edge.edgeEnd), (_c = {}, _c[coordinate] = firstSnappableEdge.edgeEnd[coordinate], _c)) }),
        snappableEdges: snappableEdges,
    };
};
exports.findSnappableEdges = findSnappableEdges;
/**
 * Find all the edges that could be snapped to, given the limitations enforced by the surrounding visualizations.
 * @param {Object} options
 * @param {Object} options.edge the edge being dragged
 * @param {array}  options.edges all the edges on canvas
 * @param {Object} options.edgeBoundaries Object with either lower/upper or left/right boundaries
 * @returns {array} the edges that are within the boundary of the edge being moved
 */
var findEdgesInBoundary = function (_a) {
    var edge = _a.edge, edges = _a.edges, edgeBoundaries = _a.edgeBoundaries;
    var orientation = edge.orientation;
    if (orientation === 'horizontal') {
        return edges.filter(function (e) {
            return e.orientation === 'horizontal' &&
                e.edgeStart.y >=
                    edgeBoundaries.upperBoundary &&
                e.edgeStart.y <=
                    edgeBoundaries.lowerBoundary &&
                e !== edge;
        });
    }
    if (orientation === 'vertical') {
        return edges.filter(function (e) {
            return e.orientation === 'vertical' &&
                e.edgeStart.x >=
                    edgeBoundaries.leftBoundary &&
                e.edgeStart.x <=
                    edgeBoundaries.rightBoundary &&
                e !== edge;
        });
    }
    // can't match any edge because the orientation is invalid, this shouldn't happen.
    return [];
};
exports.findEdgesInBoundary = findEdgesInBoundary;


/***/ }),
/* 12 */
/***/ (function(module, exports) {

module.exports = require("@splunk/dashboard-utils/uniqueId");

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.default = {
    showTitleAndDescription: {
        type: 'boolean',
        default: true,
        description: 'A Boolean value to determine whether to display the Canvas Title and Description or not.',
    },
    submitButton: {
        type: 'boolean',
        description: 'You can also specify the layout option "submitButton". When set to true, a user must click a Submit button in order for the change in input selection to take effect (e.g. rerun searches with new dropdown values). If set to false, or if not specified at all, the dashboard will immediately refresh when a user makes a change in input selection.',
    },
    submitOnDashboardLoad: {
        type: 'boolean',
        default: false,
        description: 'A Boolean value to determine whether inputs should submit their default values (if they exist) on initial dashboard load in order to allow searches to run once before requiring submit button to be used. To be used when `submitButton` is set to true.',
    },
};


/***/ }),
/* 14 */
/***/ (function(module, exports) {

module.exports = require("@splunk/dashboard-context");

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateBackgroundImage = exports.getImageDimension = exports.invalidImageSizeType = exports.validImageWidthHeight = exports.validImagePos = exports.isFromImageRegistry = void 0;
var console_1 = __importDefault(__webpack_require__(5));
var isEmpty_1 = __importDefault(__webpack_require__(25));
// /**
//  * Check whether image src url is valid or not
//  * @method validImageSrc
//  * @param {String} src
//  */
// export const validImageSrc = src => {
//     const img = new Image();
//     img.onerror = () => {
//         console.error(`Background image url ${src} is invalid`);
//     };
//     img.src = src
// };
/**
 * check if an image is from Image Registry
 * @param {*} src
 */
var isFromImageRegistry = function (src) {
    if (src === void 0) { src = ''; }
    var _a = __read(src.split('://'), 1), type = _a[0];
    return (src.indexOf('://') > -1 &&
        type !== 'http' &&
        type !== 'https' &&
        type !== 'ftp' &&
        type !== 'file');
};
exports.isFromImageRegistry = isFromImageRegistry;
/**
 * Check whether image position is valid or not
 * @method validImagePos
 * @param {Number} x
 * @param {Number} y
 * @param {Number} canvasWidth
 * @param {Number} canvasHeight
 * @returns {Boolean}
 */
var validImagePos = function (_a) {
    var x = _a.x, y = _a.y, canvasWidth = _a.canvasWidth, canvasHeight = _a.canvasHeight;
    return !!(x != null &&
        Number.isInteger(x) &&
        y != null &&
        Number.isInteger(y) &&
        x <= canvasWidth &&
        y <= canvasHeight &&
        x >= 0 &&
        y >= 0);
};
exports.validImagePos = validImagePos;
/**
 * Check whether image width and height is valid or not
 * @method validImageWidthHeight
 * @param {Number} imageWidth //Defaulted to 1 because w can't be undefined
 * @param {Number} imageHeight //Defaulted to 1 because h can't be undefined
 * @param {Number} canvasWidth
 * @param {Number} canvasHeight
 * @returns {Boolean}
 */
var validImageWidthHeight = function (imageWidth, imageHeight) {
    if (imageWidth === void 0) { imageWidth = 1; }
    if (imageHeight === void 0) { imageHeight = 1; }
    return !!(Number.isInteger(imageWidth) &&
        Number.isInteger(imageHeight) &&
        imageWidth > 0 &&
        imageHeight > 0);
};
exports.validImageWidthHeight = validImageWidthHeight;
/**
 * Check whether image size type is valid or not (cover/auto/contain/undefined)
 * @method invalidImageSizeType
 * @param {String} sizeType
 * @returns {Boolean}
 */
var invalidImageSizeType = function (sizeType) {
    return !!(sizeType !== 'cover' &&
        sizeType !== 'contain' &&
        sizeType !== 'auto' &&
        sizeType !== undefined);
};
exports.invalidImageSizeType = invalidImageSizeType;
/**
 * Return the original width and height of a valid image
 * @method getImageWidthHeight
 * @param {String} imgSrc
 * @returns {Number. Number} Image width and height
 */
var getImageDimension = function (imgSrc) {
    var img = new Image();
    try {
        img.src = imgSrc;
        img.style.position = 'absolute';
        img.style.left = '-9999'; // Image width must not exceed 9999 pixels
        img.style.visibility = 'hidden';
        document.body.appendChild(img);
        var height = img.naturalHeight;
        var width = img.naturalWidth;
        return { width: width, height: height };
    }
    catch (ex) {
        return { width: 0, height: 0 };
    }
    finally {
        if (document.body.contains(img)) {
            document.body.removeChild(img); // Removes the image from the DOM
        }
    }
};
exports.getImageDimension = getImageDimension;
/**
 * Check whether background image options are valid or not. Default to x:0, y:0, w:0, h:0 and sizeType:'auto'
 * @method validateBackgroundImage
 * @param {Object} backgroundImage
 * @param {String} backgroundImage.src
 * @param {Number} backgroundImage.x
 * @param {Number} backgroundImage.y
 * @param {Number} backgroundImage.w
 * @param {Number} backgroundImage.h
 * @param {String} backgroundImage.sizeType
 * @param {Number} width
 * @param {Number} height
 * @returns {Object}
 */
var validateBackgroundImage = function (_a) {
    var _b = _a.backgroundImage, backgroundImage = _b === void 0 ? {} : _b, canvasWidth = _a.canvasWidth, canvasHeight = _a.canvasHeight;
    var src = backgroundImage.src;
    var x = backgroundImage.x, y = backgroundImage.y, w = backgroundImage.w, h = backgroundImage.h, sizeType = backgroundImage.sizeType;
    if (isEmpty_1.default(backgroundImage)) {
        return { src: src, x: x, y: y, w: w, h: h, sizeType: sizeType };
    }
    if (src == null) {
        return { src: src, x: x, y: y, w: w, h: h, sizeType: sizeType };
    }
    // validImageSrc(src); make no sense to validate but not display errors.
    if (!exports.validImagePos({ x: x, y: y, canvasWidth: canvasWidth, canvasHeight: canvasHeight })) {
        console_1.default.warn("Invalid background image position, x: " + x + " y: " + y + ". Defaulting to x: 0, y: 0");
        x = 0;
        y = 0;
    }
    if (w == null &&
        h == null &&
        (sizeType == null || exports.invalidImageSizeType(sizeType))) {
        console_1.default.warn("Invalid background image sizeType, " + sizeType + ". Defaulting to contain");
        sizeType = 'contain';
    }
    else if ((sizeType == null || exports.invalidImageSizeType(sizeType)) &&
        ((w != null && h == null) ||
            (w == null && h != null) ||
            !exports.validImageWidthHeight(w, h))) {
        console_1.default.warn("Invalid background image width and height, w: " + w + " h: " + h + ". Defaulting to image original size");
        w = w || 0;
        h = h || 0;
    }
    return { src: src, x: x, y: y, w: w, h: h, sizeType: sizeType };
};
exports.validateBackgroundImage = validateBackgroundImage;


/***/ }),
/* 16 */
/***/ (function(module, exports) {

module.exports = require("lodash/noop");

/***/ }),
/* 17 */
/***/ (function(module, exports) {

module.exports = require("lodash/findLast");

/***/ }),
/* 18 */
/***/ (function(module, exports) {

module.exports = require("lodash/isNumber");

/***/ }),
/* 19 */
/***/ (function(module, exports) {

module.exports = require("lodash/reduce");

/***/ }),
/* 20 */
/***/ (function(module, exports) {

module.exports = require("lodash/pullAt");

/***/ }),
/* 21 */
/***/ (function(module, exports) {

module.exports = require("lodash/cloneDeep");

/***/ }),
/* 22 */
/***/ (function(module, exports) {

module.exports = require("lodash/sortBy");

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.getBlockItem = exports.computePortPosition = exports.getAllBlockItems = exports.findSelectedBlockItems = void 0;
var findSelectedBlockItems = function (_a) {
    var layoutStructure = _a.layoutStructure, selectedItems = _a.selectedItems;
    return layoutStructure.filter(function (_a) {
        var item = _a.item, type = _a.type;
        return selectedItems.findIndex(function (_a) {
            var id = _a.id;
            return item === id && (type === 'block' || !type);
        }) >= 0;
    });
};
exports.findSelectedBlockItems = findSelectedBlockItems;
var getAllBlockItems = function (_a) {
    var layoutStructure = _a.layoutStructure, _b = _a.layoutStructureState, layoutStructureState = _b === void 0 ? {} : _b;
    return layoutStructure
        .map(function (item) { var _a; return (_a = layoutStructureState[item.item]) !== null && _a !== void 0 ? _a : item; })
        .filter(function (_a) {
        var type = _a.type;
        return type === 'block' || !type;
    });
};
exports.getAllBlockItems = getAllBlockItems;
/**
 * compute port position for a given block item
 * @param {Object} blockItem
 * @param {String} port
 */
var computePortPosition = function (blockItem, port) {
    var blockPosition = blockItem.position;
    switch (port) {
        case 'n':
            return {
                x: Math.round(blockPosition.x + blockPosition.w / 2),
                y: blockPosition.y,
            };
        case 'w':
            return {
                x: blockPosition.x,
                y: Math.round(blockPosition.y + blockPosition.h / 2),
            };
        case 'e':
            return {
                x: blockPosition.x + blockPosition.w,
                y: Math.round(blockPosition.y + blockPosition.h / 2),
            };
        case 's':
        default:
            return {
                x: Math.round(blockPosition.x + blockPosition.w / 2),
                y: blockPosition.y + blockPosition.h,
            };
    }
};
exports.computePortPosition = computePortPosition;
var getBlockItem = function (_a) {
    var layoutStructure = _a.layoutStructure, id = _a.id;
    var blockItem = layoutStructure.find(function (_a) {
        var item = _a.item;
        return item === id;
    });
    if (!blockItem || blockItem.type === 'line') {
        throw Error(id + " refers to an invalid block item");
    }
    return blockItem;
};
exports.getBlockItem = getBlockItem;


/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.HANDLE_DIRECTIONS = exports.getHorizontalPosition = exports.getVerticalPosition = void 0;
/**
 * Compute absolute horizontal position (top/bottom) based on dir
 * @param {String} dir
 * @param {Number} offset
 * @returns {String}
 */
var getVerticalPosition = function (dir, offset) {
    if (dir[0] === 'n') {
        return "top: -" + offset + "px";
    }
    if (dir[0] === 's') {
        return "bottom: -" + offset + "px";
    }
    return "top: calc(50% - " + offset + "px)";
};
exports.getVerticalPosition = getVerticalPosition;
/**
 * Compute absolute vertical position (left/right) based on dir
 * @param {String} dir
 * @param {Number} offset
 * @returns {String}
 */
var getHorizontalPosition = function (dir, offset) {
    if (dir.slice(-1) === 'w') {
        return "left: -" + offset + "px";
    }
    if (dir.slice(-1) === 'e') {
        return "right: -" + offset + "px";
    }
    return "left: calc(50% - " + offset + "px)";
};
exports.getHorizontalPosition = getHorizontalPosition;
exports.HANDLE_DIRECTIONS = [
    'n',
    'ne',
    'e',
    'se',
    's',
    'sw',
    'w',
    'nw',
];


/***/ }),
/* 25 */
/***/ (function(module, exports) {

module.exports = require("lodash/isEmpty");

/***/ }),
/* 26 */,
/* 27 */,
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 *
 */
var BaseLayoutApi = /** @class */ (function () {
    function BaseLayoutApi() {
        var _this = this;
        this.emitTelemetry = function (payload) {
            if (!_this.telemetry) {
                return false;
            }
            _this.telemetry.emit(__assign({ source: 'layoutApi' }, payload));
            return true;
        };
    }
    return BaseLayoutApi;
}());
exports.default = BaseLayoutApi;


/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.getAllLineItems = exports.handleSingleLineDragStart = exports.handleSingleLineMove = exports.findSelectedLineItems = exports.computeLineAbsPosition = void 0;
var layoutUtils_1 = __webpack_require__(2);
var blockUtils_1 = __webpack_require__(23);
var computeLineAbsPosition = function (_a) {
    var layoutStructure = _a.layoutStructure, position = _a.position;
    var from = position.from, to = position.to;
    if ('item' in from && 'port' in from) {
        var blockItem = blockUtils_1.getBlockItem({ layoutStructure: layoutStructure, id: from.item });
        from = blockUtils_1.computePortPosition(blockItem, from.port);
    }
    if ('item' in to && 'port' in to) {
        var blockItem = blockUtils_1.getBlockItem({ layoutStructure: layoutStructure, id: to.item });
        to = blockUtils_1.computePortPosition(blockItem, to.port);
    }
    return {
        from: from,
        to: to,
    };
};
exports.computeLineAbsPosition = computeLineAbsPosition;
var findSelectedLineItems = function (_a) {
    var layoutStructure = _a.layoutStructure, selectedItems = _a.selectedItems;
    return layoutStructure.filter(function (_a) {
        var item = _a.item, type = _a.type;
        return selectedItems.findIndex(function (_a) {
            var id = _a.id;
            return item === id && type === 'line';
        }) >= 0;
    });
};
exports.findSelectedLineItems = findSelectedLineItems;
var handleSingleLineMove = function (_a) {
    var lineId = _a.lineId, offset = _a.offset, layoutStructure = _a.layoutStructure;
    var line = layoutStructure.find(function (item) { return item.item === lineId; });
    var linePosition = exports.computeLineAbsPosition({
        layoutStructure: layoutStructure,
        position: line.position,
    });
    if (layoutUtils_1.isLineConnected({ line: line, dir: 'from' })) {
        line = layoutUtils_1.disconnectLine({
            line: line,
            dir: 'from',
            absPos: linePosition.from,
        });
    }
    if (layoutUtils_1.isLineConnected({ line: line, dir: 'to' })) {
        line = layoutUtils_1.disconnectLine({
            line: line,
            dir: 'to',
            absPos: linePosition.to,
        });
    }
    line = layoutUtils_1.updateLineAbsPosition({
        line: line,
        dir: 'from',
        offset: offset,
    });
    line = layoutUtils_1.updateLineAbsPosition({
        line: line,
        dir: 'to',
        offset: offset,
    });
    return line;
};
exports.handleSingleLineMove = handleSingleLineMove;
var handleSingleLineDragStart = function (_a) {
    var lineId = _a.lineId, layoutStructure = _a.layoutStructure, lineDir = _a.lineDir;
    var line = layoutStructure.find(function (item) { return item.item === lineId; });
    var linePosition = exports.computeLineAbsPosition({
        layoutStructure: layoutStructure,
        position: line.position,
    });
    if (layoutUtils_1.isLineConnected({
        line: line,
        dir: lineDir,
    })) {
        line = layoutUtils_1.disconnectLine({
            line: line,
            dir: lineDir,
            absPos: linePosition[lineDir],
        });
    }
    return line;
};
exports.handleSingleLineDragStart = handleSingleLineDragStart;
var getAllLineItems = function (_a) {
    var layoutStructure = _a.layoutStructure, _b = _a.layoutStructureState, layoutStructureState = _b === void 0 ? {} : _b;
    return layoutStructure
        .map(function (item) { var _a; return (_a = layoutStructureState[item.item]) !== null && _a !== void 0 ? _a : item; })
        .filter(function (_a) {
        var type = _a.type;
        return type === 'line';
    });
};
exports.getAllLineItems = getAllLineItems;


/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var react_1 = __importStar(__webpack_require__(0));
var styled_components_1 = __importDefault(__webpack_require__(1));
var mixins_1 = __webpack_require__(8);
var themes_1 = __webpack_require__(4);
var style_1 = __webpack_require__(31);
var colorUtils_1 = __webpack_require__(32);
var customThemeVariables_1 = __webpack_require__(7);
var imageUtils_1 = __webpack_require__(15);
var useBackgroundImage_1 = __webpack_require__(33);
var GRID_LINE_OPACITY = 0.1;
/**
 * logic for background image size css.
 * @param {BackgroundProps} props
 */
var toBackgroundImageSize = function (props) {
    var _a;
    var _b = imageUtils_1.getImageDimension((_a = props.bgImageSrc) !== null && _a !== void 0 ? _a : ''), width = _b.width, height = _b.height;
    if (props.bgImageWidth && props.bgImageHeight) {
        return style_1.toPx(props.bgImageWidth) + " " + style_1.toPx(props.bgImageHeight);
    }
    if (props.bgImageWidth || props.bgImageHeight) {
        return style_1.toPx(props.bgImageWidth || width) + " " + style_1.toPx(props.bgImageHeight || height);
    }
    if (props.bgImageSizeType) {
        return props.bgImageSizeType;
    }
    return 'contain';
};
/**
 * make sure to only include image related css when backgroundImageSrc is specified.
 * @param {BackgroundProps} props
 */
var toBackgroundImage = function (props) {
    if (props.bgImageSrc) {
        return "\n            background-repeat: no-repeat;\n            background-image: url(\"" + props.bgImageSrc + "\");\n            background-size: " + toBackgroundImageSize(props) + ";\n            background-position:\n                " + style_1.toPx(props.bgImagePositionX) + " " + style_1.toPx(props.bgImagePositionY) + ";\n        ";
    }
    return '';
};
var toScale = function (scale) {
    if (scale) {
        return "\n            transform: scale(" + scale + ");\n            transform-origin: 0 0;\n        ";
    }
    return '';
};
var CanvasContainer = styled_components_1.default.div(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n    ", ";\n    ", ";\n    overflow: ", ";\n    user-select: ", ";\n    position: relative;\n"], ["\n    ", ";\n    ", ";\n    overflow: ", ";\n    user-select: ", ";\n    position: relative;\n"])), mixins_1.reset('block'), function (prop) { return style_1.toDimension({ width: prop.width, height: prop.height }); }, function (prop) { return (prop.showOverflowContent ? 'visible' : 'hidden'); }, function (prop) { return (prop.userSelect ? 'text' : 'none'); });
/**
 * A layer that renders canvas with background color/image
 */
var Background = styled_components_1.default.div(templateObject_2 || (templateObject_2 = __makeTemplateObject(["\n    ", ";\n    ", ";\n    position: relative;\n    background: ", ";\n    ", ";\n    ", ";\n"], ["\n    ", ";\n    ", ";\n    position: relative;\n    background: ",
    ";\n    ", ";\n    ", ";\n"])), mixins_1.reset('inline-block'), function (prop) { return style_1.toDimension({ width: prop.width, height: prop.height }); }, function (prop) {
    return prop.bgColor ||
        // NOTE: this needs to match packages/dashboard-editors/src/layouts/AbsoluteLayoutEditor.jsx
        customThemeVariables_1.customThemeVariables.dashboardBackgroundColor;
}, function (prop) { return toBackgroundImage(prop); }, function (prop) { return toScale(prop.scale); });
/**
 * A layer that renders border
 */
var Border = styled_components_1.default.div(templateObject_3 || (templateObject_3 = __makeTemplateObject(["\n    position: absolute;\n    box-sizing: border-box;\n    border: 2px dashed\n        ", ";\n    left: 0px;\n    top: 0px;\n    right: 0px;\n    bottom: 0px;\n    ", ";\n"], ["\n    position: absolute;\n    box-sizing: border-box;\n    border: 2px dashed\n        ",
    ";\n    left: 0px;\n    top: 0px;\n    right: 0px;\n    bottom: 0px;\n    ", ";\n"])), themes_1.pick({
    enterprise: {
        light: themes_1.variables.gray80,
        dark: themes_1.variables.gray30,
    },
    prisma: themes_1.variables.interactiveColorBorder,
}), function (prop) { return style_1.toDimension({ width: prop.width, height: prop.height }); });
var getGridLineColor = function (props) {
    return props.gridLineColor ||
        themes_1.pick({
            light: '#D8D8D8',
            dark: '#9B9B9B',
        });
};
/**
 * A layer that renders grid
 */
var GridLines = styled_components_1.default.div(templateObject_4 || (templateObject_4 = __makeTemplateObject(["\n    position: absolute;\n    box-sizing: border-box;\n    left: 0px;\n    top: 0px;\n    right: 0px;\n    bottom: 0px;\n    opacity: ", ";\n    ", ";\n    background-size: ", "px\n        ", "px;\n    background-image: repeating-linear-gradient(\n            0deg,\n            ", ",\n            ", " ", ",\n            transparent ", "px,\n            transparent ", "px\n        ),\n        repeating-linear-gradient(\n            -90deg,\n            ", ",\n            ", " ", ",\n            transparent ", "px,\n            transparent ", "px\n        );\n"], ["\n    position: absolute;\n    box-sizing: border-box;\n    left: 0px;\n    top: 0px;\n    right: 0px;\n    bottom: 0px;\n    opacity: ", ";\n    ", ";\n    background-size: ", "px\n        ", "px;\n    background-image: repeating-linear-gradient(\n            0deg,\n            ", ",\n            ", " ", ",\n            transparent ", "px,\n            transparent ", "px\n        ),\n        repeating-linear-gradient(\n            -90deg,\n            ", ",\n            ", " ", ",\n            transparent ", "px,\n            transparent ", "px\n        );\n"])), function (prop) { return prop.gridLineOpacity || GRID_LINE_OPACITY; }, function (prop) { return style_1.toDimension({ width: prop.width, height: prop.height }); }, function (prop) { return prop.gridWidth + prop.gridLineWidth; }, function (prop) { return prop.gridHeight + prop.gridLineWidth; }, getGridLineColor, getGridLineColor, function (prop) { return style_1.toPx(prop.gridLineWidth); }, function (prop) { return prop.gridLineWidth; }, function (prop) { return prop.gridHeight + prop.gridLineWidth; }, getGridLineColor, getGridLineColor, function (prop) { return style_1.toPx(prop.gridLineWidth); }, function (prop) { return prop.gridLineWidth; }, function (prop) { return prop.gridWidth + prop.gridLineWidth; });
/**
 * Canvas is a component that render background for a layout.
 * All visualizations will be displayed on top of a canvas
 */
var Canvas = function (_a, canvasRef) {
    var width = _a.width, height = _a.height, scale = _a.scale, _b = _a.backgroundColor, unsanitizedBgColor = _b === void 0 ? '' : _b, backgroundImageSrc = _a.backgroundImageSrc, backgroundImageSizeType = _a.backgroundImageSizeType, backgroundImageWidth = _a.backgroundImageWidth, backgroundImageHeight = _a.backgroundImageHeight, backgroundImagePositionX = _a.backgroundImagePositionX, backgroundImagePositionY = _a.backgroundImagePositionY, gridLineOpacity = _a.gridLineOpacity, children = _a.children, _c = _a.showOverflowContent, showOverflowContent = _c === void 0 ? false : _c, _d = _a.userSelect, userSelect = _d === void 0 ? false : _d, _e = _a.showGrid, showGrid = _e === void 0 ? false : _e, _f = _a.gridPadding, gridPadding = _f === void 0 ? 0 : _f, _g = _a.gridLineWidth, gridLineWidth = _g === void 0 ? 1 : _g, gridLineColor = _a.gridLineColor, _h = _a.gridWidth, gridWidth = _h === void 0 ? 9 : _h, _j = _a.gridHeight, gridHeight = _j === void 0 ? 9 : _j, _k = _a.showBorder, showBorder = _k === void 0 ? false : _k, _l = _a.cssScaling, cssScaling = _l === void 0 ? true : _l, others = __rest(_a, ["width", "height", "scale", "backgroundColor", "backgroundImageSrc", "backgroundImageSizeType", "backgroundImageWidth", "backgroundImageHeight", "backgroundImagePositionX", "backgroundImagePositionY", "gridLineOpacity", "children", "showOverflowContent", "userSelect", "showGrid", "gridPadding", "gridLineWidth", "gridLineColor", "gridWidth", "gridHeight", "showBorder", "cssScaling"]);
    var imageSrc = useBackgroundImage_1.useBackgroundImage(backgroundImageSrc);
    var containerWidth = scale != null ? width * scale : width;
    var containerHeight = scale != null && cssScaling ? height * scale : height;
    var backgroundColor = colorUtils_1.sanitizeColor(unsanitizedBgColor);
    return (react_1.default.createElement(CanvasContainer, __assign({ "data-test": "canvas-container", "data-width": containerWidth, "data-height": containerHeight, width: cssScaling ? containerWidth : width, height: containerHeight, showOverflowContent: showOverflowContent, userSelect: userSelect, ref: canvasRef }, others),
        react_1.default.createElement(Background, { "data-test": "canvas", "data-width": width, "data-height": height, "data-scale": scale, width: cssScaling ? width : containerWidth, height: height, scale: cssScaling ? scale : undefined, bgColor: backgroundColor, bgImageSrc: imageSrc, bgImageSizeType: backgroundImageSizeType, bgImageWidth: backgroundImageWidth, bgImageHeight: backgroundImageHeight, bgImagePositionX: backgroundImagePositionX, bgImagePositionY: backgroundImagePositionY },
            showBorder && react_1.default.createElement(Border, { width: width, height: height }),
            showGrid && (react_1.default.createElement(GridLines, { width: width, height: height, gridLineOpacity: gridLineOpacity, gridPadding: gridPadding, gridLineWidth: gridLineWidth, gridLineColor: gridLineColor, gridWidth: gridWidth, gridHeight: gridHeight })),
            children)));
};
exports.default = react_1.forwardRef(Canvas);
var templateObject_1, templateObject_2, templateObject_3, templateObject_4;


/***/ }),
/* 31 */
/***/ (function(module, exports) {

module.exports = require("@splunk/dashboard-utils/style");

/***/ }),
/* 32 */
/***/ (function(module, exports) {

module.exports = require("@splunk/dashboard-ui/utils/colorUtils");

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.useBackgroundImage = void 0;
var react_1 = __webpack_require__(0);
var dashboard_context_1 = __importDefault(__webpack_require__(14));
var console_1 = __importDefault(__webpack_require__(5));
var useBackgroundImage = function (backgroundImageSrc) {
    var _a = __read(react_1.useState(''), 2), imageSrc = _a[0], setImageSrc = _a[1];
    var imageRegistry = react_1.useContext(dashboard_context_1.default).imageRegistry;
    /**
     * Check whether backgroundImage src is a remote image url or stored in the image registry. Fetch if its the latter
     * @param string backgroundImageSrc
     */
    var fetchBackgroundImage = function (registry, bgImageSrc) { return __awaiter(void 0, void 0, void 0, function () {
        var imageObject, error_1;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    _a.trys.push([0, 6, , 7]);
                    if (!registry) return [3 /*break*/, 4];
                    if (!registry.isResourceURL(bgImageSrc)) return [3 /*break*/, 2];
                    return [4 /*yield*/, registry.getByURL(bgImageSrc)];
                case 1:
                    imageObject = _a.sent();
                    setImageSrc(imageObject.dataURI);
                    return [3 /*break*/, 3];
                case 2:
                    setImageSrc(bgImageSrc);
                    _a.label = 3;
                case 3: return [3 /*break*/, 5];
                case 4:
                    setImageSrc(bgImageSrc);
                    _a.label = 5;
                case 5: return [3 /*break*/, 7];
                case 6:
                    error_1 = _a.sent();
                    console_1.default.error(error_1); // TODO Refactor error display
                    return [3 /*break*/, 7];
                case 7: return [2 /*return*/];
            }
        });
    }); };
    react_1.useEffect(function () {
        if (backgroundImageSrc) {
            fetchBackgroundImage(imageRegistry, backgroundImageSrc);
        }
    }, [imageRegistry, backgroundImageSrc]);
    return imageSrc;
};
exports.useBackgroundImage = useBackgroundImage;


/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var styled_components_1 = __importDefault(__webpack_require__(1));
var ResponsiveBox = styled_components_1.default.div.attrs(function (_a) {
    var itemId = _a.itemId, x = _a.x, y = _a.y, w = _a.w, h = _a.h, dataTest = _a["data-test"];
    return ({
        'data-test': dataTest !== null && dataTest !== void 0 ? dataTest : 'responsive-box',
        'data-id': itemId,
        'data-test-viz-item-position': x + "," + y + "," + w + "," + h,
        style: {
            width: w + "px",
            height: h + "px",
            top: y + "px",
            left: x + "px",
        },
    });
})(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n    display: block;\n    position: absolute;\n    background: transparent;\n    pointer-events: none;\n    box-sizing: border-box;\n    visibility: ", ";\n    opacity: ", ";\n"], ["\n    display: block;\n    position: absolute;\n    background: transparent;\n    pointer-events: none;\n    box-sizing: border-box;\n    visibility: ",
    ";\n    opacity: ", ";\n"])), function (props) {
    return props.appearance === 'hidden' ? 'hidden' : 'visible';
}, function (props) { return (props.appearance === 'highlighted' ? 1 : 0.5); });
ResponsiveBox.defaultProps = {
    appearance: 'highlighted',
};
exports.default = ResponsiveBox;
var templateObject_1;


/***/ }),
/* 35 */
/***/ (function(module, exports) {

module.exports = require("@splunk/dashboard-ui/hooks/useEventCallback");

/***/ }),
/* 36 */
/***/ (function(module, exports) {

module.exports = require("lodash");

/***/ }),
/* 37 */
/***/ (function(module, exports) {

module.exports = require("@splunk/dashboard-telemetry");

/***/ }),
/* 38 */
/***/ (function(module, exports) {

module.exports = require("@splunk/dashboard-ui/hooks/usePrevious");

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.normalizeAddLayoutItemArgs = void 0;
var deprecated_1 = __importDefault(__webpack_require__(40));
var isPlainObject_1 = __importDefault(__webpack_require__(41));
var normalizeAddLayoutItemArgs = function (args) {
    // make it backward compatible
    if (args.length === 1 && isPlainObject_1.default(args[0])) {
        return args[0];
    }
    deprecated_1.default('Calling addLayoutItem with multiple parameters is deprecated. Please use the object form instead.');
    var _a = __read(args, 3), itemId = _a[0], vizContract = _a[1], type = _a[2];
    return {
        itemId: itemId,
        vizContract: vizContract,
        type: type,
    };
};
exports.normalizeAddLayoutItemArgs = normalizeAddLayoutItemArgs;


/***/ }),
/* 40 */
/***/ (function(module, exports) {

module.exports = require("@splunk/dashboard-utils/deprecated");

/***/ }),
/* 41 */
/***/ (function(module, exports) {

module.exports = require("lodash/isPlainObject");

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var styled_components_1 = __importDefault(__webpack_require__(1));
/**
 * A layer that does not block events
 */
var Layer = styled_components_1.default.div(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n    position: absolute;\n    top: 0px;\n    left: 0px;\n    right: 0px;\n    bottom: 0px;\n    pointer-events: none;\n"], ["\n    position: absolute;\n    top: 0px;\n    left: 0px;\n    right: 0px;\n    bottom: 0px;\n    pointer-events: none;\n"])));
exports.default = Layer;
var templateObject_1;


/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var react_1 = __importStar(__webpack_require__(0));
var ResponsiveBox_1 = __importDefault(__webpack_require__(34));
var ErrorMessageOverlay_1 = __webpack_require__(44);
/**
 * layout item that renders block element
 */
var ResponsiveBlockItem = function (props) {
    var x = props.x, y = props.y, w = props.w, h = props.h, canvasHeight = props.canvasHeight, itemId = props.itemId, errorMessages = props.errorMessages, onItemSelected = props.onItemSelected, renderLayoutItem = props.renderLayoutItem, _a = props.appearance, appearance = _a === void 0 ? 'highlighted' : _a;
    var layoutItem = react_1.useMemo(function () {
        return renderLayoutItem(itemId, {
            width: w,
            height: h,
            y: y,
            canvasHeight: canvasHeight,
        }, 'block', onItemSelected);
    }, [renderLayoutItem, itemId, w, h, y, canvasHeight, onItemSelected]);
    return (react_1.default.createElement(ResponsiveBox_1.default, { "data-test": "absolute-item", itemId: itemId, appearance: appearance, x: x, y: y, w: w, h: h },
        layoutItem,
        react_1.default.createElement(ErrorMessageOverlay_1.ErrorMessageOverlay, { messages: errorMessages })));
};
exports.default = ResponsiveBlockItem;


/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ErrorMessageOverlay = exports.MessageContainer = void 0;
var react_1 = __importDefault(__webpack_require__(0));
var styled_components_1 = __importDefault(__webpack_require__(1));
var prop_types_1 = __importDefault(__webpack_require__(3));
var themes_1 = __webpack_require__(4);
var ErrorOverlay = styled_components_1.default.div(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n    position: absolute;\n    box-sizing: border-box;\n    top: 0;\n    left: 0;\n    height: 100%;\n    width: 100%;\n    pointer-events: none;\n    background-color: ", ";\n    color: white;\n    overflow: hidden;\n    padding: 8px;\n    z-index: 2;\n"], ["\n    position: absolute;\n    box-sizing: border-box;\n    top: 0;\n    left: 0;\n    height: 100%;\n    width: 100%;\n    pointer-events: none;\n    background-color: ",
    ";\n    color: white;\n    overflow: hidden;\n    padding: 8px;\n    z-index: 2;\n"])), themes_1.pick({
    light: '#a81916cc',
    dark: '#a81916b3',
}));
exports.MessageContainer = styled_components_1.default.div(templateObject_2 || (templateObject_2 = __makeTemplateObject(["\n    padding-top: 8px;\n"], ["\n    padding-top: 8px;\n"])));
var OverlayTitle = styled_components_1.default.div(templateObject_3 || (templateObject_3 = __makeTemplateObject(["\n    font-weight: bold;\n"], ["\n    font-weight: bold;\n"])));
var ErrorMessageOverlay = function (_a) {
    var messages = _a.messages;
    if (!messages || messages.length === 0) {
        return null;
    }
    return (react_1.default.createElement(ErrorOverlay, { "data-test": "error-overlay" },
        react_1.default.createElement(OverlayTitle, null, "Layout Errors:"),
        messages.map(function (message) { return (react_1.default.createElement(exports.MessageContainer, { "data-test": "error-overlay-message", key: message }, message)); })));
};
exports.ErrorMessageOverlay = ErrorMessageOverlay;
exports.ErrorMessageOverlay.propTypes = {
    messages: prop_types_1.default.arrayOf(prop_types_1.default.string),
};
var templateObject_1, templateObject_2, templateObject_3;


/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var noop_1 = __importDefault(__webpack_require__(16));
var react_1 = __importStar(__webpack_require__(0));
var styled_components_1 = __importDefault(__webpack_require__(1));
var themes_1 = __webpack_require__(4);
var layoutUtils_1 = __webpack_require__(2);
var LineBox = styled_components_1.default.div(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n    position: absolute;\n    pointer-events: none;\n"], ["\n    position: absolute;\n    pointer-events: none;\n"])));
var AdjustHandle = styled_components_1.default.a.attrs(function (_a) {
    var x = _a.x, y = _a.y;
    return ({
        style: {
            transform: "translate(" + x + "px, " + y + "px)",
        },
    });
})(templateObject_2 || (templateObject_2 = __makeTemplateObject(["\n    width: 10px;\n    height: 10px;\n    left: -5px;\n    top: -5px;\n    background-color: ", ";\n    border-radius: 50%;\n    position: absolute;\n    z-index: 999;\n    pointer-events: auto;\n    cursor: move;\n    user-select: none;\n"], ["\n    width: 10px;\n    height: 10px;\n    left: -5px;\n    top: -5px;\n    background-color: ",
    ";\n    border-radius: 50%;\n    position: absolute;\n    z-index: 999;\n    pointer-events: auto;\n    cursor: move;\n    user-select: none;\n"])), themes_1.pick({
    enterprise: themes_1.variables.accentColorL10,
    prisma: themes_1.variables.interactiveColorPrimary,
}));
var ResponsiveLine = function (_a) {
    var fromX = _a.fromX, fromY = _a.fromY, fromItem = _a.fromItem, fromPort = _a.fromPort, toX = _a.toX, toY = _a.toY, toItem = _a.toItem, toPort = _a.toPort, lineId = _a.lineId, _b = _a.scale, scale = _b === void 0 ? 1 : _b, _c = _a.selectable, selectable = _c === void 0 ? false : _c, _d = _a.editable, editable = _d === void 0 ? false : _d, renderLayoutItem = _a.renderLayoutItem, _e = _a.onItemSelected, onItemSelected = _e === void 0 ? noop_1.default : _e, _f = _a.onLineDragStart, onLineDragStart = _f === void 0 ? noop_1.default : _f, _g = _a.onLineMove, onLineMove = _g === void 0 ? noop_1.default : _g, _h = _a.onLineMoved, onLineMoved = _h === void 0 ? noop_1.default : _h, _j = _a.onLineDrag, onLineDrag = _j === void 0 ? noop_1.default : _j, _k = _a.onLineDragged, onLineDragged = _k === void 0 ? noop_1.default : _k;
    var _l = __read(react_1.useState(null), 2), startPosition = _l[0], setStartPosition = _l[1];
    var _m = __read(react_1.useState(null), 2), action = _m[0], setAction = _m[1];
    var handleLineSelected = react_1.useCallback(function (e) {
        e.stopPropagation();
        setStartPosition(layoutUtils_1.getClientPosition(e, scale));
        setAction('move');
        onItemSelected(e, [{ id: lineId, type: 'line' }]);
    }, [lineId, onItemSelected, scale]);
    var handleMouseDownFrom = react_1.useCallback(function (e) {
        e.stopPropagation();
        setStartPosition(layoutUtils_1.getClientPosition(e, scale));
        setAction('drag');
        onLineDragStart(e, 'from');
    }, [onLineDragStart, scale]);
    var handleMouseDownTo = react_1.useCallback(function (e) {
        e.stopPropagation();
        setStartPosition(layoutUtils_1.getClientPosition(e, scale));
        setAction('drag');
        onLineDragStart(e, 'to');
    }, [onLineDragStart, scale]);
    var handleMouseMove = react_1.useCallback(function (e) {
        if (startPosition == null || action == null) {
            return;
        }
        e.preventDefault();
        var currentPosition = layoutUtils_1.getClientPosition(e, scale);
        var offset = layoutUtils_1.getOffset(currentPosition, startPosition);
        switch (action) {
            case 'drag':
                onLineDrag(e, offset);
                break;
            case 'move':
                onLineMove(e, offset);
                break;
            default:
                break;
        }
    }, [action, onLineDrag, onLineMove, scale, startPosition]);
    var handleMouseUp = react_1.useCallback(function (e) {
        if (startPosition == null || action == null) {
            return;
        }
        setStartPosition(null);
        var currentPosition = layoutUtils_1.getClientPosition(e, scale);
        var offset = layoutUtils_1.getOffset(currentPosition, startPosition);
        switch (action) {
            case 'drag':
                onLineDragged(e, offset);
                break;
            case 'move':
                onLineMoved(e, offset);
                break;
            default:
                break;
        }
    }, [action, onLineDragged, onLineMoved, scale, startPosition]);
    var from = { x: fromX, y: fromY };
    var to = { x: toX, y: toY };
    var boxPos = layoutUtils_1.computeLineBoxPosition(from, to);
    var relativePos = layoutUtils_1.computeLineRelativePosition(from, to, boxPos);
    var lineBoxStyle = react_1.useMemo(function () { return ({
        transform: "translate(" + boxPos.x + "px, " + boxPos.y + "px)",
    }); }, [boxPos.x, boxPos.y]);
    var fromHandleElement = react_1.useMemo(function () {
        if (!editable) {
            return null;
        }
        return (react_1.default.createElement(AdjustHandle, { "data-test": "line-handle-from", "data-test-item": fromItem, "data-test-port": fromPort, x: relativePos.from.x, y: relativePos.from.y, onMouseDown: handleMouseDownFrom }));
    }, [
        editable,
        fromItem,
        fromPort,
        relativePos.from.x,
        relativePos.from.y,
        handleMouseDownFrom,
    ]);
    var tohandleElement = react_1.useMemo(function () {
        if (!editable) {
            return null;
        }
        return (react_1.default.createElement(AdjustHandle, { "data-test": "line-handle-to", "data-test-item": toItem, "data-test-port": toPort, x: relativePos.to.x, y: relativePos.to.y, onMouseDown: handleMouseDownTo }));
    }, [
        editable,
        toItem,
        toPort,
        relativePos.to.x,
        relativePos.to.y,
        handleMouseDownTo,
    ]);
    var lineElement = react_1.useMemo(function () {
        return renderLayoutItem(lineId, {
            from: {
                x: relativePos.from.x,
                y: relativePos.from.y,
            },
            to: {
                x: relativePos.to.x,
                y: relativePos.to.y,
            },
            // todo: this is inconsistent with the ResponsiveBlockitem which accepts the `onSelect` callback as the 4th argument of `renderLayoutItem`.
            onLineSelect: selectable ? handleLineSelected : noop_1.default,
        }, 'line');
    }, [
        handleLineSelected,
        lineId,
        relativePos.from.x,
        relativePos.from.y,
        relativePos.to.x,
        relativePos.to.y,
        renderLayoutItem,
        selectable,
    ]);
    react_1.useEffect(function () {
        if (editable) {
            document.addEventListener('mousemove', handleMouseMove);
            document.addEventListener('mouseup', handleMouseUp);
        }
        return function () {
            document.removeEventListener('mousemove', handleMouseMove);
            document.removeEventListener('mouseup', handleMouseUp);
        };
    }, [editable, handleMouseMove, handleMouseUp]);
    return (react_1.default.createElement(LineBox, { "data-test": "line-box", style: lineBoxStyle, "data-viz-type": "abslayout.line", "data-id": lineId, "data-test-line-position": from.x + "," + from.y + "-" + to.x + "," + to.y },
        fromHandleElement,
        tohandleElement,
        lineElement));
};
exports.default = ResponsiveLine;
var templateObject_1, templateObject_2;


/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var react_1 = __importStar(__webpack_require__(0));
var outlineUtils_1 = __webpack_require__(24);
var ResponsiveBox_1 = __importDefault(__webpack_require__(34));
var layoutUtils_1 = __webpack_require__(2);
var Port_1 = __webpack_require__(47);
var ResizeHandle_1 = __webpack_require__(49);
var noop = function () { return undefined; };
var ResponsiveBlockOutline = function (_a) {
    var itemId = _a.itemId, _b = _a.scale, scale = _b === void 0 ? 1 : _b, _c = _a.connectable, connectable = _c === void 0 ? false : _c, _d = _a.resizable, resizable = _d === void 0 ? false : _d, _e = _a.onResize, onResize = _e === void 0 ? noop : _e, _f = _a.onResized, onResized = _f === void 0 ? noop : _f, _g = _a.onLineConnect, onLineConnect = _g === void 0 ? noop : _g, _h = _a.onLineDisconnect, onLineDisconnect = _h === void 0 ? noop : _h, handleDirections = _a.handleDirections, x = _a.x, y = _a.y, w = _a.w, h = _a.h;
    var _j = __read(react_1.useState(null), 2), startPosition = _j[0], setStartPosition = _j[1];
    var _k = __read(react_1.useState(false), 2), resizing = _k[0], setResizing = _k[1];
    var _l = __read(react_1.useState(null), 2), resizeDir = _l[0], setResizeDir = _l[1];
    // Setup start of resize operation
    var handleResizeMouseDown = react_1.useCallback(function (e, dir) {
        e.preventDefault();
        e.stopPropagation();
        setStartPosition(layoutUtils_1.getClientPosition(e, scale));
        setResizing(true);
        setResizeDir(dir);
    }, [scale]);
    // Update size when resizing
    var handleMouseMove = react_1.useCallback(function (e) {
        if (startPosition && resizing && resizeDir) {
            e.preventDefault();
            var currentPosition = layoutUtils_1.getClientPosition(e, scale);
            var offset = layoutUtils_1.getOffset(currentPosition, startPosition);
            onResize(e, itemId, offset, resizeDir);
        }
    }, [scale, startPosition, resizing, onResize, itemId, resizeDir]);
    // Update final position at end of resize
    var handleMouseUp = react_1.useCallback(function (e) {
        if (startPosition && resizing && resizeDir) {
            e.preventDefault();
            var currentPosition = layoutUtils_1.getClientPosition(e, scale);
            var offset = layoutUtils_1.getOffset(currentPosition, startPosition);
            setStartPosition(null);
            setResizing(false);
            setResizeDir(null);
            onResized(e, itemId, offset, resizeDir);
        }
    }, [itemId, startPosition, resizing, resizeDir, scale, onResized]);
    // Update line when connecting to port
    var handlePortEnter = react_1.useCallback(function (port) { return function (e) {
        e.preventDefault();
        onLineConnect(itemId, port);
    }; }, [itemId, onLineConnect]);
    // Update line when disconnecting from port
    var handlePortLeave = react_1.useCallback(function (port) { return function (e) {
        e.preventDefault();
        onLineDisconnect(itemId, port);
    }; }, [itemId, onLineDisconnect]);
    react_1.useEffect(function () {
        if (resizable) {
            document.addEventListener('mousemove', handleMouseMove);
            document.addEventListener('mouseup', handleMouseUp);
        }
        return function () {
            document.removeEventListener('mousemove', handleMouseMove);
            document.removeEventListener('mouseup', handleMouseUp);
        };
    }, [resizable, handleMouseMove, handleMouseUp]);
    // Memoized resize handles
    var ResizeHandles = react_1.useMemo(function () {
        if (!resizable) {
            return null;
        }
        var directions = Array.isArray(handleDirections)
            ? handleDirections // casting as readonly so typescript doesn't think this is mutable
            : outlineUtils_1.HANDLE_DIRECTIONS;
        return directions.map(function (dir) { return (react_1.default.createElement(ResizeHandle_1.ResizeHandle, { key: "handle-" + dir, onMouseDown: handleResizeMouseDown, direction: dir })); });
    }, [handleDirections, resizable, handleResizeMouseDown]);
    // Memoized connection ports
    var Ports = react_1.useMemo(function () {
        if (!connectable) {
            return null;
        }
        return Port_1.PORT_DIRECTIONS.map(function (port) { return (react_1.default.createElement(Port_1.Port, { key: "port-" + port, port: port, onMouseEnter: handlePortEnter(port), onMouseLeave: handlePortLeave(port) })); });
    }, [connectable, handlePortEnter, handlePortLeave]);
    return (react_1.default.createElement(ResponsiveBox_1.default, { itemId: itemId, x: x, y: y, w: w, h: h },
        ResizeHandles,
        Ports));
};
exports.default = ResponsiveBlockOutline;


/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Port = exports.PORT_DIRECTIONS = void 0;
var react_1 = __importDefault(__webpack_require__(0));
var styled_components_1 = __importDefault(__webpack_require__(1));
var Plus_1 = __importDefault(__webpack_require__(48));
var themes_1 = __webpack_require__(4);
var outlineUtils_1 = __webpack_require__(24);
var portOffset = 8;
exports.PORT_DIRECTIONS = ['n', 'e', 's', 'w'];
var PortContainer = styled_components_1.default.div.attrs(function (_a) {
    var port = _a.port;
    return ({
        'data-test': 'port',
        'data-test-port': port,
    });
})(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n    text-align: center;\n    width: 16px;\n    height: 16px;\n    line-height: 16px;\n    box-sizing: border-box;\n    border-radius: 50%;\n    position: absolute;\n    color: ", ";\n    ", ";\n    ", ";\n    z-index: 999;\n    pointer-events: auto;\n    user-select: none;\n    &:hover {\n        background-color: ", ";\n    }\n"], ["\n    text-align: center;\n    width: 16px;\n    height: 16px;\n    line-height: 16px;\n    box-sizing: border-box;\n    border-radius: 50%;\n    position: absolute;\n    color: ",
    ";\n    ", ";\n    ", ";\n    z-index: 999;\n    pointer-events: auto;\n    user-select: none;\n    &:hover {\n        background-color: ",
    ";\n    }\n"])), themes_1.pick({
    enterprise: themes_1.variables.accentColorL10,
    prisma: themes_1.variables.interactiveColorPrimary,
}), function (_a) {
    var port = _a.port;
    return outlineUtils_1.getVerticalPosition(port, portOffset);
}, function (_a) {
    var port = _a.port;
    return outlineUtils_1.getHorizontalPosition(port, portOffset);
}, themes_1.pick({
    enterprise: themes_1.variables.accentColorL10,
    prisma: themes_1.variables.interactiveColorPrimary,
}));
var Port = function (_a) {
    var port = _a.port, onMouseEnter = _a.onMouseEnter, onMouseLeave = _a.onMouseLeave;
    return (react_1.default.createElement(PortContainer, { port: port, onMouseEnter: onMouseEnter, onMouseLeave: onMouseLeave },
        react_1.default.createElement(Plus_1.default, null)));
};
exports.Port = Port;
var templateObject_1;


/***/ }),
/* 48 */
/***/ (function(module, exports) {

module.exports = require("@splunk/react-icons/Plus");

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ResizeHandle = void 0;
var react_1 = __importStar(__webpack_require__(0));
var styled_components_1 = __importDefault(__webpack_require__(1));
var themes_1 = __webpack_require__(4);
var outlineUtils_1 = __webpack_require__(24);
var resizeHandleOffset = 7;
/**
 * compute cursor base on resize dir
 * @param {String} dir
 */
var computeCursor = function (dir) {
    switch (dir) {
        case 'n':
        case 's':
            return 'ns-resize';
        case 'e':
        case 'w':
            return 'ew-resize';
        case 'ne':
        case 'sw':
            return 'nesw-resize';
        case 'se':
        case 'nw':
        default:
            return 'nwse-resize';
    }
};
var Handle = styled_components_1.default.a.attrs(function (_a) {
    var direction = _a.direction;
    return ({
        'data-test': 'handle',
        'data-test-direction': direction,
    });
})(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n    width: 10px;\n    height: 10px;\n    background-color: ", ";\n    border-radius: 20%;\n    position: absolute;\n    ", ";\n    ", ";\n    cursor: ", ";\n    z-index: 999;\n    pointer-events: auto;\n    user-select: none;\n"], ["\n    width: 10px;\n    height: 10px;\n    background-color: ",
    ";\n    border-radius: 20%;\n    position: absolute;\n    ", ";\n    ", ";\n    cursor: ", ";\n    z-index: 999;\n    pointer-events: auto;\n    user-select: none;\n"])), themes_1.pick({
    enterprise: themes_1.variables.accentColorL10,
    prisma: themes_1.variables.interactiveColorPrimary,
}), function (_a) {
    var direction = _a.direction;
    return outlineUtils_1.getVerticalPosition(direction, resizeHandleOffset);
}, function (_a) {
    var direction = _a.direction;
    return outlineUtils_1.getHorizontalPosition(direction, resizeHandleOffset);
}, function (_a) {
    var direction = _a.direction;
    return computeCursor(direction);
});
var ResizeHandle = function (_a) {
    var onMouseDown = _a.onMouseDown, direction = _a.direction;
    var handleMouseDown = react_1.useCallback(function (e) {
        onMouseDown(e, direction);
    }, [onMouseDown, direction]);
    return react_1.default.createElement(Handle, { direction: direction, onMouseDown: handleMouseDown });
};
exports.ResizeHandle = ResizeHandle;
var templateObject_1;


/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var namedColors_1 = __importDefault(__webpack_require__(51));
var commonLayoutOptionsSchema_1 = __importDefault(__webpack_require__(13));
exports.default = __assign(__assign({}, commonLayoutOptionsSchema_1.default), { backgroundColor: {
        oneOf: [
            {
                pattern: '^#[0-9a-fA-F]{6}$',
                type: 'string',
                description: "Specify the color of the layout background color using a Hex code, such as \"#FF0000\".\n            The default for light mode is \"#F2F4f5\". The default for dark mode is \"#3C444D\". The default for SCP mode is \"#15161B\"",
            },
            {
                type: 'string',
                enum: namedColors_1.default,
                description: "Specify the color of the layout background color using a valid web color such as 'blue'",
            },
        ],
    }, display: {
        type: 'string',
        default: 'actual-size',
        enum: ['actual-size', 'auto-scale'],
        description: "Specify the display behavior.\n        If this property is set to actual-size, changing the size of your browser will not change the size of your dashboard or visualizations.\n        If this property is set to auto-scale, your dashboard and visualizations will automatically also change size.",
    }, backgroundImage: {
        type: 'object',
        properties: {
            w: {
                type: 'number',
                description: "Specify the image's h (height) and w (width) in pixels. These options should not be specified if you set the sizeType option. If they are, they will overrule that setting.",
            },
            h: {
                type: 'number',
                description: "Specify the image's h (height) and w (width) in pixels. These options should not be specified if you set the sizeType option. If they are, they will overrule that setting.",
            },
            x: {
                type: 'number',
                description: 'Specify, in pixels, the position of the background image on the x-axis and y-axis. These options should not be specified if you set the sizeType option. If they are, they will overrule that setting.',
            },
            y: {
                type: 'number',
                description: 'Specify, in pixels, the position of the background image on the x-axis and y-axis. These options should not be specified if you set the sizeType option. If they are, they will overrule that setting.',
            },
            src: {
                type: 'string',
                description: 'The url of background image.',
            },
            sizeType: {
                type: 'string',
                enum: ['auto', 'contain', 'cover'],
                default: 'contain',
                description: "Specify one of the following:\n                (auto | contain | cover).\n                auto : Scales the image while maintaining the image proportion.\n                contain: Increases the size of the of the image as much as possible without cropping or stretching it.\n                cover: Increases the size of the image without stretching it. The image may be cropped vertically and horizontally so that no empty space is shown.",
            },
        },
        description: "A background image must be one of the following types:\n        jpg, jpeg, png, svg, or gif.\n        Specify the location of a background image using the option src. For example: \"src\": \"https://www.myImageLocation.com/galleryX/image1.png",
        additionalProperties: false,
    }, width: {
        type: 'number',
        default: 1200,
        description: 'Canvas width in pixels.',
    }, height: {
        type: 'number',
        default: 900,
        description: 'Canvas height in pixels.',
    } });


/***/ }),
/* 51 */
/***/ (function(module, exports) {

module.exports = require("@splunk/dashboard-ui/utils/namedColors");

/***/ }),
/* 52 */,
/* 53 */,
/* 54 */,
/* 55 */,
/* 56 */,
/* 57 */,
/* 58 */,
/* 59 */,
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var noop_1 = __importDefault(__webpack_require__(16));
var rxjs_1 = __webpack_require__(61);
var react_1 = __importStar(__webpack_require__(0));
var lodash_1 = __webpack_require__(36);
var dashboard_context_1 = __webpack_require__(14);
var dashboard_telemetry_1 = __webpack_require__(37);
var usePrevious_1 = __importDefault(__webpack_require__(38));
var layoutUtils_1 = __webpack_require__(2);
var DefaultOptions_1 = __webpack_require__(9);
var AbsoluteLayoutApi_1 = __importDefault(__webpack_require__(62));
var AbsoluteCanvas_1 = __importDefault(__webpack_require__(63));
var lineUtils_1 = __webpack_require__(29);
var blockUtils_1 = __webpack_require__(23);
var Layer_1 = __importDefault(__webpack_require__(42));
var imageUtils_1 = __webpack_require__(15);
var ResponsiveBlockItem_1 = __importDefault(__webpack_require__(43));
var ResponsiveLine_1 = __importDefault(__webpack_require__(45));
var ResponsiveBlockOutline_1 = __importDefault(__webpack_require__(46));
var absoluteLayoutUtils_1 = __webpack_require__(67);
var absoluteLayoutOptionsSchema_1 = __importDefault(__webpack_require__(50));
var GRID_SIZE = 10;
var GRID_PADDING = 1;
var MIN_WIDTH = GRID_SIZE * 2;
var MIN_HEIGHT = GRID_SIZE * 2;
var ZOOM_STEP_SIZE = 0.25;
var emptySelectedItems = [];
var AbsoluteLayout = function (props) {
    var _a = props.mode, mode = _a === void 0 ? 'view' : _a, _b = props.showGrid, showGrid = _b === void 0 ? true : _b, _c = props.options, _d = _c === void 0 ? {} : _c, _e = _d.width, width = _e === void 0 ? DefaultOptions_1.absoluteLayoutOptions.width : _e, _f = _d.height, height = _f === void 0 ? DefaultOptions_1.absoluteLayoutOptions.height : _f, _g = _d.display, display = _g === void 0 ? DefaultOptions_1.absoluteLayoutOptions.display : _g, backgroundColor = _d.backgroundColor, backgroundImage = _d.backgroundImage, _h = props.layoutStructure, layoutStructure = _h === void 0 ? [] : _h, containerWidth = props.containerWidth, _j = props.selectedItems, selectedItems = _j === void 0 ? emptySelectedItems : _j, renderLayoutItem = props.renderLayoutItem, _k = props.onLayoutItemsSelect, onLayoutItemsSelect = _k === void 0 ? noop_1.default : _k, _l = props.onLayoutStructureChange, onLayoutStructureChange = _l === void 0 ? noop_1.default : _l, _m = props.layoutApiRef, layoutApiRef = _m === void 0 ? noop_1.default : _m;
    var _o = __read(react_1.useState(null), 2), activeLine = _o[0], setActiveLine = _o[1];
    var _p = __read(react_1.useState(1), 2), scale = _p[0], setScaleInternal = _p[1];
    var _q = __read(react_1.useState(false), 2), fitToWidth = _q[0], setFitToWidth = _q[1];
    var _r = __read(react_1.useReducer(absoluteLayoutUtils_1.reducer, layoutStructure, absoluteLayoutUtils_1.initializeLayoutStructureState), 2), layoutStructureState = _r[0], dispatch = _r[1];
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    var canvasRef = react_1.useRef(null);
    var layoutApi = react_1.useRef(null);
    var zoomObserver = react_1.useRef(null);
    var savedScroll = react_1.useRef(null);
    // have a ref to the latest layoutStructure, so that the AbsoluteLayoutApi can use it
    var layoutStructureRef = react_1.useRef(layoutStructure);
    layoutStructureRef.current = layoutStructure;
    // have a ref to the latest zoom step, so that the AbsoluteLayoutApi can use it
    var currentStepRef = react_1.useRef(1);
    currentStepRef.current =
        Math.round(scale / ZOOM_STEP_SIZE) * ZOOM_STEP_SIZE;
    var _s = react_1.useContext(dashboard_context_1.DashboardContext), keyboardListener = _s.keyboardListener, _t = _s.featureFlags, featureFlags = _t === void 0 ? {} : _t;
    var telemetry = react_1.useContext(dashboard_telemetry_1.TelemetryContext);
    var previousScale = usePrevious_1.default(scale);
    var previousLayoutStructure = usePrevious_1.default(layoutStructure);
    var getZoomObserver = react_1.useCallback(function () {
        if (zoomObserver.current == null) {
            zoomObserver.current = new rxjs_1.BehaviorSubject(1);
        }
        return zoomObserver.current;
    }, []);
    var setScale = react_1.useCallback(function (s) {
        getZoomObserver().next(s);
        setScaleInternal(s);
        setFitToWidth(false);
    }, [getZoomObserver]);
    var getCanvasDomElement = react_1.useCallback(function () {
        return canvasRef.current;
    }, []);
    var scrollToTopLeft = react_1.useCallback(function () {
        var layoutEl = getCanvasDomElement().parentElement;
        if (layoutEl) {
            layoutEl.scrollTop = 0;
            layoutEl.scrollLeft = 0;
        }
    }, [getCanvasDomElement]);
    var setFitToWidthAndScrollToTopLeft = react_1.useCallback(function () {
        setFitToWidth(true);
        scrollToTopLeft();
    }, [scrollToTopLeft]);
    var zoomIn = react_1.useCallback(function () {
        setScale(currentStepRef.current + ZOOM_STEP_SIZE);
    }, [setScale]);
    var zoomOut = react_1.useCallback(function () {
        var nextStep = currentStepRef.current - ZOOM_STEP_SIZE;
        if (nextStep >= ZOOM_STEP_SIZE) {
            setScale(nextStep);
        }
    }, [setScale]);
    var handleKeyboardZoom = react_1.useCallback(function (_a) {
        var dir = _a.dir, preventDefault = _a.preventDefault;
        switch (dir) {
            case 'in':
                zoomIn();
                break;
            case 'out':
                zoomOut();
                break;
            case 'reset':
                setFitToWidthAndScrollToTopLeft();
                break;
            default:
                break;
        }
        preventDefault();
    }, [setFitToWidthAndScrollToTopLeft, zoomIn, zoomOut]);
    /**
     * Keyboard move updates the definition directly, no need to update state
     */
    var handleKeyboardMove = react_1.useCallback(function (_a) {
        var dir = _a.dir, snap = _a.snap, preventDefault = _a.preventDefault;
        var selectedLineItems = lineUtils_1.findSelectedLineItems({
            layoutStructure: layoutStructure,
            selectedItems: selectedItems,
        });
        var selectedBlockItems = blockUtils_1.findSelectedBlockItems({
            layoutStructure: layoutStructure,
            selectedItems: selectedItems,
        });
        if ((selectedLineItems.length === 0 &&
            selectedBlockItems.length === 0) ||
            mode !== 'edit') {
            return;
        }
        var updatedLayoutStructure = absoluteLayoutUtils_1.updateLayoutStructureOnKeyboardMove({
            selectedBlockItems: selectedBlockItems,
            selectedLineItems: selectedLineItems,
            dir: dir,
            snap: snap,
            gridSize: GRID_SIZE,
            layoutStructure: layoutStructure,
        });
        onLayoutStructureChange(updatedLayoutStructure);
        preventDefault();
    }, [layoutStructure, mode, onLayoutStructureChange, selectedItems]);
    var handleLayoutStructureChange = react_1.useCallback(function () {
        var updatedLayoutStructure = layoutStructure.map(function (item) { var _a; return (_a = layoutStructureState[item.item]) !== null && _a !== void 0 ? _a : item; });
        onLayoutStructureChange(updatedLayoutStructure);
    }, [layoutStructure, layoutStructureState, onLayoutStructureChange]);
    var handleLineMove = react_1.useCallback(function (e, offset) {
        var selectedLineItems = lineUtils_1.findSelectedLineItems({
            layoutStructure: layoutStructure,
            selectedItems: selectedItems,
        });
        if (selectedLineItems.length === 0) {
            return;
        }
        var lineId = selectedLineItems[0].item;
        dispatch({
            type: 'lineMove',
            payload: lineUtils_1.handleSingleLineMove({
                layoutStructure: layoutStructure,
                lineId: lineId,
                offset: offset,
            }),
        });
    }, [layoutStructure, selectedItems]);
    var handleLineMoved = react_1.useCallback(function () {
        handleLayoutStructureChange();
    }, [handleLayoutStructureChange]);
    var handleLineDragStart = react_1.useCallback(function (e, dir) {
        var selectedLineItems = lineUtils_1.findSelectedLineItems({
            layoutStructure: layoutStructure,
            selectedItems: selectedItems,
        });
        if (selectedLineItems.length !== 1) {
            return;
        }
        var lineId = selectedLineItems[0].item;
        var line = lineUtils_1.handleSingleLineDragStart({
            lineId: lineId,
            layoutStructure: layoutStructure,
            lineDir: dir,
        });
        dispatch({
            type: 'lineDragStart',
            payload: line,
        });
        setActiveLine({ id: lineId, dir: dir });
    }, [layoutStructure, selectedItems]);
    var handleLineDrag = react_1.useCallback(function (e, offset) {
        if (!activeLine) {
            return;
        }
        var line = layoutStructure.find(function (item) { return item.item === activeLine.id; });
        var absPos = lineUtils_1.computeLineAbsPosition({
            layoutStructure: layoutStructure,
            position: line.position,
        })[activeLine.dir];
        // line should already been disconnect in this case
        dispatch({
            type: 'lineDrag',
            payload: {
                id: activeLine.id,
                dir: activeLine.dir,
                absPos: {
                    x: absPos.x + offset.offsetX,
                    y: absPos.y + offset.offsetY,
                },
            },
        });
    }, [activeLine, layoutStructure]);
    var handleLineDragged = react_1.useCallback(function () {
        setActiveLine(null);
        handleLayoutStructureChange();
    }, [handleLayoutStructureChange]);
    var handleLineConnected = react_1.useCallback(function (itemId, port) {
        if (!activeLine) {
            return;
        }
        var lineId = activeLine.id;
        dispatch({
            type: 'lineConnect',
            payload: { lineId: lineId, lineDir: activeLine.dir, itemId: itemId, port: port },
        });
    }, [activeLine]);
    var handleLineDisconnected = react_1.useCallback(function () {
        if (!activeLine) {
            return;
        }
        dispatch({
            type: 'lineDisconnect',
            payload: {
                lineId: activeLine.id,
                lineDir: activeLine.dir,
            },
        });
    }, [activeLine]);
    var handleItemSelected = react_1.useCallback(function (e, newSelectedItems) {
        if (newSelectedItems === void 0) { newSelectedItems = emptySelectedItems; }
        onLayoutItemsSelect(newSelectedItems);
    }, [onLayoutItemsSelect]);
    var handleBlockItemResize = react_1.useCallback(function (e, itemId, offset, dir) {
        var item = layoutStructure.find(function (itm) { return itm.item === itemId; });
        var snapOffset = layoutUtils_1.snapOffsetToWH({
            position: item.position,
            offset: offset,
            gridWidth: GRID_SIZE,
            gridHeight: GRID_SIZE,
            spacing: 0,
            padding: 0,
        });
        var newItem = layoutUtils_1.updateBlockItemSize({
            item: item,
            offset: snapOffset,
            dir: dir,
            options: {
                minHeight: MIN_HEIGHT,
                minWidth: MIN_WIDTH,
            },
        });
        dispatch({
            type: 'blockResize',
            payload: newItem,
        });
    }, [layoutStructure]);
    var handleBlockItemResized = react_1.useCallback(function () {
        handleLayoutStructureChange();
    }, [handleLayoutStructureChange]);
    var handleBlockItemMove = react_1.useCallback(function (e, offset) {
        var selectedBlockItems = blockUtils_1.findSelectedBlockItems({
            layoutStructure: layoutStructure,
            selectedItems: selectedItems,
        });
        if (selectedBlockItems.length === 0) {
            return;
        }
        // use any block item to calculate the moveOffset
        var firstBlockItem = selectedBlockItems[0];
        var moveOffset = layoutUtils_1.snapOffsetToXY({
            position: firstBlockItem.position,
            offset: offset,
            gridWidth: GRID_SIZE,
            gridHeight: GRID_SIZE,
            spacing: 0,
            padding: 0,
        });
        var updatedSelectedBlockItems = selectedBlockItems.map(function (blockItem) { return layoutUtils_1.updateBlockItemPosition(blockItem, moveOffset); });
        dispatch({
            type: 'blocksMove',
            payload: updatedSelectedBlockItems,
        });
    }, [layoutStructure, selectedItems]);
    var handleBlockItemMoved = react_1.useCallback(function () {
        handleLayoutStructureChange();
    }, [handleLayoutStructureChange]);
    // todo: we should memoize the return value
    var blockItems = react_1.useMemo(function () {
        return layoutStructure
            .filter(function (_a) {
            var type = _a.type;
            return type === 'block' || !type;
        })
            .map(function (block) { var _a; return (_a = layoutStructureState[block.item]) !== null && _a !== void 0 ? _a : block; });
    }, [layoutStructure, layoutStructureState]);
    var lineItems = react_1.useMemo(function () {
        return layoutStructure
            .filter(function (_a) {
            var type = _a.type;
            return type === 'line';
        })
            .map(function (line) { var _a; return (_a = layoutStructureState[line.item]) !== null && _a !== void 0 ? _a : line; });
    }, [layoutStructure, layoutStructureState]);
    var getLayoutApi = react_1.useCallback(function () {
        if (layoutApi.current == null) {
            layoutApi.current = new AbsoluteLayoutApi_1.default({
                getZoomObserver: getZoomObserver,
                setFitToWidthAndScrollToTopLeft: setFitToWidthAndScrollToTopLeft,
                zoomIn: zoomIn,
                zoomOut: zoomOut,
                setScale: setScale,
                options: props.options,
                layoutStructureRef: layoutStructureRef,
                getCanvasDomElement: getCanvasDomElement,
                telemetry: telemetry,
            });
        }
        return layoutApi.current;
    }, [
        getCanvasDomElement,
        getZoomObserver,
        layoutStructureRef,
        props.options,
        setFitToWidthAndScrollToTopLeft,
        setScale,
        zoomIn,
        zoomOut,
        telemetry,
    ]);
    // reset the state when the layoutStructure changes, this handles the case like undo/redo
    react_1.useEffect(function () {
        if (!lodash_1.isEqual(layoutStructure, previousLayoutStructure)) {
            dispatch({
                type: 'reset',
                payload: layoutStructure,
            });
        }
    }, [layoutStructure, previousLayoutStructure]);
    // register layout api
    react_1.useEffect(function () {
        layoutApiRef(getLayoutApi());
        return function () {
            layoutApiRef(null);
        };
    }, [getLayoutApi, layoutApiRef]);
    react_1.useEffect(function () {
        if (!keyboardListener) {
            return noop_1.default;
        }
        var unsubscribeMove = keyboardListener.subscribe('move', handleKeyboardMove);
        return function () {
            unsubscribeMove();
        };
    }, [handleKeyboardMove, keyboardListener]);
    react_1.useEffect(function () {
        if (!keyboardListener) {
            return noop_1.default;
        }
        var unsubscribeZoom = keyboardListener.subscribe('zoom', handleKeyboardZoom);
        return function () {
            unsubscribeZoom();
        };
    }, [handleKeyboardZoom, keyboardListener]);
    react_1.useEffect(function () {
        if (!keyboardListener) {
            return noop_1.default;
        }
        var unsubscribeCancel = keyboardListener.subscribe('cancel', function () {
            return handleItemSelected(null, []);
        });
        return function () {
            unsubscribeCancel();
        };
    }, [handleItemSelected, keyboardListener]);
    // apply display mode
    react_1.useEffect(function () {
        if (display === 'auto-scale') {
            setFitToWidthAndScrollToTopLeft();
        }
        else {
            setScale(1);
        }
    }, [display, setFitToWidthAndScrollToTopLeft, setScale]);
    // We need to record the scroll position right before next DOM update,
    // so that we can restore the scroll position later.
    // Refer to the next useEffect() for the logic of restoring scroll position.
    // Reference to the original implementation of this logic:
    // https://cd.splunkdev.com/devplat/dashboard-framework/-/merge_requests/2356
    if (previousScale != null &&
        previousScale >= 1 &&
        scale < 1 &&
        featureFlags.enableZoomCenter) {
        var previousLayout = getCanvasDomElement().parentElement;
        if (previousLayout) {
            savedScroll.current = {
                x: previousLayout.scrollLeft + previousLayout.offsetWidth / 2,
                y: previousLayout.scrollTop + previousLayout.offsetHeight / 2,
            };
        }
    }
    // center zoom
    react_1.useLayoutEffect(function () {
        var _a, _b;
        if (fitToWidth || previousScale == null || previousScale === scale) {
            return;
        }
        var layout = getCanvasDomElement().parentElement;
        if (!layout) {
            return;
        }
        var offsetWidth = layout.offsetWidth, offsetHeight = layout.offsetHeight, scrollTop = layout.scrollTop, scrollLeft = layout.scrollLeft;
        /* scale changed from scale = 0.25 or 0.5 to scale = 1, 1.5 or 2.0 then the scroll position is restored
         * scale changed from scale >= 1 to scale = 0.5 or 0.25 then the scroll position is saved
         * savedScroll.x and SavedScroll.y saves the horizontal and vertical scroll position
         * The scroll position is calculated based on taking half of offsetWidth and offsetHeight
         */
        if (previousScale < 1 &&
            scale > 1 &&
            ((_a = savedScroll === null || savedScroll === void 0 ? void 0 : savedScroll.current) === null || _a === void 0 ? void 0 : _a.x) != null &&
            ((_b = savedScroll === null || savedScroll === void 0 ? void 0 : savedScroll.current) === null || _b === void 0 ? void 0 : _b.y) != null &&
            featureFlags.enableZoomCenter) {
            layout.scrollLeft = savedScroll.current.x - layout.offsetWidth / 2;
            layout.scrollTop = savedScroll.current.y - layout.offsetHeight / 2;
        }
        else {
            var scaleRatio = scale / previousScale;
            var newScroll = layoutUtils_1.shiftViewportOnZoom({
                offsetWidth: offsetWidth,
                offsetHeight: offsetHeight,
                scrollTop: scrollTop,
                scrollLeft: scrollLeft,
                scaleRatio: scaleRatio,
            });
            layout.scrollLeft = newScroll.scrollLeft;
            layout.scrollTop = newScroll.scrollTop;
        }
    }, [
        featureFlags.enableZoomCenter,
        fitToWidth,
        getCanvasDomElement,
        previousScale,
        scale,
    ]);
    // scale to fit
    react_1.useEffect(function () {
        if (!fitToWidth) {
            return;
        }
        var newScale = layoutUtils_1.computeScaleToFit(containerWidth, width);
        getZoomObserver().next(newScale);
        setScaleInternal(newScale);
    }, [containerWidth, fitToWidth, getZoomObserver, width]);
    // update active line
    react_1.useEffect(function () {
        if (activeLine && layoutStructureState[activeLine.id] == null) {
            setActiveLine(null);
        }
    }, [activeLine, layoutStructureState]);
    var image = react_1.useMemo(function () {
        return backgroundImage
            ? imageUtils_1.validateBackgroundImage({
                backgroundImage: backgroundImage,
                canvasWidth: width,
                canvasHeight: height,
            })
            : {};
    }, [backgroundImage, height, width]);
    var modeSpecificProps = react_1.useMemo(function () {
        return mode === 'edit'
            ? {
                movable: true,
                showOverflowContent: true,
                showGrid: showGrid,
                showBorder: true,
                gridLineWidth: 1,
                gridPadding: GRID_PADDING,
                onItemMove: handleBlockItemMove,
                onItemMoved: handleBlockItemMoved,
                userSelect: false,
                allowMultiselect: true,
            }
            : {
                movable: false,
                showOverflowContent: false,
                showGrid: false,
                showBorder: false,
                userSelect: true,
                allowMultiselect: false,
            };
    }, [handleBlockItemMove, handleBlockItemMoved, mode, showGrid]);
    var blockItemElements = react_1.useMemo(function () {
        return blockUtils_1.getAllBlockItems({
            layoutStructure: layoutStructure,
            layoutStructureState: layoutStructureState,
        }).map(function (_a) {
            var item = _a.item, _b = _a.position, x = _b.x, y = _b.y, w = _b.w, h = _b.h;
            return (react_1.default.createElement(ResponsiveBlockItem_1.default, { key: item, itemId: item, x: x, y: y, w: w, h: h, canvasHeight: height, renderLayoutItem: renderLayoutItem, onItemSelected: handleItemSelected }));
        });
    }, [
        handleItemSelected,
        height,
        layoutStructure,
        layoutStructureState,
        renderLayoutItem,
    ]);
    var lineElements = react_1.useMemo(function () {
        var selectedLineItems = lineUtils_1.findSelectedLineItems({
            layoutStructure: layoutStructure,
            selectedItems: selectedItems,
        });
        var selectable = mode === 'edit';
        return lineItems.map(function (line) {
            // we don't support multiple select for line
            var editable = selectedLineItems.length === 1 &&
                selectedLineItems[0].item === line.item &&
                selectable;
            var absPos = lineUtils_1.computeLineAbsPosition({
                layoutStructure: Object.values(layoutStructureState),
                position: line.position,
            });
            var fromTestHooks = 'item' in line.position.from && 'port' in line.position.from
                ? {
                    fromItem: line.position.from.item,
                    fromPort: line.position.from.port,
                }
                : {};
            var toTestHooks = 'item' in line.position.to && 'port' in line.position.to
                ? {
                    toItem: line.position.to.item,
                    toPort: line.position.to.port,
                }
                : {};
            return (react_1.default.createElement(ResponsiveLine_1.default, __assign({ key: line.item, lineId: line.item, scale: scale, selectable: selectable, editable: editable, renderLayoutItem: renderLayoutItem, onLineMove: handleLineMove, onLineMoved: handleLineMoved, onLineDragStart: handleLineDragStart, onLineDrag: handleLineDrag, onLineDragged: handleLineDragged, onItemSelected: handleItemSelected, fromX: absPos.from.x, fromY: absPos.from.y, toX: absPos.to.x, toY: absPos.to.y }, fromTestHooks, toTestHooks)));
        });
    }, [
        handleItemSelected,
        handleLineDrag,
        handleLineDragStart,
        handleLineDragged,
        handleLineMove,
        handleLineMoved,
        layoutStructure,
        layoutStructureState,
        lineItems,
        mode,
        renderLayoutItem,
        scale,
        selectedItems,
    ]);
    var outlineElements = react_1.useMemo(function () {
        var selectedLineItems = lineUtils_1.findSelectedLineItems({
            layoutStructure: Object.values(layoutStructureState),
            selectedItems: selectedItems,
        });
        var selectedBlockItems = blockUtils_1.findSelectedBlockItems({
            layoutStructure: Object.values(layoutStructureState),
            selectedItems: selectedItems,
        });
        var allBlockItems = blockUtils_1.getAllBlockItems({
            layoutStructure: layoutStructure,
            layoutStructureState: layoutStructureState,
        });
        return allBlockItems.map(function (block) {
            // current outline has 3 state
            // 1. If only one line is selected and actively been dragging, set outline to connectable
            // outline will display connect port in this case and fire onLineConnect/onLineDisconnect callback
            var connectable = mode === 'edit' &&
                selectedBlockItems.length === 0 &&
                selectedLineItems.length === 1 &&
                activeLine != null;
            // 2. If this is the only block item been selected, set outline to resizable
            // in this case outline will display resize handle and fire onResize/onResized callback
            var resizable = mode === 'edit' &&
                selectedBlockItems.length === 1 &&
                selectedBlockItems[0].item === block.item;
            // 3. current block item is selected or active, just display the outline
            var selected = selectedBlockItems.findIndex(function (b) { return b.item === block.item; }) >= 0;
            if (!connectable && !resizable && !selected) {
                return null;
            }
            return (react_1.default.createElement(ResponsiveBlockOutline_1.default, { key: block.item, itemId: block.item, x: block.position.x, y: block.position.y, w: block.position.w, h: block.position.h, scale: scale, connectable: connectable, resizable: resizable, onResize: handleBlockItemResize, onResized: handleBlockItemResized, onLineConnect: handleLineConnected, onLineDisconnect: handleLineDisconnected }));
        });
    }, [
        activeLine,
        handleBlockItemResize,
        handleBlockItemResized,
        handleLineConnected,
        handleLineDisconnected,
        layoutStructure,
        layoutStructureState,
        mode,
        scale,
        selectedItems,
    ]);
    return (react_1.default.createElement(AbsoluteCanvas_1.default, __assign({ "data-test": "absolute-layout", blockItems: blockItems, width: width, height: height, scale: scale, 
        // can someone tell me why the original implementation had this magic number minus one?
        gridWidth: GRID_SIZE - 1, gridHeight: GRID_SIZE - 1, backgroundColor: backgroundColor, backgroundImageSrc: image.src, backgroundImageSizeType: image.sizeType, backgroundImageWidth: image.w, backgroundImageHeight: image.h, backgroundImagePositionX: image.x, backgroundImagePositionY: image.y, selectedLayoutItems: selectedItems, onItemSelected: handleItemSelected, ref: canvasRef }, modeSpecificProps),
        react_1.default.createElement(Layer_1.default, { key: "block-item-layer", "data-test": "block-item-layer" }, blockItemElements),
        react_1.default.createElement(Layer_1.default, { key: "outline-layer", "data-test": "outline-layer" },
            lineElements,
            outlineElements)));
};
AbsoluteLayout.schema = absoluteLayoutOptionsSchema_1.default;
exports.default = AbsoluteLayout;


/***/ }),
/* 61 */
/***/ (function(module, exports) {

module.exports = require("rxjs");

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var get_1 = __importDefault(__webpack_require__(10));
var layout_1 = __webpack_require__(6);
var BaseLayoutApi_1 = __importDefault(__webpack_require__(28));
var layoutUtils_1 = __webpack_require__(2);
var lineUtils_1 = __webpack_require__(29);
var imageUtils_1 = __webpack_require__(15);
var DefaultOptions_1 = __webpack_require__(9);
var layoutApiUtils_1 = __webpack_require__(39);
var blockUtils_1 = __webpack_require__(23);
var AbsoluteLayoutApi = /** @class */ (function (_super) {
    __extends(AbsoluteLayoutApi, _super);
    function AbsoluteLayoutApi(_a) {
        var telemetry = _a.telemetry, layout = __rest(_a, ["telemetry"]);
        var _this = _super.call(this) || this;
        /**
         * Get layout items in order
         * @method
         * @returns {String} ordered item ids
         * @public
         */
        _this.getLayoutItemOrder = function () {
            return blockUtils_1.getAllBlockItems({
                layoutStructure: _this.layout.layoutStructureRef.current,
            }).map(function (_a) {
                var item = _a.item;
                return item;
            });
        };
        /**
         * Adjust layout item order
         * @method
         * @param {Number} currentOrder
         * @param {Number} newOrder
         * @returns {Promise<Object[]>} updated layout structure
         * @public
         */
        _this.adjustLayoutItemOrder = function (currentOrder, newOrder, metadata) { return __awaiter(_this, void 0, void 0, function () {
            var blockItems, lineItems, updatedBlockItems;
            return __generator(this, function (_a) {
                this.emitTelemetry({
                    pageAction: 'adjustLayoutItemOrder',
                    metadata: metadata,
                });
                blockItems = blockUtils_1.getAllBlockItems({
                    layoutStructure: this.layout.layoutStructureRef.current,
                });
                lineItems = lineUtils_1.getAllLineItems({
                    layoutStructure: this.layout.layoutStructureRef.current,
                });
                updatedBlockItems = layoutUtils_1.moveLayoutItem(blockItems, currentOrder, Math.min(newOrder, blockItems.length));
                // an lazy way of rearrange block item orders. lol
                return [2 /*return*/, __spread(lineItems, updatedBlockItems)];
            });
        }); };
        /**
         * Add a new layout item to the structure
         * @method
         * @param {Object} options
         * @param {String} options.itemId
         * @param {Object} options.vizContract
         * @param {String} [options.type='block']
         * @param {Object} options.config
         * @returns {Promise<Object[]>} updated layout structure
         * @public
         */
        _this.addLayoutItem = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return __awaiter(_this, void 0, void 0, function () {
                var _a, itemId, vizContract, _b, type, config, metadata, width, height;
                var _c, _d, _e, _f;
                return __generator(this, function (_g) {
                    _a = layoutApiUtils_1.normalizeAddLayoutItemArgs(args), itemId = _a.itemId, vizContract = _a.vizContract, _b = _a.type, type = _b === void 0 ? 'block' : _b, config = _a.config, metadata = _a.metadata;
                    this.emitTelemetry({
                        pageAction: 'addLayoutItem',
                        metadata: metadata,
                    });
                    width = (_d = (_c = this.layout.options) === null || _c === void 0 ? void 0 : _c.width) !== null && _d !== void 0 ? _d : DefaultOptions_1.absoluteLayoutOptions.width;
                    height = (_f = (_e = this.layout.options) === null || _e === void 0 ? void 0 : _e.height) !== null && _f !== void 0 ? _f : DefaultOptions_1.absoluteLayoutOptions.height;
                    return [2 /*return*/, __spread(this.layout.layoutStructureRef.current, [
                            layout_1.computeNewAbsoluteStructureItem({
                                itemId: itemId,
                                type: type,
                                canvasWidth: width,
                                canvasHeight: height,
                                vizContract: vizContract,
                                layoutItems: this.layout.layoutStructureRef.current,
                                config: config,
                            }),
                        ])];
                });
            });
        };
        /**
         * Remove items from layout structure
         * @method
         * @param {Promise<String[]>} itemIds
         * @public
         */
        _this.removeLayoutItems = function (itemIds, metadata) {
            if (itemIds === void 0) { itemIds = []; }
            return __awaiter(_this, void 0, void 0, function () {
                var updatedItems;
                var _this = this;
                return __generator(this, function (_a) {
                    this.emitTelemetry({
                        pageAction: 'removeLayoutItems',
                        metadata: metadata,
                    });
                    updatedItems = [];
                    this.layout.layoutStructureRef.current.forEach(function (item) {
                        var iterItem = item;
                        if (item.type === 'line') {
                            var updatedLine = item;
                            // disconnect line if necessary
                            var absPos = lineUtils_1.computeLineAbsPosition({
                                layoutStructure: _this.layout.layoutStructureRef.current,
                                position: updatedLine.position,
                            });
                            if ('item' in updatedLine.position.from &&
                                itemIds.indexOf(updatedLine.position.from.item) >= 0) {
                                updatedLine = layoutUtils_1.disconnectLine({
                                    line: updatedLine,
                                    dir: 'from',
                                    absPos: absPos.from,
                                });
                            }
                            if ('item' in updatedLine.position.to &&
                                itemIds.indexOf(updatedLine.position.to.item) >= 0) {
                                updatedLine = layoutUtils_1.disconnectLine({
                                    line: updatedLine,
                                    dir: 'to',
                                    absPos: absPos.to,
                                });
                            }
                            iterItem = updatedLine;
                        }
                        if (itemIds.indexOf(iterItem.item) < 0) {
                            // push into array if it's not been removed
                            updatedItems.push(iterItem);
                        }
                    });
                    return [2 /*return*/, updatedItems];
                });
            });
        };
        /**
         * Copies a layout item position and size and offsets by 2 * GRID_SIZE
         * @method
         * @param {Object} config
         * @param {Array} config.from List of original viz ids
         * @param {Array} config.to List of new viz ids
         * @param {Number} [config.offsetMultiplier=1] Number of grids to offset
         * @returns {Promise<Object[]>} Layout structure of all known items
         * @public
         */
        _this.cloneLayoutItems = function (_a) {
            var from = _a.from, to = _a.to, _b = _a.offsetMultiplier, offsetMultiplier = _b === void 0 ? 1 : _b, metadata = _a.metadata;
            return __awaiter(_this, void 0, void 0, function () {
                var newLayoutItems;
                var _this = this;
                return __generator(this, function (_c) {
                    if (!Array.isArray(from) ||
                        !Array.isArray(to) ||
                        from.length !== to.length) {
                        throw new Error("Cannot clone viz, incorrect inputs from " + from + ", to: " + to);
                    }
                    this.emitTelemetry({
                        pageAction: 'cloneLayoutItems',
                        metadata: metadata,
                    });
                    newLayoutItems = [];
                    from.forEach(function (copyItemId, idx) {
                        var item = _this.layout.layoutStructureRef.current.find(function (itm) { return itm.item === copyItemId; });
                        if (!item) {
                            return;
                        }
                        if (item.type === 'block' || !item.type) {
                            var clonedBlockItem = layoutUtils_1.cloneBlockItem({
                                id: to[idx],
                                item: item,
                                offsetMultiplier: offsetMultiplier,
                            });
                            newLayoutItems.push(clonedBlockItem);
                        }
                        else if (item.type === 'line') {
                            // line is a bit complicate as we need to clone base on abs position
                            var linePosition = lineUtils_1.computeLineAbsPosition({
                                layoutStructure: _this.layout.layoutStructureRef.current,
                                position: item.position,
                            });
                            var clonedLine = layoutUtils_1.cloneLine({
                                id: to[idx],
                                item: {
                                    item: copyItemId,
                                    type: 'line',
                                    position: linePosition,
                                },
                                offsetMultiplier: offsetMultiplier,
                            });
                            newLayoutItems.push(clonedLine);
                        }
                    });
                    return [2 /*return*/, __spread(this.layout.layoutStructureRef.current, newLayoutItems)];
                });
            });
        };
        /**
         * get dashboard canvas dom element
         */
        _this.getCanvasDomElement = function () {
            return _this.layout.getCanvasDomElement();
        };
        /**
         * return snapshot of that includes inlined background image
         * @method
         * @returns {Object} Updated Layout options with encoded background image
         * @public
         */
        _this.snapshot = function () {
            var _a, _b, _c, _d;
            var srcFromOptions = (_c = (_b = (_a = _this.layout.options) === null || _a === void 0 ? void 0 : _a.backgroundImage) === null || _b === void 0 ? void 0 : _b.src) !== null && _c !== void 0 ? _c : '';
            var srcFromImageRegistry = imageUtils_1.isFromImageRegistry(srcFromOptions);
            var backgroundImage = ((_d = _this.layout.options) === null || _d === void 0 ? void 0 : _d.backgroundImage) ? {
                backgroundImage: __assign(__assign({}, _this.layout.options.backgroundImage), { src: srcFromImageRegistry &&
                        get_1.default(_this.layout, ['canvasRef'])
                        ? get_1.default(_this.layout, [
                            'canvasRef',
                            'current',
                            'state',
                            'imageSrc',
                        ], '')
                        : srcFromOptions }),
            }
                : {};
            return {
                options: __assign(__assign({}, _this.layout.options), backgroundImage),
            };
        };
        /**
         * Sets dashboard scale
         * @param {Number} scale New scale as floating point number
         */
        _this.setScale = function (scale) {
            return _this.layout.setScale(scale);
        };
        /**
         * Increases dashboard zoom level for one step
         */
        _this.zoomIn = function () {
            return _this.layout.zoomIn();
        };
        /**
         * Decreases dashboard zoom level for one step
         */
        _this.zoomOut = function () {
            return _this.layout.zoomOut();
        };
        /**
         * Adjust dashboard's scale to fit the width of the container
         */
        _this.fitToWidth = function () {
            return _this.layout.setFitToWidthAndScrollToTopLeft();
        };
        /**
         * @returns {Object} Observable that tracks zoom level changes or null if zoom is unsupported
         */
        _this.getZoomLevel = function () {
            return _this.layout.getZoomObserver();
        };
        _this.layout = layout;
        _this.telemetry = telemetry;
        return _this;
    }
    return AbsoluteLayoutApi;
}(BaseLayoutApi_1.default));
exports.default = AbsoluteLayoutApi;


/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var react_1 = __importStar(__webpack_require__(0));
var uniqBy_1 = __importDefault(__webpack_require__(64));
var noop_1 = __importDefault(__webpack_require__(16));
var last_1 = __importDefault(__webpack_require__(65));
var useEventCallback_1 = __importDefault(__webpack_require__(35));
var Canvas_1 = __importDefault(__webpack_require__(30));
var SelectBox_1 = __importDefault(__webpack_require__(66));
var layoutUtils_1 = __webpack_require__(2);
/**
 * default internal state
 */
var defaultState = {
    startPosition: null,
    currentPosition: null,
    isMoving: false,
    isSelecting: false,
};
var DEFAULT_SELECTED_LAYOUT_ITEMS = [];
var AbsoluteCanvas = function (props) {
    var scale = props.scale, children = props.children, canvasRef = props.canvasRef, blockItems = props.blockItems, _a = props.onItemMove, onItemMove = _a === void 0 ? noop_1.default : _a, _b = props.onItemMoved, onItemMoved = _b === void 0 ? noop_1.default : _b, onItemSelected = props.onItemSelected, _c = props.movable, movable = _c === void 0 ? false : _c, allowMultiselect = props.allowMultiselect, _d = props.selectedLayoutItems, selectedLayoutItems = _d === void 0 ? DEFAULT_SELECTED_LAYOUT_ITEMS : _d, _e = props.initialState, initialState = _e === void 0 ? defaultState : _e, canvasProps = __rest(props, ["scale", "children", "canvasRef", "blockItems", "onItemMove", "onItemMoved", "onItemSelected", "movable", "allowMultiselect", "selectedLayoutItems", "initialState"]);
    // State management
    var _f = __read(react_1.useState(initialState.startPosition), 2), startPosition = _f[0], setStartPosition = _f[1];
    var _g = __read(react_1.useState(initialState.currentPosition), 2), currentPosition = _g[0], setCurrentPosition = _g[1];
    var _h = __read(react_1.useState(initialState.isMoving), 2), isMoving = _h[0], setIsMoving = _h[1];
    var _j = __read(react_1.useState(initialState.isSelecting), 2), isSelecting = _j[0], setIsSelecting = _j[1];
    var resetState = react_1.useCallback(function () {
        setStartPosition(defaultState.startPosition);
        setCurrentPosition(defaultState.currentPosition);
        setIsMoving(defaultState.isMoving);
        setIsSelecting(defaultState.isSelecting);
    }, []);
    var handleItemSelected = react_1.useCallback(function (e, itemIds) {
        if (itemIds === void 0) { itemIds = []; }
        if (e.metaKey) {
            // Do not allow selecting line and block item with meta+click
            var selectedItems = selectedLayoutItems.filter(function (_a) {
                var type = _a.type;
                return type === 'block';
            });
            onItemSelected(e, uniqBy_1.default(__spread(selectedItems, itemIds), 'id'));
        }
        else {
            onItemSelected(e, itemIds);
        }
    }, [selectedLayoutItems, onItemSelected]);
    // Update current position and trigger onItemMove
    var handleMouseMove = useEventCallback_1.default(function (e) {
        if (!startPosition) {
            return;
        }
        var newPosition = layoutUtils_1.computeRelativePosition(e, canvasRef, scale);
        var offset = layoutUtils_1.getOffset(newPosition, startPosition);
        if (isMoving && layoutUtils_1.considerMoved(offset)) {
            e.preventDefault();
            onItemMove(e, offset);
        }
        setCurrentPosition(newPosition);
    });
    // If moving an item we'll trigger onItemMoved otherwise we select the items within the boundary
    var handleMouseUp = useEventCallback_1.default(function (e) {
        if (!startPosition) {
            return;
        }
        e.preventDefault();
        var curPosition = layoutUtils_1.computeRelativePosition(e, canvasRef, scale);
        var offset = layoutUtils_1.getOffset(curPosition, startPosition);
        var isMoved = layoutUtils_1.considerMoved(offset);
        if (isMoving && isMoved) {
            onItemMoved(e, offset);
        }
        else {
            // if the mosue is moved between mousedown and mouseup, then we should find all the items covered by the select box
            var boundary = layoutUtils_1.positionsToBoundary(startPosition, curPosition);
            var selectedBlocks = layoutUtils_1.filterBlockItemsByBoundary(blockItems, boundary).map(function (_a) {
                var item = _a.item;
                return ({
                    id: item,
                    type: 'block',
                });
            });
            // Just select the top item if single clicking a stacked viz
            var selectedBlockItems = [];
            if (!isMoved && selectedBlocks.length) {
                selectedBlockItems.push(last_1.default(selectedBlocks));
            }
            else {
                selectedBlockItems = selectedBlocks;
            }
            // it could be an unselect operation in view/edit mode, or a multiselect operation in edit mode
            if (selectedBlocks.length === 0 || isSelecting) {
                handleItemSelected(e, selectedBlockItems);
            }
        }
        resetState();
    });
    // Handle starting the select box or selecting and moving and item
    var handleMouseDown = useEventCallback_1.default(function (e) {
        var pos = layoutUtils_1.computeRelativePosition(e, canvasRef, scale);
        // always track start position
        setStartPosition(pos);
        if (allowMultiselect) {
            setIsSelecting(true);
        }
        var block = layoutUtils_1.findTopBlockItemByPosition(blockItems, pos);
        if (!block) {
            return;
        }
        // mouse down on an item, set it to selected and start moving.
        if (!selectedLayoutItems.find(function (_a) {
            var id = _a.id;
            return id === block.item;
        })) {
            // select the block item right away if it's not selected.
            handleItemSelected(e, [{ id: block.item, type: 'block' }]);
        }
        if (movable) {
            setIsMoving(true);
        }
    });
    // we bind mouse move and mouse up on global so user move mouse out of canvas will still work
    react_1.useEffect(function () {
        document.addEventListener('mousemove', handleMouseMove);
        return function () {
            document.removeEventListener('mousemove', handleMouseMove);
        };
    }, [handleMouseMove]);
    react_1.useEffect(function () {
        document.addEventListener('mouseup', handleMouseUp);
        return function () {
            document.removeEventListener('mouseup', handleMouseUp);
        };
    }, [handleMouseUp]);
    var selectBox = react_1.useMemo(function () {
        if (allowMultiselect &&
            isSelecting &&
            !isMoving &&
            startPosition &&
            currentPosition) {
            return react_1.default.createElement(SelectBox_1.default, { start: startPosition, end: currentPosition });
        }
        return null;
    }, [
        allowMultiselect,
        isSelecting,
        isMoving,
        startPosition,
        currentPosition,
    ]);
    return (react_1.default.createElement(Canvas_1.default, __assign({ ref: canvasRef }, canvasProps, { scale: scale, onMouseDown: handleMouseDown, onContextMenu: resetState }),
        selectBox,
        children));
};
exports.default = react_1.forwardRef(function (props, ref) {
    return react_1.default.createElement(AbsoluteCanvas, __assign({ canvasRef: ref }, props));
});


/***/ }),
/* 64 */
/***/ (function(module, exports) {

module.exports = require("lodash/uniqBy");

/***/ }),
/* 65 */
/***/ (function(module, exports) {

module.exports = require("lodash/last");

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var react_1 = __importDefault(__webpack_require__(0));
var prop_types_1 = __importDefault(__webpack_require__(3));
var styled_components_1 = __importDefault(__webpack_require__(1));
var themes_1 = __webpack_require__(4);
var mixins_1 = __webpack_require__(8);
var SelectDiv = styled_components_1.default.div.attrs(function (_a) {
    var x = _a.x, y = _a.y, w = _a.w, h = _a.h;
    return ({
        style: {
            width: w,
            height: h,
            transform: "translate(" + x + "px, " + y + "px)",
        },
    });
})(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n    ", ";\n    position: absolute;\n    background: transparent;\n    // the next line is important to avoid blocking the drilldowns, and it allows to select text from visualizations\n    pointer-events: none;\n    border: 1px solid\n        ", ";\n    z-index: 1000;\n"], ["\n    ", ";\n    position: absolute;\n    background: transparent;\n    // the next line is important to avoid blocking the drilldowns, and it allows to select text from visualizations\n    pointer-events: none;\n    border: 1px solid\n        ",
    ";\n    z-index: 1000;\n"])), mixins_1.reset('block'), themes_1.pick({
    enterprise: themes_1.variables.accentColorL10,
    prisma: themes_1.variables.interactiveColorPrimary,
}));
var SelectBox = function (_a) {
    var start = _a.start, end = _a.end;
    return (react_1.default.createElement(SelectDiv, { w: Math.abs(start.x - end.x), h: Math.abs(start.y - end.y), x: Math.min(start.x, end.x), y: Math.min(start.y, end.y) }));
};
SelectBox.propTypes = {
    /**
     * starting position
     */
    start: prop_types_1.default.shape({
        x: prop_types_1.default.number,
        y: prop_types_1.default.number,
    }),
    /**
     * end position
     */
    end: prop_types_1.default.shape({
        x: prop_types_1.default.number,
        y: prop_types_1.default.number,
    }),
};
exports.default = SelectBox;
var templateObject_1;


/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.updateLayoutStructureOnKeyboardMove = exports.reducer = exports.initializeLayoutStructureState = void 0;
var layoutUtils_1 = __webpack_require__(2);
var lineUtils_1 = __webpack_require__(29);
var initializeLayoutStructureState = function (layoutStructure) {
    return layoutStructure.reduce(function (obj, item) {
        // eslint-disable-next-line no-param-reassign
        obj[item.item] = __assign({}, item);
        return obj;
    }, {});
};
exports.initializeLayoutStructureState = initializeLayoutStructureState;
var reducer = function (state, action) {
    var _a, _b, _c, _d, _e, _f, _g;
    switch (action.type) {
        case 'lineMove':
            return __assign(__assign({}, state), (_a = {}, _a[action.payload.item] = action.payload, _a));
        case 'lineDragStart':
            return __assign(__assign({}, state), (_b = {}, _b[action.payload.item] = action.payload, _b));
        case 'lineDrag': {
            var lineToDrag = state[action.payload.id];
            return layoutUtils_1.isLineConnected({
                line: lineToDrag,
                dir: action.payload.dir,
            })
                ? state
                : __assign(__assign({}, state), (_c = {}, _c[action.payload.id] = __assign(__assign({}, lineToDrag), { position: __assign(__assign({}, lineToDrag.position), (_d = {}, _d[action.payload.dir] = action.payload.absPos, _d)) }), _c));
        }
        case 'lineConnect': {
            var lineToConnect = state[action.payload.lineId];
            return layoutUtils_1.isLineConnected({
                line: lineToConnect,
                dir: action.payload.lineDir,
            })
                ? state
                : __assign(__assign({}, state), (_e = {}, _e[action.payload.lineId] = layoutUtils_1.connectLine({
                    line: lineToConnect,
                    dir: action.payload.lineDir,
                    itemId: action.payload.itemId,
                    port: action.payload.port,
                }), _e));
        }
        case 'lineDisconnect': {
            var lineToDisconnect = state[action.payload.lineId];
            return layoutUtils_1.isLineConnected({
                line: lineToDisconnect,
                dir: action.payload.lineDir,
            })
                ? __assign(__assign({}, state), (_f = {}, _f[action.payload.lineId] = layoutUtils_1.disconnectLine({
                    line: lineToDisconnect,
                    dir: action.payload.lineDir,
                    absPos: lineUtils_1.computeLineAbsPosition({
                        layoutStructure: Object.values(state),
                        position: lineToDisconnect.position,
                    })[action.payload.lineDir],
                }), _f)) : state;
        }
        case 'blockResize':
            return __assign(__assign({}, state), (_g = {}, _g[action.payload.item] = action.payload, _g));
        case 'blocksMove':
            return action.payload.reduce(function (s, blockItem) {
                var _a;
                return (__assign(__assign({}, s), (_a = {}, _a[blockItem.item] = blockItem, _a)));
            }, __assign({}, state));
        case 'reset':
            return exports.initializeLayoutStructureState(action.payload);
        default:
            return state;
    }
};
exports.reducer = reducer;
var updateLayoutStructureOnKeyboardMove = function (_a) {
    var selectedLineItems = _a.selectedLineItems, selectedBlockItems = _a.selectedBlockItems, layoutStructure = _a.layoutStructure, dir = _a.dir, snap = _a.snap, gridSize = _a.gridSize;
    var updatedLines = selectedLineItems.map(function (_a) {
        var item = _a.item;
        var offset = layoutUtils_1.createOffset(dir, 1, 1);
        return lineUtils_1.handleSingleLineMove({
            layoutStructure: layoutStructure,
            lineId: item,
            offset: offset,
        });
    });
    var updatedBlocks = selectedBlockItems.map(function (blockItem) {
        var position = blockItem.position;
        var snapOffset = snap
            ? layoutUtils_1.snapOffsetToXY({
                position: position,
                offset: layoutUtils_1.createOffset(dir, gridSize, gridSize),
                gridWidth: gridSize,
                gridHeight: gridSize,
                spacing: 0,
                padding: 0,
            })
            : layoutUtils_1.createOffset(dir, 1, 1);
        return layoutUtils_1.updateBlockItemPosition(blockItem, snapOffset);
    });
    var updatedItems = __spread(updatedLines, updatedBlocks);
    var updatedLayoutStructure = layoutStructure.map(function (item) { var _a; return (_a = updatedItems.find(function (line) { return line.item === item.item; })) !== null && _a !== void 0 ? _a : item; });
    return updatedLayoutStructure;
};
exports.updateLayoutStructureOnKeyboardMove = updateLayoutStructureOnKeyboardMove;


/***/ })
/******/ ]);
//# sourceMappingURL=AbsoluteLayout.js.map
/*!
 * Copyright © 2020 Splunk Inc.
 * SPLUNK CONFIDENTIAL – Use or disclosure of this material in whole or
 * in part without a valid written license from Splunk Inc. is PROHIBITED.
 */
module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 82);
/******/ })
/************************************************************************/
/******/ ({

/***/ 0:
/***/ (function(module, exports) {

module.exports = require("react");

/***/ }),

/***/ 1:
/***/ (function(module, exports) {

module.exports = require("styled-components");

/***/ }),

/***/ 10:
/***/ (function(module, exports) {

module.exports = require("lodash/get");

/***/ }),

/***/ 11:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.findEdgesInBoundary = exports.findSnappableEdges = exports.moveVerticalEdge = exports.moveHorizontalEdge = exports.getHorizontalBoundaries = exports.getVerticalBoundaries = exports.applyVizPadding = exports.formatEdge = exports.computeEdges = exports.getAllEdges = void 0;
var uniqueId_1 = __webpack_require__(12);
var nextEdgeId = function () { return "edge_" + uniqueId_1.uniqueId(); };
/**
 * generate edge id
 */
var getNextEdgeId = function () {
    return nextEdgeId();
};
/**
 * Returns a 2D array of every viz corner, indicating which visualizations touch which node(corner)
 * @param {Object} layoutStructure - Array of visualizations from definition
 * @returns {Object[][]} - {x: { y: [vizList] } }
 */
var getNodes = function (layoutStructure) {
    if (layoutStructure.length === 0) {
        return null;
    }
    var nodes = {};
    layoutStructure.forEach(function (viz) {
        var _a = viz.position, x = _a.x, y = _a.y, w = _a.w, h = _a.h;
        var corners = [
            { x: x, y: y },
            { x: x + w, y: y },
            { x: x, y: y + h },
            { x: x + w, y: y + h },
        ];
        corners.forEach(function (corner) {
            if (nodes[corner.x] === undefined) {
                nodes[corner.x] = {};
            }
            if (nodes[corner.x][corner.y] === undefined) {
                nodes[corner.x][corner.y] = [];
            }
            nodes[corner.x][corner.y].push(viz);
        });
    });
    return nodes;
};
var isTopEdge = function (edge) {
    return edge.orientation === 'horizontal' && edge.edgeStart.y === 0;
};
var isBottomEdge = function (edge, canvasHeight) {
    return edge.orientation === 'horizontal' && edge.edgeStart.y === canvasHeight;
};
var isLeftEdge = function (edge) {
    return edge.orientation === 'vertical' && edge.edgeStart.x === 0;
};
var isRightEdge = function (edge, canvasWidth) {
    return edge.orientation === 'vertical' && edge.edgeStart.x === canvasWidth;
};
/**
 * Returns all the visualizations along a vertical edge
 * @param {Object} param - Param object needed to traverse along vertical edge
 * @param {num} param.x - x-coordinate of the edge
 * @param {num} param.yStart - y-coordinate of the edge start
 * @param {num} param.yEnd - y-coordinate of the edge end
 * @param {num} param.yCurrent - Current y in recursion
 * @param {num} param.nodes - The map of x,y coordinates to visualizations that touch that (x,y)
 * @param {num} param.visualizations - the list to add visualizations to, and then return
 * @returns {Set<Object>} - Set of unique visualizations along the edge
 */
var findVizAlongVerticalEdge = function (_a) {
    var x = _a.x, yStart = _a.yStart, yEnd = _a.yEnd, _b = _a.yCurrent, yCurrent = _b === void 0 ? yStart : _b, nodes = _a.nodes, _c = _a.visualizations, visualizations = _c === void 0 ? new Set() : _c;
    nodes[x][yCurrent].forEach(function (viz) {
        if (viz.position.y >= yStart && viz.position.y < yEnd) {
            visualizations.add(viz);
        }
        if (viz.position.y >= yCurrent && yCurrent + viz.position.h <= yEnd) {
            findVizAlongVerticalEdge({
                x: x,
                yStart: yStart,
                yEnd: yEnd,
                yCurrent: yCurrent + viz.position.h,
                nodes: nodes,
                visualizations: visualizations,
            });
        }
    });
    return visualizations;
};
/**
 * Returns all the visualizations along a horizontal edge
 * @param {Object} param - Param object needed to traverse along horizontal edge
 * @param {num} param.y - x-coordinate of the edge
 * @param {num} param.xStart - x-coordinate of the edge start
 * @param {num} param.xEnd - x-coordinate of the edge end
 * @param {num} param.xCurrent - Current x in recursion
 * @param {num} param.nodes - The map of x,y coordinates to visualizations that touch that (x,y)
 * @param {num} param.visualizations - the list to add visualizations to, and then return
 * @returns {Set<Object>} - Set of unique visualizations along the edge
 */
var findVizAlongHorizontalEdge = function (_a) {
    var y = _a.y, xStart = _a.xStart, xEnd = _a.xEnd, _b = _a.xCurrent, xCurrent = _b === void 0 ? xStart : _b, nodes = _a.nodes, _c = _a.visualizations, visualizations = _c === void 0 ? new Set() : _c;
    nodes[xCurrent][y].forEach(function (viz) {
        if (viz.position.x >= xStart && viz.position.x < xEnd) {
            visualizations.add(viz);
        }
        if (viz.position.x >= xCurrent && xCurrent + viz.position.w <= xEnd) {
            findVizAlongHorizontalEdge({
                y: y,
                xStart: xStart,
                xEnd: xEnd,
                xCurrent: xCurrent + viz.position.w,
                nodes: nodes,
                visualizations: visualizations,
            });
        }
    });
    return visualizations;
};
/**
 * Add edge to the provided list
 * @param {Object} param - Params containing edge info
 * @param {num} param.edges - the list to add the edge to
 * @param {Object} param.edgeStart - the start of the edge
 * @param {Object} param.edgeEnd - the end of the edge
 * @param {Object[][]} param.nodes - The map of x,y coordinates to visualizations that touch that (x,y)
 */
var addEdge = function (_a) {
    var edges = _a.edges, edgeStart = _a.edgeStart, edgeEnd = _a.edgeEnd, nodes = _a.nodes;
    var orientation = edgeStart.y === edgeEnd.y ? 'horizontal' : 'vertical';
    // Find all visualizations that are affected by this edge
    var visualizations = orientation === 'vertical'
        ? findVizAlongVerticalEdge({
            x: edgeStart.x,
            yStart: edgeStart.y,
            yEnd: edgeEnd.y,
            nodes: nodes,
        })
        : findVizAlongHorizontalEdge({
            y: edgeStart.y,
            xStart: edgeStart.x,
            xEnd: edgeEnd.x,
            nodes: nodes,
        });
    edges.push({
        item: getNextEdgeId(),
        edgeStart: edgeStart,
        edgeEnd: edgeEnd,
        visualizations: Array.from(visualizations),
        orientation: orientation,
    });
};
/**
 * If there is no incoming edge from the top, return true
 * @param {num} y - Current y position to compare against
 * @param {Object[]} visualizations - Array of visualizations attached to the node at (x, y). Length will be 1 to 4.
 * @returns {boolean}
 */
var shouldTraverseDown = function (y, visualizations) {
    return visualizations.every(function (viz) { return viz.position.y >= y; });
};
/**
 * If there is no incoming edge from the left, return true
 * @param {num} x - Current x position to compare against
 * @param {Object[]} visualizations - Array of visualizations attached to the node at (x, y). Length will be 1 to 4.
 * @returns {boolean}
 */
var shouldTraverseRight = function (x, visualizations) {
    return visualizations.every(function (viz) { return viz.position.x >= x; });
};
/**
 * Find the offset to the next node.
 * @param {Object} param - Param object to find offset to next node
 * @param {Number} param.x - The x co-ordinate of the current position to find offset from
 * @param {Number} param.y - The y co-ordinate of the current position to find offset from
 * @param {Object[]} param.visualizations - Array of visualizations attached to the node at (x, y). Length will be 1 to 4.
 * @param {Object} param.visualizations[].position - Position information of the visualization
 * @param {String} param.type - The type of co-ordinate. One of 'w' or 'h'.
 * @returns {number}
 */
var findOffset = function (_a) {
    var x = _a.x, y = _a.y, visualizations = _a.visualizations, type = _a.type;
    for (var i = 0; i < visualizations.length; i += 1) {
        var position = visualizations[i].position;
        if (position.y === y && position.x === x) {
            return position[type];
        }
    }
    // This for-loop is only for finding the bottom canvas edge and the right canvas edge
    for (var i = 0; i < visualizations.length; i += 1) {
        var position = visualizations[i].position;
        if (type === 'w' && position.x === x) {
            // horizontal canvas edge
            return position.w;
        }
        if (type === 'h' && position.y === y) {
            // vertical canvas edge
            return position.h;
        }
    }
    return 0;
};
/**
 * Traverse right along nodes, creating or extending edges
 * @param {Object} param - Param object to traverse right along layout
 * @param {Object[][]} param.nodes - An object that maps {x, y} coord to an array of visualizations. Indexed as nodes[x][y].
 * @param {Object[]} param.edges - The resulting array of edges that gets mutated
 * @param {Number} param.x - x coordinate of current node
 * @param {Number} param.y - y coordinate of current node
 * @param {Object} param.edgeStart - The { x, y } coordinates of start of edge
 * @param {Boolean} param.canTraverseDown - Used to prevent loops during indirect recursion
 */
function traverseRight(_a) {
    var x = _a.x, y = _a.y, nodes = _a.nodes, edges = _a.edges, edgeStart = _a.edgeStart, _b = _a.canTraverseDown, canTraverseDown = _b === void 0 ? true : _b;
    // Check if we should traverse down (if there is no incoming edge)
    // canTraverseRight must be false to avoid endless loop
    if (canTraverseDown && shouldTraverseDown(y, nodes[x][y])) {
        // eslint-disable-next-line @typescript-eslint/no-use-before-define
        traverseDown({
            x: x,
            y: y,
            nodes: nodes,
            edges: edges,
            edgeStart: { x: x, y: y },
            canTraverseRight: false,
        });
    }
    // Check if horizontal edge ends here
    // 'w' signifies we want width offset returned as opposed to height
    var offset = findOffset({ x: x, y: y, visualizations: nodes[x][y], type: 'w' });
    // Case 1 for ending edge: can't go right anymore (hit a viz OR end of dashboard), create edge up to this point.
    if (!offset) {
        addEdge({ edges: edges, edgeStart: edgeStart, edgeEnd: { x: x, y: y }, nodes: nodes });
        return;
    }
    // Case 2 for ending edge: reached window, need to create edge and start new one to avoid merging across window
    var isWindow = nodes[x][y].length === 4; // 4-way intersection
    if (isWindow) {
        addEdge({ edges: edges, edgeStart: edgeStart, edgeEnd: { x: x, y: y }, nodes: nodes });
        // Continue traversing right, starting with a new edge from current position
        traverseRight({
            x: x + offset,
            y: y,
            nodes: nodes,
            edges: edges,
            edgeStart: { x: x, y: y },
        });
        return;
    }
    // Continue traversing right, merging the past edge with the next
    traverseRight({
        x: x + offset,
        y: y,
        nodes: nodes,
        edges: edges,
        edgeStart: edgeStart,
    });
}
/**
 * Traverse right along nodes, creating or extending edges
 * @param {Object} param - Param object to traverse down along layout
 * @param {Object[][]} param.nodes - An object that maps {x, y} coord to an array of visualizations. Indexed as nodes[x][y].
 * @param {Object[]} param.edges - The resulting array of edges that gets mutated
 * @param {Number} param.x - x coordinate of current node
 * @param {Number} param.y - y coordinate of current node
 * @param {Object} param.edgeStart - The { x, y } coordinates of start of edge
 * @param {Boolean} param.canTraverseRight - Used to prevent loops during indirect recursion
 */
function traverseDown(_a) {
    var x = _a.x, y = _a.y, nodes = _a.nodes, edges = _a.edges, edgeStart = _a.edgeStart, _b = _a.canTraverseRight, canTraverseRight = _b === void 0 ? true : _b;
    if (canTraverseRight && shouldTraverseRight(x, nodes[x][y])) {
        traverseRight({
            x: x,
            y: y,
            nodes: nodes,
            edges: edges,
            edgeStart: { x: x, y: y },
            canTraverseDown: false,
        });
    }
    // Check if vertical edge ends here
    var offset = findOffset({ x: x, y: y, visualizations: nodes[x][y], type: 'h' });
    // Case 1 for ending edge: can't go down anymore (hit a viz OR end of dashboard), create edge up to this point.
    if (!offset) {
        addEdge({ edges: edges, edgeStart: edgeStart, edgeEnd: { x: x, y: y }, nodes: nodes });
        return;
    }
    // Case 2 for ending edge: reached window, need to create edge and start new one to avoid merging across window
    var isWindow = nodes[x][y].length === 4;
    if (isWindow) {
        addEdge({ edges: edges, edgeStart: edgeStart, edgeEnd: { x: x, y: y }, nodes: nodes });
        // Start a new edge from current position
        traverseDown({
            x: x,
            y: y + offset,
            nodes: nodes,
            edges: edges,
            edgeStart: { x: x, y: y },
        });
        return;
    }
    // Continue traversing, thus "merging" edges
    traverseDown({
        x: x,
        y: y + offset,
        nodes: nodes,
        edges: edges,
        edgeStart: edgeStart,
    });
}
/**
 * Compute the vertical edges for every canvas row - a row that spans the entire width of the canvas
 * @param {Object} param
 * @param {AbsoluteBlockItem[]} param.layout - Layout structure
 * @param {EdgeItem[]} param.edges - The resulting array of edges that gets mutated
 * @param {Number} param.canvasWidth - Canvas width
 */
var computeVerticalCanvasEdges = function (_a) {
    var edges = _a.edges, canvasWidth = _a.canvasWidth, layout = _a.layout;
    var nodes = getNodes(layout);
    if (nodes == null) {
        return;
    }
    // get all the horizontal edges that span the entire canvas width
    var sortedRowEdges = edges
        .filter(function (edge) {
        return edge.orientation === 'horizontal' &&
            edge.edgeStart.x === 0 &&
            edge.edgeEnd.x === canvasWidth;
    })
        .sort(function (a, b) { return a.edgeStart.y - b.edgeStart.y; });
    /**
     * iterate through the sorted horizontal edges to get their start and end coordinates
     * vertical edges between canvas row A and canvas row B will span from edgeStartA to edgeStartB and edgeEndA to edgeEndB
     */
    for (var i = 0; i < sortedRowEdges.length - 1; i += 1) {
        var _b = sortedRowEdges[i], edgeStartA = _b.edgeStart, edgeEndA = _b.edgeEnd;
        var _c = sortedRowEdges[i + 1], edgeStartB = _c.edgeStart, edgeEndB = _c.edgeEnd;
        addEdge({
            edges: edges,
            edgeStart: edgeStartA,
            edgeEnd: edgeStartB,
            nodes: nodes,
        });
        addEdge({
            edges: edges,
            edgeStart: edgeEndA,
            edgeEnd: edgeEndB,
            nodes: nodes,
        });
    }
};
/**
 * Gets all the edges given a layout of AbsoluteBlockItems
 * @param {AbsoluteBlockItem[]} layout - Array of AbsoluteBlockItems
 * @returns {EdgeItem[]} - Array of computed edges
 */
var getAllEdges = function (layout) {
    var edges = [];
    var nodes = getNodes(layout);
    if (nodes === null || nodes[0] === undefined || nodes[0][0] === undefined) {
        // When no visualizations in the layout structure
        // OR when there is no visualization at (0,0), which this algorithm assumes
        return [];
    }
    // run the algorithm
    traverseRight({
        x: 0,
        y: 0,
        nodes: nodes,
        edges: edges,
        edgeStart: { x: 0, y: 0 },
    });
    return edges;
};
exports.getAllEdges = getAllEdges;
/**
 * Compute edges given a valid layout, canvasHeight, and canvasWidth
 * @param {Object} param - Param object containing layout, canvasHeight, canvasWidth
 * @param {Object[]} param.layout - Array of visualizations from the dashboard layout definition
 * @param {Number} param.canvasHeight - Canvas height
 * @param {Number} param.canvasWidth - Canvas width
 * @returns {Object[]} - Array of computed edges
 */
var computeEdges = function (_a) {
    var layout = _a.layout, canvasHeight = _a.canvasHeight, canvasWidth = _a.canvasWidth;
    if (layout === undefined) {
        return [];
    }
    var edges = exports.getAllEdges(layout);
    // remove the computed left and right vertical canvas edges as they span the entire height of the canvas
    edges = edges.filter(function (edge) {
        return !(isLeftEdge(edge) || isRightEdge(edge, canvasWidth));
    });
    // recompute the vertical canvas edges for each canvas row where the row spans the entire width of the canvas
    computeVerticalCanvasEdges({ edges: edges, layout: layout, canvasWidth: canvasWidth });
    // Additionally, the top and bottom edge are there, but set to hidden
    edges = edges.map(function (edge) {
        var isCanvasEdge = false;
        if (isTopEdge(edge) ||
            isRightEdge(edge, canvasWidth) ||
            isBottomEdge(edge, canvasHeight) ||
            isLeftEdge(edge)) {
            isCanvasEdge = true;
        }
        return __assign(__assign({}, edge), { isCanvasEdge: isCanvasEdge });
    });
    return edges;
};
exports.computeEdges = computeEdges;
/**
 * Format edge according to a given padding and edge thickness
 * @param {Object} param - Param object containing edge, padding, and edgeThickness
 * @param {Object} param.edge - Edge object
 * @param {Number} param.padding - Layout padding
 * @param {Number} param.edgeThickness - Thickness of edge
 * @returns {Object} - Returns formatted edge object
 */
var formatEdge = function (_a) {
    var edge = _a.edge, _b = _a.padding, padding = _b === void 0 ? 0 : _b, _c = _a.edgeThickness, edgeThickness = _c === void 0 ? 0 : _c;
    // Formatted edges are centered between visualizations and respect the padding (gutter-size) between them
    var formattedEdgeStart = __assign({}, edge.edgeStart);
    var formattedEdgeEnd = __assign({}, edge.edgeEnd);
    if (edge.orientation === 'horizontal') {
        formattedEdgeStart.x += padding;
        formattedEdgeStart.y -= edgeThickness / 2;
        formattedEdgeEnd.x -= padding;
        formattedEdgeEnd.y -= edgeThickness / 2;
    }
    else {
        formattedEdgeStart.y += padding;
        formattedEdgeStart.x -= edgeThickness / 2;
        formattedEdgeEnd.y -= padding;
        formattedEdgeEnd.x -= edgeThickness / 2;
    }
    return __assign(__assign({}, edge), { edgeStart: formattedEdgeStart, edgeEnd: formattedEdgeEnd });
};
exports.formatEdge = formatEdge;
/**
 * Format visualization according to a given padding
 * @param {Object} param - Param object containing item and padding
 * @param {Object} param.item - Visualization object
 * @param {Number} param.padding - Layout padding
 * @returns {AbsoluteBlockItem} - Returns formatted edge object
 */
var applyVizPadding = function (_a) {
    var item = _a.item, _b = _a.padding, padding = _b === void 0 ? 0 : _b;
    var _c = item.position, x = _c.x, y = _c.y, w = _c.w, h = _c.h;
    return __assign(__assign({}, item), { position: {
            x: x + padding,
            y: y + padding,
            w: w - 2 * padding,
            h: h - 2 * padding,
        } });
};
exports.applyVizPadding = applyVizPadding;
/**
 * Determines Upper and Lower boundaries of an edge given its visualizations around it
 * @param {Object[]} visualizations - The visualizations surrounding the edge
 * @param {Number} y - The y position of the selected edge
 * @param {Number} minHeight - minimum Item Height Value
 * @param {Boolean} isFullWidthEdge - If the edge we are getting boundaries of is the size of canvas width
 * @returns {Object} - returns the boundaries in an object
 */
var getVerticalBoundaries = function (_a) {
    var visualizations = _a.visualizations, y = _a.y, minHeight = _a.minHeight, _b = _a.isFullWidthEdge, isFullWidthEdge = _b === void 0 ? false : _b;
    var boundaries = {
        upperBoundary: Number.NEGATIVE_INFINITY,
        lowerBoundary: Number.POSITIVE_INFINITY,
    };
    var comparePosition = function (position) {
        // If viz is below of the edge
        // When the edge is a full width edge, there is no lower boundary
        //  since dragging down increases canvas size
        if (position.y >= y && !isFullWidthEdge) {
            boundaries.lowerBoundary = Math.min(boundaries.lowerBoundary, position.y + position.h - minHeight);
        }
        // If viz is above the edge
        if (position.y < y) {
            boundaries.upperBoundary = Math.max(boundaries.upperBoundary, position.y + minHeight);
        }
    };
    visualizations.forEach(function (viz) { return comparePosition(viz.position); });
    return boundaries;
};
exports.getVerticalBoundaries = getVerticalBoundaries;
/**
 * Determines Left and Right boundaries of an edge given its visualizations around it
 * @param {Object[]} visualizations - The visualizations surrounding the edge
 * @param {Number} x - The x position of the selected edge
 * @param {Number} minWidth - minimum Item Width Value
 * @returns {Object} - returns the boundaries in an object
 */
var getHorizontalBoundaries = function (_a) {
    var visualizations = _a.visualizations, x = _a.x, minWidth = _a.minWidth;
    var boundaries = {
        rightBoundary: Number.POSITIVE_INFINITY,
        leftBoundary: Number.NEGATIVE_INFINITY,
    };
    var comparePosition = function (position) {
        if (position.x >= x) {
            // If viz is to the right of the edge
            boundaries.rightBoundary = Math.min(boundaries.rightBoundary, position.x + position.w - minWidth);
        }
        if (position.x < x) {
            // If viz is to the left of the edge
            boundaries.leftBoundary = Math.max(boundaries.leftBoundary, position.x + minWidth);
        }
    };
    visualizations.forEach(function (viz) { return comparePosition(viz.position); });
    return boundaries;
};
exports.getHorizontalBoundaries = getHorizontalBoundaries;
/**
 * Determines the next edge position for movement up and down of a horizontal edge
 * @param {Object} edge - the current moving edge
 * @param {Number} offset - offset to move edge
 * @param {Object} options.edgeBoundaries Object with lower/upper boundaries
 * @returns {Object} - returns edge with updated position
 */
var moveHorizontalEdge = function (_a) {
    var edge = _a.edge, offset = _a.offset, _b = _a.edgeBoundaries, upperBoundary = _b.upperBoundary, lowerBoundary = _b.lowerBoundary;
    // Update edge to either the offset value,
    // or the defined maximum/minimum based on min viz height/width
    var updatedY = offset < 0
        ? Math.max(upperBoundary, edge.edgeStart.y + offset)
        : Math.min(lowerBoundary, edge.edgeStart.y + offset);
    return __assign(__assign({}, edge), { edgeStart: {
            x: edge.edgeStart.x,
            y: updatedY,
        }, edgeEnd: {
            x: edge.edgeEnd.x,
            y: updatedY,
        } });
};
exports.moveHorizontalEdge = moveHorizontalEdge;
/**
 * Determines the next edge position for movement left and right of a vertical edge
 * @param {Object} edge - the current moving edge
 * @param {Number} offset - offset to move edge
 * @param {Object} options.edgeBoundaries Object with left/right boundaries
 * @returns {Object} - returns edge with updated position
 */
var moveVerticalEdge = function (_a) {
    var edge = _a.edge, offset = _a.offset, _b = _a.edgeBoundaries, leftBoundary = _b.leftBoundary, rightBoundary = _b.rightBoundary;
    var updatedX = offset < 0
        ? Math.max(leftBoundary, edge.edgeStart.x + offset)
        : Math.min(rightBoundary, edge.edgeStart.x + offset);
    return __assign(__assign({}, edge), { edgeStart: {
            x: updatedX,
            y: edge.edgeStart.y,
        }, edgeEnd: {
            x: updatedX,
            y: edge.edgeEnd.y,
        } });
};
exports.moveVerticalEdge = moveVerticalEdge;
/**
 * find edges that the given edge should snap to, according to the snap range
 * @param {Object} options
 * @param {Object} options.edge the edge being dragged, edge has the structure
 * @param {array}  options.edges all the edges that are parallel to target edge and within the boundary
 * @param {Number} options.snapRange the range within which that triggers snapping
 * @returns {Object} updatedEdge and snappableEdges
 */
var findSnappableEdges = function (_a) {
    var _b, _c;
    var edge = _a.edge, edges = _a.edges, snapRange = _a.snapRange;
    var coordinate = edge.orientation === 'horizontal' ? 'y' : 'x';
    var snappableEdges = edges.reduce(function (currentSnappableEdges, nextEdge) {
        var nextEdgeDistance = Math.abs(nextEdge.edgeStart[coordinate] - edge.edgeStart[coordinate]);
        // nextEdge is in range
        if (nextEdgeDistance <= snapRange) {
            if (currentSnappableEdges.length === 0) {
                return [nextEdge];
            }
            var lastEdge = currentSnappableEdges[currentSnappableEdges.length - 1];
            var lastEdgeDistance = Math.abs(lastEdge.edgeStart[coordinate] - edge.edgeStart[coordinate]);
            // find new closest snappable edge
            if (nextEdgeDistance < lastEdgeDistance) {
                return [nextEdge];
            }
            // it is possible there are several snappable edges having the same x or y value
            if (nextEdgeDistance === lastEdgeDistance) {
                return __spread(currentSnappableEdges, [nextEdge]);
            }
        }
        // nextEdge is out of range
        return __spread(currentSnappableEdges);
    }, []);
    // if no snappable edge, snap to itself
    var firstSnappableEdge = snappableEdges.length > 0 ? snappableEdges[0] : edge;
    return {
        updatedEdge: __assign(__assign({}, edge), { edgeStart: __assign(__assign({}, edge.edgeStart), (_b = {}, _b[coordinate] = firstSnappableEdge.edgeStart[coordinate], _b)), edgeEnd: __assign(__assign({}, edge.edgeEnd), (_c = {}, _c[coordinate] = firstSnappableEdge.edgeEnd[coordinate], _c)) }),
        snappableEdges: snappableEdges,
    };
};
exports.findSnappableEdges = findSnappableEdges;
/**
 * Find all the edges that could be snapped to, given the limitations enforced by the surrounding visualizations.
 * @param {Object} options
 * @param {Object} options.edge the edge being dragged
 * @param {array}  options.edges all the edges on canvas
 * @param {Object} options.edgeBoundaries Object with either lower/upper or left/right boundaries
 * @returns {array} the edges that are within the boundary of the edge being moved
 */
var findEdgesInBoundary = function (_a) {
    var edge = _a.edge, edges = _a.edges, edgeBoundaries = _a.edgeBoundaries;
    var orientation = edge.orientation;
    if (orientation === 'horizontal') {
        return edges.filter(function (e) {
            return e.orientation === 'horizontal' &&
                e.edgeStart.y >=
                    edgeBoundaries.upperBoundary &&
                e.edgeStart.y <=
                    edgeBoundaries.lowerBoundary &&
                e !== edge;
        });
    }
    if (orientation === 'vertical') {
        return edges.filter(function (e) {
            return e.orientation === 'vertical' &&
                e.edgeStart.x >=
                    edgeBoundaries.leftBoundary &&
                e.edgeStart.x <=
                    edgeBoundaries.rightBoundary &&
                e !== edge;
        });
    }
    // can't match any edge because the orientation is invalid, this shouldn't happen.
    return [];
};
exports.findEdgesInBoundary = findEdgesInBoundary;


/***/ }),

/***/ 12:
/***/ (function(module, exports) {

module.exports = require("@splunk/dashboard-utils/uniqueId");

/***/ }),

/***/ 17:
/***/ (function(module, exports) {

module.exports = require("lodash/findLast");

/***/ }),

/***/ 18:
/***/ (function(module, exports) {

module.exports = require("lodash/isNumber");

/***/ }),

/***/ 19:
/***/ (function(module, exports) {

module.exports = require("lodash/reduce");

/***/ }),

/***/ 2:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.scaleGridLayoutStructureByWidth = exports.computeRelativePosition = exports.shiftViewportOnZoom = exports.cloneLine = exports.cloneBlockItem = exports.getAllCollisions = exports.resolveCompactionCollision = exports.bottom = exports.computeLineRelativePosition = exports.computeLineBoxPosition = exports.updateLineAbsPosition = exports.connectLine = exports.disconnectLine = exports.isLineConnected = exports.moveLayoutItem = exports.computeScaleToFit = exports.createOffset = exports.updateBlockItemPosition = exports.updateBlockItemSize = exports.snapOffsetToWH = exports.snapOffsetToXY = exports.snapOffset = exports.findTopBlockItemByPosition = exports.filterBlockItemsByBoundary = exports.positionsToBoundary = exports.considerMoved = exports.getOffset = exports.getClientPosition = exports.positionToStyleString = exports.positionToStyle = exports.removeInvalidItems = exports.isLinePositionValid = exports.isValidConnection = exports.isBlockPositionValid = exports.computeMaxHeight = void 0;
var findLast_1 = __importDefault(__webpack_require__(17));
var get_1 = __importDefault(__webpack_require__(10));
var isNumber_1 = __importDefault(__webpack_require__(18));
var reduce_1 = __importDefault(__webpack_require__(19));
var pullAt_1 = __importDefault(__webpack_require__(20));
var cloneDeep_1 = __importDefault(__webpack_require__(21));
var sortBy_1 = __importDefault(__webpack_require__(22));
var console_1 = __importDefault(__webpack_require__(5));
var layout_1 = __webpack_require__(6);
var edgeUtils_1 = __webpack_require__(11);
// export for gridLayout/legacyGridLayout
exports.computeMaxHeight = layout_1.computeMaxHeight;
/**
 *  check if a position is valid
 * @param {Object} position
 */
var isBlockPositionValid = function (position) {
    return !!(position &&
        Number.isInteger(position.x) &&
        Number.isInteger(position.y) &&
        Number.isInteger(position.w) &&
        Number.isInteger(position.h));
};
exports.isBlockPositionValid = isBlockPositionValid;
var isValidConnection = function (connection) {
    if ('x' in connection &&
        'y' in connection &&
        Number.isInteger(connection.x) &&
        Number.isInteger(connection.y)) {
        return true;
    }
    if ('item' in connection &&
        'port' in connection &&
        connection.item != null &&
        connection.port != null) {
        return true;
    }
    return false;
};
exports.isValidConnection = isValidConnection;
/**
 * a line should has from and to
 */
var isLinePositionValid = function (position) {
    if (position.from != null && position.to != null) {
        return (exports.isValidConnection(position.from) && exports.isValidConnection(position.to));
    }
    return false;
};
exports.isLinePositionValid = isLinePositionValid;
/**
 * filter invalid position
 * @param {Object[]} layoutStructure - Array of items (viz, edges, lines)
 * @returns {Object[]} - Returns filtered array
 */
var removeInvalidItems = function (layoutStructure) {
    if (layoutStructure === void 0) { layoutStructure = []; }
    return layoutStructure.filter(function (structure) {
        if (structure.type === 'line') {
            return exports.isLinePositionValid(structure.position);
        }
        return exports.isBlockPositionValid(structure.position);
    });
};
exports.removeInvalidItems = removeInvalidItems;
/**
 * convert position to css object
 */
var positionToStyle = function (pos) { return ({
    width: pos.w + "px",
    height: pos.h + "px",
    transform: "translate(" + pos.x + "px, " + pos.y + "px)",
}); };
exports.positionToStyle = positionToStyle;
/**
 * convert position to css string
 */
var positionToStyleString = function (pos) {
    var style = exports.positionToStyle(pos);
    return reduce_1.default(style, function (result, v, k) { return result + " " + k + ":" + v + ";"; }, '');
};
exports.positionToStyleString = positionToStyleString;
/**
 * get client position for given event with scale factor
 */
var getClientPosition = function (e, scaleFactor) {
    if (scaleFactor === void 0) { scaleFactor = 1; }
    return ({
        x: Math.round(e.clientX / scaleFactor),
        y: Math.round(e.clientY / scaleFactor),
    });
};
exports.getClientPosition = getClientPosition;
/**
 * compute offset from 2 positions
 */
var getOffset = function (currentPosition, startPosition) { return ({
    offsetX: currentPosition.x - startPosition.x,
    offsetY: currentPosition.y - startPosition.y,
}); };
exports.getOffset = getOffset;
/**
 * check if a given offset can be considered as 'move'
 * @param {Object} config
 * @param {Number} config.offsetX
 * @param {Number} config.offsetY
 */
var considerMoved = function (_a) {
    var offsetX = _a.offsetX, offsetY = _a.offsetY;
    return offsetX !== 0 || offsetY !== 0;
};
exports.considerMoved = considerMoved;
/**
 * return a boundary for 2 positions
 * @param {Coordinate} startPos
 * @param {Coordinate} endPos
 */
var positionsToBoundary = function (startPos, endPos) { return ({
    x: Math.min(startPos.x, endPos.x),
    y: Math.min(startPos.y, endPos.y),
    w: Math.abs(startPos.x - endPos.x),
    h: Math.abs(startPos.y - endPos.y),
}); };
exports.positionsToBoundary = positionsToBoundary;
/**
 * filter abs items within a boundary
 * @param {Array} items
 * @param {Object} boundary
 */
var filterBlockItemsByBoundary = function (items, boundary) {
    return items.filter(function (item) {
        var itemPosition = item.position;
        return !(boundary.x > itemPosition.x + itemPosition.w ||
            boundary.x + boundary.w < itemPosition.x ||
            boundary.y > itemPosition.y + itemPosition.h ||
            boundary.y + boundary.h < itemPosition.y);
    });
};
exports.filterBlockItemsByBoundary = filterBlockItemsByBoundary;
/**
 * find the first item that contains the pos.
 */
var findTopBlockItemByPosition = function (items, pos, padding) {
    if (padding === void 0) { padding = 0; }
    return findLast_1.default(items, function (item) {
        var itemPosition = padding
            ? edgeUtils_1.applyVizPadding({ item: item, padding: padding }).position
            : item.position;
        return (itemPosition.x <= pos.x &&
            itemPosition.x + itemPosition.w >= pos.x &&
            itemPosition.y <= pos.y &&
            itemPosition.y + itemPosition.h >= pos.y);
    });
};
exports.findTopBlockItemByPosition = findTopBlockItemByPosition;
/**
 * Compute the new offset so current + new offset will be the multiple of snapTo unit
 * For examples:
 * (5, 2, 5) => 0, user moved less than half of the snapTo unit, return 0 so 5 + 0 = 5
 * (5, 3, 5) => 5, user moved more than half of the snapTo unit, return 5 so 5 + 5 = 5 * 2
 * (5, 12, 5) => 10
 * (5, 13, 5) => 15
 * @param {Number} current
 * @param {Number} offset
 * @param {Number} snapTo
 */
var snapOffset = function (current, offset, snapTo) {
    // return a new offset
    var remainder = (current + offset) % snapTo;
    var newOffset = remainder > snapTo / 2
        ? offset + (snapTo - remainder)
        : offset - remainder;
    return newOffset;
};
exports.snapOffset = snapOffset;
/**
 * snap item with its top-left corner (represent by x, y)
 * @param {Object} position
 * @param {Object} offset
 * @param {Number} gridWidth
 * @param {Number} gridHeight
 * @param {Number} spacing
 */
var snapOffsetToXY = function (_a) {
    var position = _a.position, offset = _a.offset, gridWidth = _a.gridWidth, gridHeight = _a.gridHeight, _b = _a.spacing, spacing = _b === void 0 ? 0 : _b, _c = _a.padding, padding = _c === void 0 ? 0 : _c;
    var offsetX = offset.offsetX, offsetY = offset.offsetY;
    offsetX = exports.snapOffset(position.x, offsetX, gridWidth + spacing) + padding;
    offsetY = exports.snapOffset(position.y, offsetY, gridHeight + spacing) + padding;
    return {
        offsetX: offsetX,
        offsetY: offsetY,
    };
};
exports.snapOffsetToXY = snapOffsetToXY;
/**
 * snap item with its size (represent by w, h)
 * @param {Object} position
 * @param {Object} offset
 * @param {Number} gridWidth
 * @param {Number} gridHeight
 * @param {Number} spacing
 */
var snapOffsetToWH = function (_a) {
    var position = _a.position, offset = _a.offset, gridWidth = _a.gridWidth, gridHeight = _a.gridHeight, _b = _a.spacing, spacing = _b === void 0 ? 0 : _b, _c = _a.padding, padding = _c === void 0 ? 0 : _c;
    var offsetX = offset.offsetX, offsetY = offset.offsetY;
    offsetX =
        exports.snapOffset(position.x + position.w, offsetX, gridWidth + spacing) +
            (padding - spacing);
    offsetY =
        exports.snapOffset(position.y + position.h, offsetY, gridHeight + spacing) +
            (padding - spacing);
    return {
        offsetX: offsetX,
        offsetY: offsetY,
    };
};
exports.snapOffsetToWH = snapOffsetToWH;
/**
 * Mutate item coordinates and/or dimensions.
 * This mutation's new dimensions and coordinates are bounded within the original block item real estate.
 * @param {Object} item
 * @param {Object} offset
 * @param {String} dir Cartesian direction to shift item towards.
 * @param {Object} options
 */
var updateBlockItemSize = function (_a) {
    var item = _a.item, offset = _a.offset, dir = _a.dir, _b = _a.options, _c = _b === void 0 ? {} : _b, _d = _c.minWidth, minWidth = _d === void 0 ? 0 : _d, _e = _c.minHeight, minHeight = _e === void 0 ? 0 : _e;
    var _f = item.position, w = _f.w, h = _f.h;
    var offsetX = offset.offsetX, offsetY = offset.offsetY;
    var updatedPosition = __assign({}, item.position);
    // resizing from north
    if (['n', 'ne', 'nw'].includes(dir)) {
        updatedPosition.y += Math.min(h - minHeight, offsetY);
        updatedPosition.h -= offsetY;
    }
    // resizing from the south
    if (['s', 'se', 'sw'].includes(dir)) {
        updatedPosition.h += offsetY;
    }
    // resizing from the east
    if (['e', 'ne', 'se'].includes(dir)) {
        updatedPosition.w += offsetX;
    }
    // resizing from west
    if (['w', 'nw', 'sw'].includes(dir)) {
        updatedPosition.x += Math.min(w - minWidth, offsetX);
        updatedPosition.w -= offsetX;
    }
    updatedPosition.w = Math.max(minWidth, updatedPosition.w);
    updatedPosition.h = Math.max(minHeight, updatedPosition.h);
    return __assign(__assign({}, item), { position: updatedPosition });
};
exports.updateBlockItemSize = updateBlockItemSize;
var updateBlockItemPosition = function (item, offset) {
    var offsetX = offset.offsetX, offsetY = offset.offsetY;
    return __assign(__assign({}, item), { position: __assign(__assign({}, item.position), { x: item.position.x + offsetX, y: item.position.y + offsetY }) });
};
exports.updateBlockItemPosition = updateBlockItemPosition;
/**
 * create offset based on dir, x and y
 * @method createOffset
 * @param {String} dir
 * @param {Number} x
 * @param {Number} y
 * @returns {Object} offset
 */
var createOffset = function (dir, x, y) {
    switch (dir) {
        case 'n':
            return {
                offsetX: 0,
                offsetY: -y,
            };
        case 's':
            return {
                offsetX: 0,
                offsetY: y,
            };
        case 'w':
            return {
                offsetX: -x,
                offsetY: 0,
            };
        case 'e':
            return {
                offsetX: x,
                offsetY: 0,
            };
        default:
            return {
                offsetX: 0,
                offsetY: 0,
            };
    }
};
exports.createOffset = createOffset;
/**
 * compute scale factor
 * @param {Number} actualWidth
 * @param {Number} canvasWidth
 */
var computeScaleToFit = function (actualWidth, canvasWidth) {
    if (!(isNumber_1.default(canvasWidth) &&
        canvasWidth > 0 &&
        isNumber_1.default(actualWidth) &&
        actualWidth > 0)) {
        console_1.default.warn("Failed to calculate layout scale: containerWidth=" + actualWidth + ", width=" + canvasWidth + "; falling back to scale=1");
        return 1;
    }
    return actualWidth / canvasWidth;
};
exports.computeScaleToFit = computeScaleToFit;
/**
 *
 * @param {Array} items
 * @param {Number} from  target item index
 * @param {Number} to    where does this item move to
 */
var moveLayoutItem = function (items, from, to) {
    var structure = __spread(items);
    var removed = pullAt_1.default(structure, [from]);
    structure.splice(to, 0, removed[0]);
    return structure;
};
exports.moveLayoutItem = moveLayoutItem;
/**
 * check if a line is connected
 */
var isLineConnected = function (_a) {
    var line = _a.line, dir = _a.dir;
    return 'item' in line.position[dir];
};
exports.isLineConnected = isLineConnected;
/**
 *  disconnect a line from item and set it to abs position
 */
var disconnectLine = function (_a) {
    var _b;
    var line = _a.line, dir = _a.dir, absPos = _a.absPos;
    var updatePosition = __assign(__assign({}, line.position), (_b = {}, _b[dir] = __assign({}, absPos), _b));
    return __assign(__assign({}, line), { position: updatePosition });
};
exports.disconnectLine = disconnectLine;
/**
 * connect a line with an item and port
 */
var connectLine = function (_a) {
    var _b;
    var line = _a.line, dir = _a.dir, itemId = _a.itemId, port = _a.port;
    var position = line.position;
    var updatedPosition = __assign(__assign({}, position), (_b = {}, _b[dir] = {
        item: itemId,
        port: port,
    }, _b));
    return __assign(__assign({}, line), { position: updatedPosition });
};
exports.connectLine = connectLine;
/**
 * update line absolute position
 */
var updateLineAbsPosition = function (_a) {
    var _b;
    var line = _a.line, dir = _a.dir, offset = _a.offset;
    var offsetX = offset.offsetX, offsetY = offset.offsetY;
    var position = line.position;
    if (!('x' in position[dir])) {
        throw Error("line item " + line.item + " does not have x value for its direction " + dir);
    }
    if (!('y' in position[dir])) {
        throw Error("line item " + line.item + " does not have y value for its direction " + dir);
    }
    var _c = position[dir], x = _c.x, y = _c.y;
    return __assign(__assign({}, line), { position: __assign(__assign({}, position), (_b = {}, _b[dir] = {
            x: x + offsetX,
            y: y + offsetY,
        }, _b)) });
};
exports.updateLineAbsPosition = updateLineAbsPosition;
/**
 *
 * @param {Object} from
 * @param {Object} to
 */
var computeLineBoxPosition = function (from, to) { return ({
    x: Math.min(from.x, to.x),
    y: Math.min(from.y, to.y),
}); };
exports.computeLineBoxPosition = computeLineBoxPosition;
/**
 *
 * @param {Object} from
 * @param {Object} to
 * @param {Object} box
 */
var computeLineRelativePosition = function (from, to, box) { return ({
    from: {
        x: from.x - box.x,
        y: from.y - box.y,
    },
    to: {
        x: to.x - box.x,
        y: to.y - box.y,
    },
}); };
exports.computeLineRelativePosition = computeLineRelativePosition;
/**
 * Return the bottom coordinate of the layout.
 *
 * @param  {Array} layout Layout array.
 * @return {Number}       Bottom coordinate.
 */
var bottom = function (layout) {
    return layout.length > 0
        ? Math.max.apply(Math, __spread(layout.map(function (_a) {
            var position = _a.position;
            return position.y + position.h;
        }))) : 1;
};
exports.bottom = bottom;
/**
 * Before moving item down, it will check if the movement will cause collisions
 * and move those items down before.
 * @method resolveCompactionCollision
 * @param {Array} layout
 * @param {Object} itemToMove current item which need to be moved to solve the collision
 * @param {Number} moveToCoord the destination coordination of y axis
 * @returns {Array} [newLayout, newItem]
 */
var resolveCompactionCollision = function (layout, itemToMove, moveToCoord) {
    var _a;
    var axisVal = itemToMove.position.y;
    axisVal += 1;
    var newLayout = cloneDeep_1.default(layout);
    var itemIndex = newLayout.findIndex(function (layoutItem) { return layoutItem.item === itemToMove.item; });
    var newItem = cloneDeep_1.default(itemToMove);
    newItem.position.y = axisVal;
    // Go through each item we collide with.
    // If there is a collision, we will move this collision down, otherwise set y = moveToCoord and return
    for (var i = itemIndex + 1; i < layout.length; i += 1) {
        // Optimization: we can break early if we know we're past this el
        // We can do this b/c it's a sorted layout
        if (newLayout[i].position.y > newItem.position.y + newItem.position.h) {
            break;
        }
        if (layout_1.collides(newItem, newLayout[i])) {
            _a = __read(exports.resolveCompactionCollision(layout, layout[i], moveToCoord + newItem.position.h), 2), newLayout = _a[0], newLayout[i] = _a[1];
        }
    }
    newItem.position.y = moveToCoord;
    newLayout[itemIndex] = newItem;
    return [newLayout, newItem];
};
exports.resolveCompactionCollision = resolveCompactionCollision;
/**
 * get all collisions given an item and current layout
 * @method getAllCollisions
 * @param {Array} layout
 * @param {Object} layoutItem
 * @returns {Array} sorted layout
 */
var getAllCollisions = function (layout, layoutItem) {
    return layout.filter(function (item) { return layout_1.collides(item, layoutItem); });
};
exports.getAllCollisions = getAllCollisions;
/**
 * clone a block item
 * @param {Number} id
 * @param {Object} item
 * @param {Number} offsetMultiplier
 */
var cloneBlockItem = function (_a) {
    var id = _a.id, item = _a.item, offsetMultiplier = _a.offsetMultiplier;
    var copiedPosition = item.position;
    return __assign(__assign({}, item), { item: id, position: {
            x: copiedPosition.x + 20 * offsetMultiplier,
            y: copiedPosition.y + 20 * offsetMultiplier,
            w: copiedPosition.w,
            h: copiedPosition.h,
        } });
};
exports.cloneBlockItem = cloneBlockItem;
/**
 * clone an line, it assume the line is not connected
 * @param {Number} id
 * @param {Object} item
 * @param {Number} offsetMultiplier
 */
var cloneLine = function (_a) {
    var id = _a.id, item = _a.item, offsetMultiplier = _a.offsetMultiplier;
    var copiedPosition = item.position;
    return __assign(__assign({}, item), { item: id, position: {
            from: {
                x: copiedPosition.from.x +
                    20 * offsetMultiplier,
                y: copiedPosition.from.y +
                    20 * offsetMultiplier,
            },
            to: {
                x: copiedPosition.to.x + 20 * offsetMultiplier,
                y: copiedPosition.to.y + 20 * offsetMultiplier,
            },
        } });
};
exports.cloneLine = cloneLine;
/**
 * Calculates new viewport position after a zoom event to keep the previous central point in the center of
 * the scaled canvas. See MR #2030 for algorithm details.
 * @param {Number} scrollLeft viewport left edge offset relative to canvas
 * @param {Number} scrollTop viewport top edge offset relative to canvas
 * @param {Number} offsetWidth viewport width
 * @param {Number} offsetHeight viewport height
 * @param {Number} scaleRatio new scale to old scale ratio
 * @returns {Object} object containing new scrollLeft and scrollTop values
 */
var shiftViewportOnZoom = function (_a) {
    var scrollLeft = _a.scrollLeft, scrollTop = _a.scrollTop, offsetWidth = _a.offsetWidth, offsetHeight = _a.offsetHeight, scaleRatio = _a.scaleRatio;
    var middleOffsetWidth = offsetWidth / 2;
    var middleOffsetHeight = offsetHeight / 2;
    return {
        scrollLeft: (scrollLeft + middleOffsetWidth) * scaleRatio - middleOffsetWidth,
        scrollTop: (scrollTop + middleOffsetHeight) * scaleRatio - middleOffsetHeight,
    };
};
exports.shiftViewportOnZoom = shiftViewportOnZoom;
/**
 * return position relative to the canvas rect
 */
var computeRelativePosition = function (e, canvasRef, scale) {
    if (scale === void 0) { scale = 1; }
    var pos = exports.getClientPosition(e, scale);
    var canvasDomNode = get_1.default(canvasRef, ['current']);
    var rect = canvasDomNode && canvasDomNode.getBoundingClientRect();
    if (pos && rect) {
        return {
            x: pos.x - rect.left / scale,
            y: pos.y - rect.top / scale,
        };
    }
    return pos;
};
exports.computeRelativePosition = computeRelativePosition;
/**
 * Scales a GridLayout by stretching the width of each item by the scale factor
 * @param {AbsoluteBlockItem[]} items items to scale
 * @param {Number} scale how much to scale
 */
var scaleGridLayoutStructureByWidth = function (_a) {
    var layout = _a.layout, _b = _a.scale, scale = _b === void 0 ? 1 : _b;
    if (scale === 1) {
        return layout;
    }
    // Compute the edges of the existing layout. Since we're scaling
    // just the X and width we only care about vertical edges.
    var edges = edgeUtils_1.getAllEdges(layout);
    var verticalEdges = sortBy_1.default(edges.filter(function (edge) { return edge.orientation === 'vertical'; }), ['edgeStart.x']);
    // Scale the vertical edges and than align the
    // left and right items to the scaled edge position
    var newLayout = [];
    verticalEdges.forEach(function (edge) {
        var visualizations = edge.visualizations, x = edge.edgeStart.x;
        var scaledEdgeX = Math.round(x * scale);
        var left = visualizations.filter(function (viz) { return viz.position.x < x; });
        var right = visualizations.filter(function (viz) { return viz.position.x >= x; });
        // Update the Width of the layout items using the difference between the
        // newly scaled edge and the existing x
        left.forEach(function (layoutItem) {
            var newLayoutItem = newLayout.find(function (_a) {
                var id = _a.item;
                return layoutItem.item === id;
            });
            if (newLayoutItem) {
                newLayoutItem.position.w =
                    scaledEdgeX - newLayoutItem.position.x;
            }
        });
        // Since we walk the edges from the left to the right we
        // ALWAYS have to create the new layout item here but won't
        // ever need to update it.
        right.forEach(function (layoutItem) {
            newLayout.push(__assign(__assign({}, layoutItem), { position: __assign(__assign({}, layoutItem.position), { x: scaledEdgeX }) }));
        });
    });
    return newLayout;
};
exports.scaleGridLayoutStructureByWidth = scaleGridLayoutStructureByWidth;


/***/ }),

/***/ 20:
/***/ (function(module, exports) {

module.exports = require("lodash/pullAt");

/***/ }),

/***/ 21:
/***/ (function(module, exports) {

module.exports = require("lodash/cloneDeep");

/***/ }),

/***/ 22:
/***/ (function(module, exports) {

module.exports = require("lodash/sortBy");

/***/ }),

/***/ 3:
/***/ (function(module, exports) {

module.exports = require("prop-types");

/***/ }),

/***/ 5:
/***/ (function(module, exports) {

module.exports = require("@splunk/dashboard-utils/console");

/***/ }),

/***/ 52:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-disable react/no-unused-prop-types,react/prefer-stateless-function, no-unused-vars */
var react_1 = __webpack_require__(0);
var prop_types_1 = __importDefault(__webpack_require__(3));
var noop = function () { };
var BaseLayout = /** @class */ (function (_super) {
    __extends(BaseLayout, _super);
    function BaseLayout() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    BaseLayout.prototype.render = function () {
        return null;
    };
    BaseLayout.propTypes = {
        /**
         * dashboard mode
         */
        mode: prop_types_1.default.string,
        /**
         * whether gridlines should be displayed in edit mode
         */
        showGrid: prop_types_1.default.bool,
        /**
         * layout formatting options
         */
        options: prop_types_1.default.object,
        /**
         * layout structure
         */
        layoutStructure: prop_types_1.default.arrayOf(prop_types_1.default.any),
        /**
         * container width in pixel
         */
        containerWidth: prop_types_1.default.number,
        /**
         * container height in pixel
         */
        containerHeight: prop_types_1.default.number,
        /**
         * list of selected items
         */
        selectedItems: prop_types_1.default.arrayOf(prop_types_1.default.shape({ id: prop_types_1.default.string, type: prop_types_1.default.oneOf(['block', 'line', 'input']) })),
        /**
         * layout item render prop
         */
        renderLayoutItem: prop_types_1.default.func,
        /**
         * callback when items are selected
         */
        onLayoutItemsSelect: prop_types_1.default.func,
        /**
         * callback to trigger event
         */
        onEventTrigger: prop_types_1.default.func,
        /**
         * callback when layout structure changed
         */
        onLayoutStructureChange: prop_types_1.default.func,
        /**
         * layoutApi ref
         */
        layoutApiRef: prop_types_1.default.func,
    };
    BaseLayout.defaultProps = {
        mode: 'view',
        options: {},
        showGrid: true,
        layoutStructure: [],
        selectedItems: [],
        renderLayoutItem: noop,
        onEventTrigger: noop,
        onLayoutStructureChange: noop,
        onLayoutItemsSelect: noop,
        layoutApiRef: noop,
    };
    return BaseLayout;
}(react_1.Component));
exports.default = BaseLayout;


/***/ }),

/***/ 6:
/***/ (function(module, exports) {

module.exports = require("@splunk/dashboard-utils/layout");

/***/ }),

/***/ 7:
/***/ (function(module, exports) {

module.exports = require("@splunk/dashboard-ui/customThemeVariables");

/***/ }),

/***/ 8:
/***/ (function(module, exports) {

module.exports = require("@splunk/themes/mixins");

/***/ }),

/***/ 82:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var react_1 = __importStar(__webpack_require__(0));
var styled_components_1 = __importDefault(__webpack_require__(1));
var mixins_1 = __webpack_require__(8);
var customThemeVariables_1 = __webpack_require__(7);
var BaseLayout_1 = __importDefault(__webpack_require__(52));
var GridItem_1 = __importDefault(__webpack_require__(83));
var DefaultOptions_1 = __webpack_require__(9);
var layoutUtils_1 = __webpack_require__(2);
var gridLayoutViewerUtils_1 = __webpack_require__(84);
var GridCanvas = styled_components_1.default.div(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n    ", ";\n    height: ", "px;\n    width: 100%;\n    padding: ", "px;\n    box-sizing: border-box;\n    grid-template-columns: ", ";\n    grid-template-rows: ", ";\n    gap: ", "px;\n    background: ", ";\n"], ["\n    ", ";\n    height: ", "px;\n    width: 100%;\n    padding: ", "px;\n    box-sizing: border-box;\n    grid-template-columns: ", ";\n    grid-template-rows: ", ";\n    gap: ", "px;\n    background: ", ";\n"])), mixins_1.reset('grid'), function (props) { return props.height; }, function (props) { return props.gutterSize / 2; }, function (props) { return props.colTemplate; }, function (props) { return props.rowTemplate; }, function (props) { return props.gutterSize; }, customThemeVariables_1.customThemeVariables.dashboardBackgroundColor);
GridCanvas.displayName = 'GridCanvas';
var GridLayoutViewer = function (_a) {
    var layoutStructure = _a.layoutStructure, renderLayoutItem = _a.renderLayoutItem, options = _a.options;
    var _b = __assign(__assign({}, DefaultOptions_1.gridLayoutOptions), options), width = _b.width, gutterSize = _b.gutterSize;
    var _c = react_1.useMemo(function () {
        var filteredStructure = layoutUtils_1.removeInvalidItems(layoutStructure);
        var structureHeight = layoutUtils_1.computeMaxHeight(filteredStructure);
        var _a = gridLayoutViewerUtils_1.getCSSGridTemplate({
            layoutStructure: filteredStructure,
            width: width,
            height: structureHeight,
        }), gridRowTemplate = _a.gridRowTemplate, gridColTemplate = _a.gridColTemplate;
        var items = filteredStructure.map(function (_a) {
            var itemId = _a.item;
            return (react_1.default.createElement(GridItem_1.default, { itemId: itemId, key: itemId, renderLayoutItem: renderLayoutItem }));
        });
        return {
            height: structureHeight,
            gridItems: items,
            rowTemplate: gridRowTemplate,
            colTemplate: gridColTemplate,
        };
    }, [layoutStructure, width, renderLayoutItem]), height = _c.height, gridItems = _c.gridItems, rowTemplate = _c.rowTemplate, colTemplate = _c.colTemplate;
    return (react_1.default.createElement(GridCanvas, { "data-test": "grid-layout-canvas", "data-layout-type": "grid", height: height, gutterSize: gutterSize, rowTemplate: rowTemplate, colTemplate: colTemplate }, gridItems));
};
GridLayoutViewer.propTypes = __assign({}, BaseLayout_1.default.propTypes);
GridLayoutViewer.defaultProps = __assign({}, BaseLayout_1.default.defaultProps);
exports.default = GridLayoutViewer;
var templateObject_1;


/***/ }),

/***/ 83:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var react_1 = __importDefault(__webpack_require__(0));
var styled_components_1 = __importDefault(__webpack_require__(1));
var prop_types_1 = __importDefault(__webpack_require__(3));
var GridDiv = styled_components_1.default.div(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n    height: 100%;\n    width: 100%;\n    grid-row: ", "-start / ", "-end;\n    grid-column: ", "-start / ", "-end;\n    background: transparent;\n"], ["\n    height: 100%;\n    width: 100%;\n    grid-row: ", "-start / ", "-end;\n    grid-column: ", "-start / ", "-end;\n    background: transparent;\n"])), function (props) { return props.id; }, function (props) { return props.id; }, function (props) { return props.id; }, function (props) { return props.id; });
/**
 * Item positioned on a grid.
 */
var GridItem = function (_a) {
    var itemId = _a.itemId, renderLayoutItem = _a.renderLayoutItem;
    return (react_1.default.createElement(GridDiv, { id: itemId, "data-test": "grid-item" }, renderLayoutItem(itemId, { width: '100%', height: '100%' }, 'block')));
};
GridItem.propTypes = {
    itemId: prop_types_1.default.string.isRequired,
    renderLayoutItem: prop_types_1.default.func.isRequired,
};
exports.default = GridItem;
var templateObject_1;


/***/ }),

/***/ 84:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getCSSGridTemplate = void 0;
/**
 * Returns a template for the rows/columns of a CSS grid given a list of grid lines along an axis
 * with range [0, axisLength].
 */
var getTemplateItems = function (_a, axisLength, templateItems) {
    var _b = __read(_a), currGridLine = _b[0], nextGridLine = _b[1], rest = _b.slice(2);
    if (templateItems === void 0) { templateItems = []; }
    // add the names for the current grid line
    templateItems.push("[" + currGridLine.names.join(' ') + "]");
    if (!nextGridLine) {
        return templateItems.join(' ');
    }
    // add the space between the current grid line and the next grid line
    var gridTrackWidth = Math.round(((nextGridLine.pos - currGridLine.pos) / axisLength) * 100);
    templateItems.push("minmax(0, " + gridTrackWidth + "fr)");
    return getTemplateItems(__spread([nextGridLine], rest), axisLength, templateItems);
};
/**
 * Wrapper function for getTemplateItems.
 */
var getTemplateItemsFromGridLines = function (gridLines, axisLength) {
    if (gridLines.length === 0) {
        return '';
    }
    return getTemplateItems(gridLines, axisLength);
};
/**
 * Returns strings to be used as the `grid-template-columns` and `grid-layout-rows` properties of
 * a CSS Grid. Derived from the layout structure.
 */
var getCSSGridTemplate = function (_a) {
    var layoutStructure = _a.layoutStructure, width = _a.width, height = _a.height;
    var xCoords = [];
    var yCoords = [];
    layoutStructure.forEach(function (_a) {
        var _b, _c, _d, _e;
        var _f = _a.position, x = _f.x, y = _f.y, w = _f.w, h = _f.h, item = _a.item;
        // create an empty list of breakpoints for a given point if it does not exist
        xCoords[x] = (_b = xCoords[x]) !== null && _b !== void 0 ? _b : [];
        xCoords[x + w] = (_c = xCoords[x + w]) !== null && _c !== void 0 ? _c : [];
        yCoords[y] = (_d = yCoords[y]) !== null && _d !== void 0 ? _d : [];
        yCoords[y + h] = (_e = yCoords[y + h]) !== null && _e !== void 0 ? _e : [];
        // add breakpoint to the list of breakpoints for a given point
        xCoords[x].push(item + "-start");
        xCoords[x + w].push(item + "-end");
        yCoords[y].push(item + "-start");
        yCoords[y + h].push(item + "-end");
    });
    var xGridLines = Object.entries(xCoords).map(function (_a) {
        var _b = __read(_a, 2), pos = _b[0], names = _b[1];
        return ({
            pos: Number(pos),
            names: names,
        });
    });
    var yGridLines = Object.entries(yCoords).map(function (_a) {
        var _b = __read(_a, 2), pos = _b[0], names = _b[1];
        return ({
            pos: Number(pos),
            names: names,
        });
    });
    var gridRowTemplate = getTemplateItemsFromGridLines(yGridLines, height);
    var gridColTemplate = getTemplateItemsFromGridLines(xGridLines, width);
    return { gridRowTemplate: gridRowTemplate, gridColTemplate: gridColTemplate };
};
exports.getCSSGridTemplate = getCSSGridTemplate;


/***/ }),

/***/ 9:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.gridLayoutOptions = exports.absoluteLayoutOptions = void 0;
var layout_1 = __webpack_require__(6);
exports.absoluteLayoutOptions = {
    width: layout_1.DEFAULT_CANVAS_WIDTH,
    height: layout_1.DEFAULT_CANVAS_HEIGHT,
    display: 'actual-size',
};
exports.gridLayoutOptions = {
    width: layout_1.DEFAULT_CANVAS_WIDTH,
    gutterSize: 8,
};


/***/ })

/******/ });
//# sourceMappingURL=GridLayoutViewer.js.map
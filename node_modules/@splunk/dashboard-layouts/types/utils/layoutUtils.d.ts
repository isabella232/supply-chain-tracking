import type { Coordinate, ConnectedPosition, AbsolutePosition, Port, ConnectedLineItem, ConnectedLinePosition, AbsoluteLayoutStructure, AbsoluteBlockItem, AbsoluteLayoutItem, GridLayoutStructure } from '@splunk/dashboard-types';
import type { Offset, LineDirection, HandleDirection } from '../types';
export declare const computeMaxHeight: (layoutItems: AbsoluteBlockItem[], minHeight?: number | undefined) => number;
/**
 *  check if a position is valid
 * @param {Object} position
 */
export declare const isBlockPositionValid: (position: AbsolutePosition) => boolean;
export declare const isValidConnection: (connection: Coordinate | ConnectedPosition) => boolean;
/**
 * a line should has from and to
 */
export declare const isLinePositionValid: (position: ConnectedLinePosition) => boolean;
/**
 * filter invalid position
 * @param {Object[]} layoutStructure - Array of items (viz, edges, lines)
 * @returns {Object[]} - Returns filtered array
 */
export declare const removeInvalidItems: (layoutStructure?: AbsoluteLayoutStructure) => AbsoluteLayoutStructure;
interface PositionStyle {
    width: string;
    height: string;
    transform: string;
}
/**
 * convert position to css object
 */
export declare const positionToStyle: (pos: AbsolutePosition) => PositionStyle;
/**
 * convert position to css string
 */
export declare const positionToStyleString: (pos: AbsolutePosition) => string;
/**
 * get client position for given event with scale factor
 */
export declare const getClientPosition: (e: {
    clientX: number;
    clientY: number;
}, scaleFactor?: number) => Coordinate;
/**
 * compute offset from 2 positions
 */
export declare const getOffset: (currentPosition: Coordinate, startPosition: Coordinate) => Offset;
/**
 * check if a given offset can be considered as 'move'
 * @param {Object} config
 * @param {Number} config.offsetX
 * @param {Number} config.offsetY
 */
export declare const considerMoved: ({ offsetX, offsetY, }: {
    offsetX: number;
    offsetY: number;
}) => boolean;
/**
 * return a boundary for 2 positions
 * @param {Coordinate} startPos
 * @param {Coordinate} endPos
 */
export declare const positionsToBoundary: (startPos: Coordinate, endPos: Coordinate) => AbsolutePosition;
/**
 * filter abs items within a boundary
 * @param {Array} items
 * @param {Object} boundary
 */
export declare const filterBlockItemsByBoundary: (items: AbsoluteBlockItem[], boundary: AbsolutePosition) => AbsoluteBlockItem[];
/**
 * find the first item that contains the pos.
 */
export declare const findTopBlockItemByPosition: (items: AbsoluteBlockItem[], pos: Coordinate, padding?: number) => AbsoluteBlockItem | undefined;
/**
 * Compute the new offset so current + new offset will be the multiple of snapTo unit
 * For examples:
 * (5, 2, 5) => 0, user moved less than half of the snapTo unit, return 0 so 5 + 0 = 5
 * (5, 3, 5) => 5, user moved more than half of the snapTo unit, return 5 so 5 + 5 = 5 * 2
 * (5, 12, 5) => 10
 * (5, 13, 5) => 15
 * @param {Number} current
 * @param {Number} offset
 * @param {Number} snapTo
 */
export declare const snapOffset: (current: number, offset: number, snapTo: number) => number;
interface SnapOffsetToXYArgs {
    position: AbsolutePosition;
    offset: Offset;
    gridWidth: number;
    gridHeight: number;
    spacing?: number;
    padding?: number;
}
/**
 * snap item with its top-left corner (represent by x, y)
 * @param {Object} position
 * @param {Object} offset
 * @param {Number} gridWidth
 * @param {Number} gridHeight
 * @param {Number} spacing
 */
export declare const snapOffsetToXY: ({ position, offset, gridWidth, gridHeight, spacing, padding, }: SnapOffsetToXYArgs) => Offset;
declare type SnapOffsetToWHArgs = SnapOffsetToXYArgs;
/**
 * snap item with its size (represent by w, h)
 * @param {Object} position
 * @param {Object} offset
 * @param {Number} gridWidth
 * @param {Number} gridHeight
 * @param {Number} spacing
 */
export declare const snapOffsetToWH: ({ position, offset, gridWidth, gridHeight, spacing, padding, }: SnapOffsetToWHArgs) => Offset;
interface UpdateBlockItemSizeArgs {
    item: AbsoluteBlockItem;
    offset: Offset;
    dir: HandleDirection;
    options?: {
        minWidth?: number;
        minHeight?: number;
    };
}
/**
 * Mutate item coordinates and/or dimensions.
 * This mutation's new dimensions and coordinates are bounded within the original block item real estate.
 * @param {Object} item
 * @param {Object} offset
 * @param {String} dir Cartesian direction to shift item towards.
 * @param {Object} options
 */
export declare const updateBlockItemSize: ({ item, offset, dir, options: { minWidth, minHeight }, }: UpdateBlockItemSizeArgs) => AbsoluteBlockItem;
export declare const updateBlockItemPosition: (item: AbsoluteBlockItem, offset: Offset) => AbsoluteBlockItem;
/**
 * create offset based on dir, x and y
 * @method createOffset
 * @param {String} dir
 * @param {Number} x
 * @param {Number} y
 * @returns {Object} offset
 */
export declare const createOffset: (dir: HandleDirection, x: number, y: number) => Offset;
/**
 * compute scale factor
 * @param {Number} actualWidth
 * @param {Number} canvasWidth
 */
export declare const computeScaleToFit: (actualWidth: number, canvasWidth: number) => number;
/**
 *
 * @param {Array} items
 * @param {Number} from  target item index
 * @param {Number} to    where does this item move to
 */
export declare const moveLayoutItem: (items: AbsoluteLayoutItem[], from: number, to: number) => AbsoluteLayoutItem[];
interface IsLineConnectedArgs {
    line: ConnectedLineItem;
    dir: LineDirection;
}
/**
 * check if a line is connected
 */
export declare const isLineConnected: ({ line, dir }: IsLineConnectedArgs) => boolean;
interface DisconnectLineArgs {
    line: ConnectedLineItem;
    dir: LineDirection;
    absPos: Coordinate;
}
/**
 *  disconnect a line from item and set it to abs position
 */
export declare const disconnectLine: ({ line, dir, absPos, }: DisconnectLineArgs) => ConnectedLineItem;
interface ConnectLineArgs {
    line: ConnectedLineItem;
    dir: LineDirection;
    itemId: string;
    port: Port;
}
/**
 * connect a line with an item and port
 */
export declare const connectLine: ({ line, dir, itemId, port, }: ConnectLineArgs) => ConnectedLineItem;
interface UpdateLineAbsPositionArgs {
    line: ConnectedLineItem;
    dir: LineDirection;
    offset: Offset;
}
/**
 * update line absolute position
 */
export declare const updateLineAbsPosition: ({ line, dir, offset, }: UpdateLineAbsPositionArgs) => ConnectedLineItem;
/**
 *
 * @param {Object} from
 * @param {Object} to
 */
export declare const computeLineBoxPosition: (from: Coordinate, to: Coordinate) => Coordinate;
/**
 *
 * @param {Object} from
 * @param {Object} to
 * @param {Object} box
 */
export declare const computeLineRelativePosition: (from: Coordinate, to: Coordinate, box: Coordinate) => {
    from: {
        x: number;
        y: number;
    };
    to: {
        x: number;
        y: number;
    };
};
/**
 * Return the bottom coordinate of the layout.
 *
 * @param  {Array} layout Layout array.
 * @return {Number}       Bottom coordinate.
 */
export declare const bottom: (layout: AbsoluteBlockItem[]) => number;
/**
 * Before moving item down, it will check if the movement will cause collisions
 * and move those items down before.
 * @method resolveCompactionCollision
 * @param {Array} layout
 * @param {Object} itemToMove current item which need to be moved to solve the collision
 * @param {Number} moveToCoord the destination coordination of y axis
 * @returns {Array} [newLayout, newItem]
 */
export declare const resolveCompactionCollision: (layout: AbsoluteBlockItem[], itemToMove: AbsoluteBlockItem, moveToCoord: number) => [AbsoluteBlockItem[], AbsoluteBlockItem];
/**
 * get all collisions given an item and current layout
 * @method getAllCollisions
 * @param {Array} layout
 * @param {Object} layoutItem
 * @returns {Array} sorted layout
 */
export declare const getAllCollisions: (layout: AbsoluteBlockItem[], layoutItem: AbsoluteBlockItem) => AbsoluteBlockItem[];
interface CloneBlockItemArgs {
    id: string;
    item: AbsoluteBlockItem;
    offsetMultiplier: number;
}
/**
 * clone a block item
 * @param {Number} id
 * @param {Object} item
 * @param {Number} offsetMultiplier
 */
export declare const cloneBlockItem: ({ id, item, offsetMultiplier, }: CloneBlockItemArgs) => AbsoluteBlockItem;
interface CloneLineArgs {
    id: string;
    item: ConnectedLineItem;
    offsetMultiplier: number;
}
/**
 * clone an line, it assume the line is not connected
 * @param {Number} id
 * @param {Object} item
 * @param {Number} offsetMultiplier
 */
export declare const cloneLine: ({ id, item, offsetMultiplier, }: CloneLineArgs) => ConnectedLineItem;
interface ShiftViewportOnZoomArgs {
    scrollLeft: number;
    scrollTop: number;
    offsetWidth: number;
    offsetHeight: number;
    scaleRatio: number;
}
/**
 * Calculates new viewport position after a zoom event to keep the previous central point in the center of
 * the scaled canvas. See MR #2030 for algorithm details.
 * @param {Number} scrollLeft viewport left edge offset relative to canvas
 * @param {Number} scrollTop viewport top edge offset relative to canvas
 * @param {Number} offsetWidth viewport width
 * @param {Number} offsetHeight viewport height
 * @param {Number} scaleRatio new scale to old scale ratio
 * @returns {Object} object containing new scrollLeft and scrollTop values
 */
export declare const shiftViewportOnZoom: ({ scrollLeft, scrollTop, offsetWidth, offsetHeight, scaleRatio, }: ShiftViewportOnZoomArgs) => {
    scrollLeft: number;
    scrollTop: number;
};
/**
 * return position relative to the canvas rect
 */
export declare const computeRelativePosition: (e: {
    clientX: number;
    clientY: number;
}, canvasRef: unknown, scale?: number) => Coordinate;
/**
 * Scales a GridLayout by stretching the width of each item by the scale factor
 * @param {AbsoluteBlockItem[]} items items to scale
 * @param {Number} scale how much to scale
 */
export declare const scaleGridLayoutStructureByWidth: ({ layout, scale, }: {
    layout: GridLayoutStructure;
    scale?: number | undefined;
}) => AbsoluteBlockItem[];
export {};
//# sourceMappingURL=layoutUtils.d.ts.map
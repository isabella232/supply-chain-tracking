import type { AbsoluteBlockItem } from '@splunk/dashboard-types';
import { EdgeItem, VerticalBoundaries, HorizontalBoundaries, EdgeBoundaries } from '../types';
/**
 * Gets all the edges given a layout of AbsoluteBlockItems
 * @param {AbsoluteBlockItem[]} layout - Array of AbsoluteBlockItems
 * @returns {EdgeItem[]} - Array of computed edges
 */
export declare const getAllEdges: (layout: AbsoluteBlockItem[]) => EdgeItem[];
/**
 * Compute edges given a valid layout, canvasHeight, and canvasWidth
 * @param {Object} param - Param object containing layout, canvasHeight, canvasWidth
 * @param {Object[]} param.layout - Array of visualizations from the dashboard layout definition
 * @param {Number} param.canvasHeight - Canvas height
 * @param {Number} param.canvasWidth - Canvas width
 * @returns {Object[]} - Array of computed edges
 */
export declare const computeEdges: ({ layout, canvasHeight, canvasWidth, }: {
    layout?: AbsoluteBlockItem[] | undefined;
    canvasHeight: number;
    canvasWidth: number;
}) => EdgeItem[];
/**
 * Format edge according to a given padding and edge thickness
 * @param {Object} param - Param object containing edge, padding, and edgeThickness
 * @param {Object} param.edge - Edge object
 * @param {Number} param.padding - Layout padding
 * @param {Number} param.edgeThickness - Thickness of edge
 * @returns {Object} - Returns formatted edge object
 */
export declare const formatEdge: ({ edge, padding, edgeThickness, }: {
    edge: EdgeItem;
    padding?: number | undefined;
    edgeThickness?: number | undefined;
}) => EdgeItem;
/**
 * Format visualization according to a given padding
 * @param {Object} param - Param object containing item and padding
 * @param {Object} param.item - Visualization object
 * @param {Number} param.padding - Layout padding
 * @returns {AbsoluteBlockItem} - Returns formatted edge object
 */
export declare const applyVizPadding: ({ item, padding, }: {
    item: AbsoluteBlockItem;
    padding?: number | undefined;
}) => AbsoluteBlockItem;
/**
 * Determines Upper and Lower boundaries of an edge given its visualizations around it
 * @param {Object[]} visualizations - The visualizations surrounding the edge
 * @param {Number} y - The y position of the selected edge
 * @param {Number} minHeight - minimum Item Height Value
 * @param {Boolean} isFullWidthEdge - If the edge we are getting boundaries of is the size of canvas width
 * @returns {Object} - returns the boundaries in an object
 */
export declare const getVerticalBoundaries: ({ visualizations, y, minHeight, isFullWidthEdge, }: {
    visualizations: AbsoluteBlockItem[];
    y: number;
    minHeight: number;
    isFullWidthEdge?: boolean | undefined;
}) => VerticalBoundaries;
/**
 * Determines Left and Right boundaries of an edge given its visualizations around it
 * @param {Object[]} visualizations - The visualizations surrounding the edge
 * @param {Number} x - The x position of the selected edge
 * @param {Number} minWidth - minimum Item Width Value
 * @returns {Object} - returns the boundaries in an object
 */
export declare const getHorizontalBoundaries: ({ visualizations, x, minWidth, }: {
    visualizations: AbsoluteBlockItem[];
    x: number;
    minWidth: number;
}) => HorizontalBoundaries;
/**
 * Determines the next edge position for movement up and down of a horizontal edge
 * @param {Object} edge - the current moving edge
 * @param {Number} offset - offset to move edge
 * @param {Object} options.edgeBoundaries Object with lower/upper boundaries
 * @returns {Object} - returns edge with updated position
 */
export declare const moveHorizontalEdge: ({ edge, offset, edgeBoundaries: { upperBoundary, lowerBoundary }, }: {
    edge: EdgeItem;
    offset: number;
    edgeBoundaries: VerticalBoundaries;
}) => EdgeItem;
/**
 * Determines the next edge position for movement left and right of a vertical edge
 * @param {Object} edge - the current moving edge
 * @param {Number} offset - offset to move edge
 * @param {Object} options.edgeBoundaries Object with left/right boundaries
 * @returns {Object} - returns edge with updated position
 */
export declare const moveVerticalEdge: ({ edge, offset, edgeBoundaries: { leftBoundary, rightBoundary }, }: {
    edge: EdgeItem;
    offset: number;
    edgeBoundaries: HorizontalBoundaries;
}) => EdgeItem;
/**
 * find edges that the given edge should snap to, according to the snap range
 * @param {Object} options
 * @param {Object} options.edge the edge being dragged, edge has the structure
 * @param {array}  options.edges all the edges that are parallel to target edge and within the boundary
 * @param {Number} options.snapRange the range within which that triggers snapping
 * @returns {Object} updatedEdge and snappableEdges
 */
export declare const findSnappableEdges: ({ edge, edges, snapRange, }: {
    edge: EdgeItem;
    edges: EdgeItem[];
    snapRange: number;
}) => {
    updatedEdge: EdgeItem;
    snappableEdges: EdgeItem[];
};
/**
 * Find all the edges that could be snapped to, given the limitations enforced by the surrounding visualizations.
 * @param {Object} options
 * @param {Object} options.edge the edge being dragged
 * @param {array}  options.edges all the edges on canvas
 * @param {Object} options.edgeBoundaries Object with either lower/upper or left/right boundaries
 * @returns {array} the edges that are within the boundary of the edge being moved
 */
export declare const findEdgesInBoundary: ({ edge, edges, edgeBoundaries, }: {
    edge: EdgeItem;
    edges: EdgeItem[];
    edgeBoundaries: EdgeBoundaries;
}) => EdgeItem[];
//# sourceMappingURL=edgeUtils.d.ts.map
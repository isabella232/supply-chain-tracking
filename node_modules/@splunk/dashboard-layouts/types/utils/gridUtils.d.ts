/**
 * This file is a central location for all shared utility functions related to Grid Layout.
 * If a certain function requires a dependency that lives in another utility file, then
 * that function should live here. If it does not have any dependencies, then it can live
 * in a separate utility file.
 */
import type { AbsoluteBlockItem, Coordinate, AbsolutePosition } from '@splunk/dashboard-types';
import type { EdgeItem, LayoutError, Quadrant } from '../types';
/**
 * Return a wrapper for the edge, such that this wrapper fills the entire gutter between 2 viz
 * @param {Object} params
 * @param {EdgeItem} params.edge - The edge that this wrapper will go "around"
 * @param {Number} params.padding - The amount of padding between two visualizations
 * @returns {EdgeItem} - Formatted edge such that it fills the gutter space between two visualizations
 */
export declare const formatEdgeWrapper: ({ edge, padding, }: {
    edge: EdgeItem;
    padding?: number | undefined;
}) => EdgeItem;
export declare const getDimensions: ({ edge, thickness, }: {
    edge: EdgeItem;
    thickness: number;
}) => {
    width: number;
    height: number;
};
/**
 * Check whether the mouse is on top of the edge
 * @param {Object} params
 * @param {EdgeItem} params.edge - The edge that is being checked
 * @param {Coordinate} params.mousePosition - The position of the mouse on the screen, scaled
 * @param {Number} params.padding - The amount of padding between two visualizations
 * @returns {boolean}
 */
export declare const isMouseOnEdge: ({ edge, mousePosition, padding, }: {
    edge: EdgeItem;
    mousePosition: Coordinate;
    padding?: number | undefined;
}) => boolean;
/**
 * When dropping a viz on a full-width edge, shift all the visualizations below that edge down
 * instead of taking size from the nearby visualizations
 * @param {Object}
 * @param {EdgeItem} params.edge - The edge that is being dropped on. Spans full width of canvas
 * @param {AbsoluteBlockItem} params.itemToMove - The item that is being removed
 * @param {AbsoluteBlockItem[]} params.items - All the items on the canvas
 * @returns {AbsoluteBlockItem[]} - Array of updated items, shifted down to create space for the added viz.
 */
export declare const computeNewVizPositionsGutterCase: ({ edge, itemToMove, items, }: {
    edge: EdgeItem;
    itemToMove: AbsoluteBlockItem;
    items: AbsoluteBlockItem[];
}) => AbsoluteBlockItem[];
/**
 * Determine the amount to take from each viz surrounding an edge that itemToMove is being dropped on
 * @param {Object}
 * @param {EdgeItem} params.edge - The edge that is being dropped on
 * @param {Number} params.amountToTake - The proportion of each viz to take. ex: 1/3
 * @param {Number} params.minWidth - Minimum width a viz can have
 * @param {Number} params.minHeight - Minimum height a viz can have
 * @returns {Object}
 */
export declare const sizeToTakeFromViz: ({ amountToTake, edge, minWidth, minHeight, }: {
    amountToTake: number;
    edge: EdgeItem;
    minWidth: number;
    minHeight: number;
}) => {
    firstHalf: number | null;
    secondHalf: number | null;
};
/**
 * When dropping a viz on a normal edge (not full canvas width), take a proportion from each of the visualizations
 * around the edge, updating those items and inserting the moved viz in the space created
 * @param {Object}
 * @param {EdgeItem} params.edge - The edge that is being dropped on. Spans full width of canvas
 * @param {AbsoluteBlockItem} params.itemToMove - The item that is being moved
 * @param {Number} params.firstHalf - The amount of space moved viz will take up on the left/top sides
 * @param {Number} params.secondHalf - The amount of space moved viz will take up on the right/bottom sides
 * @returns {AbsoluteBlockItem[]} - Array of updated items after the moved viz was added
 */
export declare const computeNewVizPositions: ({ edge, itemToMove, firstHalf, secondHalf, }: {
    edge: EdgeItem;
    itemToMove: AbsoluteBlockItem;
    firstHalf: number;
    secondHalf: number;
}) => AbsoluteBlockItem[];
/**
 * updates the Items into a valid Grid Layout Items List
 * @param {Object} params
 * @param {Object} params.updatedVisualizations visualizations that have been updated
 * @param {Object} params.itemToMove visualization that is being moved (removed)
 * @param {Array} params.items list of visualization items
 * @param {Number} params.canvasWidth width of canvas
 * @returns {Array{}} - returns a combined array of Viz Item Objects
 */
export declare const updateItems: ({ updatedVisualizations, itemToMove, items, canvasWidth, }: {
    updatedVisualizations: AbsoluteBlockItem[];
    itemToMove: AbsoluteBlockItem;
    items: AbsoluteBlockItem[];
    canvasWidth: number;
}) => AbsoluteBlockItem[];
/**
 * check if the moving item is dropping on its own edge and the edge has same width/height as item
 * @param {Object} params
 * @param {Object} edge edge being dropped onto
 * @param {Object} itemToMove visualization item being moved
 * @return {Boolean}
 */
export declare const isDropOnOwnEdge: ({ edge, itemToMove, }: {
    edge: EdgeItem;
    itemToMove: AbsoluteBlockItem;
}) => boolean;
/**
 * Calculates new position values for visualizations being affected from a Visualization being dropped on an Edge
 * @param {Object} params
 * @param {Object} edge edge being dropped onto
 * @param {Object} itemToMove visualization Item being moved
 * @param {Object[]} items array of all visualization Items
 * @param {String} canvasWidth width of canvas
 * @return {Object[]} object of the list of updated visualizations items and updated itemToMove object
 */
export declare const updateDropOnEdge: ({ edge, itemToMove, items, canvasWidth, }: {
    edge: EdgeItem;
    itemToMove: AbsoluteBlockItem;
    items: AbsoluteBlockItem[];
    canvasWidth: number;
}) => {
    updatedVisualizations: AbsoluteBlockItem[];
    updatedItemToMove: AbsoluteBlockItem;
} | null;
/**
 * Given a rectangular Item, determine whether the position is within bounds of the item
 * @param {Object} params
 * @param {Object} params.item visualization item being hovered over
 * @param {Object} params.position position of the mouse over the visualization
 * @returns {Boolean} whether the position is in bounds of the Item
 */
export declare const positionInItemBoundary: ({ item, position, }: {
    item: AbsoluteBlockItem;
    position: Coordinate;
}) => boolean;
/**
 * Given a rectangular Item, find the quadrant where position is located on an item
 * where the quadrants are divided by diagonal lines creating four triangles
 * Dividing Line 1: (start: {top left corner}, end: {bottom right corner}) y = f(x) = slope * x
 * Dividing Line 2: (start: {bottom left corner}, end: {top right corner}) y = f(x) = -slope * x
 * @param {Object} params
 * @param {Object} params.item visualization item being hovered over
 * @param {Object} params.position position of the mouse over the visualization
 * @returns {String} returns the quadrant position is in Item oneOf('n', 's', 'w', 'e'), if not in quadrant it returns null
 */
export declare const findQuadrant: ({ item, position, }: {
    item: AbsoluteBlockItem;
    position: Coordinate;
}) => Quadrant | null;
/**
 * Calculates the updated position values for the viz being moved and dropped onto
 * @param {Object} params
 * @param {Object} params.itemToMove item that is being moved
 * @param {Object} params.itemToDropOn item that the visualization is being dropped onto
 * @param {String} direction direction item is dropped on oneOf('n', 's', 'w', 'e')
 * @returns {Object[]} an Array containing updated itemToMove and itemToDropOn
 */
export declare const updateDropOnViz: ({ itemToMove, itemToDropOn, direction, }: {
    itemToMove: AbsoluteBlockItem;
    itemToDropOn: AbsoluteBlockItem;
    direction: Quadrant;
}) => [AbsoluteBlockItem, AbsoluteBlockItem] | null;
/**
 * Calculates new viz positions after the itemToMove viz is dropped on edge
 * @param {Object} params
 * @param {Object} params.edge edge being dropped onto
 * @param {Object} params.itemToMove visualization Item being moved
 * @param {Object[]} params.items array of all visualization Items
 * @param {String} params.canvasWidth width of canvas
 * @return {Object[]} object of the list of updated visualizations items, updated itemToMove object, and the old itemToMove
 */
export declare const previewDropOnEdge: ({ edge, itemToMove, items, canvasWidth, }: {
    edge: EdgeItem;
    itemToMove: AbsoluteBlockItem;
    items: AbsoluteBlockItem[];
    canvasWidth: number;
}) => AbsoluteBlockItem[] | null;
/**
 * Calculates the updated position values for the viz being moved and dropped onto
 * @param {Object} params
 * @param {Object} params.itemToMove item that is being moved
 * @param {Object} params.itemToDropOn item that the visualization is being dropped onto
 * @param {String} direction direction item is dropped on oneOf('n', 's', 'w', 'e')
 * @param {Object[]} items list of all visualizations on canvas
 * @returns {Object[]} an Array containing updated itemToMove and itemToDropOn
 */
export declare const previewDropOnViz: ({ itemToDropOn, itemToMove, items, direction, }: {
    itemToDropOn: AbsoluteBlockItem;
    itemToMove: AbsoluteBlockItem;
    items: AbsoluteBlockItem[];
    direction: Quadrant;
}) => AbsoluteBlockItem[] | null;
/**
 * Finds items that live outside the canvas boundary, and returns an error message for each item.
 * @param {Object} params
 * @param {Object[]} params.items items in the layout structure of the dashboard
 * @param {Object} params.boundary canvas boundary { x, y, w, h }
 * @returns {Object[]} array of objects out of bounds
 */
export declare const findItemsOutsideBoundary: ({ items, boundary, }: {
    items: AbsoluteBlockItem[];
    boundary: AbsolutePosition;
}) => LayoutError[];
interface EdgeValidationItem {
    start: Coordinate;
    end: Coordinate;
    orientation: EdgeItem['orientation'];
    type: 'above' | 'below' | 'left' | 'right';
    belongsTo: AbsolutePosition;
}
/**
 * Gets the 4 edges of every item (top, bottom, left, and right)
 * @param {Object} params
 * @param {Object} params.item item positions { x, y, w, h }
 * @param {Object} [params.belongsTo={}] item to which these edges belong
 * @returns {Object[]} array of edges where edge = { start: { x, y }, end: { x, y } }
 */
export declare const getItemEdges: ({ item, belongsTo, }: {
    item: AbsolutePosition;
    belongsTo?: AbsolutePosition | undefined;
}) => EdgeValidationItem[];
/**
 * validate if layout is valid and return the appropriate error object if it is not
 * @param {Object} params
 * @param {Object[]} params.layout layout structure of the dashboard
 * @param {Object} params.canvasBounds canvas boundary { x, y, w, h }
 * @returns {Object[]} Array of objects containing itemId and error messages
 */
export declare const validateLayoutStructure: ({ layout, canvasBounds, }: {
    layout?: AbsoluteBlockItem[] | undefined;
    canvasBounds: AbsolutePosition;
}) => LayoutError[];
export declare const isInvalidAdjacentVizDrop: ({ itemToMove, itemToDropOn, direction, visualizations, }: {
    itemToMove: AbsoluteBlockItem;
    itemToDropOn: AbsoluteBlockItem;
    direction: Quadrant;
    visualizations: AbsoluteBlockItem[];
}) => boolean;
export {};
//# sourceMappingURL=gridUtils.d.ts.map
/*!
 * Copyright © 2020 Splunk Inc.
 * SPLUNK CONFIDENTIAL – Use or disclosure of this material in whole or
 * in part without a valid written license from Splunk Inc. is PROHIBITED.
 */
module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 70);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

module.exports = require("react");

/***/ }),
/* 1 */
/***/ (function(module, exports) {

module.exports = require("styled-components");

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.scaleGridLayoutStructureByWidth = exports.computeRelativePosition = exports.shiftViewportOnZoom = exports.cloneLine = exports.cloneBlockItem = exports.getAllCollisions = exports.resolveCompactionCollision = exports.bottom = exports.computeLineRelativePosition = exports.computeLineBoxPosition = exports.updateLineAbsPosition = exports.connectLine = exports.disconnectLine = exports.isLineConnected = exports.moveLayoutItem = exports.computeScaleToFit = exports.createOffset = exports.updateBlockItemPosition = exports.updateBlockItemSize = exports.snapOffsetToWH = exports.snapOffsetToXY = exports.snapOffset = exports.findTopBlockItemByPosition = exports.filterBlockItemsByBoundary = exports.positionsToBoundary = exports.considerMoved = exports.getOffset = exports.getClientPosition = exports.positionToStyleString = exports.positionToStyle = exports.removeInvalidItems = exports.isLinePositionValid = exports.isValidConnection = exports.isBlockPositionValid = exports.computeMaxHeight = void 0;
var findLast_1 = __importDefault(__webpack_require__(17));
var get_1 = __importDefault(__webpack_require__(10));
var isNumber_1 = __importDefault(__webpack_require__(18));
var reduce_1 = __importDefault(__webpack_require__(19));
var pullAt_1 = __importDefault(__webpack_require__(20));
var cloneDeep_1 = __importDefault(__webpack_require__(21));
var sortBy_1 = __importDefault(__webpack_require__(22));
var console_1 = __importDefault(__webpack_require__(5));
var layout_1 = __webpack_require__(6);
var edgeUtils_1 = __webpack_require__(11);
// export for gridLayout/legacyGridLayout
exports.computeMaxHeight = layout_1.computeMaxHeight;
/**
 *  check if a position is valid
 * @param {Object} position
 */
var isBlockPositionValid = function (position) {
    return !!(position &&
        Number.isInteger(position.x) &&
        Number.isInteger(position.y) &&
        Number.isInteger(position.w) &&
        Number.isInteger(position.h));
};
exports.isBlockPositionValid = isBlockPositionValid;
var isValidConnection = function (connection) {
    if ('x' in connection &&
        'y' in connection &&
        Number.isInteger(connection.x) &&
        Number.isInteger(connection.y)) {
        return true;
    }
    if ('item' in connection &&
        'port' in connection &&
        connection.item != null &&
        connection.port != null) {
        return true;
    }
    return false;
};
exports.isValidConnection = isValidConnection;
/**
 * a line should has from and to
 */
var isLinePositionValid = function (position) {
    if (position.from != null && position.to != null) {
        return (exports.isValidConnection(position.from) && exports.isValidConnection(position.to));
    }
    return false;
};
exports.isLinePositionValid = isLinePositionValid;
/**
 * filter invalid position
 * @param {Object[]} layoutStructure - Array of items (viz, edges, lines)
 * @returns {Object[]} - Returns filtered array
 */
var removeInvalidItems = function (layoutStructure) {
    if (layoutStructure === void 0) { layoutStructure = []; }
    return layoutStructure.filter(function (structure) {
        if (structure.type === 'line') {
            return exports.isLinePositionValid(structure.position);
        }
        return exports.isBlockPositionValid(structure.position);
    });
};
exports.removeInvalidItems = removeInvalidItems;
/**
 * convert position to css object
 */
var positionToStyle = function (pos) { return ({
    width: pos.w + "px",
    height: pos.h + "px",
    transform: "translate(" + pos.x + "px, " + pos.y + "px)",
}); };
exports.positionToStyle = positionToStyle;
/**
 * convert position to css string
 */
var positionToStyleString = function (pos) {
    var style = exports.positionToStyle(pos);
    return reduce_1.default(style, function (result, v, k) { return result + " " + k + ":" + v + ";"; }, '');
};
exports.positionToStyleString = positionToStyleString;
/**
 * get client position for given event with scale factor
 */
var getClientPosition = function (e, scaleFactor) {
    if (scaleFactor === void 0) { scaleFactor = 1; }
    return ({
        x: Math.round(e.clientX / scaleFactor),
        y: Math.round(e.clientY / scaleFactor),
    });
};
exports.getClientPosition = getClientPosition;
/**
 * compute offset from 2 positions
 */
var getOffset = function (currentPosition, startPosition) { return ({
    offsetX: currentPosition.x - startPosition.x,
    offsetY: currentPosition.y - startPosition.y,
}); };
exports.getOffset = getOffset;
/**
 * check if a given offset can be considered as 'move'
 * @param {Object} config
 * @param {Number} config.offsetX
 * @param {Number} config.offsetY
 */
var considerMoved = function (_a) {
    var offsetX = _a.offsetX, offsetY = _a.offsetY;
    return offsetX !== 0 || offsetY !== 0;
};
exports.considerMoved = considerMoved;
/**
 * return a boundary for 2 positions
 * @param {Coordinate} startPos
 * @param {Coordinate} endPos
 */
var positionsToBoundary = function (startPos, endPos) { return ({
    x: Math.min(startPos.x, endPos.x),
    y: Math.min(startPos.y, endPos.y),
    w: Math.abs(startPos.x - endPos.x),
    h: Math.abs(startPos.y - endPos.y),
}); };
exports.positionsToBoundary = positionsToBoundary;
/**
 * filter abs items within a boundary
 * @param {Array} items
 * @param {Object} boundary
 */
var filterBlockItemsByBoundary = function (items, boundary) {
    return items.filter(function (item) {
        var itemPosition = item.position;
        return !(boundary.x > itemPosition.x + itemPosition.w ||
            boundary.x + boundary.w < itemPosition.x ||
            boundary.y > itemPosition.y + itemPosition.h ||
            boundary.y + boundary.h < itemPosition.y);
    });
};
exports.filterBlockItemsByBoundary = filterBlockItemsByBoundary;
/**
 * find the first item that contains the pos.
 */
var findTopBlockItemByPosition = function (items, pos, padding) {
    if (padding === void 0) { padding = 0; }
    return findLast_1.default(items, function (item) {
        var itemPosition = padding
            ? edgeUtils_1.applyVizPadding({ item: item, padding: padding }).position
            : item.position;
        return (itemPosition.x <= pos.x &&
            itemPosition.x + itemPosition.w >= pos.x &&
            itemPosition.y <= pos.y &&
            itemPosition.y + itemPosition.h >= pos.y);
    });
};
exports.findTopBlockItemByPosition = findTopBlockItemByPosition;
/**
 * Compute the new offset so current + new offset will be the multiple of snapTo unit
 * For examples:
 * (5, 2, 5) => 0, user moved less than half of the snapTo unit, return 0 so 5 + 0 = 5
 * (5, 3, 5) => 5, user moved more than half of the snapTo unit, return 5 so 5 + 5 = 5 * 2
 * (5, 12, 5) => 10
 * (5, 13, 5) => 15
 * @param {Number} current
 * @param {Number} offset
 * @param {Number} snapTo
 */
var snapOffset = function (current, offset, snapTo) {
    // return a new offset
    var remainder = (current + offset) % snapTo;
    var newOffset = remainder > snapTo / 2
        ? offset + (snapTo - remainder)
        : offset - remainder;
    return newOffset;
};
exports.snapOffset = snapOffset;
/**
 * snap item with its top-left corner (represent by x, y)
 * @param {Object} position
 * @param {Object} offset
 * @param {Number} gridWidth
 * @param {Number} gridHeight
 * @param {Number} spacing
 */
var snapOffsetToXY = function (_a) {
    var position = _a.position, offset = _a.offset, gridWidth = _a.gridWidth, gridHeight = _a.gridHeight, _b = _a.spacing, spacing = _b === void 0 ? 0 : _b, _c = _a.padding, padding = _c === void 0 ? 0 : _c;
    var offsetX = offset.offsetX, offsetY = offset.offsetY;
    offsetX = exports.snapOffset(position.x, offsetX, gridWidth + spacing) + padding;
    offsetY = exports.snapOffset(position.y, offsetY, gridHeight + spacing) + padding;
    return {
        offsetX: offsetX,
        offsetY: offsetY,
    };
};
exports.snapOffsetToXY = snapOffsetToXY;
/**
 * snap item with its size (represent by w, h)
 * @param {Object} position
 * @param {Object} offset
 * @param {Number} gridWidth
 * @param {Number} gridHeight
 * @param {Number} spacing
 */
var snapOffsetToWH = function (_a) {
    var position = _a.position, offset = _a.offset, gridWidth = _a.gridWidth, gridHeight = _a.gridHeight, _b = _a.spacing, spacing = _b === void 0 ? 0 : _b, _c = _a.padding, padding = _c === void 0 ? 0 : _c;
    var offsetX = offset.offsetX, offsetY = offset.offsetY;
    offsetX =
        exports.snapOffset(position.x + position.w, offsetX, gridWidth + spacing) +
            (padding - spacing);
    offsetY =
        exports.snapOffset(position.y + position.h, offsetY, gridHeight + spacing) +
            (padding - spacing);
    return {
        offsetX: offsetX,
        offsetY: offsetY,
    };
};
exports.snapOffsetToWH = snapOffsetToWH;
/**
 * Mutate item coordinates and/or dimensions.
 * This mutation's new dimensions and coordinates are bounded within the original block item real estate.
 * @param {Object} item
 * @param {Object} offset
 * @param {String} dir Cartesian direction to shift item towards.
 * @param {Object} options
 */
var updateBlockItemSize = function (_a) {
    var item = _a.item, offset = _a.offset, dir = _a.dir, _b = _a.options, _c = _b === void 0 ? {} : _b, _d = _c.minWidth, minWidth = _d === void 0 ? 0 : _d, _e = _c.minHeight, minHeight = _e === void 0 ? 0 : _e;
    var _f = item.position, w = _f.w, h = _f.h;
    var offsetX = offset.offsetX, offsetY = offset.offsetY;
    var updatedPosition = __assign({}, item.position);
    // resizing from north
    if (['n', 'ne', 'nw'].includes(dir)) {
        updatedPosition.y += Math.min(h - minHeight, offsetY);
        updatedPosition.h -= offsetY;
    }
    // resizing from the south
    if (['s', 'se', 'sw'].includes(dir)) {
        updatedPosition.h += offsetY;
    }
    // resizing from the east
    if (['e', 'ne', 'se'].includes(dir)) {
        updatedPosition.w += offsetX;
    }
    // resizing from west
    if (['w', 'nw', 'sw'].includes(dir)) {
        updatedPosition.x += Math.min(w - minWidth, offsetX);
        updatedPosition.w -= offsetX;
    }
    updatedPosition.w = Math.max(minWidth, updatedPosition.w);
    updatedPosition.h = Math.max(minHeight, updatedPosition.h);
    return __assign(__assign({}, item), { position: updatedPosition });
};
exports.updateBlockItemSize = updateBlockItemSize;
var updateBlockItemPosition = function (item, offset) {
    var offsetX = offset.offsetX, offsetY = offset.offsetY;
    return __assign(__assign({}, item), { position: __assign(__assign({}, item.position), { x: item.position.x + offsetX, y: item.position.y + offsetY }) });
};
exports.updateBlockItemPosition = updateBlockItemPosition;
/**
 * create offset based on dir, x and y
 * @method createOffset
 * @param {String} dir
 * @param {Number} x
 * @param {Number} y
 * @returns {Object} offset
 */
var createOffset = function (dir, x, y) {
    switch (dir) {
        case 'n':
            return {
                offsetX: 0,
                offsetY: -y,
            };
        case 's':
            return {
                offsetX: 0,
                offsetY: y,
            };
        case 'w':
            return {
                offsetX: -x,
                offsetY: 0,
            };
        case 'e':
            return {
                offsetX: x,
                offsetY: 0,
            };
        default:
            return {
                offsetX: 0,
                offsetY: 0,
            };
    }
};
exports.createOffset = createOffset;
/**
 * compute scale factor
 * @param {Number} actualWidth
 * @param {Number} canvasWidth
 */
var computeScaleToFit = function (actualWidth, canvasWidth) {
    if (!(isNumber_1.default(canvasWidth) &&
        canvasWidth > 0 &&
        isNumber_1.default(actualWidth) &&
        actualWidth > 0)) {
        console_1.default.warn("Failed to calculate layout scale: containerWidth=" + actualWidth + ", width=" + canvasWidth + "; falling back to scale=1");
        return 1;
    }
    return actualWidth / canvasWidth;
};
exports.computeScaleToFit = computeScaleToFit;
/**
 *
 * @param {Array} items
 * @param {Number} from  target item index
 * @param {Number} to    where does this item move to
 */
var moveLayoutItem = function (items, from, to) {
    var structure = __spread(items);
    var removed = pullAt_1.default(structure, [from]);
    structure.splice(to, 0, removed[0]);
    return structure;
};
exports.moveLayoutItem = moveLayoutItem;
/**
 * check if a line is connected
 */
var isLineConnected = function (_a) {
    var line = _a.line, dir = _a.dir;
    return 'item' in line.position[dir];
};
exports.isLineConnected = isLineConnected;
/**
 *  disconnect a line from item and set it to abs position
 */
var disconnectLine = function (_a) {
    var _b;
    var line = _a.line, dir = _a.dir, absPos = _a.absPos;
    var updatePosition = __assign(__assign({}, line.position), (_b = {}, _b[dir] = __assign({}, absPos), _b));
    return __assign(__assign({}, line), { position: updatePosition });
};
exports.disconnectLine = disconnectLine;
/**
 * connect a line with an item and port
 */
var connectLine = function (_a) {
    var _b;
    var line = _a.line, dir = _a.dir, itemId = _a.itemId, port = _a.port;
    var position = line.position;
    var updatedPosition = __assign(__assign({}, position), (_b = {}, _b[dir] = {
        item: itemId,
        port: port,
    }, _b));
    return __assign(__assign({}, line), { position: updatedPosition });
};
exports.connectLine = connectLine;
/**
 * update line absolute position
 */
var updateLineAbsPosition = function (_a) {
    var _b;
    var line = _a.line, dir = _a.dir, offset = _a.offset;
    var offsetX = offset.offsetX, offsetY = offset.offsetY;
    var position = line.position;
    if (!('x' in position[dir])) {
        throw Error("line item " + line.item + " does not have x value for its direction " + dir);
    }
    if (!('y' in position[dir])) {
        throw Error("line item " + line.item + " does not have y value for its direction " + dir);
    }
    var _c = position[dir], x = _c.x, y = _c.y;
    return __assign(__assign({}, line), { position: __assign(__assign({}, position), (_b = {}, _b[dir] = {
            x: x + offsetX,
            y: y + offsetY,
        }, _b)) });
};
exports.updateLineAbsPosition = updateLineAbsPosition;
/**
 *
 * @param {Object} from
 * @param {Object} to
 */
var computeLineBoxPosition = function (from, to) { return ({
    x: Math.min(from.x, to.x),
    y: Math.min(from.y, to.y),
}); };
exports.computeLineBoxPosition = computeLineBoxPosition;
/**
 *
 * @param {Object} from
 * @param {Object} to
 * @param {Object} box
 */
var computeLineRelativePosition = function (from, to, box) { return ({
    from: {
        x: from.x - box.x,
        y: from.y - box.y,
    },
    to: {
        x: to.x - box.x,
        y: to.y - box.y,
    },
}); };
exports.computeLineRelativePosition = computeLineRelativePosition;
/**
 * Return the bottom coordinate of the layout.
 *
 * @param  {Array} layout Layout array.
 * @return {Number}       Bottom coordinate.
 */
var bottom = function (layout) {
    return layout.length > 0
        ? Math.max.apply(Math, __spread(layout.map(function (_a) {
            var position = _a.position;
            return position.y + position.h;
        }))) : 1;
};
exports.bottom = bottom;
/**
 * Before moving item down, it will check if the movement will cause collisions
 * and move those items down before.
 * @method resolveCompactionCollision
 * @param {Array} layout
 * @param {Object} itemToMove current item which need to be moved to solve the collision
 * @param {Number} moveToCoord the destination coordination of y axis
 * @returns {Array} [newLayout, newItem]
 */
var resolveCompactionCollision = function (layout, itemToMove, moveToCoord) {
    var _a;
    var axisVal = itemToMove.position.y;
    axisVal += 1;
    var newLayout = cloneDeep_1.default(layout);
    var itemIndex = newLayout.findIndex(function (layoutItem) { return layoutItem.item === itemToMove.item; });
    var newItem = cloneDeep_1.default(itemToMove);
    newItem.position.y = axisVal;
    // Go through each item we collide with.
    // If there is a collision, we will move this collision down, otherwise set y = moveToCoord and return
    for (var i = itemIndex + 1; i < layout.length; i += 1) {
        // Optimization: we can break early if we know we're past this el
        // We can do this b/c it's a sorted layout
        if (newLayout[i].position.y > newItem.position.y + newItem.position.h) {
            break;
        }
        if (layout_1.collides(newItem, newLayout[i])) {
            _a = __read(exports.resolveCompactionCollision(layout, layout[i], moveToCoord + newItem.position.h), 2), newLayout = _a[0], newLayout[i] = _a[1];
        }
    }
    newItem.position.y = moveToCoord;
    newLayout[itemIndex] = newItem;
    return [newLayout, newItem];
};
exports.resolveCompactionCollision = resolveCompactionCollision;
/**
 * get all collisions given an item and current layout
 * @method getAllCollisions
 * @param {Array} layout
 * @param {Object} layoutItem
 * @returns {Array} sorted layout
 */
var getAllCollisions = function (layout, layoutItem) {
    return layout.filter(function (item) { return layout_1.collides(item, layoutItem); });
};
exports.getAllCollisions = getAllCollisions;
/**
 * clone a block item
 * @param {Number} id
 * @param {Object} item
 * @param {Number} offsetMultiplier
 */
var cloneBlockItem = function (_a) {
    var id = _a.id, item = _a.item, offsetMultiplier = _a.offsetMultiplier;
    var copiedPosition = item.position;
    return __assign(__assign({}, item), { item: id, position: {
            x: copiedPosition.x + 20 * offsetMultiplier,
            y: copiedPosition.y + 20 * offsetMultiplier,
            w: copiedPosition.w,
            h: copiedPosition.h,
        } });
};
exports.cloneBlockItem = cloneBlockItem;
/**
 * clone an line, it assume the line is not connected
 * @param {Number} id
 * @param {Object} item
 * @param {Number} offsetMultiplier
 */
var cloneLine = function (_a) {
    var id = _a.id, item = _a.item, offsetMultiplier = _a.offsetMultiplier;
    var copiedPosition = item.position;
    return __assign(__assign({}, item), { item: id, position: {
            from: {
                x: copiedPosition.from.x +
                    20 * offsetMultiplier,
                y: copiedPosition.from.y +
                    20 * offsetMultiplier,
            },
            to: {
                x: copiedPosition.to.x + 20 * offsetMultiplier,
                y: copiedPosition.to.y + 20 * offsetMultiplier,
            },
        } });
};
exports.cloneLine = cloneLine;
/**
 * Calculates new viewport position after a zoom event to keep the previous central point in the center of
 * the scaled canvas. See MR #2030 for algorithm details.
 * @param {Number} scrollLeft viewport left edge offset relative to canvas
 * @param {Number} scrollTop viewport top edge offset relative to canvas
 * @param {Number} offsetWidth viewport width
 * @param {Number} offsetHeight viewport height
 * @param {Number} scaleRatio new scale to old scale ratio
 * @returns {Object} object containing new scrollLeft and scrollTop values
 */
var shiftViewportOnZoom = function (_a) {
    var scrollLeft = _a.scrollLeft, scrollTop = _a.scrollTop, offsetWidth = _a.offsetWidth, offsetHeight = _a.offsetHeight, scaleRatio = _a.scaleRatio;
    var middleOffsetWidth = offsetWidth / 2;
    var middleOffsetHeight = offsetHeight / 2;
    return {
        scrollLeft: (scrollLeft + middleOffsetWidth) * scaleRatio - middleOffsetWidth,
        scrollTop: (scrollTop + middleOffsetHeight) * scaleRatio - middleOffsetHeight,
    };
};
exports.shiftViewportOnZoom = shiftViewportOnZoom;
/**
 * return position relative to the canvas rect
 */
var computeRelativePosition = function (e, canvasRef, scale) {
    if (scale === void 0) { scale = 1; }
    var pos = exports.getClientPosition(e, scale);
    var canvasDomNode = get_1.default(canvasRef, ['current']);
    var rect = canvasDomNode && canvasDomNode.getBoundingClientRect();
    if (pos && rect) {
        return {
            x: pos.x - rect.left / scale,
            y: pos.y - rect.top / scale,
        };
    }
    return pos;
};
exports.computeRelativePosition = computeRelativePosition;
/**
 * Scales a GridLayout by stretching the width of each item by the scale factor
 * @param {AbsoluteBlockItem[]} items items to scale
 * @param {Number} scale how much to scale
 */
var scaleGridLayoutStructureByWidth = function (_a) {
    var layout = _a.layout, _b = _a.scale, scale = _b === void 0 ? 1 : _b;
    if (scale === 1) {
        return layout;
    }
    // Compute the edges of the existing layout. Since we're scaling
    // just the X and width we only care about vertical edges.
    var edges = edgeUtils_1.getAllEdges(layout);
    var verticalEdges = sortBy_1.default(edges.filter(function (edge) { return edge.orientation === 'vertical'; }), ['edgeStart.x']);
    // Scale the vertical edges and than align the
    // left and right items to the scaled edge position
    var newLayout = [];
    verticalEdges.forEach(function (edge) {
        var visualizations = edge.visualizations, x = edge.edgeStart.x;
        var scaledEdgeX = Math.round(x * scale);
        var left = visualizations.filter(function (viz) { return viz.position.x < x; });
        var right = visualizations.filter(function (viz) { return viz.position.x >= x; });
        // Update the Width of the layout items using the difference between the
        // newly scaled edge and the existing x
        left.forEach(function (layoutItem) {
            var newLayoutItem = newLayout.find(function (_a) {
                var id = _a.item;
                return layoutItem.item === id;
            });
            if (newLayoutItem) {
                newLayoutItem.position.w =
                    scaledEdgeX - newLayoutItem.position.x;
            }
        });
        // Since we walk the edges from the left to the right we
        // ALWAYS have to create the new layout item here but won't
        // ever need to update it.
        right.forEach(function (layoutItem) {
            newLayout.push(__assign(__assign({}, layoutItem), { position: __assign(__assign({}, layoutItem.position), { x: scaledEdgeX }) }));
        });
    });
    return newLayout;
};
exports.scaleGridLayoutStructureByWidth = scaleGridLayoutStructureByWidth;


/***/ }),
/* 3 */
/***/ (function(module, exports) {

module.exports = require("prop-types");

/***/ }),
/* 4 */
/***/ (function(module, exports) {

module.exports = require("@splunk/themes");

/***/ }),
/* 5 */
/***/ (function(module, exports) {

module.exports = require("@splunk/dashboard-utils/console");

/***/ }),
/* 6 */
/***/ (function(module, exports) {

module.exports = require("@splunk/dashboard-utils/layout");

/***/ }),
/* 7 */
/***/ (function(module, exports) {

module.exports = require("@splunk/dashboard-ui/customThemeVariables");

/***/ }),
/* 8 */
/***/ (function(module, exports) {

module.exports = require("@splunk/themes/mixins");

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.gridLayoutOptions = exports.absoluteLayoutOptions = void 0;
var layout_1 = __webpack_require__(6);
exports.absoluteLayoutOptions = {
    width: layout_1.DEFAULT_CANVAS_WIDTH,
    height: layout_1.DEFAULT_CANVAS_HEIGHT,
    display: 'actual-size',
};
exports.gridLayoutOptions = {
    width: layout_1.DEFAULT_CANVAS_WIDTH,
    gutterSize: 8,
};


/***/ }),
/* 10 */
/***/ (function(module, exports) {

module.exports = require("lodash/get");

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.findEdgesInBoundary = exports.findSnappableEdges = exports.moveVerticalEdge = exports.moveHorizontalEdge = exports.getHorizontalBoundaries = exports.getVerticalBoundaries = exports.applyVizPadding = exports.formatEdge = exports.computeEdges = exports.getAllEdges = void 0;
var uniqueId_1 = __webpack_require__(12);
var nextEdgeId = function () { return "edge_" + uniqueId_1.uniqueId(); };
/**
 * generate edge id
 */
var getNextEdgeId = function () {
    return nextEdgeId();
};
/**
 * Returns a 2D array of every viz corner, indicating which visualizations touch which node(corner)
 * @param {Object} layoutStructure - Array of visualizations from definition
 * @returns {Object[][]} - {x: { y: [vizList] } }
 */
var getNodes = function (layoutStructure) {
    if (layoutStructure.length === 0) {
        return null;
    }
    var nodes = {};
    layoutStructure.forEach(function (viz) {
        var _a = viz.position, x = _a.x, y = _a.y, w = _a.w, h = _a.h;
        var corners = [
            { x: x, y: y },
            { x: x + w, y: y },
            { x: x, y: y + h },
            { x: x + w, y: y + h },
        ];
        corners.forEach(function (corner) {
            if (nodes[corner.x] === undefined) {
                nodes[corner.x] = {};
            }
            if (nodes[corner.x][corner.y] === undefined) {
                nodes[corner.x][corner.y] = [];
            }
            nodes[corner.x][corner.y].push(viz);
        });
    });
    return nodes;
};
var isTopEdge = function (edge) {
    return edge.orientation === 'horizontal' && edge.edgeStart.y === 0;
};
var isBottomEdge = function (edge, canvasHeight) {
    return edge.orientation === 'horizontal' && edge.edgeStart.y === canvasHeight;
};
var isLeftEdge = function (edge) {
    return edge.orientation === 'vertical' && edge.edgeStart.x === 0;
};
var isRightEdge = function (edge, canvasWidth) {
    return edge.orientation === 'vertical' && edge.edgeStart.x === canvasWidth;
};
/**
 * Returns all the visualizations along a vertical edge
 * @param {Object} param - Param object needed to traverse along vertical edge
 * @param {num} param.x - x-coordinate of the edge
 * @param {num} param.yStart - y-coordinate of the edge start
 * @param {num} param.yEnd - y-coordinate of the edge end
 * @param {num} param.yCurrent - Current y in recursion
 * @param {num} param.nodes - The map of x,y coordinates to visualizations that touch that (x,y)
 * @param {num} param.visualizations - the list to add visualizations to, and then return
 * @returns {Set<Object>} - Set of unique visualizations along the edge
 */
var findVizAlongVerticalEdge = function (_a) {
    var x = _a.x, yStart = _a.yStart, yEnd = _a.yEnd, _b = _a.yCurrent, yCurrent = _b === void 0 ? yStart : _b, nodes = _a.nodes, _c = _a.visualizations, visualizations = _c === void 0 ? new Set() : _c;
    nodes[x][yCurrent].forEach(function (viz) {
        if (viz.position.y >= yStart && viz.position.y < yEnd) {
            visualizations.add(viz);
        }
        if (viz.position.y >= yCurrent && yCurrent + viz.position.h <= yEnd) {
            findVizAlongVerticalEdge({
                x: x,
                yStart: yStart,
                yEnd: yEnd,
                yCurrent: yCurrent + viz.position.h,
                nodes: nodes,
                visualizations: visualizations,
            });
        }
    });
    return visualizations;
};
/**
 * Returns all the visualizations along a horizontal edge
 * @param {Object} param - Param object needed to traverse along horizontal edge
 * @param {num} param.y - x-coordinate of the edge
 * @param {num} param.xStart - x-coordinate of the edge start
 * @param {num} param.xEnd - x-coordinate of the edge end
 * @param {num} param.xCurrent - Current x in recursion
 * @param {num} param.nodes - The map of x,y coordinates to visualizations that touch that (x,y)
 * @param {num} param.visualizations - the list to add visualizations to, and then return
 * @returns {Set<Object>} - Set of unique visualizations along the edge
 */
var findVizAlongHorizontalEdge = function (_a) {
    var y = _a.y, xStart = _a.xStart, xEnd = _a.xEnd, _b = _a.xCurrent, xCurrent = _b === void 0 ? xStart : _b, nodes = _a.nodes, _c = _a.visualizations, visualizations = _c === void 0 ? new Set() : _c;
    nodes[xCurrent][y].forEach(function (viz) {
        if (viz.position.x >= xStart && viz.position.x < xEnd) {
            visualizations.add(viz);
        }
        if (viz.position.x >= xCurrent && xCurrent + viz.position.w <= xEnd) {
            findVizAlongHorizontalEdge({
                y: y,
                xStart: xStart,
                xEnd: xEnd,
                xCurrent: xCurrent + viz.position.w,
                nodes: nodes,
                visualizations: visualizations,
            });
        }
    });
    return visualizations;
};
/**
 * Add edge to the provided list
 * @param {Object} param - Params containing edge info
 * @param {num} param.edges - the list to add the edge to
 * @param {Object} param.edgeStart - the start of the edge
 * @param {Object} param.edgeEnd - the end of the edge
 * @param {Object[][]} param.nodes - The map of x,y coordinates to visualizations that touch that (x,y)
 */
var addEdge = function (_a) {
    var edges = _a.edges, edgeStart = _a.edgeStart, edgeEnd = _a.edgeEnd, nodes = _a.nodes;
    var orientation = edgeStart.y === edgeEnd.y ? 'horizontal' : 'vertical';
    // Find all visualizations that are affected by this edge
    var visualizations = orientation === 'vertical'
        ? findVizAlongVerticalEdge({
            x: edgeStart.x,
            yStart: edgeStart.y,
            yEnd: edgeEnd.y,
            nodes: nodes,
        })
        : findVizAlongHorizontalEdge({
            y: edgeStart.y,
            xStart: edgeStart.x,
            xEnd: edgeEnd.x,
            nodes: nodes,
        });
    edges.push({
        item: getNextEdgeId(),
        edgeStart: edgeStart,
        edgeEnd: edgeEnd,
        visualizations: Array.from(visualizations),
        orientation: orientation,
    });
};
/**
 * If there is no incoming edge from the top, return true
 * @param {num} y - Current y position to compare against
 * @param {Object[]} visualizations - Array of visualizations attached to the node at (x, y). Length will be 1 to 4.
 * @returns {boolean}
 */
var shouldTraverseDown = function (y, visualizations) {
    return visualizations.every(function (viz) { return viz.position.y >= y; });
};
/**
 * If there is no incoming edge from the left, return true
 * @param {num} x - Current x position to compare against
 * @param {Object[]} visualizations - Array of visualizations attached to the node at (x, y). Length will be 1 to 4.
 * @returns {boolean}
 */
var shouldTraverseRight = function (x, visualizations) {
    return visualizations.every(function (viz) { return viz.position.x >= x; });
};
/**
 * Find the offset to the next node.
 * @param {Object} param - Param object to find offset to next node
 * @param {Number} param.x - The x co-ordinate of the current position to find offset from
 * @param {Number} param.y - The y co-ordinate of the current position to find offset from
 * @param {Object[]} param.visualizations - Array of visualizations attached to the node at (x, y). Length will be 1 to 4.
 * @param {Object} param.visualizations[].position - Position information of the visualization
 * @param {String} param.type - The type of co-ordinate. One of 'w' or 'h'.
 * @returns {number}
 */
var findOffset = function (_a) {
    var x = _a.x, y = _a.y, visualizations = _a.visualizations, type = _a.type;
    for (var i = 0; i < visualizations.length; i += 1) {
        var position = visualizations[i].position;
        if (position.y === y && position.x === x) {
            return position[type];
        }
    }
    // This for-loop is only for finding the bottom canvas edge and the right canvas edge
    for (var i = 0; i < visualizations.length; i += 1) {
        var position = visualizations[i].position;
        if (type === 'w' && position.x === x) {
            // horizontal canvas edge
            return position.w;
        }
        if (type === 'h' && position.y === y) {
            // vertical canvas edge
            return position.h;
        }
    }
    return 0;
};
/**
 * Traverse right along nodes, creating or extending edges
 * @param {Object} param - Param object to traverse right along layout
 * @param {Object[][]} param.nodes - An object that maps {x, y} coord to an array of visualizations. Indexed as nodes[x][y].
 * @param {Object[]} param.edges - The resulting array of edges that gets mutated
 * @param {Number} param.x - x coordinate of current node
 * @param {Number} param.y - y coordinate of current node
 * @param {Object} param.edgeStart - The { x, y } coordinates of start of edge
 * @param {Boolean} param.canTraverseDown - Used to prevent loops during indirect recursion
 */
function traverseRight(_a) {
    var x = _a.x, y = _a.y, nodes = _a.nodes, edges = _a.edges, edgeStart = _a.edgeStart, _b = _a.canTraverseDown, canTraverseDown = _b === void 0 ? true : _b;
    // Check if we should traverse down (if there is no incoming edge)
    // canTraverseRight must be false to avoid endless loop
    if (canTraverseDown && shouldTraverseDown(y, nodes[x][y])) {
        // eslint-disable-next-line @typescript-eslint/no-use-before-define
        traverseDown({
            x: x,
            y: y,
            nodes: nodes,
            edges: edges,
            edgeStart: { x: x, y: y },
            canTraverseRight: false,
        });
    }
    // Check if horizontal edge ends here
    // 'w' signifies we want width offset returned as opposed to height
    var offset = findOffset({ x: x, y: y, visualizations: nodes[x][y], type: 'w' });
    // Case 1 for ending edge: can't go right anymore (hit a viz OR end of dashboard), create edge up to this point.
    if (!offset) {
        addEdge({ edges: edges, edgeStart: edgeStart, edgeEnd: { x: x, y: y }, nodes: nodes });
        return;
    }
    // Case 2 for ending edge: reached window, need to create edge and start new one to avoid merging across window
    var isWindow = nodes[x][y].length === 4; // 4-way intersection
    if (isWindow) {
        addEdge({ edges: edges, edgeStart: edgeStart, edgeEnd: { x: x, y: y }, nodes: nodes });
        // Continue traversing right, starting with a new edge from current position
        traverseRight({
            x: x + offset,
            y: y,
            nodes: nodes,
            edges: edges,
            edgeStart: { x: x, y: y },
        });
        return;
    }
    // Continue traversing right, merging the past edge with the next
    traverseRight({
        x: x + offset,
        y: y,
        nodes: nodes,
        edges: edges,
        edgeStart: edgeStart,
    });
}
/**
 * Traverse right along nodes, creating or extending edges
 * @param {Object} param - Param object to traverse down along layout
 * @param {Object[][]} param.nodes - An object that maps {x, y} coord to an array of visualizations. Indexed as nodes[x][y].
 * @param {Object[]} param.edges - The resulting array of edges that gets mutated
 * @param {Number} param.x - x coordinate of current node
 * @param {Number} param.y - y coordinate of current node
 * @param {Object} param.edgeStart - The { x, y } coordinates of start of edge
 * @param {Boolean} param.canTraverseRight - Used to prevent loops during indirect recursion
 */
function traverseDown(_a) {
    var x = _a.x, y = _a.y, nodes = _a.nodes, edges = _a.edges, edgeStart = _a.edgeStart, _b = _a.canTraverseRight, canTraverseRight = _b === void 0 ? true : _b;
    if (canTraverseRight && shouldTraverseRight(x, nodes[x][y])) {
        traverseRight({
            x: x,
            y: y,
            nodes: nodes,
            edges: edges,
            edgeStart: { x: x, y: y },
            canTraverseDown: false,
        });
    }
    // Check if vertical edge ends here
    var offset = findOffset({ x: x, y: y, visualizations: nodes[x][y], type: 'h' });
    // Case 1 for ending edge: can't go down anymore (hit a viz OR end of dashboard), create edge up to this point.
    if (!offset) {
        addEdge({ edges: edges, edgeStart: edgeStart, edgeEnd: { x: x, y: y }, nodes: nodes });
        return;
    }
    // Case 2 for ending edge: reached window, need to create edge and start new one to avoid merging across window
    var isWindow = nodes[x][y].length === 4;
    if (isWindow) {
        addEdge({ edges: edges, edgeStart: edgeStart, edgeEnd: { x: x, y: y }, nodes: nodes });
        // Start a new edge from current position
        traverseDown({
            x: x,
            y: y + offset,
            nodes: nodes,
            edges: edges,
            edgeStart: { x: x, y: y },
        });
        return;
    }
    // Continue traversing, thus "merging" edges
    traverseDown({
        x: x,
        y: y + offset,
        nodes: nodes,
        edges: edges,
        edgeStart: edgeStart,
    });
}
/**
 * Compute the vertical edges for every canvas row - a row that spans the entire width of the canvas
 * @param {Object} param
 * @param {AbsoluteBlockItem[]} param.layout - Layout structure
 * @param {EdgeItem[]} param.edges - The resulting array of edges that gets mutated
 * @param {Number} param.canvasWidth - Canvas width
 */
var computeVerticalCanvasEdges = function (_a) {
    var edges = _a.edges, canvasWidth = _a.canvasWidth, layout = _a.layout;
    var nodes = getNodes(layout);
    if (nodes == null) {
        return;
    }
    // get all the horizontal edges that span the entire canvas width
    var sortedRowEdges = edges
        .filter(function (edge) {
        return edge.orientation === 'horizontal' &&
            edge.edgeStart.x === 0 &&
            edge.edgeEnd.x === canvasWidth;
    })
        .sort(function (a, b) { return a.edgeStart.y - b.edgeStart.y; });
    /**
     * iterate through the sorted horizontal edges to get their start and end coordinates
     * vertical edges between canvas row A and canvas row B will span from edgeStartA to edgeStartB and edgeEndA to edgeEndB
     */
    for (var i = 0; i < sortedRowEdges.length - 1; i += 1) {
        var _b = sortedRowEdges[i], edgeStartA = _b.edgeStart, edgeEndA = _b.edgeEnd;
        var _c = sortedRowEdges[i + 1], edgeStartB = _c.edgeStart, edgeEndB = _c.edgeEnd;
        addEdge({
            edges: edges,
            edgeStart: edgeStartA,
            edgeEnd: edgeStartB,
            nodes: nodes,
        });
        addEdge({
            edges: edges,
            edgeStart: edgeEndA,
            edgeEnd: edgeEndB,
            nodes: nodes,
        });
    }
};
/**
 * Gets all the edges given a layout of AbsoluteBlockItems
 * @param {AbsoluteBlockItem[]} layout - Array of AbsoluteBlockItems
 * @returns {EdgeItem[]} - Array of computed edges
 */
var getAllEdges = function (layout) {
    var edges = [];
    var nodes = getNodes(layout);
    if (nodes === null || nodes[0] === undefined || nodes[0][0] === undefined) {
        // When no visualizations in the layout structure
        // OR when there is no visualization at (0,0), which this algorithm assumes
        return [];
    }
    // run the algorithm
    traverseRight({
        x: 0,
        y: 0,
        nodes: nodes,
        edges: edges,
        edgeStart: { x: 0, y: 0 },
    });
    return edges;
};
exports.getAllEdges = getAllEdges;
/**
 * Compute edges given a valid layout, canvasHeight, and canvasWidth
 * @param {Object} param - Param object containing layout, canvasHeight, canvasWidth
 * @param {Object[]} param.layout - Array of visualizations from the dashboard layout definition
 * @param {Number} param.canvasHeight - Canvas height
 * @param {Number} param.canvasWidth - Canvas width
 * @returns {Object[]} - Array of computed edges
 */
var computeEdges = function (_a) {
    var layout = _a.layout, canvasHeight = _a.canvasHeight, canvasWidth = _a.canvasWidth;
    if (layout === undefined) {
        return [];
    }
    var edges = exports.getAllEdges(layout);
    // remove the computed left and right vertical canvas edges as they span the entire height of the canvas
    edges = edges.filter(function (edge) {
        return !(isLeftEdge(edge) || isRightEdge(edge, canvasWidth));
    });
    // recompute the vertical canvas edges for each canvas row where the row spans the entire width of the canvas
    computeVerticalCanvasEdges({ edges: edges, layout: layout, canvasWidth: canvasWidth });
    // Additionally, the top and bottom edge are there, but set to hidden
    edges = edges.map(function (edge) {
        var isCanvasEdge = false;
        if (isTopEdge(edge) ||
            isRightEdge(edge, canvasWidth) ||
            isBottomEdge(edge, canvasHeight) ||
            isLeftEdge(edge)) {
            isCanvasEdge = true;
        }
        return __assign(__assign({}, edge), { isCanvasEdge: isCanvasEdge });
    });
    return edges;
};
exports.computeEdges = computeEdges;
/**
 * Format edge according to a given padding and edge thickness
 * @param {Object} param - Param object containing edge, padding, and edgeThickness
 * @param {Object} param.edge - Edge object
 * @param {Number} param.padding - Layout padding
 * @param {Number} param.edgeThickness - Thickness of edge
 * @returns {Object} - Returns formatted edge object
 */
var formatEdge = function (_a) {
    var edge = _a.edge, _b = _a.padding, padding = _b === void 0 ? 0 : _b, _c = _a.edgeThickness, edgeThickness = _c === void 0 ? 0 : _c;
    // Formatted edges are centered between visualizations and respect the padding (gutter-size) between them
    var formattedEdgeStart = __assign({}, edge.edgeStart);
    var formattedEdgeEnd = __assign({}, edge.edgeEnd);
    if (edge.orientation === 'horizontal') {
        formattedEdgeStart.x += padding;
        formattedEdgeStart.y -= edgeThickness / 2;
        formattedEdgeEnd.x -= padding;
        formattedEdgeEnd.y -= edgeThickness / 2;
    }
    else {
        formattedEdgeStart.y += padding;
        formattedEdgeStart.x -= edgeThickness / 2;
        formattedEdgeEnd.y -= padding;
        formattedEdgeEnd.x -= edgeThickness / 2;
    }
    return __assign(__assign({}, edge), { edgeStart: formattedEdgeStart, edgeEnd: formattedEdgeEnd });
};
exports.formatEdge = formatEdge;
/**
 * Format visualization according to a given padding
 * @param {Object} param - Param object containing item and padding
 * @param {Object} param.item - Visualization object
 * @param {Number} param.padding - Layout padding
 * @returns {AbsoluteBlockItem} - Returns formatted edge object
 */
var applyVizPadding = function (_a) {
    var item = _a.item, _b = _a.padding, padding = _b === void 0 ? 0 : _b;
    var _c = item.position, x = _c.x, y = _c.y, w = _c.w, h = _c.h;
    return __assign(__assign({}, item), { position: {
            x: x + padding,
            y: y + padding,
            w: w - 2 * padding,
            h: h - 2 * padding,
        } });
};
exports.applyVizPadding = applyVizPadding;
/**
 * Determines Upper and Lower boundaries of an edge given its visualizations around it
 * @param {Object[]} visualizations - The visualizations surrounding the edge
 * @param {Number} y - The y position of the selected edge
 * @param {Number} minHeight - minimum Item Height Value
 * @param {Boolean} isFullWidthEdge - If the edge we are getting boundaries of is the size of canvas width
 * @returns {Object} - returns the boundaries in an object
 */
var getVerticalBoundaries = function (_a) {
    var visualizations = _a.visualizations, y = _a.y, minHeight = _a.minHeight, _b = _a.isFullWidthEdge, isFullWidthEdge = _b === void 0 ? false : _b;
    var boundaries = {
        upperBoundary: Number.NEGATIVE_INFINITY,
        lowerBoundary: Number.POSITIVE_INFINITY,
    };
    var comparePosition = function (position) {
        // If viz is below of the edge
        // When the edge is a full width edge, there is no lower boundary
        //  since dragging down increases canvas size
        if (position.y >= y && !isFullWidthEdge) {
            boundaries.lowerBoundary = Math.min(boundaries.lowerBoundary, position.y + position.h - minHeight);
        }
        // If viz is above the edge
        if (position.y < y) {
            boundaries.upperBoundary = Math.max(boundaries.upperBoundary, position.y + minHeight);
        }
    };
    visualizations.forEach(function (viz) { return comparePosition(viz.position); });
    return boundaries;
};
exports.getVerticalBoundaries = getVerticalBoundaries;
/**
 * Determines Left and Right boundaries of an edge given its visualizations around it
 * @param {Object[]} visualizations - The visualizations surrounding the edge
 * @param {Number} x - The x position of the selected edge
 * @param {Number} minWidth - minimum Item Width Value
 * @returns {Object} - returns the boundaries in an object
 */
var getHorizontalBoundaries = function (_a) {
    var visualizations = _a.visualizations, x = _a.x, minWidth = _a.minWidth;
    var boundaries = {
        rightBoundary: Number.POSITIVE_INFINITY,
        leftBoundary: Number.NEGATIVE_INFINITY,
    };
    var comparePosition = function (position) {
        if (position.x >= x) {
            // If viz is to the right of the edge
            boundaries.rightBoundary = Math.min(boundaries.rightBoundary, position.x + position.w - minWidth);
        }
        if (position.x < x) {
            // If viz is to the left of the edge
            boundaries.leftBoundary = Math.max(boundaries.leftBoundary, position.x + minWidth);
        }
    };
    visualizations.forEach(function (viz) { return comparePosition(viz.position); });
    return boundaries;
};
exports.getHorizontalBoundaries = getHorizontalBoundaries;
/**
 * Determines the next edge position for movement up and down of a horizontal edge
 * @param {Object} edge - the current moving edge
 * @param {Number} offset - offset to move edge
 * @param {Object} options.edgeBoundaries Object with lower/upper boundaries
 * @returns {Object} - returns edge with updated position
 */
var moveHorizontalEdge = function (_a) {
    var edge = _a.edge, offset = _a.offset, _b = _a.edgeBoundaries, upperBoundary = _b.upperBoundary, lowerBoundary = _b.lowerBoundary;
    // Update edge to either the offset value,
    // or the defined maximum/minimum based on min viz height/width
    var updatedY = offset < 0
        ? Math.max(upperBoundary, edge.edgeStart.y + offset)
        : Math.min(lowerBoundary, edge.edgeStart.y + offset);
    return __assign(__assign({}, edge), { edgeStart: {
            x: edge.edgeStart.x,
            y: updatedY,
        }, edgeEnd: {
            x: edge.edgeEnd.x,
            y: updatedY,
        } });
};
exports.moveHorizontalEdge = moveHorizontalEdge;
/**
 * Determines the next edge position for movement left and right of a vertical edge
 * @param {Object} edge - the current moving edge
 * @param {Number} offset - offset to move edge
 * @param {Object} options.edgeBoundaries Object with left/right boundaries
 * @returns {Object} - returns edge with updated position
 */
var moveVerticalEdge = function (_a) {
    var edge = _a.edge, offset = _a.offset, _b = _a.edgeBoundaries, leftBoundary = _b.leftBoundary, rightBoundary = _b.rightBoundary;
    var updatedX = offset < 0
        ? Math.max(leftBoundary, edge.edgeStart.x + offset)
        : Math.min(rightBoundary, edge.edgeStart.x + offset);
    return __assign(__assign({}, edge), { edgeStart: {
            x: updatedX,
            y: edge.edgeStart.y,
        }, edgeEnd: {
            x: updatedX,
            y: edge.edgeEnd.y,
        } });
};
exports.moveVerticalEdge = moveVerticalEdge;
/**
 * find edges that the given edge should snap to, according to the snap range
 * @param {Object} options
 * @param {Object} options.edge the edge being dragged, edge has the structure
 * @param {array}  options.edges all the edges that are parallel to target edge and within the boundary
 * @param {Number} options.snapRange the range within which that triggers snapping
 * @returns {Object} updatedEdge and snappableEdges
 */
var findSnappableEdges = function (_a) {
    var _b, _c;
    var edge = _a.edge, edges = _a.edges, snapRange = _a.snapRange;
    var coordinate = edge.orientation === 'horizontal' ? 'y' : 'x';
    var snappableEdges = edges.reduce(function (currentSnappableEdges, nextEdge) {
        var nextEdgeDistance = Math.abs(nextEdge.edgeStart[coordinate] - edge.edgeStart[coordinate]);
        // nextEdge is in range
        if (nextEdgeDistance <= snapRange) {
            if (currentSnappableEdges.length === 0) {
                return [nextEdge];
            }
            var lastEdge = currentSnappableEdges[currentSnappableEdges.length - 1];
            var lastEdgeDistance = Math.abs(lastEdge.edgeStart[coordinate] - edge.edgeStart[coordinate]);
            // find new closest snappable edge
            if (nextEdgeDistance < lastEdgeDistance) {
                return [nextEdge];
            }
            // it is possible there are several snappable edges having the same x or y value
            if (nextEdgeDistance === lastEdgeDistance) {
                return __spread(currentSnappableEdges, [nextEdge]);
            }
        }
        // nextEdge is out of range
        return __spread(currentSnappableEdges);
    }, []);
    // if no snappable edge, snap to itself
    var firstSnappableEdge = snappableEdges.length > 0 ? snappableEdges[0] : edge;
    return {
        updatedEdge: __assign(__assign({}, edge), { edgeStart: __assign(__assign({}, edge.edgeStart), (_b = {}, _b[coordinate] = firstSnappableEdge.edgeStart[coordinate], _b)), edgeEnd: __assign(__assign({}, edge.edgeEnd), (_c = {}, _c[coordinate] = firstSnappableEdge.edgeEnd[coordinate], _c)) }),
        snappableEdges: snappableEdges,
    };
};
exports.findSnappableEdges = findSnappableEdges;
/**
 * Find all the edges that could be snapped to, given the limitations enforced by the surrounding visualizations.
 * @param {Object} options
 * @param {Object} options.edge the edge being dragged
 * @param {array}  options.edges all the edges on canvas
 * @param {Object} options.edgeBoundaries Object with either lower/upper or left/right boundaries
 * @returns {array} the edges that are within the boundary of the edge being moved
 */
var findEdgesInBoundary = function (_a) {
    var edge = _a.edge, edges = _a.edges, edgeBoundaries = _a.edgeBoundaries;
    var orientation = edge.orientation;
    if (orientation === 'horizontal') {
        return edges.filter(function (e) {
            return e.orientation === 'horizontal' &&
                e.edgeStart.y >=
                    edgeBoundaries.upperBoundary &&
                e.edgeStart.y <=
                    edgeBoundaries.lowerBoundary &&
                e !== edge;
        });
    }
    if (orientation === 'vertical') {
        return edges.filter(function (e) {
            return e.orientation === 'vertical' &&
                e.edgeStart.x >=
                    edgeBoundaries.leftBoundary &&
                e.edgeStart.x <=
                    edgeBoundaries.rightBoundary &&
                e !== edge;
        });
    }
    // can't match any edge because the orientation is invalid, this shouldn't happen.
    return [];
};
exports.findEdgesInBoundary = findEdgesInBoundary;


/***/ }),
/* 12 */
/***/ (function(module, exports) {

module.exports = require("@splunk/dashboard-utils/uniqueId");

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.default = {
    showTitleAndDescription: {
        type: 'boolean',
        default: true,
        description: 'A Boolean value to determine whether to display the Canvas Title and Description or not.',
    },
    submitButton: {
        type: 'boolean',
        description: 'You can also specify the layout option "submitButton". When set to true, a user must click a Submit button in order for the change in input selection to take effect (e.g. rerun searches with new dropdown values). If set to false, or if not specified at all, the dashboard will immediately refresh when a user makes a change in input selection.',
    },
    submitOnDashboardLoad: {
        type: 'boolean',
        default: false,
        description: 'A Boolean value to determine whether inputs should submit their default values (if they exist) on initial dashboard load in order to allow searches to run once before requiring submit button to be used. To be used when `submitButton` is set to true.',
    },
};


/***/ }),
/* 14 */
/***/ (function(module, exports) {

module.exports = require("@splunk/dashboard-context");

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateBackgroundImage = exports.getImageDimension = exports.invalidImageSizeType = exports.validImageWidthHeight = exports.validImagePos = exports.isFromImageRegistry = void 0;
var console_1 = __importDefault(__webpack_require__(5));
var isEmpty_1 = __importDefault(__webpack_require__(25));
// /**
//  * Check whether image src url is valid or not
//  * @method validImageSrc
//  * @param {String} src
//  */
// export const validImageSrc = src => {
//     const img = new Image();
//     img.onerror = () => {
//         console.error(`Background image url ${src} is invalid`);
//     };
//     img.src = src
// };
/**
 * check if an image is from Image Registry
 * @param {*} src
 */
var isFromImageRegistry = function (src) {
    if (src === void 0) { src = ''; }
    var _a = __read(src.split('://'), 1), type = _a[0];
    return (src.indexOf('://') > -1 &&
        type !== 'http' &&
        type !== 'https' &&
        type !== 'ftp' &&
        type !== 'file');
};
exports.isFromImageRegistry = isFromImageRegistry;
/**
 * Check whether image position is valid or not
 * @method validImagePos
 * @param {Number} x
 * @param {Number} y
 * @param {Number} canvasWidth
 * @param {Number} canvasHeight
 * @returns {Boolean}
 */
var validImagePos = function (_a) {
    var x = _a.x, y = _a.y, canvasWidth = _a.canvasWidth, canvasHeight = _a.canvasHeight;
    return !!(x != null &&
        Number.isInteger(x) &&
        y != null &&
        Number.isInteger(y) &&
        x <= canvasWidth &&
        y <= canvasHeight &&
        x >= 0 &&
        y >= 0);
};
exports.validImagePos = validImagePos;
/**
 * Check whether image width and height is valid or not
 * @method validImageWidthHeight
 * @param {Number} imageWidth //Defaulted to 1 because w can't be undefined
 * @param {Number} imageHeight //Defaulted to 1 because h can't be undefined
 * @param {Number} canvasWidth
 * @param {Number} canvasHeight
 * @returns {Boolean}
 */
var validImageWidthHeight = function (imageWidth, imageHeight) {
    if (imageWidth === void 0) { imageWidth = 1; }
    if (imageHeight === void 0) { imageHeight = 1; }
    return !!(Number.isInteger(imageWidth) &&
        Number.isInteger(imageHeight) &&
        imageWidth > 0 &&
        imageHeight > 0);
};
exports.validImageWidthHeight = validImageWidthHeight;
/**
 * Check whether image size type is valid or not (cover/auto/contain/undefined)
 * @method invalidImageSizeType
 * @param {String} sizeType
 * @returns {Boolean}
 */
var invalidImageSizeType = function (sizeType) {
    return !!(sizeType !== 'cover' &&
        sizeType !== 'contain' &&
        sizeType !== 'auto' &&
        sizeType !== undefined);
};
exports.invalidImageSizeType = invalidImageSizeType;
/**
 * Return the original width and height of a valid image
 * @method getImageWidthHeight
 * @param {String} imgSrc
 * @returns {Number. Number} Image width and height
 */
var getImageDimension = function (imgSrc) {
    var img = new Image();
    try {
        img.src = imgSrc;
        img.style.position = 'absolute';
        img.style.left = '-9999'; // Image width must not exceed 9999 pixels
        img.style.visibility = 'hidden';
        document.body.appendChild(img);
        var height = img.naturalHeight;
        var width = img.naturalWidth;
        return { width: width, height: height };
    }
    catch (ex) {
        return { width: 0, height: 0 };
    }
    finally {
        if (document.body.contains(img)) {
            document.body.removeChild(img); // Removes the image from the DOM
        }
    }
};
exports.getImageDimension = getImageDimension;
/**
 * Check whether background image options are valid or not. Default to x:0, y:0, w:0, h:0 and sizeType:'auto'
 * @method validateBackgroundImage
 * @param {Object} backgroundImage
 * @param {String} backgroundImage.src
 * @param {Number} backgroundImage.x
 * @param {Number} backgroundImage.y
 * @param {Number} backgroundImage.w
 * @param {Number} backgroundImage.h
 * @param {String} backgroundImage.sizeType
 * @param {Number} width
 * @param {Number} height
 * @returns {Object}
 */
var validateBackgroundImage = function (_a) {
    var _b = _a.backgroundImage, backgroundImage = _b === void 0 ? {} : _b, canvasWidth = _a.canvasWidth, canvasHeight = _a.canvasHeight;
    var src = backgroundImage.src;
    var x = backgroundImage.x, y = backgroundImage.y, w = backgroundImage.w, h = backgroundImage.h, sizeType = backgroundImage.sizeType;
    if (isEmpty_1.default(backgroundImage)) {
        return { src: src, x: x, y: y, w: w, h: h, sizeType: sizeType };
    }
    if (src == null) {
        return { src: src, x: x, y: y, w: w, h: h, sizeType: sizeType };
    }
    // validImageSrc(src); make no sense to validate but not display errors.
    if (!exports.validImagePos({ x: x, y: y, canvasWidth: canvasWidth, canvasHeight: canvasHeight })) {
        console_1.default.warn("Invalid background image position, x: " + x + " y: " + y + ". Defaulting to x: 0, y: 0");
        x = 0;
        y = 0;
    }
    if (w == null &&
        h == null &&
        (sizeType == null || exports.invalidImageSizeType(sizeType))) {
        console_1.default.warn("Invalid background image sizeType, " + sizeType + ". Defaulting to contain");
        sizeType = 'contain';
    }
    else if ((sizeType == null || exports.invalidImageSizeType(sizeType)) &&
        ((w != null && h == null) ||
            (w == null && h != null) ||
            !exports.validImageWidthHeight(w, h))) {
        console_1.default.warn("Invalid background image width and height, w: " + w + " h: " + h + ". Defaulting to image original size");
        w = w || 0;
        h = h || 0;
    }
    return { src: src, x: x, y: y, w: w, h: h, sizeType: sizeType };
};
exports.validateBackgroundImage = validateBackgroundImage;


/***/ }),
/* 16 */
/***/ (function(module, exports) {

module.exports = require("lodash/noop");

/***/ }),
/* 17 */
/***/ (function(module, exports) {

module.exports = require("lodash/findLast");

/***/ }),
/* 18 */
/***/ (function(module, exports) {

module.exports = require("lodash/isNumber");

/***/ }),
/* 19 */
/***/ (function(module, exports) {

module.exports = require("lodash/reduce");

/***/ }),
/* 20 */
/***/ (function(module, exports) {

module.exports = require("lodash/pullAt");

/***/ }),
/* 21 */
/***/ (function(module, exports) {

module.exports = require("lodash/cloneDeep");

/***/ }),
/* 22 */
/***/ (function(module, exports) {

module.exports = require("lodash/sortBy");

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.getBlockItem = exports.computePortPosition = exports.getAllBlockItems = exports.findSelectedBlockItems = void 0;
var findSelectedBlockItems = function (_a) {
    var layoutStructure = _a.layoutStructure, selectedItems = _a.selectedItems;
    return layoutStructure.filter(function (_a) {
        var item = _a.item, type = _a.type;
        return selectedItems.findIndex(function (_a) {
            var id = _a.id;
            return item === id && (type === 'block' || !type);
        }) >= 0;
    });
};
exports.findSelectedBlockItems = findSelectedBlockItems;
var getAllBlockItems = function (_a) {
    var layoutStructure = _a.layoutStructure, _b = _a.layoutStructureState, layoutStructureState = _b === void 0 ? {} : _b;
    return layoutStructure
        .map(function (item) { var _a; return (_a = layoutStructureState[item.item]) !== null && _a !== void 0 ? _a : item; })
        .filter(function (_a) {
        var type = _a.type;
        return type === 'block' || !type;
    });
};
exports.getAllBlockItems = getAllBlockItems;
/**
 * compute port position for a given block item
 * @param {Object} blockItem
 * @param {String} port
 */
var computePortPosition = function (blockItem, port) {
    var blockPosition = blockItem.position;
    switch (port) {
        case 'n':
            return {
                x: Math.round(blockPosition.x + blockPosition.w / 2),
                y: blockPosition.y,
            };
        case 'w':
            return {
                x: blockPosition.x,
                y: Math.round(blockPosition.y + blockPosition.h / 2),
            };
        case 'e':
            return {
                x: blockPosition.x + blockPosition.w,
                y: Math.round(blockPosition.y + blockPosition.h / 2),
            };
        case 's':
        default:
            return {
                x: Math.round(blockPosition.x + blockPosition.w / 2),
                y: blockPosition.y + blockPosition.h,
            };
    }
};
exports.computePortPosition = computePortPosition;
var getBlockItem = function (_a) {
    var layoutStructure = _a.layoutStructure, id = _a.id;
    var blockItem = layoutStructure.find(function (_a) {
        var item = _a.item;
        return item === id;
    });
    if (!blockItem || blockItem.type === 'line') {
        throw Error(id + " refers to an invalid block item");
    }
    return blockItem;
};
exports.getBlockItem = getBlockItem;


/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.HANDLE_DIRECTIONS = exports.getHorizontalPosition = exports.getVerticalPosition = void 0;
/**
 * Compute absolute horizontal position (top/bottom) based on dir
 * @param {String} dir
 * @param {Number} offset
 * @returns {String}
 */
var getVerticalPosition = function (dir, offset) {
    if (dir[0] === 'n') {
        return "top: -" + offset + "px";
    }
    if (dir[0] === 's') {
        return "bottom: -" + offset + "px";
    }
    return "top: calc(50% - " + offset + "px)";
};
exports.getVerticalPosition = getVerticalPosition;
/**
 * Compute absolute vertical position (left/right) based on dir
 * @param {String} dir
 * @param {Number} offset
 * @returns {String}
 */
var getHorizontalPosition = function (dir, offset) {
    if (dir.slice(-1) === 'w') {
        return "left: -" + offset + "px";
    }
    if (dir.slice(-1) === 'e') {
        return "right: -" + offset + "px";
    }
    return "left: calc(50% - " + offset + "px)";
};
exports.getHorizontalPosition = getHorizontalPosition;
exports.HANDLE_DIRECTIONS = [
    'n',
    'ne',
    'e',
    'se',
    's',
    'sw',
    'w',
    'nw',
];


/***/ }),
/* 25 */
/***/ (function(module, exports) {

module.exports = require("lodash/isEmpty");

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.EDGE_PREVIEW_DELAY_MS = exports.VIZ_PREVIEW_DELAY_MS = exports.VIZ_DEFAULT_HEIGHT_PX = exports.ITEM_DROP_TARGET_PX = exports.PLACEHOLDER_SIZE_PX = exports.SNAP_RANGE_PX = exports.MIN_WIDTH_PX = exports.MIN_HEIGHT_PX = exports.GRID_SIZE_PX = exports.GRID_PADDING_PX = exports.EDGE_THICKNESS_PX = exports.CLONE_LAYOUT_ITEMS_MSG_PANEL_TOO_SMALL = void 0;
var i18n_1 = __webpack_require__(27);
exports.CLONE_LAYOUT_ITEMS_MSG_PANEL_TOO_SMALL = i18n_1._('This panel is too small to be split into duplicates. Stretch or move the panel to make it bigger first.');
exports.EDGE_THICKNESS_PX = 4;
exports.GRID_PADDING_PX = 1;
exports.GRID_SIZE_PX = 10;
exports.MIN_HEIGHT_PX = 64;
exports.MIN_WIDTH_PX = 64;
exports.SNAP_RANGE_PX = 8;
exports.PLACEHOLDER_SIZE_PX = 128;
exports.ITEM_DROP_TARGET_PX = 12;
exports.VIZ_DEFAULT_HEIGHT_PX = 400;
exports.VIZ_PREVIEW_DELAY_MS = 50;
exports.EDGE_PREVIEW_DELAY_MS = 500;


/***/ }),
/* 27 */
/***/ (function(module, exports) {

module.exports = require("@splunk/ui-utils/i18n");

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 *
 */
var BaseLayoutApi = /** @class */ (function () {
    function BaseLayoutApi() {
        var _this = this;
        this.emitTelemetry = function (payload) {
            if (!_this.telemetry) {
                return false;
            }
            _this.telemetry.emit(__assign({ source: 'layoutApi' }, payload));
            return true;
        };
    }
    return BaseLayoutApi;
}());
exports.default = BaseLayoutApi;


/***/ }),
/* 29 */,
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var react_1 = __importStar(__webpack_require__(0));
var styled_components_1 = __importDefault(__webpack_require__(1));
var mixins_1 = __webpack_require__(8);
var themes_1 = __webpack_require__(4);
var style_1 = __webpack_require__(31);
var colorUtils_1 = __webpack_require__(32);
var customThemeVariables_1 = __webpack_require__(7);
var imageUtils_1 = __webpack_require__(15);
var useBackgroundImage_1 = __webpack_require__(33);
var GRID_LINE_OPACITY = 0.1;
/**
 * logic for background image size css.
 * @param {BackgroundProps} props
 */
var toBackgroundImageSize = function (props) {
    var _a;
    var _b = imageUtils_1.getImageDimension((_a = props.bgImageSrc) !== null && _a !== void 0 ? _a : ''), width = _b.width, height = _b.height;
    if (props.bgImageWidth && props.bgImageHeight) {
        return style_1.toPx(props.bgImageWidth) + " " + style_1.toPx(props.bgImageHeight);
    }
    if (props.bgImageWidth || props.bgImageHeight) {
        return style_1.toPx(props.bgImageWidth || width) + " " + style_1.toPx(props.bgImageHeight || height);
    }
    if (props.bgImageSizeType) {
        return props.bgImageSizeType;
    }
    return 'contain';
};
/**
 * make sure to only include image related css when backgroundImageSrc is specified.
 * @param {BackgroundProps} props
 */
var toBackgroundImage = function (props) {
    if (props.bgImageSrc) {
        return "\n            background-repeat: no-repeat;\n            background-image: url(\"" + props.bgImageSrc + "\");\n            background-size: " + toBackgroundImageSize(props) + ";\n            background-position:\n                " + style_1.toPx(props.bgImagePositionX) + " " + style_1.toPx(props.bgImagePositionY) + ";\n        ";
    }
    return '';
};
var toScale = function (scale) {
    if (scale) {
        return "\n            transform: scale(" + scale + ");\n            transform-origin: 0 0;\n        ";
    }
    return '';
};
var CanvasContainer = styled_components_1.default.div(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n    ", ";\n    ", ";\n    overflow: ", ";\n    user-select: ", ";\n    position: relative;\n"], ["\n    ", ";\n    ", ";\n    overflow: ", ";\n    user-select: ", ";\n    position: relative;\n"])), mixins_1.reset('block'), function (prop) { return style_1.toDimension({ width: prop.width, height: prop.height }); }, function (prop) { return (prop.showOverflowContent ? 'visible' : 'hidden'); }, function (prop) { return (prop.userSelect ? 'text' : 'none'); });
/**
 * A layer that renders canvas with background color/image
 */
var Background = styled_components_1.default.div(templateObject_2 || (templateObject_2 = __makeTemplateObject(["\n    ", ";\n    ", ";\n    position: relative;\n    background: ", ";\n    ", ";\n    ", ";\n"], ["\n    ", ";\n    ", ";\n    position: relative;\n    background: ",
    ";\n    ", ";\n    ", ";\n"])), mixins_1.reset('inline-block'), function (prop) { return style_1.toDimension({ width: prop.width, height: prop.height }); }, function (prop) {
    return prop.bgColor ||
        // NOTE: this needs to match packages/dashboard-editors/src/layouts/AbsoluteLayoutEditor.jsx
        customThemeVariables_1.customThemeVariables.dashboardBackgroundColor;
}, function (prop) { return toBackgroundImage(prop); }, function (prop) { return toScale(prop.scale); });
/**
 * A layer that renders border
 */
var Border = styled_components_1.default.div(templateObject_3 || (templateObject_3 = __makeTemplateObject(["\n    position: absolute;\n    box-sizing: border-box;\n    border: 2px dashed\n        ", ";\n    left: 0px;\n    top: 0px;\n    right: 0px;\n    bottom: 0px;\n    ", ";\n"], ["\n    position: absolute;\n    box-sizing: border-box;\n    border: 2px dashed\n        ",
    ";\n    left: 0px;\n    top: 0px;\n    right: 0px;\n    bottom: 0px;\n    ", ";\n"])), themes_1.pick({
    enterprise: {
        light: themes_1.variables.gray80,
        dark: themes_1.variables.gray30,
    },
    prisma: themes_1.variables.interactiveColorBorder,
}), function (prop) { return style_1.toDimension({ width: prop.width, height: prop.height }); });
var getGridLineColor = function (props) {
    return props.gridLineColor ||
        themes_1.pick({
            light: '#D8D8D8',
            dark: '#9B9B9B',
        });
};
/**
 * A layer that renders grid
 */
var GridLines = styled_components_1.default.div(templateObject_4 || (templateObject_4 = __makeTemplateObject(["\n    position: absolute;\n    box-sizing: border-box;\n    left: 0px;\n    top: 0px;\n    right: 0px;\n    bottom: 0px;\n    opacity: ", ";\n    ", ";\n    background-size: ", "px\n        ", "px;\n    background-image: repeating-linear-gradient(\n            0deg,\n            ", ",\n            ", " ", ",\n            transparent ", "px,\n            transparent ", "px\n        ),\n        repeating-linear-gradient(\n            -90deg,\n            ", ",\n            ", " ", ",\n            transparent ", "px,\n            transparent ", "px\n        );\n"], ["\n    position: absolute;\n    box-sizing: border-box;\n    left: 0px;\n    top: 0px;\n    right: 0px;\n    bottom: 0px;\n    opacity: ", ";\n    ", ";\n    background-size: ", "px\n        ", "px;\n    background-image: repeating-linear-gradient(\n            0deg,\n            ", ",\n            ", " ", ",\n            transparent ", "px,\n            transparent ", "px\n        ),\n        repeating-linear-gradient(\n            -90deg,\n            ", ",\n            ", " ", ",\n            transparent ", "px,\n            transparent ", "px\n        );\n"])), function (prop) { return prop.gridLineOpacity || GRID_LINE_OPACITY; }, function (prop) { return style_1.toDimension({ width: prop.width, height: prop.height }); }, function (prop) { return prop.gridWidth + prop.gridLineWidth; }, function (prop) { return prop.gridHeight + prop.gridLineWidth; }, getGridLineColor, getGridLineColor, function (prop) { return style_1.toPx(prop.gridLineWidth); }, function (prop) { return prop.gridLineWidth; }, function (prop) { return prop.gridHeight + prop.gridLineWidth; }, getGridLineColor, getGridLineColor, function (prop) { return style_1.toPx(prop.gridLineWidth); }, function (prop) { return prop.gridLineWidth; }, function (prop) { return prop.gridWidth + prop.gridLineWidth; });
/**
 * Canvas is a component that render background for a layout.
 * All visualizations will be displayed on top of a canvas
 */
var Canvas = function (_a, canvasRef) {
    var width = _a.width, height = _a.height, scale = _a.scale, _b = _a.backgroundColor, unsanitizedBgColor = _b === void 0 ? '' : _b, backgroundImageSrc = _a.backgroundImageSrc, backgroundImageSizeType = _a.backgroundImageSizeType, backgroundImageWidth = _a.backgroundImageWidth, backgroundImageHeight = _a.backgroundImageHeight, backgroundImagePositionX = _a.backgroundImagePositionX, backgroundImagePositionY = _a.backgroundImagePositionY, gridLineOpacity = _a.gridLineOpacity, children = _a.children, _c = _a.showOverflowContent, showOverflowContent = _c === void 0 ? false : _c, _d = _a.userSelect, userSelect = _d === void 0 ? false : _d, _e = _a.showGrid, showGrid = _e === void 0 ? false : _e, _f = _a.gridPadding, gridPadding = _f === void 0 ? 0 : _f, _g = _a.gridLineWidth, gridLineWidth = _g === void 0 ? 1 : _g, gridLineColor = _a.gridLineColor, _h = _a.gridWidth, gridWidth = _h === void 0 ? 9 : _h, _j = _a.gridHeight, gridHeight = _j === void 0 ? 9 : _j, _k = _a.showBorder, showBorder = _k === void 0 ? false : _k, _l = _a.cssScaling, cssScaling = _l === void 0 ? true : _l, others = __rest(_a, ["width", "height", "scale", "backgroundColor", "backgroundImageSrc", "backgroundImageSizeType", "backgroundImageWidth", "backgroundImageHeight", "backgroundImagePositionX", "backgroundImagePositionY", "gridLineOpacity", "children", "showOverflowContent", "userSelect", "showGrid", "gridPadding", "gridLineWidth", "gridLineColor", "gridWidth", "gridHeight", "showBorder", "cssScaling"]);
    var imageSrc = useBackgroundImage_1.useBackgroundImage(backgroundImageSrc);
    var containerWidth = scale != null ? width * scale : width;
    var containerHeight = scale != null && cssScaling ? height * scale : height;
    var backgroundColor = colorUtils_1.sanitizeColor(unsanitizedBgColor);
    return (react_1.default.createElement(CanvasContainer, __assign({ "data-test": "canvas-container", "data-width": containerWidth, "data-height": containerHeight, width: cssScaling ? containerWidth : width, height: containerHeight, showOverflowContent: showOverflowContent, userSelect: userSelect, ref: canvasRef }, others),
        react_1.default.createElement(Background, { "data-test": "canvas", "data-width": width, "data-height": height, "data-scale": scale, width: cssScaling ? width : containerWidth, height: height, scale: cssScaling ? scale : undefined, bgColor: backgroundColor, bgImageSrc: imageSrc, bgImageSizeType: backgroundImageSizeType, bgImageWidth: backgroundImageWidth, bgImageHeight: backgroundImageHeight, bgImagePositionX: backgroundImagePositionX, bgImagePositionY: backgroundImagePositionY },
            showBorder && react_1.default.createElement(Border, { width: width, height: height }),
            showGrid && (react_1.default.createElement(GridLines, { width: width, height: height, gridLineOpacity: gridLineOpacity, gridPadding: gridPadding, gridLineWidth: gridLineWidth, gridLineColor: gridLineColor, gridWidth: gridWidth, gridHeight: gridHeight })),
            children)));
};
exports.default = react_1.forwardRef(Canvas);
var templateObject_1, templateObject_2, templateObject_3, templateObject_4;


/***/ }),
/* 31 */
/***/ (function(module, exports) {

module.exports = require("@splunk/dashboard-utils/style");

/***/ }),
/* 32 */
/***/ (function(module, exports) {

module.exports = require("@splunk/dashboard-ui/utils/colorUtils");

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.useBackgroundImage = void 0;
var react_1 = __webpack_require__(0);
var dashboard_context_1 = __importDefault(__webpack_require__(14));
var console_1 = __importDefault(__webpack_require__(5));
var useBackgroundImage = function (backgroundImageSrc) {
    var _a = __read(react_1.useState(''), 2), imageSrc = _a[0], setImageSrc = _a[1];
    var imageRegistry = react_1.useContext(dashboard_context_1.default).imageRegistry;
    /**
     * Check whether backgroundImage src is a remote image url or stored in the image registry. Fetch if its the latter
     * @param string backgroundImageSrc
     */
    var fetchBackgroundImage = function (registry, bgImageSrc) { return __awaiter(void 0, void 0, void 0, function () {
        var imageObject, error_1;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    _a.trys.push([0, 6, , 7]);
                    if (!registry) return [3 /*break*/, 4];
                    if (!registry.isResourceURL(bgImageSrc)) return [3 /*break*/, 2];
                    return [4 /*yield*/, registry.getByURL(bgImageSrc)];
                case 1:
                    imageObject = _a.sent();
                    setImageSrc(imageObject.dataURI);
                    return [3 /*break*/, 3];
                case 2:
                    setImageSrc(bgImageSrc);
                    _a.label = 3;
                case 3: return [3 /*break*/, 5];
                case 4:
                    setImageSrc(bgImageSrc);
                    _a.label = 5;
                case 5: return [3 /*break*/, 7];
                case 6:
                    error_1 = _a.sent();
                    console_1.default.error(error_1); // TODO Refactor error display
                    return [3 /*break*/, 7];
                case 7: return [2 /*return*/];
            }
        });
    }); };
    react_1.useEffect(function () {
        if (backgroundImageSrc) {
            fetchBackgroundImage(imageRegistry, backgroundImageSrc);
        }
    }, [imageRegistry, backgroundImageSrc]);
    return imageSrc;
};
exports.useBackgroundImage = useBackgroundImage;


/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var styled_components_1 = __importDefault(__webpack_require__(1));
var ResponsiveBox = styled_components_1.default.div.attrs(function (_a) {
    var itemId = _a.itemId, x = _a.x, y = _a.y, w = _a.w, h = _a.h, dataTest = _a["data-test"];
    return ({
        'data-test': dataTest !== null && dataTest !== void 0 ? dataTest : 'responsive-box',
        'data-id': itemId,
        'data-test-viz-item-position': x + "," + y + "," + w + "," + h,
        style: {
            width: w + "px",
            height: h + "px",
            top: y + "px",
            left: x + "px",
        },
    });
})(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n    display: block;\n    position: absolute;\n    background: transparent;\n    pointer-events: none;\n    box-sizing: border-box;\n    visibility: ", ";\n    opacity: ", ";\n"], ["\n    display: block;\n    position: absolute;\n    background: transparent;\n    pointer-events: none;\n    box-sizing: border-box;\n    visibility: ",
    ";\n    opacity: ", ";\n"])), function (props) {
    return props.appearance === 'hidden' ? 'hidden' : 'visible';
}, function (props) { return (props.appearance === 'highlighted' ? 1 : 0.5); });
ResponsiveBox.defaultProps = {
    appearance: 'highlighted',
};
exports.default = ResponsiveBox;
var templateObject_1;


/***/ }),
/* 35 */
/***/ (function(module, exports) {

module.exports = require("@splunk/dashboard-ui/hooks/useEventCallback");

/***/ }),
/* 36 */
/***/ (function(module, exports) {

module.exports = require("lodash");

/***/ }),
/* 37 */
/***/ (function(module, exports) {

module.exports = require("@splunk/dashboard-telemetry");

/***/ }),
/* 38 */
/***/ (function(module, exports) {

module.exports = require("@splunk/dashboard-ui/hooks/usePrevious");

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.normalizeAddLayoutItemArgs = void 0;
var deprecated_1 = __importDefault(__webpack_require__(40));
var isPlainObject_1 = __importDefault(__webpack_require__(41));
var normalizeAddLayoutItemArgs = function (args) {
    // make it backward compatible
    if (args.length === 1 && isPlainObject_1.default(args[0])) {
        return args[0];
    }
    deprecated_1.default('Calling addLayoutItem with multiple parameters is deprecated. Please use the object form instead.');
    var _a = __read(args, 3), itemId = _a[0], vizContract = _a[1], type = _a[2];
    return {
        itemId: itemId,
        vizContract: vizContract,
        type: type,
    };
};
exports.normalizeAddLayoutItemArgs = normalizeAddLayoutItemArgs;


/***/ }),
/* 40 */
/***/ (function(module, exports) {

module.exports = require("@splunk/dashboard-utils/deprecated");

/***/ }),
/* 41 */
/***/ (function(module, exports) {

module.exports = require("lodash/isPlainObject");

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var styled_components_1 = __importDefault(__webpack_require__(1));
/**
 * A layer that does not block events
 */
var Layer = styled_components_1.default.div(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n    position: absolute;\n    top: 0px;\n    left: 0px;\n    right: 0px;\n    bottom: 0px;\n    pointer-events: none;\n"], ["\n    position: absolute;\n    top: 0px;\n    left: 0px;\n    right: 0px;\n    bottom: 0px;\n    pointer-events: none;\n"])));
exports.default = Layer;
var templateObject_1;


/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var react_1 = __importStar(__webpack_require__(0));
var ResponsiveBox_1 = __importDefault(__webpack_require__(34));
var ErrorMessageOverlay_1 = __webpack_require__(44);
/**
 * layout item that renders block element
 */
var ResponsiveBlockItem = function (props) {
    var x = props.x, y = props.y, w = props.w, h = props.h, canvasHeight = props.canvasHeight, itemId = props.itemId, errorMessages = props.errorMessages, onItemSelected = props.onItemSelected, renderLayoutItem = props.renderLayoutItem, _a = props.appearance, appearance = _a === void 0 ? 'highlighted' : _a;
    var layoutItem = react_1.useMemo(function () {
        return renderLayoutItem(itemId, {
            width: w,
            height: h,
            y: y,
            canvasHeight: canvasHeight,
        }, 'block', onItemSelected);
    }, [renderLayoutItem, itemId, w, h, y, canvasHeight, onItemSelected]);
    return (react_1.default.createElement(ResponsiveBox_1.default, { "data-test": "absolute-item", itemId: itemId, appearance: appearance, x: x, y: y, w: w, h: h },
        layoutItem,
        react_1.default.createElement(ErrorMessageOverlay_1.ErrorMessageOverlay, { messages: errorMessages })));
};
exports.default = ResponsiveBlockItem;


/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ErrorMessageOverlay = exports.MessageContainer = void 0;
var react_1 = __importDefault(__webpack_require__(0));
var styled_components_1 = __importDefault(__webpack_require__(1));
var prop_types_1 = __importDefault(__webpack_require__(3));
var themes_1 = __webpack_require__(4);
var ErrorOverlay = styled_components_1.default.div(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n    position: absolute;\n    box-sizing: border-box;\n    top: 0;\n    left: 0;\n    height: 100%;\n    width: 100%;\n    pointer-events: none;\n    background-color: ", ";\n    color: white;\n    overflow: hidden;\n    padding: 8px;\n    z-index: 2;\n"], ["\n    position: absolute;\n    box-sizing: border-box;\n    top: 0;\n    left: 0;\n    height: 100%;\n    width: 100%;\n    pointer-events: none;\n    background-color: ",
    ";\n    color: white;\n    overflow: hidden;\n    padding: 8px;\n    z-index: 2;\n"])), themes_1.pick({
    light: '#a81916cc',
    dark: '#a81916b3',
}));
exports.MessageContainer = styled_components_1.default.div(templateObject_2 || (templateObject_2 = __makeTemplateObject(["\n    padding-top: 8px;\n"], ["\n    padding-top: 8px;\n"])));
var OverlayTitle = styled_components_1.default.div(templateObject_3 || (templateObject_3 = __makeTemplateObject(["\n    font-weight: bold;\n"], ["\n    font-weight: bold;\n"])));
var ErrorMessageOverlay = function (_a) {
    var messages = _a.messages;
    if (!messages || messages.length === 0) {
        return null;
    }
    return (react_1.default.createElement(ErrorOverlay, { "data-test": "error-overlay" },
        react_1.default.createElement(OverlayTitle, null, "Layout Errors:"),
        messages.map(function (message) { return (react_1.default.createElement(exports.MessageContainer, { "data-test": "error-overlay-message", key: message }, message)); })));
};
exports.ErrorMessageOverlay = ErrorMessageOverlay;
exports.ErrorMessageOverlay.propTypes = {
    messages: prop_types_1.default.arrayOf(prop_types_1.default.string),
};
var templateObject_1, templateObject_2, templateObject_3;


/***/ }),
/* 45 */,
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var react_1 = __importStar(__webpack_require__(0));
var outlineUtils_1 = __webpack_require__(24);
var ResponsiveBox_1 = __importDefault(__webpack_require__(34));
var layoutUtils_1 = __webpack_require__(2);
var Port_1 = __webpack_require__(47);
var ResizeHandle_1 = __webpack_require__(49);
var noop = function () { return undefined; };
var ResponsiveBlockOutline = function (_a) {
    var itemId = _a.itemId, _b = _a.scale, scale = _b === void 0 ? 1 : _b, _c = _a.connectable, connectable = _c === void 0 ? false : _c, _d = _a.resizable, resizable = _d === void 0 ? false : _d, _e = _a.onResize, onResize = _e === void 0 ? noop : _e, _f = _a.onResized, onResized = _f === void 0 ? noop : _f, _g = _a.onLineConnect, onLineConnect = _g === void 0 ? noop : _g, _h = _a.onLineDisconnect, onLineDisconnect = _h === void 0 ? noop : _h, handleDirections = _a.handleDirections, x = _a.x, y = _a.y, w = _a.w, h = _a.h;
    var _j = __read(react_1.useState(null), 2), startPosition = _j[0], setStartPosition = _j[1];
    var _k = __read(react_1.useState(false), 2), resizing = _k[0], setResizing = _k[1];
    var _l = __read(react_1.useState(null), 2), resizeDir = _l[0], setResizeDir = _l[1];
    // Setup start of resize operation
    var handleResizeMouseDown = react_1.useCallback(function (e, dir) {
        e.preventDefault();
        e.stopPropagation();
        setStartPosition(layoutUtils_1.getClientPosition(e, scale));
        setResizing(true);
        setResizeDir(dir);
    }, [scale]);
    // Update size when resizing
    var handleMouseMove = react_1.useCallback(function (e) {
        if (startPosition && resizing && resizeDir) {
            e.preventDefault();
            var currentPosition = layoutUtils_1.getClientPosition(e, scale);
            var offset = layoutUtils_1.getOffset(currentPosition, startPosition);
            onResize(e, itemId, offset, resizeDir);
        }
    }, [scale, startPosition, resizing, onResize, itemId, resizeDir]);
    // Update final position at end of resize
    var handleMouseUp = react_1.useCallback(function (e) {
        if (startPosition && resizing && resizeDir) {
            e.preventDefault();
            var currentPosition = layoutUtils_1.getClientPosition(e, scale);
            var offset = layoutUtils_1.getOffset(currentPosition, startPosition);
            setStartPosition(null);
            setResizing(false);
            setResizeDir(null);
            onResized(e, itemId, offset, resizeDir);
        }
    }, [itemId, startPosition, resizing, resizeDir, scale, onResized]);
    // Update line when connecting to port
    var handlePortEnter = react_1.useCallback(function (port) { return function (e) {
        e.preventDefault();
        onLineConnect(itemId, port);
    }; }, [itemId, onLineConnect]);
    // Update line when disconnecting from port
    var handlePortLeave = react_1.useCallback(function (port) { return function (e) {
        e.preventDefault();
        onLineDisconnect(itemId, port);
    }; }, [itemId, onLineDisconnect]);
    react_1.useEffect(function () {
        if (resizable) {
            document.addEventListener('mousemove', handleMouseMove);
            document.addEventListener('mouseup', handleMouseUp);
        }
        return function () {
            document.removeEventListener('mousemove', handleMouseMove);
            document.removeEventListener('mouseup', handleMouseUp);
        };
    }, [resizable, handleMouseMove, handleMouseUp]);
    // Memoized resize handles
    var ResizeHandles = react_1.useMemo(function () {
        if (!resizable) {
            return null;
        }
        var directions = Array.isArray(handleDirections)
            ? handleDirections // casting as readonly so typescript doesn't think this is mutable
            : outlineUtils_1.HANDLE_DIRECTIONS;
        return directions.map(function (dir) { return (react_1.default.createElement(ResizeHandle_1.ResizeHandle, { key: "handle-" + dir, onMouseDown: handleResizeMouseDown, direction: dir })); });
    }, [handleDirections, resizable, handleResizeMouseDown]);
    // Memoized connection ports
    var Ports = react_1.useMemo(function () {
        if (!connectable) {
            return null;
        }
        return Port_1.PORT_DIRECTIONS.map(function (port) { return (react_1.default.createElement(Port_1.Port, { key: "port-" + port, port: port, onMouseEnter: handlePortEnter(port), onMouseLeave: handlePortLeave(port) })); });
    }, [connectable, handlePortEnter, handlePortLeave]);
    return (react_1.default.createElement(ResponsiveBox_1.default, { itemId: itemId, x: x, y: y, w: w, h: h },
        ResizeHandles,
        Ports));
};
exports.default = ResponsiveBlockOutline;


/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Port = exports.PORT_DIRECTIONS = void 0;
var react_1 = __importDefault(__webpack_require__(0));
var styled_components_1 = __importDefault(__webpack_require__(1));
var Plus_1 = __importDefault(__webpack_require__(48));
var themes_1 = __webpack_require__(4);
var outlineUtils_1 = __webpack_require__(24);
var portOffset = 8;
exports.PORT_DIRECTIONS = ['n', 'e', 's', 'w'];
var PortContainer = styled_components_1.default.div.attrs(function (_a) {
    var port = _a.port;
    return ({
        'data-test': 'port',
        'data-test-port': port,
    });
})(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n    text-align: center;\n    width: 16px;\n    height: 16px;\n    line-height: 16px;\n    box-sizing: border-box;\n    border-radius: 50%;\n    position: absolute;\n    color: ", ";\n    ", ";\n    ", ";\n    z-index: 999;\n    pointer-events: auto;\n    user-select: none;\n    &:hover {\n        background-color: ", ";\n    }\n"], ["\n    text-align: center;\n    width: 16px;\n    height: 16px;\n    line-height: 16px;\n    box-sizing: border-box;\n    border-radius: 50%;\n    position: absolute;\n    color: ",
    ";\n    ", ";\n    ", ";\n    z-index: 999;\n    pointer-events: auto;\n    user-select: none;\n    &:hover {\n        background-color: ",
    ";\n    }\n"])), themes_1.pick({
    enterprise: themes_1.variables.accentColorL10,
    prisma: themes_1.variables.interactiveColorPrimary,
}), function (_a) {
    var port = _a.port;
    return outlineUtils_1.getVerticalPosition(port, portOffset);
}, function (_a) {
    var port = _a.port;
    return outlineUtils_1.getHorizontalPosition(port, portOffset);
}, themes_1.pick({
    enterprise: themes_1.variables.accentColorL10,
    prisma: themes_1.variables.interactiveColorPrimary,
}));
var Port = function (_a) {
    var port = _a.port, onMouseEnter = _a.onMouseEnter, onMouseLeave = _a.onMouseLeave;
    return (react_1.default.createElement(PortContainer, { port: port, onMouseEnter: onMouseEnter, onMouseLeave: onMouseLeave },
        react_1.default.createElement(Plus_1.default, null)));
};
exports.Port = Port;
var templateObject_1;


/***/ }),
/* 48 */
/***/ (function(module, exports) {

module.exports = require("@splunk/react-icons/Plus");

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ResizeHandle = void 0;
var react_1 = __importStar(__webpack_require__(0));
var styled_components_1 = __importDefault(__webpack_require__(1));
var themes_1 = __webpack_require__(4);
var outlineUtils_1 = __webpack_require__(24);
var resizeHandleOffset = 7;
/**
 * compute cursor base on resize dir
 * @param {String} dir
 */
var computeCursor = function (dir) {
    switch (dir) {
        case 'n':
        case 's':
            return 'ns-resize';
        case 'e':
        case 'w':
            return 'ew-resize';
        case 'ne':
        case 'sw':
            return 'nesw-resize';
        case 'se':
        case 'nw':
        default:
            return 'nwse-resize';
    }
};
var Handle = styled_components_1.default.a.attrs(function (_a) {
    var direction = _a.direction;
    return ({
        'data-test': 'handle',
        'data-test-direction': direction,
    });
})(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n    width: 10px;\n    height: 10px;\n    background-color: ", ";\n    border-radius: 20%;\n    position: absolute;\n    ", ";\n    ", ";\n    cursor: ", ";\n    z-index: 999;\n    pointer-events: auto;\n    user-select: none;\n"], ["\n    width: 10px;\n    height: 10px;\n    background-color: ",
    ";\n    border-radius: 20%;\n    position: absolute;\n    ", ";\n    ", ";\n    cursor: ", ";\n    z-index: 999;\n    pointer-events: auto;\n    user-select: none;\n"])), themes_1.pick({
    enterprise: themes_1.variables.accentColorL10,
    prisma: themes_1.variables.interactiveColorPrimary,
}), function (_a) {
    var direction = _a.direction;
    return outlineUtils_1.getVerticalPosition(direction, resizeHandleOffset);
}, function (_a) {
    var direction = _a.direction;
    return outlineUtils_1.getHorizontalPosition(direction, resizeHandleOffset);
}, function (_a) {
    var direction = _a.direction;
    return computeCursor(direction);
});
var ResizeHandle = function (_a) {
    var onMouseDown = _a.onMouseDown, direction = _a.direction;
    var handleMouseDown = react_1.useCallback(function (e) {
        onMouseDown(e, direction);
    }, [onMouseDown, direction]);
    return react_1.default.createElement(Handle, { direction: direction, onMouseDown: handleMouseDown });
};
exports.ResizeHandle = ResizeHandle;
var templateObject_1;


/***/ }),
/* 50 */,
/* 51 */,
/* 52 */,
/* 53 */
/***/ (function(module, exports) {

module.exports = require("lodash/isEqual");

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var commonLayoutOptionsSchema_1 = __importDefault(__webpack_require__(13));
exports.default = __assign(__assign({}, commonLayoutOptionsSchema_1.default), { gutterSize: {
        type: 'number',
        default: 8,
        minimum: 8,
        maximum: 16,
        description: 'A number that represents the size of the gutter between visualizations in pixels. The minimum value is 8 and maximum value is 16.',
    } });


/***/ }),
/* 55 */,
/* 56 */,
/* 57 */,
/* 58 */
/***/ (function(module, exports) {

module.exports = require("@splunk/dashboard-ui/hooks/useMouseMoveHandler");

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.updateRemovedVizNeighbors = exports.getItemsWithUpdatedPositions = exports.findVerticalNeighbors = exports.findHorizontalNeighbors = exports.isBottomNeighbor = exports.isTopNeighbor = exports.isRightNeighbor = exports.isLeftNeighbor = void 0;
var isEqual_1 = __importDefault(__webpack_require__(53));
/**
 * @param {Object} itemPosition
 * @param {Object} vizPosition
 * @returns {boolean} whether viz is contained with the y bounds of item
 */
var isInVerticalRange = function (itemPosition, vizPosition) {
    return (vizPosition.y >= itemPosition.y &&
        vizPosition.y + vizPosition.h <= itemPosition.y + itemPosition.h);
};
/**
 * @param {Object} itemPosition
 * @param {Object} vizPosition
 * @returns {boolean} whether viz is contained with the x bounds of item
 */
var isInHorizontalRange = function (itemPosition, vizPosition) {
    return (vizPosition.x >= itemPosition.x &&
        vizPosition.x + vizPosition.w <= itemPosition.x + itemPosition.w);
};
/**
 * @param {Object} item
 * @param {Object} viz
 * @returns {boolean} whether viz is left neighbor of item
 */
var isLeftNeighbor = function (item, viz) {
    var isLeftOf = viz.position.x + viz.position.w === item.position.x;
    return isLeftOf && isInVerticalRange(item.position, viz.position);
};
exports.isLeftNeighbor = isLeftNeighbor;
/**
 * @param {Object} item
 * @param {Object} viz
 * @returns {boolean} whether viz is right neighbor of item
 */
var isRightNeighbor = function (item, viz) {
    var isRightOf = viz.position.x === item.position.x + item.position.w;
    return isRightOf && isInVerticalRange(item.position, viz.position);
};
exports.isRightNeighbor = isRightNeighbor;
/**
 * @param {Object} item
 * @param {Object} viz
 * @returns {boolean} whether viz is top neighbor of item
 */
var isTopNeighbor = function (item, viz) {
    var isAbove = viz.position.y + viz.position.h === item.position.y;
    return isAbove && isInHorizontalRange(item.position, viz.position);
};
exports.isTopNeighbor = isTopNeighbor;
/**
 * @param {Object} item
 * @param {Object} viz
 * @returns {boolean} whether viz is bottom neighbor of item
 */
var isBottomNeighbor = function (item, viz) {
    var isBelow = viz.position.y === item.position.y + item.position.h;
    return isBelow && isInHorizontalRange(item.position, viz.position);
};
exports.isBottomNeighbor = isBottomNeighbor;
/**
 * Finds left and right neighbors of the given item and list of visualizations.
 * Note: This is *not* a generic function to find all neighbors. It is customized for remove
 * items and only returns neighbors that are contained with the y bounds of item.
 * @param {Object} item
 * @param {object[]} visualizations
 * @returns {{leftNeighbors: object[], rightNeighbors: object[]}}} list of horizontal neighbors that are within the y bounds of item
 */
var findHorizontalNeighbors = function (_a) {
    var item = _a.item, visualizations = _a.visualizations;
    var leftHeight = 0;
    var rightHeight = 0;
    var leftNeighbors = [];
    var rightNeighbors = [];
    visualizations.forEach(function (viz) {
        if (isEqual_1.default(item, viz)) {
            return;
        }
        if (exports.isLeftNeighbor(item, viz)) {
            leftHeight += viz.position.h;
            leftNeighbors.push(viz);
        }
        if (exports.isRightNeighbor(item, viz)) {
            rightHeight += viz.position.h;
            rightNeighbors.push(viz);
        }
    });
    if (leftHeight !== item.position.h) {
        leftNeighbors = [];
    }
    if (rightHeight !== item.position.h) {
        rightNeighbors = [];
    }
    return { leftNeighbors: leftNeighbors, rightNeighbors: rightNeighbors };
};
exports.findHorizontalNeighbors = findHorizontalNeighbors;
/**
 * Finds top and bottom neighbors of the given item and list of visualizations.
 * Note: This is *not* a generic function to find all neighbors. It is customized for remove
 * items and only returns neighbors that are contained with the x bounds of item.
 * @param {Object} item
 * @param {object[]} visualizations
 * @returns {{topNeighbors: object[], bottomNeighbors: object[]}} list of vertical neighbors that are within the y bounds of item
 */
var findVerticalNeighbors = function (_a) {
    var item = _a.item, visualizations = _a.visualizations;
    var topWidth = 0;
    var bottomWidth = 0;
    var topNeighbors = [];
    var bottomNeighbors = [];
    visualizations.forEach(function (viz) {
        if (isEqual_1.default(item, viz)) {
            return;
        }
        if (exports.isTopNeighbor(item, viz)) {
            topWidth += viz.position.w;
            topNeighbors.push(viz);
        }
        if (exports.isBottomNeighbor(item, viz)) {
            bottomWidth += viz.position.w;
            bottomNeighbors.push(viz);
        }
    });
    if (topWidth !== item.position.w) {
        topNeighbors = [];
    }
    if (bottomWidth !== item.position.w) {
        bottomNeighbors = [];
    }
    return { topNeighbors: topNeighbors, bottomNeighbors: bottomNeighbors };
};
exports.findVerticalNeighbors = findVerticalNeighbors;
/**
 * Returns the updated positions of visualizations when an item that spans an entire row is deleted.
 * Essentially all visualizations are shifted up.
 * @param {Object} obj
 * @param {Object} obj.itemToRemove
 * @param {object[]} obj.visualizations
 * @returns {object[]} visualizations with updated positions
 */
var getItemsWithUpdatedPositions = function (_a) {
    var itemToRemove = _a.itemToRemove, visualizations = _a.visualizations;
    var updatedVisualizations = [];
    visualizations.forEach(function (viz) {
        // Item is below removed row
        if (itemToRemove.position.y < viz.position.y) {
            updatedVisualizations.push(__assign(__assign({}, viz), { position: __assign(__assign({}, viz.position), { y: viz.position.y - itemToRemove.position.h }) }));
        }
    });
    return updatedVisualizations;
};
exports.getItemsWithUpdatedPositions = getItemsWithUpdatedPositions;
/**
 * Update the items around the item that is removed to fill the space
 * @param {Object} params
 * @param {Object} params.itemToRemove - The item that is being removed
 * @param {object[]} params.items - All the items on the canvas
 * @param {Number} params.width - The width of the entire canvas
 * @returns {object[]} - Array of updated items, filling the space of itemToRemove
 */
var updateRemovedVizNeighbors = function (_a) {
    var itemToRemove = _a.itemToRemove, items = _a.items, width = _a.width;
    var updatedItems = [];
    // viz spans entire row, delete it & move rows below in its place
    if (itemToRemove.position.w === width) {
        return exports.getItemsWithUpdatedPositions({
            itemToRemove: itemToRemove,
            visualizations: items,
        });
    }
    var _b = exports.findHorizontalNeighbors({
        item: itemToRemove,
        visualizations: items,
    }), leftNeighbors = _b.leftNeighbors, rightNeighbors = _b.rightNeighbors;
    if (leftNeighbors.length || rightNeighbors.length) {
        if (leftNeighbors.length && rightNeighbors.length) {
            var leftWidthToAdd_1 = Math.floor(itemToRemove.position.w / 2);
            // if itemToRemove.position.w is odd, we give 1 px extra to the right neighbor
            var rightWidthToAdd_1 = Math.ceil(itemToRemove.position.w / 2);
            leftNeighbors.forEach(function (viz) {
                updatedItems.push(__assign(__assign({}, viz), { position: __assign(__assign({}, viz.position), { w: viz.position.w + leftWidthToAdd_1 }) }));
            });
            rightNeighbors.forEach(function (viz) {
                updatedItems.push(__assign(__assign({}, viz), { position: __assign(__assign({}, viz.position), { x: viz.position.x - rightWidthToAdd_1, w: viz.position.w + rightWidthToAdd_1 }) }));
            });
        }
        else if (leftNeighbors.length) {
            leftNeighbors.forEach(function (viz) {
                updatedItems.push(__assign(__assign({}, viz), { position: __assign(__assign({}, viz.position), { w: viz.position.w + itemToRemove.position.w }) }));
            });
        }
        else {
            rightNeighbors.forEach(function (viz) {
                updatedItems.push(__assign(__assign({}, viz), { position: __assign(__assign({}, viz.position), { x: viz.position.x - itemToRemove.position.w, w: viz.position.w + itemToRemove.position.w }) }));
            });
        }
    }
    else {
        var _c = exports.findVerticalNeighbors({
            item: itemToRemove,
            visualizations: items,
        }), topNeighbors = _c.topNeighbors, bottomNeighbors = _c.bottomNeighbors;
        if (topNeighbors.length || bottomNeighbors.length) {
            if (topNeighbors.length && bottomNeighbors.length) {
                var topHeightToAdd_1 = Math.floor(itemToRemove.position.h / 2);
                // if itemToRemove.position.h is odd, we give 1 px extra to the bottom neighbor
                var bottomHeightToAdd_1 = Math.ceil(itemToRemove.position.h / 2);
                topNeighbors.forEach(function (viz) {
                    updatedItems.push(__assign(__assign({}, viz), { position: __assign(__assign({}, viz.position), { h: viz.position.h + topHeightToAdd_1 }) }));
                });
                bottomNeighbors.forEach(function (viz) {
                    updatedItems.push(__assign(__assign({}, viz), { position: __assign(__assign({}, viz.position), { y: viz.position.y - bottomHeightToAdd_1, h: viz.position.h + bottomHeightToAdd_1 }) }));
                });
            }
            else if (topNeighbors.length) {
                topNeighbors.forEach(function (viz) {
                    updatedItems.push(__assign(__assign({}, viz), { position: __assign(__assign({}, viz.position), { h: viz.position.h + itemToRemove.position.h }) }));
                });
            }
            else {
                bottomNeighbors.forEach(function (viz) {
                    updatedItems.push(__assign(__assign({}, viz), { position: __assign(__assign({}, viz.position), { y: viz.position.y - itemToRemove.position.h, h: viz.position.h + itemToRemove.position.h }) }));
                });
            }
        }
    }
    return updatedItems;
};
exports.updateRemovedVizNeighbors = updateRemovedVizNeighbors;


/***/ }),
/* 60 */,
/* 61 */,
/* 62 */,
/* 63 */,
/* 64 */,
/* 65 */,
/* 66 */,
/* 67 */,
/* 68 */,
/* 69 */,
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var react_1 = __importStar(__webpack_require__(0));
var memoize_one_1 = __importDefault(__webpack_require__(71));
var get_1 = __importDefault(__webpack_require__(10));
var isEqual_1 = __importDefault(__webpack_require__(53));
var noop_1 = __importDefault(__webpack_require__(16));
var CanvasContext_1 = __importDefault(__webpack_require__(72));
var dashboard_context_1 = __importStar(__webpack_require__(14));
var dashboard_telemetry_1 = __webpack_require__(37);
var usePrevious_1 = __importDefault(__webpack_require__(38));
var useEventCallback_1 = __importDefault(__webpack_require__(35));
var useMouseMoveHandler_1 = __importDefault(__webpack_require__(58));
var GridLayoutConstants_1 = __webpack_require__(26);
var GridCanvas_1 = __importDefault(__webpack_require__(73));
var Layer_1 = __importDefault(__webpack_require__(42));
var ResponsiveBlockOutline_1 = __importDefault(__webpack_require__(46));
var ResponsiveBlockItem_1 = __importDefault(__webpack_require__(43));
var layoutUtils_1 = __webpack_require__(2);
var edgeUtils_1 = __webpack_require__(11);
var gridUtils_1 = __webpack_require__(74);
var GridLayoutApi_1 = __importDefault(__webpack_require__(75));
var DefaultOptions_1 = __webpack_require__(9);
var gridLayoutOptionsSchema_1 = __importDefault(__webpack_require__(54));
var Edge_1 = __webpack_require__(77);
var ItemDragPlaceholder_1 = __webpack_require__(78);
var ItemDropTarget_1 = __webpack_require__(79);
var PreviewPlaceholderItem_1 = __webpack_require__(80);
var gridLayoutUtils_1 = __webpack_require__(81);
var HANDLE_DIRECTIONS = [];
var MemoizedBlockItem = react_1.default.memo(ResponsiveBlockItem_1.default);
var MemoizedBlockOutline = react_1.default.memo(ResponsiveBlockOutline_1.default);
var MemoizedEdge = react_1.default.memo(Edge_1.Edge);
/**
 * loop through structure to render each block. Memoized block rendering to prevent rerender of each block
 */
var renderBlockItems = memoize_one_1.default(function (_a) {
    var layoutStructure = _a.layoutStructure, renderLayoutItem = _a.renderLayoutItem, handleItemSelected = _a.handleItemSelected, isBlockItemMoving = _a.isBlockItemMoving, selectedItem = _a.selectedItem, mode = _a.mode, errors = _a.errors, padding = _a.padding, canvasHeight = _a.canvasHeight;
    return layoutStructure.map(function (item) {
        var key = item.item;
        if (key === 'preview-old-item') {
            return null;
        }
        var isSelected = get_1.default(selectedItem, 'id') === key;
        // Highlight the item if:
        // 1. in view mode
        // 2. in edit mode and no item is selected
        // 3. in edit mode and the item is selected
        var appearance = mode === 'view' || !selectedItem || isSelected
            ? 'highlighted'
            : 'visible';
        // If the selected visualization is moving, then we want to hide the viz itself since the
        //   preview placeholder will be rendered on top. The hiding is done using `visibility: hidden`, to avoid
        //   causing the viz to unmount, which would re-run the search.
        if (isSelected && isBlockItemMoving) {
            appearance = 'hidden';
        }
        // find the error object belonging to this viz if the error exists
        var errorMessages;
        if (errors) {
            var vizErrors = errors.find(function (_a) {
                var itemId = _a.itemId;
                return itemId === key;
            });
            errorMessages = get_1.default(vizErrors, 'messages');
        }
        var paddedItem = edgeUtils_1.applyVizPadding({
            item: item,
            padding: padding,
        });
        return (react_1.default.createElement(MemoizedBlockItem, { key: key, itemId: key, x: paddedItem.position.x, y: paddedItem.position.y, h: paddedItem.position.h, w: paddedItem.position.w, canvasHeight: canvasHeight, renderLayoutItem: renderLayoutItem, onItemSelected: handleItemSelected, appearance: appearance, errorMessages: errorMessages }));
    });
}, isEqual_1.default);
var BaseGridLayout = function (_a) {
    var layoutApiRef = _a.layoutApiRef, onLayoutItemsSelect = _a.onLayoutItemsSelect, selectedLayoutItems = _a.selectedItems, layoutStructure = _a.layoutStructure, onLayoutStructureChange = _a.onLayoutStructureChange, _b = _a.options, options = _b === void 0 ? {} : _b, renderLayoutItem = _a.renderLayoutItem, mode = _a.mode, showGrid = _a.showGrid, scale = _a.scale, canvasWidth = _a.canvasWidth;
    var canvasContext = react_1.useContext(CanvasContext_1.default);
    var _c = react_1.useContext(dashboard_context_1.default), keyboardListener = _c.keyboardListener, _d = _c.userMessage, userMessage = _d === void 0 ? noop_1.default : _d;
    var telemetryAPI = react_1.useContext(dashboard_telemetry_1.TelemetryContext);
    var _f = dashboard_context_1.useFeatureFlags(), enableGridLayoutErrors = _f.enableGridLayoutErrors, enableGridLayoutCssScaling = _f.enableGridLayoutCssScaling;
    var _g = options.gutterSize, gutterSize = _g === void 0 ? DefaultOptions_1.gridLayoutOptions.gutterSize : _g;
    // gutterSize is split between the two panels it shares
    var panelPadding = gutterSize / 2;
    var _h = __read(react_1.useReducer(gridLayoutUtils_1.gridReducer, layoutStructure, gridLayoutUtils_1.initializeGridReducer), 2), gridState = _h[0], dispatch = _h[1];
    var maxHeight = layoutUtils_1.computeMaxHeight(gridLayoutUtils_1.getBlockItems(gridState));
    var _j = __read(react_1.useState(false), 2), isBlockItemMoving = _j[0], setIsBlockItemMoving = _j[1];
    var _k = __read(react_1.useState(edgeUtils_1.computeEdges({
        layout: layoutStructure,
        canvasWidth: canvasWidth,
        canvasHeight: layoutUtils_1.computeMaxHeight(layoutStructure),
    })), 2), edges = _k[0], setEdges = _k[1];
    var _l = __read(react_1.useState([]), 2), snappableEdges = _l[0], setSnappableEdges = _l[1];
    var _m = __read(react_1.useState(false), 2), scrollToBottom = _m[0], setScrollToBottom = _m[1];
    var _o = __read(react_1.useState(null), 2), mousePosition = _o[0], setMousePosition = _o[1];
    var _p = __read(react_1.useState(false), 2), isVizAdded = _p[0], setIsVizAdded = _p[1];
    var _q = __read(react_1.useState(null), 2), edgesBeforeMove = _q[0], setEdgesBeforeMove = _q[1];
    var _r = __read(react_1.useState(null), 2), invalidEdgeId = _r[0], setInvalidEdgeId = _r[1];
    var _s = __read(react_1.useState(null), 2), hoveredEdge = _s[0], setHoveredEdge = _s[1];
    var _t = __read(react_1.useState(null), 2), initialItemToMove = _t[0], setInitialItemToMove = _t[1];
    var _u = __read(react_1.useState(null), 2), hoveredBlock = _u[0], setHoveredBlock = _u[1];
    var _v = __read(react_1.useState(null), 2), hoveredQuadrant = _v[0], setHoveredQuadrant = _v[1];
    var _w = __read(react_1.useState(0), 2), setForceUpdate = _w[1];
    var _x = __read(react_1.useState([]), 2), selectedItemsForEdge = _x[0], setSelectedItemsForEdge = _x[1];
    var _y = __read(react_1.useState(false), 2), isInvalidVizDrop = _y[0], setIsInvalidVizDrop = _y[1];
    var _z = __read(react_1.useState(true), 2), showPreviewPlaceholder = _z[0], setShowPreviewPlaceholder = _z[1];
    var _0 = __read(react_1.useState([]), 2), layoutErrors = _0[0], setLayoutErrors = _0[1];
    var isDraggingEdge = react_1.useRef(false);
    var delayPreviewEdge = react_1.useRef(null);
    var delayPreviewViz = react_1.useRef(null);
    /**
     * the follow values are saved in refs instead of states for two reasons:
     *     1. they don't affect rendering;
     *     2. they should be updated synchronously in order to handle mouse events https://jira.splunk.com/browse/SCP-25610
     */
    // mouseDownEdge is tracking the initial edge state when mouse down event happens, it is a snapshot, it won't update when mouse moves
    // the reason we need it is because we use the initial edge position and latest mouse position to calculate latest edge position
    var mouseDownEdge = react_1.useRef(null);
    var edgeMouseDownPosition = react_1.useRef(null);
    var edgeBoundaries = react_1.useRef(null);
    var edgesInBoundary = react_1.useRef(null);
    var containsPreviewItem = gridLayoutUtils_1.hasPreviewItem(gridState);
    var sendTelemetry = react_1.useCallback(function (eventData) {
        telemetryAPI.collect(eventData);
    }, [telemetryAPI]);
    var onVizAdded = react_1.useCallback(function () {
        setIsVizAdded(true);
    }, [setIsVizAdded]);
    var canvasRef = react_1.useRef(null);
    var getCanvasDomElement = function () {
        return canvasRef.current;
    };
    var layoutApi = react_1.useRef(null);
    var layoutStructureRef = react_1.useRef(layoutStructure);
    var firstSelectedItemStructure = react_1.useMemo(function () {
        return (selectedLayoutItems === null || selectedLayoutItems === void 0 ? void 0 : selectedLayoutItems.length) ? gridLayoutUtils_1.getItem(gridState, selectedLayoutItems[0].id)
            : null;
    }, [gridState, selectedLayoutItems]);
    var initializeLayoutApi = react_1.useCallback(function () {
        if (layoutApi.current === null) {
            layoutApi.current = new GridLayoutApi_1.default({
                layoutStructureRef: layoutStructureRef,
                options: options,
                userMessage: userMessage,
                onVizAdded: onVizAdded,
                getCanvasDomElement: getCanvasDomElement,
                telemetry: telemetryAPI,
            });
        }
    }, [telemetryAPI, userMessage, onVizAdded, options]);
    var prevLayoutStructure = usePrevious_1.default(layoutStructure);
    react_1.useEffect(function () {
        if (isEqual_1.default(prevLayoutStructure, layoutStructure)) {
            return;
        }
        dispatch(gridLayoutUtils_1.resetLayoutAction(layoutStructure));
        // Adding/removing/cloning is done by using this reference to the layoutStructure
        // so we need to make sure it reflects the unscaled versions of the visualizations
        layoutStructureRef.current = enableGridLayoutCssScaling
            ? layoutStructure
            : layoutUtils_1.scaleGridLayoutStructureByWidth({
                scale: 1 / scale,
                layout: layoutStructure,
            });
    }, [
        enableGridLayoutCssScaling,
        layoutStructure,
        prevLayoutStructure,
        scale,
    ]);
    // Need to do this after initializing layout structure ref!
    initializeLayoutApi();
    react_1.useEffect(function () {
        // only show errors when we're in edit mode
        if (mode === 'edit' && enableGridLayoutErrors) {
            var errors = gridUtils_1.validateLayoutStructure({
                layout: layoutStructure,
                canvasBounds: { x: 0, y: 0, w: canvasWidth, h: maxHeight },
            });
            setLayoutErrors(errors);
        }
        else if (mode === 'view') {
            // in case we had errors in edit mode, remove them when going to view mode
            setLayoutErrors([]);
        }
        // We only want this to run when we commit changes to item position/size.
        //  For example, we want it to run after resizing (on mouse up), not during.
        //  And also when we switch modes, since we only want to show errors in edit mode
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [layoutStructure, mode, enableGridLayoutErrors]);
    // we must use `useLayoutEffect` because we need to guarantee `layoutApiRef` is called before `componentDidMount()` is called on
    // the parent component (namely LayoutContainer). Otherwise LayoutContainer will not get the api.
    react_1.useLayoutEffect(function () {
        layoutApiRef(layoutApi.current);
        return function () {
            layoutApiRef(null);
        };
    }, [layoutApiRef]);
    // this ensures the layout reducer gets the latest layoutStructure
    react_1.useEffect(function () {
        // TODO: we should look into how to make `layoutStructure` not constantly change if the actual content of the layoutStructure did not change.
        // Currently, we have to do a deep comparison, because `layoutStructure` as an object reference is always changing.
        if (isEqual_1.default(prevLayoutStructure, layoutStructure)) {
            return;
        }
        dispatch(gridLayoutUtils_1.resetLayoutAction(layoutStructure));
        var canvasHeight = layoutUtils_1.computeMaxHeight(layoutStructure);
        var prevCanvasHeight = layoutUtils_1.computeMaxHeight(prevLayoutStructure || []);
        setEdges(edgeUtils_1.computeEdges({
            layout: layoutStructure,
            canvasWidth: canvasWidth,
            canvasHeight: canvasHeight,
        }));
        if (prevLayoutStructure &&
            canvasHeight > prevCanvasHeight &&
            isVizAdded) {
            // when we add a new viz to canvas, we want to scroll to it
            setScrollToBottom(true);
            setIsVizAdded(false);
        }
    }, [isVizAdded, layoutStructure, canvasWidth, prevLayoutStructure]);
    react_1.useEffect(function () {
        if (scrollToBottom) {
            var layoutContainer = canvasContext.current;
            layoutContainer.scrollTop = layoutContainer.scrollHeight;
            setScrollToBottom(false);
        }
    }, [canvasContext, layoutStructure, scrollToBottom]);
    // Not idempotent, but doesn't matter because this will only result in resetting a mouseup handler, not a rerender of any component
    var handleLayoutStructureChange = react_1.useCallback(function () {
        var layout = gridLayoutUtils_1.getBlockItems(gridState);
        onLayoutStructureChange(layout);
    }, [onLayoutStructureChange, gridState]);
    /**
     * return valid selected items, this needs to be a function because we cannot detect structureRegistry change.
     */
    var getSelectedItems = react_1.useMemo(function () {
        var itemsCache;
        return function () {
            var filteredItems = gridLayoutUtils_1.filterSelectedItems(layoutStructure, selectedLayoutItems);
            if (!isEqual_1.default(itemsCache, filteredItems)) {
                itemsCache = filteredItems;
            }
            return itemsCache;
        };
    }, [layoutStructure, selectedLayoutItems]);
    /**
     * set selected items
     * @param {Object} e mouse event
     * @param {Array} selectedItems list of selected Items
     */
    var handleItemSelected = react_1.useCallback(function (_e, selectedItems) {
        if (selectedItems === void 0) { selectedItems = []; }
        // filter out other Items as we do not currently support multi selecting Items
        var selectedItem = selectedItems.length > 0
            ? [selectedItems[selectedItems.length - 1]]
            : [];
        onLayoutItemsSelect(selectedItem);
    }, [onLayoutItemsSelect]);
    // If we're not scaling the grid via CSS we don't need to scale the mouse position
    var mouseScale = enableGridLayoutCssScaling ? scale : 1;
    /**
     * Handles scrolling in Canvas when a Viz is being dragged to the top or bottom of the visible Canvas
     */
    // TODO: something is a little odd here...when showing an edge preview on canvas bottom causes scrolling things break a little
    react_1.useEffect(function () {
        var delayed;
        if (!isBlockItemMoving || !mousePosition || !canvasContext) {
            return function () { return undefined; };
        }
        var layoutContainer = canvasContext.current;
        var visibleCanvasHeight = layoutContainer.clientHeight / mouseScale;
        var hasScrolledToBottom = layoutContainer.scrollTop / mouseScale + visibleCanvasHeight >=
            maxHeight;
        var isInBottomScrollArea = layoutContainer.scrollTop / mouseScale +
            visibleCanvasHeight -
            mousePosition.y <
            GridLayoutConstants_1.MIN_HEIGHT_PX;
        var hasScrolledToTop = layoutContainer.scrollTop <= 0;
        var isInTopScrollArea = mousePosition.y - layoutContainer.scrollTop / mouseScale <
            GridLayoutConstants_1.MIN_HEIGHT_PX;
        if (!hasScrolledToBottom && isInBottomScrollArea) {
            var increment_1 = Math.min(Math.abs(maxHeight -
                (layoutContainer.scrollTop / mouseScale +
                    visibleCanvasHeight)), 10);
            delayed = setTimeout(function () {
                layoutContainer.scrollTop += increment_1;
                setMousePosition(function (pos) {
                    return pos
                        ? __assign(__assign({}, pos), { y: pos.y + increment_1 / mouseScale }) : null;
                });
            }, 32);
        }
        else if (!hasScrolledToTop && isInTopScrollArea) {
            var decrement_1 = Math.min(layoutContainer.scrollTop, 10);
            delayed = setTimeout(function () {
                layoutContainer.scrollTop -= decrement_1;
                setMousePosition(function (pos) {
                    return pos
                        ? __assign(__assign({}, pos), { y: pos.y - decrement_1 / mouseScale }) : null;
                });
            }, 32);
        }
        return function () {
            clearTimeout(delayed);
        };
    }, [
        isBlockItemMoving,
        mousePosition,
        canvasContext,
        mouseScale,
        maxHeight,
    ]);
    /*
        Reset the preview states to original values for edge preview
    */
    var resetEdgePreviewState = react_1.useCallback(function () {
        if (edgesBeforeMove) {
            // If there was an update, stop it from happening
            if (delayPreviewEdge.current) {
                clearTimeout(delayPreviewEdge.current);
            }
            // Set edges back to original ones before the move happened
            setEdges(edgesBeforeMove);
            // Set visualizations to original
            dispatch(gridLayoutUtils_1.resetLayoutAction(layoutStructure));
        }
    }, [edgesBeforeMove, layoutStructure]);
    var showEdgeDropPreview = react_1.useCallback(function (_a) {
        var mousePos = _a.mousePos;
        if (edgesBeforeMove === null) {
            // Only update the edges before move once, since it will always be the same
            setEdgesBeforeMove(edges);
        }
        // Compute against the initial edges before we started moving, unless they haven't been set yet
        var validEdges = edgesBeforeMove || edges;
        // find if the mouse is on the edge
        var edge = validEdges.find(function (edgeToFind) {
            return gridUtils_1.isMouseOnEdge({
                edge: edgeToFind,
                mousePosition: mousePos,
                padding: panelPadding,
            });
        });
        if (!edge) {
            /* If edge is undefined, there is no edge being hovered */
            // If an edge was previously hovered, then undo the state changes made, and revert back to original
            // This deals with hovering on an edge and then hovering off it
            if (hoveredEdge) {
                setHoveredEdge(null);
                setInvalidEdgeId(null);
                resetEdgePreviewState();
            }
            return;
        }
        // Only compute preview if this is the first time we are hovering this particular edge
        // which means either the edge is undefined or it's a different edge than the last one that was hovered
        if (!hoveredEdge || hoveredEdge.item !== edge.item) {
            var itemToMove = firstSelectedItemStructure;
            if (!initialItemToMove) {
                // We need to keep the original item to move since the 'selectedItem' will change positions
                //  to the new position inserted in the preview
                setInitialItemToMove(itemToMove);
            }
            else {
                // use the original item to move
                itemToMove = initialItemToMove;
            }
            // hide preview when an item is dropped on its own edge that has the same width/height as item
            if (gridUtils_1.isDropOnOwnEdge({
                edge: edge,
                itemToMove: itemToMove,
            })) {
                return;
            }
            // Compute the preview when hovering over the edge
            var updatedItems_1 = gridUtils_1.previewDropOnEdge({
                edge: edge,
                itemToMove: itemToMove,
                items: layoutStructure,
                canvasWidth: canvasWidth,
            });
            // If the move was valid, update state to render the preview
            if (updatedItems_1) {
                // clear invalid edge if it exists
                setInvalidEdgeId(null);
                if (delayPreviewEdge.current) {
                    clearTimeout(delayPreviewEdge.current);
                }
                // When we set timeout, it means it is a valid drop, thus hide preview placeholder until the preview is shown
                setShowPreviewPlaceholder(false);
                delayPreviewEdge.current = setTimeout(function () {
                    // Update layout reducer with the new structure
                    dispatch(gridLayoutUtils_1.resetLayoutAction(updatedItems_1));
                    // render the new edges using the new updated layout structure
                    setEdges(edgeUtils_1.computeEdges({
                        layout: updatedItems_1,
                        canvasWidth: canvasWidth,
                        canvasHeight: layoutUtils_1.computeMaxHeight(updatedItems_1),
                    }));
                    // When preview is computed and shown, bring back the placeholder
                    setShowPreviewPlaceholder(true);
                }, GridLayoutConstants_1.EDGE_PREVIEW_DELAY_MS);
            }
            else {
                // if the move was invalid, highlight the hovered edge to red
                setShowPreviewPlaceholder(true);
                setInvalidEdgeId(edge.item);
                // if user moved from a valid preview directly on an invalid edge, reset
                //  the currently shown preview
                resetEdgePreviewState();
            }
        }
        // This state is used to keep track of which edge is being hovered, so that we can track
        //  when we switch to a different edge (to re-compute preview)
        setHoveredEdge(edge);
    }, [
        firstSelectedItemStructure,
        edgesBeforeMove,
        edges,
        hoveredEdge,
        panelPadding,
        resetEdgePreviewState,
        initialItemToMove,
        layoutStructure,
        canvasWidth,
    ]);
    var showVizDropPreview = react_1.useCallback(function (_a) {
        var mousePos = _a.mousePos;
        // Find the viz that the Mouse is hovering over
        var block = layoutUtils_1.findTopBlockItemByPosition(layoutStructure, mousePos, panelPadding);
        var itemToMove = firstSelectedItemStructure;
        if (!initialItemToMove) {
            // We need to keep the original item to move since the 'selectedItem' will change positions
            //  to the new position inserted in the preview
            setInitialItemToMove(itemToMove);
        }
        else {
            // use the original item to move
            itemToMove = initialItemToMove;
        }
        if (block === undefined || block.item === (itemToMove === null || itemToMove === void 0 ? void 0 : itemToMove.item)) {
            if (delayPreviewViz.current) {
                clearTimeout(delayPreviewViz.current);
            }
            setHoveredQuadrant(null);
            setHoveredBlock(null);
            setIsInvalidVizDrop(false);
            if (hoveredBlock) {
                // only reset to original if there was a preview computed
                dispatch(gridLayoutUtils_1.resetLayoutAction(layoutStructure));
            }
            return;
        }
        var currentQuadrant = gridUtils_1.findQuadrant({
            item: edgeUtils_1.applyVizPadding({ item: block, padding: panelPadding }),
            position: mousePos,
        });
        // Only compute (or re-compute) preview if either it's the first time user hovers a viz,
        //   or if the quadrant changed, or if the viz that is being hovered changed.
        if ((!hoveredBlock && !hoveredQuadrant) ||
            hoveredQuadrant !== currentQuadrant ||
            (hoveredBlock === null || hoveredBlock === void 0 ? void 0 : hoveredBlock.item) !== block.item) {
            if (gridUtils_1.isInvalidAdjacentVizDrop({
                itemToMove: itemToMove,
                itemToDropOn: block,
                visualizations: layoutStructure,
                direction: currentQuadrant,
            })) {
                return;
            }
            // get the updated position of the items that are changing as a result of the Viz drop on Viz
            var updatedItems_2 = gridUtils_1.previewDropOnViz({
                itemToDropOn: block,
                itemToMove: itemToMove,
                items: layoutStructure,
                direction: currentQuadrant,
            });
            // clear previous preview if it's queued up
            if (delayPreviewViz.current) {
                clearTimeout(delayPreviewViz.current);
            }
            if (updatedItems_2) {
                setIsInvalidVizDrop(false);
                // The quadrant of the current visualization we are hovering while dragging a viz
                setHoveredQuadrant(currentQuadrant);
                // the visualization we are hovering over
                setHoveredBlock(block);
                // Same as with edge preview, hide the placeholder until the timeout has run to avoid 'flashing' of the green preview
                setShowPreviewPlaceholder(false);
                delayPreviewViz.current = setTimeout(function () {
                    // If the move was valid, show preview of new layout
                    dispatch(gridLayoutUtils_1.resetLayoutAction(updatedItems_2));
                    // While structure registry exists, we need to force an update. This is a clear indication that it needs to be removed, asap!
                    setForceUpdate(function (prevForceUpdate) { return prevForceUpdate + 1; });
                    setShowPreviewPlaceholder(true);
                }, GridLayoutConstants_1.VIZ_PREVIEW_DELAY_MS);
            }
            else {
                setHoveredQuadrant(null);
                setHoveredBlock(null);
                setIsInvalidVizDrop(true);
                if (hoveredBlock) {
                    // only reset to original if there was a preview computed
                    dispatch(gridLayoutUtils_1.resetLayoutAction(layoutStructure));
                }
            }
        }
    }, [
        firstSelectedItemStructure,
        panelPadding,
        hoveredBlock,
        hoveredQuadrant,
        initialItemToMove,
        layoutStructure,
    ]);
    /**
     * Renders the Item Drop Target
     * @param {Object} params
     * @param {Object} params.position position of Item being hovered over
     * @param {String} params.direction direction of where Drop Target should be rendered
     */
    var renderItemDropTarget = memoize_one_1.default(function (_a) {
        var position = _a.position, direction = _a.direction;
        return react_1.default.createElement(ItemDropTarget_1.ItemDropTarget, { position: position, direction: direction });
    });
    /**
     * Handles rendering for Item Drop Targets when an Item is being dragged and hovers on top of another Item
     */
    var handleRenderItemDropTarget = react_1.useCallback(function () {
        var block = layoutUtils_1.findTopBlockItemByPosition(layoutStructure, mousePosition, panelPadding);
        var selectedItems = getSelectedItems();
        if (block !== undefined &&
            selectedItems.length > 0 &&
            block.item !== selectedItems[0].id &&
            // disables drop targets when showing preview
            !hoveredQuadrant) {
            // apply padding to Viz to get accurate mouse hover
            block = edgeUtils_1.applyVizPadding({ item: block, padding: panelPadding });
            return renderItemDropTarget({
                position: block.position,
                direction: gridUtils_1.findQuadrant({
                    item: block,
                    position: mousePosition,
                }),
            });
        }
        return null;
    }, [
        layoutStructure,
        panelPadding,
        getSelectedItems,
        hoveredQuadrant,
        mousePosition,
        renderItemDropTarget,
    ]);
    var handleShowPreviewPlaceholder = react_1.useCallback(function (_a) {
        var mousePos = _a.mousePos;
        var selectedItem = getSelectedItems()[0];
        if (!selectedItem) {
            setShowPreviewPlaceholder(false);
            return;
        }
        // Find the viz that the Mouse is hovering over
        var hoveredViz = layoutUtils_1.findTopBlockItemByPosition(layoutStructure, mousePos, panelPadding);
        // case 1 to show placeholder: mouse is on original viz
        if (hoveredViz && hoveredViz.item === selectedItem.id) {
            setShowPreviewPlaceholder(true);
            return;
        }
        // case 2 to show placeholder: mouse is on an invalid drop zone
        if (invalidEdgeId !== null || isInvalidVizDrop) {
            setShowPreviewPlaceholder(true);
            return;
        }
        // case 3 to show placeholder: preview has been computed
        // Note: preview stays on screen as long as mouse hovers on the drop zone where it was created
        //   so as soon as user moves mouse off, preview goes back to original position (case 1 or 2)
        if (containsPreviewItem) {
            setShowPreviewPlaceholder(true);
            return;
        }
        // If neither of those three cases, hide preview placeholder
        setShowPreviewPlaceholder(false);
    }, [
        containsPreviewItem,
        panelPadding,
        getSelectedItems,
        invalidEdgeId,
        isInvalidVizDrop,
        layoutStructure,
    ]);
    /**
     * set isBlockItemMoving state to true for selected Items
     */
    var handleBlockItemMove = react_1.useCallback(function (_e, _a) {
        var currentPosition = _a.currentPosition;
        if (getSelectedItems().length > 0) {
            handleShowPreviewPlaceholder({ mousePos: currentPosition });
            setIsBlockItemMoving(true);
            setMousePosition(currentPosition);
            showEdgeDropPreview({ mousePos: currentPosition });
            showVizDropPreview({ mousePos: currentPosition });
        }
    }, [
        getSelectedItems,
        showEdgeDropPreview,
        showVizDropPreview,
        handleShowPreviewPlaceholder,
    ]);
    /**
     * Handler to deal with when a Visualization that is being dragged gets dropped on mouseUp Event
     */
    var handleVizDrop = react_1.useCallback(function () {
        var validEdges = edgesBeforeMove || edges;
        var selectedItems = getSelectedItems();
        // return early if there are no selected Items
        if (selectedItems.length === 0) {
            return;
        }
        // Find if the viz is being moved on an edge, return that edge
        var edge = validEdges.find(function (e) {
            return gridUtils_1.isMouseOnEdge({
                edge: e,
                mousePosition: mousePosition,
                padding: panelPadding,
            });
        });
        // Find the viz that the Mouse is hovering over
        var block = layoutUtils_1.findTopBlockItemByPosition(layoutStructure, mousePosition, panelPadding);
        var itemToMove = layoutStructure.find(function (_a) {
            var item = _a.item;
            return item === selectedItems[0].id;
        });
        // nothing changed as a result of the Viz drop on itself - return early
        if (block === itemToMove) {
            sendTelemetry({
                source: 'canvas',
                event: 'viz_drop_on_self_successful',
            });
            return;
        }
        var itemsSelected = layoutStructure;
        var updatedItems = null;
        if (edge !== undefined) {
            // handle drop on Edge
            // get the updated position of the items that are changing as a result of the Viz drop on Edge
            updatedItems = gridUtils_1.updateDropOnEdge({
                edge: edge,
                itemToMove: itemToMove,
                items: itemsSelected,
                canvasWidth: canvasWidth,
            });
            // nothing changed as a result of the Viz drop on Edge - return early
            if (updatedItems === null) {
                sendTelemetry({
                    source: 'canvas',
                    event: 'viz_drop_on_edge_unsuccessful',
                });
                return;
            }
            // updated the entire definition with the updated Items
            updatedItems = gridUtils_1.updateItems({
                updatedVisualizations: updatedItems.updatedVisualizations,
                itemToMove: updatedItems.updatedItemToMove,
                items: itemsSelected,
                canvasWidth: canvasWidth,
            });
            sendTelemetry({
                source: 'canvas',
                event: 'viz_drop_on_edge_successful',
            });
        }
        else if (block !== undefined && block.item !== selectedItems[0].id) {
            // handle drop on Viz
            // apply padding to Viz to get accurate mouse hover position
            var direction = gridUtils_1.findQuadrant({
                item: edgeUtils_1.applyVizPadding({ item: block, padding: panelPadding }),
                position: mousePosition,
            });
            if (gridUtils_1.isInvalidAdjacentVizDrop({
                itemToMove: itemToMove,
                itemToDropOn: block,
                direction: direction,
                visualizations: layoutStructure,
            })) {
                return;
            }
            // get the updated position of the items that are changing as a result of the Viz drop on Viz
            var updatedVisualizations = gridUtils_1.updateDropOnViz({
                itemToMove: itemToMove,
                itemToDropOn: block,
                direction: direction,
            });
            if (updatedVisualizations === null) {
                sendTelemetry({
                    source: 'canvas',
                    event: 'viz_drop_on_viz_unsuccessful',
                });
                return;
            }
            // updated the entire definition with the updated Items
            updatedItems = gridUtils_1.updateItems({
                updatedVisualizations: updatedVisualizations,
                itemToMove: itemToMove,
                items: itemsSelected,
                canvasWidth: canvasWidth,
            });
            sendTelemetry({
                source: 'canvas',
                event: 'viz_drop_on_viz_successful',
            });
        }
        if (updatedItems != null) {
            onLayoutStructureChange(updatedItems);
        }
    }, [
        layoutStructure,
        edgesBeforeMove,
        edges,
        getSelectedItems,
        mousePosition,
        panelPadding,
        sendTelemetry,
        canvasWidth,
        onLayoutStructureChange,
    ]);
    /*
        Clean up the state from the preview, and undo any changes by reverting to original state before the item move
    */
    var cleanupAfterPreview = react_1.useCallback(function () {
        if (delayPreviewViz.current) {
            clearTimeout(delayPreviewViz.current);
        }
        if (delayPreviewEdge.current) {
            clearTimeout(delayPreviewEdge.current);
        }
        setInvalidEdgeId(null);
        setIsInvalidVizDrop(false);
        setInitialItemToMove(null);
        setHoveredBlock(null);
        setHoveredQuadrant(null);
        if (edgesBeforeMove) {
            // If a preview was shown, revert back to original
            setEdges(edgesBeforeMove);
            setEdgesBeforeMove(null);
            dispatch(gridLayoutUtils_1.resetLayoutAction(layoutStructure));
        }
        if (hoveredBlock) {
            dispatch(gridLayoutUtils_1.resetLayoutAction(layoutStructure));
        }
    }, [edgesBeforeMove, hoveredBlock, layoutStructure]);
    /**
     * update the blocks when it finished moving
     */
    var handleBlockItemMoved = react_1.useCallback(function () {
        cleanupAfterPreview();
        if (mousePosition !== null) {
            // updates layout structure
            handleVizDrop();
        }
        setIsBlockItemMoving(false);
        setMousePosition(null);
    }, [cleanupAfterPreview, mousePosition, handleVizDrop]);
    var handleBlockItemPositionUpdate = react_1.useCallback(function (_a) {
        var item = _a.item, offset = _a.offset;
        var newItem = layoutUtils_1.updateBlockItemPosition(item, offset);
        // update runtime structure
        dispatch(gridLayoutUtils_1.updateItemAction(newItem));
    }, []);
    /**
     * Block Items resize and move Handler
     * @param {Object} e mouse event
     * @param {Object} options
     * @param {Object} options.itemId itemId for selected Viz
     * @param {Object} options.offset offset amount to move Viz
     * @param {Object} options.dir direction to resize Viz
     */
    var handleBlockItemResize = react_1.useCallback(function (e, _a) {
        var itemId = _a.itemId, offset = _a.offset, dir = _a.dir;
        // all computation is done against last committed items!
        var item = gridLayoutUtils_1.getStructureItem(layoutStructure, itemId);
        var newItem = layoutUtils_1.updateBlockItemSize({
            item: item,
            offset: offset,
            dir: dir,
            options: {
                minHeight: GridLayoutConstants_1.MIN_HEIGHT_PX,
                minWidth: GridLayoutConstants_1.MIN_WIDTH_PX,
            },
        });
        // update runtime structure
        dispatch(gridLayoutUtils_1.updateItemAction(newItem));
    }, [layoutStructure]);
    /**
     * handler for when Block is finished Resizing
     */
    var handleBlockItemResized = react_1.useCallback(function () {
        // resize completed
        handleLayoutStructureChange();
        sendTelemetry({
            source: 'canvas',
            event: 'edge_resize',
        });
    }, [handleLayoutStructureChange, sendTelemetry]);
    var handleMouseDownOnEdge = react_1.useCallback(function (e, _a) {
        var id = _a.id;
        isDraggingEdge.current = true;
        var edge = edges.find(function (_a) {
            var item = _a.item;
            return item === id;
        });
        if (!edge) {
            return;
        }
        // set selected visualizations
        // select proper viz items and also proper edge orientation for viz
        var visualizationIds = edge.visualizations.map(function (viz) { return viz.item; });
        // find boundaries, either horizontal boundary - { leftBoundary, rightBoundary }
        // or vertical boundary - { upperBoundary, lowerBoundary }
        var newEdgeBoundaries = edge.orientation === 'horizontal'
            ? edgeUtils_1.getVerticalBoundaries({
                visualizations: edge.visualizations,
                y: edge.edgeStart.y,
                minHeight: GridLayoutConstants_1.MIN_HEIGHT_PX,
                isFullWidthEdge: edge.edgeEnd.x - edge.edgeStart.x === canvasWidth,
            })
            : edgeUtils_1.getHorizontalBoundaries({
                visualizations: edge.visualizations,
                x: edge.edgeStart.x,
                minWidth: GridLayoutConstants_1.MIN_WIDTH_PX,
            });
        // save new boundary
        edgeBoundaries.current = newEdgeBoundaries;
        // compute edges in boundary
        edgesInBoundary.current = edgeUtils_1.findEdgesInBoundary({
            edge: edge,
            edges: edges,
            edgeBoundaries: newEdgeBoundaries,
        });
        edgeMouseDownPosition.current = layoutUtils_1.getClientPosition(e, mouseScale);
        mouseDownEdge.current = __assign({}, edge);
        setSelectedItemsForEdge(visualizationIds);
    }, [edges, mouseScale, canvasWidth]);
    /**
     * handle resizing for selected edge and visualizations
     */
    var handleEdgeMove = useEventCallback_1.default(function (e) {
        var _a, _b;
        e.preventDefault();
        e.stopPropagation();
        // update selected edge location
        if (!isDraggingEdge.current || !mouseDownEdge.current) {
            return;
        }
        var currentPosition = layoutUtils_1.getClientPosition(e, mouseScale);
        var offset = layoutUtils_1.getOffset(currentPosition, edgeMouseDownPosition.current);
        var updatedEdge = ((_a = mouseDownEdge === null || mouseDownEdge === void 0 ? void 0 : mouseDownEdge.current) === null || _a === void 0 ? void 0 : _a.orientation) === 'vertical'
            ? edgeUtils_1.moveVerticalEdge({
                edge: mouseDownEdge.current,
                offset: offset.offsetX,
                edgeBoundaries: edgeBoundaries.current,
            })
            : edgeUtils_1.moveHorizontalEdge({
                edge: mouseDownEdge.current,
                offset: offset.offsetY,
                edgeBoundaries: edgeBoundaries.current,
            });
        var updatedSnappableEdges = [];
        if (!e.shiftKey) {
            var _c = edgeUtils_1.findSnappableEdges({
                edge: updatedEdge,
                edges: (_b = edgesInBoundary.current) !== null && _b !== void 0 ? _b : [],
                snapRange: GridLayoutConstants_1.SNAP_RANGE_PX,
            }), ue = _c.updatedEdge, se = _c.snappableEdges;
            updatedEdge = ue;
            updatedSnappableEdges = se;
        }
        setEdges(function (prevEdges) {
            return prevEdges.map(function (anEdge) {
                if (anEdge.item === updatedEdge.item) {
                    return updatedEdge;
                }
                return anEdge;
            });
        });
        // update visualizations locations
        var vizOffset = {
            offsetX: updatedEdge.edgeStart.x - mouseDownEdge.current.edgeStart.x,
            offsetY: updatedEdge.edgeStart.y - mouseDownEdge.current.edgeStart.y,
        };
        var isFullWidthEdge = mouseDownEdge.current.edgeEnd.x -
            mouseDownEdge.current.edgeStart.x ===
            canvasWidth;
        if (isFullWidthEdge) {
            // If user is dragging full width edge, update ALL the visualizations below the edge by
            //  shifting them downwards/upwards, including the ones that are not directly touching the edge
            // The block items need to be the committed versions
            layoutStructure.forEach(function (item) {
                if (mouseDownEdge.current &&
                    item.position.y >= mouseDownEdge.current.edgeStart.y) {
                    handleBlockItemPositionUpdate({
                        item: item,
                        offset: vizOffset,
                    });
                }
            });
        }
        if (selectedItemsForEdge.length > 0) {
            selectedItemsForEdge.forEach(function (itemId) {
                var _a;
                var item = gridLayoutUtils_1.getStructureItem(layoutStructure, itemId);
                if (!mouseDownEdge.current ||
                    (isFullWidthEdge &&
                        item.position.y >= mouseDownEdge.current.edgeStart.y)) {
                    // if the moving edge is a full width edge, we already took care of the visualizations
                    //   below that edge, thus ignore them here, and only resize the items above the edge
                    return;
                }
                var resizeDir;
                if (((_a = mouseDownEdge.current) === null || _a === void 0 ? void 0 : _a.orientation) === 'horizontal') {
                    resizeDir =
                        item.position.y >= mouseDownEdge.current.edgeStart.y
                            ? 'n'
                            : 's';
                }
                else {
                    resizeDir =
                        item.position.x >= mouseDownEdge.current.edgeStart.x
                            ? 'w'
                            : 'e';
                }
                handleBlockItemResize(e, {
                    itemId: itemId,
                    offset: vizOffset,
                    dir: resizeDir,
                });
            });
        }
        // check for snappable edges
        // highlight snappable edges
        setSnappableEdges(updatedSnappableEdges);
    });
    useMouseMoveHandler_1.default({
        onMouseMove: handleEdgeMove,
        isEnabled: mode === 'edit',
        throttledMs: 32,
    });
    /**
     * handler for when Edge is finished Moving
     */
    var handleEdgeMoved = useEventCallback_1.default(function (e) {
        // DO NOT stop propagation, because visualizations are listening to mouse up to tell
        // whether it stopped moving. Refer to GridCanvas.jsx for the logic.
        e.preventDefault();
        // need to reset this before updating state
        mouseDownEdge.current = null;
        edgeMouseDownPosition.current = null;
        edgeBoundaries.current = null;
        edgesInBoundary.current = null;
        if (isDraggingEdge.current) {
            isDraggingEdge.current = false;
            // only unset select viz when resizing edge is done,
            // not on clicking a viz.
            setSelectedItemsForEdge([]);
            handleBlockItemResized();
        }
        if (snappableEdges.length > 0) {
            setSnappableEdges([]);
        }
    });
    react_1.useEffect(function () {
        if (mode !== 'edit') {
            return undefined;
        }
        document.addEventListener('mouseup', handleEdgeMoved);
        return function () {
            document.removeEventListener('mouseup', handleEdgeMoved);
        };
    }, [handleEdgeMoved, mode]);
    react_1.useEffect(function () {
        if (!keyboardListener) {
            return function () { return undefined; };
        }
        var unsubscribeKeyboardListener = keyboardListener.subscribe('cancel', function () {
            if (isBlockItemMoving) {
                cleanupAfterPreview();
                setIsBlockItemMoving(false);
                setMousePosition(null);
            }
            else {
                // deselect all selected items;
                onLayoutItemsSelect([]);
            }
        });
        return function () {
            unsubscribeKeyboardListener();
        };
    }, [
        cleanupAfterPreview,
        isBlockItemMoving,
        onLayoutItemsSelect,
        keyboardListener,
    ]);
    /**
     * render outline for block items
     * @param {Number} scale scale value
     */
    var renderOutline = function () {
        var selectedItems = selectedItemsForEdge.length > 0
            ? selectedItemsForEdge
            : getSelectedItems().map(function (_a) {
                var id = _a.id;
                return id;
            });
        var blockItems = gridLayoutUtils_1.getBlockItems(gridState);
        return blockItems.map(function (item) {
            // 1. item must be selected AND
            // 2. either the item is not moving (user just selected it)
            //   OR the item is moving and the preview is shown (to show green outline around preview placeholder)
            var displayOutline = selectedItems.includes(item.item) &&
                (!isBlockItemMoving || showPreviewPlaceholder);
            if (displayOutline) {
                var paddedItem = edgeUtils_1.applyVizPadding({
                    item: item,
                    padding: panelPadding,
                });
                return (react_1.default.createElement(MemoizedBlockOutline, { handleDirections: HANDLE_DIRECTIONS, key: item.item, itemId: item.item, scale: mouseScale, x: paddedItem.position.x, y: paddedItem.position.y, w: paddedItem.position.w, h: paddedItem.position.h }));
            }
            // for all other block items, no outline will be displayed.
            return null;
        });
    };
    var getEdgeAppearance = react_1.useCallback(function (_a) {
        var edge = _a.edge;
        var renderAllEdges = !mouseDownEdge.current;
        var appearance = renderAllEdges ||
            edge.item === get_1.default(mouseDownEdge.current, 'item') ||
            snappableEdges.find(function (e) { return e.item === edge.item; })
            ? 'normal'
            : 'hidden';
        if (isBlockItemMoving) {
            var itemToMove = layoutStructure.find(function (_a) {
                var _b;
                var item = _a.item;
                return item === ((_b = getSelectedItems()[0]) === null || _b === void 0 ? void 0 : _b.id);
            });
            // hide edge if it's adjacent to the moving item and has the same width/height as item
            if (itemToMove &&
                gridUtils_1.isDropOnOwnEdge({
                    edge: edge,
                    itemToMove: itemToMove,
                })) {
                appearance = 'hidden';
            }
            else {
                appearance = 'dropTarget';
            }
        }
        if (invalidEdgeId === edge.item) {
            appearance = 'invalid';
        }
        return appearance;
    }, [
        invalidEdgeId,
        isBlockItemMoving,
        mouseDownEdge,
        snappableEdges,
        getSelectedItems,
        layoutStructure,
    ]);
    /**
     * Renders the Edges
     * @param {Object} options
     * @param {Number} options.edgeThickness edgeThickness
     * @param {Number} options.scale scale value
     * @returns {Object} returns edge with updated position
     */
    var edgeItems = react_1.useMemo(function () {
        if (mode !== 'edit') {
            return null;
        }
        // if no edge is selected, render all edges
        return edges.map(function (edge) {
            var formattedEdge = gridUtils_1.formatEdgeWrapper({
                edge: edge,
                padding: panelPadding,
            });
            var _a = gridUtils_1.getDimensions({
                edge: formattedEdge,
                thickness: 2 * panelPadding,
            }), width = _a.width, height = _a.height;
            var _b = formattedEdge.edgeStart, x = _b.x, y = _b.y;
            return (react_1.default.createElement(MemoizedEdge, { key: edge.item, itemId: edge.item, x: x, y: y, w: width, h: height, padding: panelPadding, orientation: edge.orientation, isCanvasEdge: edge.isCanvasEdge, appearance: getEdgeAppearance({ edge: edge }), onMouseDown: handleMouseDownOnEdge, "data-test-edge-position": edge.edgeStart.x + "," + edge.edgeStart.y + "-" + edge.edgeEnd.x + "," + edge.edgeEnd.y }));
        });
    }, [mode, edges, getEdgeAppearance, panelPadding, handleMouseDownOnEdge]);
    var handleRenderPreviewPlaceholderItem = react_1.useCallback(function () {
        if (!firstSelectedItemStructure || !showPreviewPlaceholder) {
            return null;
        }
        var item = edgeUtils_1.applyVizPadding({
            item: firstSelectedItemStructure,
            padding: panelPadding,
        });
        return (react_1.default.createElement(PreviewPlaceholderItem_1.PreviewPlaceholderItem, { key: firstSelectedItemStructure.item + "-preview", position: item.position }));
    }, [firstSelectedItemStructure, panelPadding, showPreviewPlaceholder]);
    // TODO: this is an ugly hack to make deleting a viz not break the layout
    /**
     * History:
     * layoutStructure prop changes will cause a rerender.
     * The renderBlockItems method needs to receive the modified structure (e.g. from dragging) stored in the reducer state.
     * Removing a viz will result in a layoutStructure change and render before the reducer updates, referencing a viz that no longer exists.
     * This will throw an error when trying to resolve tokens in the unknown viz config.
     * An undo operation after a delete will restore a viz that does not exist in gridState, so a filtered structure must account for this case.
     */
    var filteredState = react_1.useMemo(function () { return gridLayoutUtils_1.getFilteredStructure(gridState, layoutStructure); }, [gridState, layoutStructure]);
    var items = getSelectedItems();
    // no need to memoize because it is destructured before passing to GridCanvas
    var commonProps = {
        width: canvasWidth,
        height: maxHeight,
        scale: scale,
        selectable: true,
        selectedLayoutItems: items,
        onItemSelected: handleItemSelected,
        panelPadding: panelPadding,
        ref: canvasRef,
    };
    var modeSpecificProps = mode === 'edit'
        ? {
            movable: true,
            showOverflowContent: false,
            showGrid: showGrid,
            showBorder: true,
            gridWidth: GridLayoutConstants_1.GRID_SIZE_PX - 1,
            gridHeight: GridLayoutConstants_1.GRID_SIZE_PX - 1,
            gridLineWidth: 1,
            gridPadding: GridLayoutConstants_1.GRID_PADDING_PX,
            onItemMove: handleBlockItemMove,
            onItemMoved: handleBlockItemMoved,
            userSelect: false,
        }
        : {
            movable: false,
            showOverflowContent: false,
            showGrid: false,
            showBorder: false,
            userSelect: true,
        };
    return (react_1.default.createElement(GridCanvas_1.default, __assign({ "data-test": "grid-layout", blockItems: filteredState, "data-test-scale": scale }, commonProps, modeSpecificProps),
        react_1.default.createElement(Layer_1.default, { key: "block-item-layer", "data-test": "block-item-layer" }, renderBlockItems({
            layoutStructure: filteredState,
            renderLayoutItem: renderLayoutItem,
            handleItemSelected: handleItemSelected,
            isBlockItemMoving: isBlockItemMoving,
            selectedItem: getSelectedItems()[0],
            mode: mode,
            errors: layoutErrors,
            padding: panelPadding,
            canvasHeight: maxHeight,
        })),
        edgeItems,
        react_1.default.createElement(Layer_1.default, { key: "outline-layer", "data-test": "outline-layer" }, renderOutline()),
        mousePosition && isBlockItemMoving && handleRenderItemDropTarget(),
        mousePosition &&
            isBlockItemMoving &&
            handleRenderPreviewPlaceholderItem(),
        mousePosition && isBlockItemMoving && (react_1.default.createElement(ItemDragPlaceholder_1.ItemDragPlaceholder, { position: mousePosition, size: GridLayoutConstants_1.PLACEHOLDER_SIZE_PX }))));
};
// Wrapper function that primarily handles the enableGridLayoutCssScaling functionality.
var GridLayout = function (props) {
    var containerWidth = props.containerWidth, _a = props.options, _b = _a === void 0 ? {} : _a, _c = _b.width, canvasWidth = _c === void 0 ? DefaultOptions_1.gridLayoutOptions.width : _c, onLayoutStructureChange = props.onLayoutStructureChange, layoutStructure = props.layoutStructure;
    var enableGridLayoutCssScaling = dashboard_context_1.useFeatureFlags().enableGridLayoutCssScaling;
    var scale = layoutUtils_1.computeScaleToFit(containerWidth, canvasWidth);
    // Undo the scaling when we change the layoutStructure. With the enableGridLayoutCssScaling
    // flag we're now modifying the actual width of the BlockItem so we want to ensure
    // we are using the original unscaled values (1 / scale)
    var handleLayoutStructureChange = react_1.useCallback(function (layout) {
        onLayoutStructureChange(layoutUtils_1.scaleGridLayoutStructureByWidth({
            layout: layout,
            scale: 1 / scale,
        }));
    }, [scale, onLayoutStructureChange]);
    // If we're not scaling the layout we have to scale each blockItem
    var scaledLayoutStructure = react_1.useMemo(function () {
        return !enableGridLayoutCssScaling
            ? layoutUtils_1.scaleGridLayoutStructureByWidth({
                layout: layoutStructure,
                scale: scale,
            })
            : layoutStructure;
    }, [enableGridLayoutCssScaling, layoutStructure, scale]);
    return (react_1.default.createElement(BaseGridLayout, __assign({}, props, { scale: scale, canvasWidth: canvasWidth }, (!enableGridLayoutCssScaling
        ? {
            canvasWidth: containerWidth,
            layoutStructure: scaledLayoutStructure,
            onLayoutStructureChange: handleLayoutStructureChange,
        }
        : null))));
};
GridLayout.schema = gridLayoutOptionsSchema_1.default;
exports.default = GridLayout;


/***/ }),
/* 71 */
/***/ (function(module, exports) {

module.exports = require("memoize-one");

/***/ }),
/* 72 */
/***/ (function(module, exports) {

module.exports = require("@splunk/dashboard-context/CanvasContext");

/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var react_1 = __importStar(__webpack_require__(0));
var lodash_1 = __webpack_require__(36);
var dashboard_context_1 = __webpack_require__(14);
var useEventCallback_1 = __importDefault(__webpack_require__(35));
var useMouseMoveHandler_1 = __importDefault(__webpack_require__(58));
var Canvas_1 = __importDefault(__webpack_require__(30));
var layoutUtils_1 = __webpack_require__(2);
var edgeUtils_1 = __webpack_require__(11);
var defaultState = {
    startPosition: null,
    isMoving: false,
};
var DEFAULT_SELECTED_LAYOUT_ITEMS = [];
var noop = function () { return undefined; };
var GridCanvas = function (props) {
    var _a = props.movable, movable = _a === void 0 ? false : _a, _b = props.selectable, selectable = _b === void 0 ? false : _b, _c = props.selectedLayoutItems, selectedLayoutItems = _c === void 0 ? DEFAULT_SELECTED_LAYOUT_ITEMS : _c, _d = props.panelPadding, panelPadding = _d === void 0 ? 0 : _d, _e = props.scale, scale = _e === void 0 ? 1 : _e, _f = props.onItemMove, onItemMove = _f === void 0 ? noop : _f, _g = props.onItemMoved, onItemMoved = _g === void 0 ? noop : _g, onItemSelected = props.onItemSelected, children = props.children, canvasRef = props.canvasRef, blockItems = props.blockItems, canvasProps = __rest(props, ["movable", "selectable", "selectedLayoutItems", "panelPadding", "scale", "onItemMove", "onItemMoved", "onItemSelected", "children", "canvasRef", "blockItems"]);
    var enableGridLayoutCssScaling = dashboard_context_1.useFeatureFlags().enableGridLayoutCssScaling;
    var _h = __read(react_1.useState(defaultState.startPosition), 2), startPosition = _h[0], setStartPosition = _h[1];
    var _j = __read(react_1.useState(defaultState.isMoving), 2), isMoving = _j[0], setIsMoving = _j[1];
    var resetState = react_1.useCallback(function () {
        setIsMoving(defaultState.isMoving);
        setStartPosition(defaultState.startPosition);
    }, []);
    var mouseScale = enableGridLayoutCssScaling ? scale : 1;
    var handleItemSelected = react_1.useCallback(function (e, itemIds) {
        if (itemIds === void 0) { itemIds = []; }
        if (e.metaKey) {
            // Do not allow selecting block item with meta+click
            var selectedItems = selectedLayoutItems.filter(function (_a) {
                var type = _a.type;
                return type === 'block';
            });
            onItemSelected(e, lodash_1.uniqBy(__spread(selectedItems, itemIds), 'id'));
        }
        else {
            onItemSelected(e, itemIds);
        }
    }, [selectedLayoutItems, onItemSelected]);
    // Track starting position of mouse down event and select blockItem if it's not selected
    var handleMouseDown = react_1.useCallback(function (e) {
        var pos = layoutUtils_1.computeRelativePosition(e, canvasRef, mouseScale);
        var block = layoutUtils_1.findTopBlockItemByPosition(blockItems, pos, panelPadding);
        // always track start position
        if (selectable) {
            setStartPosition(pos);
        }
        if (block) {
            // mouse down on an item, start moving.
            if (!selectedLayoutItems.find(function (_a) {
                var id = _a.id;
                return id === block.item;
            })) {
                // select the block item right away if it's not selected.
                handleItemSelected(e, [{ id: block.item, type: 'block' }]);
            }
            if (movable) {
                setIsMoving(true);
            }
        }
    }, [
        canvasRef,
        mouseScale,
        blockItems,
        selectable,
        selectedLayoutItems,
        handleItemSelected,
        movable,
        panelPadding,
    ]);
    // Trigger onItemMove (callback) with move offset
    var handleMouseMove = useEventCallback_1.default(function (e) {
        if (startPosition) {
            var currentPosition = layoutUtils_1.computeRelativePosition(e, canvasRef, mouseScale);
            if (currentPosition) {
                var offset = layoutUtils_1.getOffset(currentPosition, startPosition);
                if (isMoving && layoutUtils_1.considerMoved(offset)) {
                    e.preventDefault();
                    onItemMove(e, { currentPosition: currentPosition });
                }
            }
        }
    });
    // Trigger onItemMoved (callback) with final offset if an item was moved OR multiselect items within a boundary
    var handleMouseUp = useEventCallback_1.default(function (e) {
        if (startPosition) {
            var currentPosition = layoutUtils_1.computeRelativePosition(e, canvasRef, mouseScale);
            if (currentPosition) {
                // if will be either complete a move or a multi select
                var offset = layoutUtils_1.getOffset(currentPosition, startPosition);
                if (isMoving && layoutUtils_1.considerMoved(offset)) {
                    onItemMoved(e, offset);
                }
                else {
                    // todo: we shouldn't need to use absolute coordinates to figure out which item is clicked, given there's no overlapped visualizations in grid layout. Ideally, we should let the actual viz being clicked update the selectedItem state.
                    var blocks = blockItems;
                    if (panelPadding) {
                        blocks = blocks.map(function (block) {
                            return edgeUtils_1.applyVizPadding({
                                item: block,
                                padding: panelPadding,
                            });
                        });
                    }
                    var boundary = layoutUtils_1.positionsToBoundary(startPosition, currentPosition);
                    var selectedBlocks = layoutUtils_1.filterBlockItemsByBoundary(blocks, boundary).map(function (_a) {
                        var item = _a.item;
                        return ({
                            id: item,
                            type: 'block',
                        });
                    });
                    // select single item
                    var topItem = selectedBlocks[selectedBlocks.length - 1];
                    handleItemSelected(e, topItem ? [topItem] : []);
                }
                resetState();
            }
        }
    });
    react_1.useEffect(function () {
        document.addEventListener('mouseup', handleMouseUp);
        return function () {
            document.removeEventListener('mouseup', handleMouseUp);
        };
    }, [handleMouseUp]);
    useMouseMoveHandler_1.default({ onMouseMove: handleMouseMove, isEnabled: movable });
    return (react_1.default.createElement(Canvas_1.default, __assign({ ref: canvasRef }, canvasProps, { scale: scale, onMouseDown: handleMouseDown, onContextMenu: resetState, cssScaling: enableGridLayoutCssScaling }), children));
};
exports.default = react_1.forwardRef(function (props, ref) { return (react_1.default.createElement(GridCanvas, __assign({ canvasRef: ref }, props))); });


/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * This file is a central location for all shared utility functions related to Grid Layout.
 * If a certain function requires a dependency that lives in another utility file, then
 * that function should live here. If it does not have any dependencies, then it can live
 * in a separate utility file.
 */
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isInvalidAdjacentVizDrop = exports.validateLayoutStructure = exports.getItemEdges = exports.findItemsOutsideBoundary = exports.previewDropOnViz = exports.previewDropOnEdge = exports.updateDropOnViz = exports.findQuadrant = exports.positionInItemBoundary = exports.updateDropOnEdge = exports.isDropOnOwnEdge = exports.updateItems = exports.computeNewVizPositions = exports.sizeToTakeFromViz = exports.computeNewVizPositionsGutterCase = exports.isMouseOnEdge = exports.getDimensions = exports.formatEdgeWrapper = void 0;
var isEqual_1 = __importDefault(__webpack_require__(53));
var isEmpty_1 = __importDefault(__webpack_require__(25));
var i18n_1 = __webpack_require__(27);
var gridLayoutApiUtils_1 = __webpack_require__(59);
var layoutUtils_1 = __webpack_require__(2);
var GridLayoutConstants_1 = __webpack_require__(26);
/**
 * Return a wrapper for the edge, such that this wrapper fills the entire gutter between 2 viz
 * @param {Object} params
 * @param {EdgeItem} params.edge - The edge that this wrapper will go "around"
 * @param {Number} params.padding - The amount of padding between two visualizations
 * @returns {EdgeItem} - Formatted edge such that it fills the gutter space between two visualizations
 */
var formatEdgeWrapper = function (_a) {
    var edge = _a.edge, _b = _a.padding, padding = _b === void 0 ? 0 : _b;
    var wrapperStart = __assign({}, edge.edgeStart);
    var wrapperEnd = __assign({}, edge.edgeEnd);
    if (edge.orientation === 'horizontal') {
        // Add padding to the ends of the edge, to make it line up with visualizations
        wrapperStart.x += padding;
        wrapperEnd.x -= padding;
        // make edge y the top of the gutter (so that when thickness === 2*padding it will fill whole gutter)
        wrapperStart.y -= padding;
        wrapperEnd.y -= padding;
    }
    else {
        // Add padding to the ends of the edge, to make it line up with visualizations
        wrapperStart.y += padding;
        wrapperEnd.y -= padding;
        // make edge x the left-most of the gutter (so that when thickness === 2*padding it will fill whole gutter)
        wrapperStart.x -= padding;
        wrapperEnd.x -= padding;
    }
    return __assign(__assign({}, edge), { edgeStart: wrapperStart, edgeEnd: wrapperEnd });
};
exports.formatEdgeWrapper = formatEdgeWrapper;
var getDimensions = function (_a) {
    var edge = _a.edge, thickness = _a.thickness;
    return {
        width: edge.orientation === 'horizontal'
            ? edge.edgeEnd.x - edge.edgeStart.x
            : thickness,
        height: edge.orientation === 'vertical'
            ? edge.edgeEnd.y - edge.edgeStart.y
            : thickness,
    };
};
exports.getDimensions = getDimensions;
/**
 * Check whether the mouse is on top of the edge
 * @param {Object} params
 * @param {EdgeItem} params.edge - The edge that is being checked
 * @param {Coordinate} params.mousePosition - The position of the mouse on the screen, scaled
 * @param {Number} params.padding - The amount of padding between two visualizations
 * @returns {boolean}
 */
var isMouseOnEdge = function (_a) {
    var edge = _a.edge, mousePosition = _a.mousePosition, _b = _a.padding, padding = _b === void 0 ? 0 : _b;
    var formattedEdge = exports.formatEdgeWrapper({ edge: edge, padding: padding });
    var _c = exports.getDimensions({
        edge: formattedEdge,
        thickness: 2 * padding,
    }), width = _c.width, height = _c.height;
    return (mousePosition.x <= formattedEdge.edgeStart.x + width &&
        mousePosition.x >= formattedEdge.edgeStart.x &&
        mousePosition.y <= formattedEdge.edgeStart.y + height &&
        mousePosition.y >= formattedEdge.edgeStart.y);
};
exports.isMouseOnEdge = isMouseOnEdge;
/**
 * When dropping a viz on a full-width edge, shift all the visualizations below that edge down
 * instead of taking size from the nearby visualizations
 * @param {Object}
 * @param {EdgeItem} params.edge - The edge that is being dropped on. Spans full width of canvas
 * @param {AbsoluteBlockItem} params.itemToMove - The item that is being removed
 * @param {AbsoluteBlockItem[]} params.items - All the items on the canvas
 * @returns {AbsoluteBlockItem[]} - Array of updated items, shifted down to create space for the added viz.
 */
var computeNewVizPositionsGutterCase = function (_a) {
    var edge = _a.edge, itemToMove = _a.itemToMove, items = _a.items;
    var updatedVisualizations = [];
    items.forEach(function (item) {
        if (item.position.y >= edge.edgeStart.y) {
            var viz = item.item === itemToMove.item
                ? __assign(__assign({}, item), { item: 'itemToRemove' }) : item;
            updatedVisualizations.push(__assign(__assign({}, viz), { position: __assign(__assign({}, viz.position), { y: viz.position.y + itemToMove.position.h }) }));
        }
    });
    // Now let's push the moved viz on the updatedVisualizations array
    updatedVisualizations.push(__assign(__assign({}, itemToMove), { position: __assign(__assign({}, itemToMove.position), { y: edge.edgeStart.y, x: edge.edgeStart.x, w: edge.edgeEnd.x - edge.edgeStart.x }) }));
    return updatedVisualizations;
};
exports.computeNewVizPositionsGutterCase = computeNewVizPositionsGutterCase;
/**
 * Determine the amount to take from each viz surrounding an edge that itemToMove is being dropped on
 * @param {Object}
 * @param {EdgeItem} params.edge - The edge that is being dropped on
 * @param {Number} params.amountToTake - The proportion of each viz to take. ex: 1/3
 * @param {Number} params.minWidth - Minimum width a viz can have
 * @param {Number} params.minHeight - Minimum height a viz can have
 * @returns {Object}
 */
var sizeToTakeFromViz = function (_a) {
    var amountToTake = _a.amountToTake, edge = _a.edge, minWidth = _a.minWidth, minHeight = _a.minHeight;
    // When a visualization is dropped, it takes `amountToTake` from each visualization. Thus
    //   it gets 1 size (firstHalf) from one side, and another (secondHalf) from the other side of the edge.
    //    It's not entirely accurate to call them halves, as they are not typically equal.
    var reduction = edge.visualizations.reduce(function (acc, viz) {
        if (acc === null) {
            return null;
        }
        if (edge.orientation === 'vertical') {
            var widthToTake = Math.ceil(viz.position.w * amountToTake);
            if (viz.position.w - widthToTake < minWidth) {
                return null; // if viz is too small, return null
            }
            if (viz.position.x < edge.edgeStart.x) {
                return __assign(__assign({}, acc), { firstHalf: __spread(acc.firstHalf, [widthToTake]) });
            }
            return __assign(__assign({}, acc), { secondHalf: __spread(acc.secondHalf, [widthToTake]) });
        }
        // if edge.orientation === horizontal
        var heightToTake = Math.ceil(viz.position.h * amountToTake);
        if (viz.position.h - heightToTake < minHeight) {
            return null;
        }
        if (viz.position.y < edge.edgeStart.y) {
            return __assign(__assign({}, acc), { firstHalf: __spread(acc.firstHalf, [heightToTake]) });
        }
        return __assign(__assign({}, acc), { secondHalf: __spread(acc.secondHalf, [heightToTake]) });
    }, { firstHalf: [], secondHalf: [] });
    if (reduction === null) {
        // then there was an invalid edge drop because a viz is too small to give its size
        // return null to indicate invalid edge drop
        return {
            firstHalf: null,
            secondHalf: null,
        };
    }
    // If there were no viz on one of the sides, return 0 for the amount to take from that side
    // Otherwise, return the minimum amount to take, to respect the smallest viz on that side
    return {
        firstHalf: reduction.firstHalf.length === 0
            ? 0
            : Math.min.apply(Math, __spread(reduction.firstHalf)),
        secondHalf: reduction.secondHalf.length === 0
            ? 0
            : Math.min.apply(Math, __spread(reduction.secondHalf)),
    };
};
exports.sizeToTakeFromViz = sizeToTakeFromViz;
/**
 * When dropping a viz on a normal edge (not full canvas width), take a proportion from each of the visualizations
 * around the edge, updating those items and inserting the moved viz in the space created
 * @param {Object}
 * @param {EdgeItem} params.edge - The edge that is being dropped on. Spans full width of canvas
 * @param {AbsoluteBlockItem} params.itemToMove - The item that is being moved
 * @param {Number} params.firstHalf - The amount of space moved viz will take up on the left/top sides
 * @param {Number} params.secondHalf - The amount of space moved viz will take up on the right/bottom sides
 * @returns {AbsoluteBlockItem[]} - Array of updated items after the moved viz was added
 */
var computeNewVizPositions = function (_a) {
    var edge = _a.edge, itemToMove = _a.itemToMove, firstHalf = _a.firstHalf, secondHalf = _a.secondHalf;
    // add width to the visualizations surrounding the edge
    var updatedVisualizations = [];
    // Update the visualizations touching the edge that is being dropped on
    edge.visualizations.forEach(function (edgeViz) {
        // Check if the viz is the one that is being moved. This would be the old position of it,
        // since we still need to update the "placeholder".
        var viz = edgeViz.item === itemToMove.item
            ? __assign(__assign({}, edgeViz), { item: 'itemToRemove' }) : edgeViz;
        if (edge.orientation === 'horizontal') {
            if (viz.position.y < edge.edgeStart.y) {
                updatedVisualizations.push(layoutUtils_1.updateBlockItemSize({
                    item: __assign({}, viz),
                    offset: { offsetY: -1 * firstHalf, offsetX: 0 },
                    dir: 's',
                }));
            }
            if (viz.position.y >= edge.edgeStart.y) {
                updatedVisualizations.push(layoutUtils_1.updateBlockItemSize({
                    item: __assign({}, viz),
                    offset: { offsetY: secondHalf, offsetX: 0 },
                    dir: 'n',
                }));
            }
        }
        else {
            if (viz.position.x < edge.edgeStart.x) {
                updatedVisualizations.push(layoutUtils_1.updateBlockItemSize({
                    item: __assign({}, viz),
                    offset: { offsetX: -1 * firstHalf, offsetY: 0 },
                    dir: 'e',
                }));
            }
            if (viz.position.x >= edge.edgeStart.x) {
                updatedVisualizations.push(layoutUtils_1.updateBlockItemSize({
                    item: __assign({}, viz),
                    offset: { offsetX: secondHalf, offsetY: 0 },
                    dir: 'w',
                }));
            }
        }
    });
    // update the moving viz to the new position
    // The offsets represent how much to the left/right (same as up/down)
    //  to offset the new viz from the EDGE position
    updatedVisualizations.push(__assign(__assign({}, itemToMove), { position: {
            x: edge.edgeStart.x -
                (edge.orientation === 'vertical' ? firstHalf : 0),
            y: edge.edgeStart.y -
                (edge.orientation === 'horizontal' ? firstHalf : 0),
            w: edge.orientation === 'vertical'
                ? firstHalf + secondHalf
                : edge.edgeEnd.x - edge.edgeStart.x,
            h: edge.orientation === 'horizontal'
                ? firstHalf + secondHalf
                : edge.edgeEnd.y - edge.edgeStart.y,
        } }));
    return updatedVisualizations;
};
exports.computeNewVizPositions = computeNewVizPositions;
var isResultingVizSizeGreaterThanMin = function (_a) {
    var size = _a.size, edgeOrientation = _a.edgeOrientation;
    if (edgeOrientation === 'vertical') {
        return size >= GridLayoutConstants_1.MIN_WIDTH_PX;
    }
    return size >= GridLayoutConstants_1.MIN_HEIGHT_PX;
};
/**
 * updates the Items into a valid Grid Layout Items List
 * @param {Object} params
 * @param {Object} params.updatedVisualizations visualizations that have been updated
 * @param {Object} params.itemToMove visualization that is being moved (removed)
 * @param {Array} params.items list of visualization items
 * @param {Number} params.canvasWidth width of canvas
 * @returns {Array{}} - returns a combined array of Viz Item Objects
 */
var updateItems = function (_a) {
    var updatedVisualizations = _a.updatedVisualizations, itemToMove = _a.itemToMove, items = _a.items, canvasWidth = _a.canvasWidth;
    // make sure to use the up to date item instead of the old
    var updatedItems = __spread(items.filter(function (item) {
        return updatedVisualizations.find(function (viz) { return viz.item === item.item; }) ===
            undefined;
    }), updatedVisualizations);
    var updatedNeighbors = gridLayoutApiUtils_1.updateRemovedVizNeighbors({
        itemToRemove: itemToMove,
        items: updatedItems,
        width: canvasWidth,
    });
    // Now that we've updated the neighbors of the removed viz, we need
    // to make sure we use the most up to date viz (since updatedVisualizations could potentially be stale)
    var filteredUpdatedVisualizations = updatedVisualizations.filter(function (viz) {
        return updatedNeighbors.find(function (neighbor) { return neighbor.item === viz.item; }) ===
            undefined && viz.item !== 'itemToRemove';
    });
    // items are all visualizations, filter out:
    // 1. the visualizations we updated when we removed the viz from its initial position (updatedNeighbors)
    // 2. the visualizations we updated when we inserted viz into its new position (filteredUpdatedVisualizations)
    // 3. the visualization that was moved to its new position (itemToMove)
    var filteredItems = items.filter(function (viz) {
        return updatedNeighbors.find(function (neighbor) { return neighbor.item === viz.item; }) ===
            undefined &&
            filteredUpdatedVisualizations.find(function (updatedViz) { return updatedViz.item === viz.item; }) === undefined &&
            viz.item !== itemToMove.item;
    });
    return __spread(filteredItems, filteredUpdatedVisualizations, updatedNeighbors);
};
exports.updateItems = updateItems;
/**
 * check if the moving item is dropping on its own edge and the edge has same width/height as item
 * @param {Object} params
 * @param {Object} edge edge being dropped onto
 * @param {Object} itemToMove visualization item being moved
 * @return {Boolean}
 */
var isDropOnOwnEdge = function (_a) {
    var edge = _a.edge, itemToMove = _a.itemToMove;
    return edge.visualizations.find(function (viz) { return viz.item === itemToMove.item; }) != null &&
        ((edge.orientation === 'horizontal' &&
            itemToMove.position.w === edge.edgeEnd.x - edge.edgeStart.x) ||
            (edge.orientation === 'vertical' &&
                itemToMove.position.h === edge.edgeEnd.y - edge.edgeStart.y));
};
exports.isDropOnOwnEdge = isDropOnOwnEdge;
/**
 * Calculates new position values for visualizations being affected from a Visualization being dropped on an Edge
 * @param {Object} params
 * @param {Object} edge edge being dropped onto
 * @param {Object} itemToMove visualization Item being moved
 * @param {Object[]} items array of all visualization Items
 * @param {String} canvasWidth width of canvas
 * @return {Object[]} object of the list of updated visualizations items and updated itemToMove object
 */
var updateDropOnEdge = function (_a) {
    var edge = _a.edge, itemToMove = _a.itemToMove, items = _a.items, canvasWidth = _a.canvasWidth;
    // Do not let user drop a viz on an edge it owns (exactly spans the width/height of that viz)
    if (exports.isDropOnOwnEdge({ edge: edge, itemToMove: itemToMove })) {
        return null;
    }
    // The amount to take from each surrounding visualization
    var amountToTake = 1 / 3;
    var updatedVisualizations = [];
    if (edge.orientation === 'horizontal' &&
        edge.edgeEnd.x - edge.edgeStart.x === canvasWidth) {
        // if we are dropping the visualization on an edge that spans the full width of
        //  the canvas, then we have different behavior: shift all visualizations down
        updatedVisualizations = exports.computeNewVizPositionsGutterCase({
            edge: edge,
            itemToMove: itemToMove,
            items: items,
        });
    }
    else {
        // Check if the visualizations surrounding the drop-target edge have enough space to give in order to insert the moving viz
        // The moved viz gets one half of its size from the visualizations on one side of the edge, and the second half from the
        //  visualizations on the other side of the edge
        var _b = exports.sizeToTakeFromViz({
            amountToTake: amountToTake,
            edge: edge,
            minWidth: GridLayoutConstants_1.MIN_WIDTH_PX,
            minHeight: GridLayoutConstants_1.MIN_HEIGHT_PX,
        }), firstHalf = _b.firstHalf, secondHalf = _b.secondHalf;
        if (firstHalf === null ||
            secondHalf === null ||
            // Check if the moved viz resulting size will be greater than the minimum width/height
            // This particular case occurs when adding to the top and bottom canvas edge
            !isResultingVizSizeGreaterThanMin({
                size: firstHalf + secondHalf,
                edgeOrientation: edge.orientation,
            })) {
            // invalid edge drop, one of the visualizations was too small to give up size
            return null;
        }
        updatedVisualizations = exports.computeNewVizPositions({
            edge: edge,
            itemToMove: itemToMove,
            firstHalf: firstHalf,
            secondHalf: secondHalf,
        });
    }
    // If the edge we move to caused an update to the old position of itemToMove, we need to update that
    // position in order to correctly handle removing the viz in that old position.
    var updatedItemToMove = updatedVisualizations.find(function (viz) { return viz.item === 'itemToRemove'; }) ||
        itemToMove;
    return { updatedVisualizations: updatedVisualizations, updatedItemToMove: updatedItemToMove };
};
exports.updateDropOnEdge = updateDropOnEdge;
/**
 * Given a rectangular Item, determine whether the position is within bounds of the item
 * @param {Object} params
 * @param {Object} params.item visualization item being hovered over
 * @param {Object} params.position position of the mouse over the visualization
 * @returns {Boolean} whether the position is in bounds of the Item
 */
var positionInItemBoundary = function (_a) {
    var item = _a.item, position = _a.position;
    return (position.x >= item.position.x &&
        position.x <= item.position.x + item.position.w &&
        position.y >= item.position.y &&
        position.y <= item.position.y + item.position.h);
};
exports.positionInItemBoundary = positionInItemBoundary;
/**
 * Given a rectangular Item, find the quadrant where position is located on an item
 * where the quadrants are divided by diagonal lines creating four triangles
 * Dividing Line 1: (start: {top left corner}, end: {bottom right corner}) y = f(x) = slope * x
 * Dividing Line 2: (start: {bottom left corner}, end: {top right corner}) y = f(x) = -slope * x
 * @param {Object} params
 * @param {Object} params.item visualization item being hovered over
 * @param {Object} params.position position of the mouse over the visualization
 * @returns {String} returns the quadrant position is in Item oneOf('n', 's', 'w', 'e'), if not in quadrant it returns null
 */
var findQuadrant = function (_a) {
    var item = _a.item, position = _a.position;
    if (exports.positionInItemBoundary({ item: item, position: position })) {
        var x = position.x, y = position.y;
        x -= item.position.x;
        y -= item.position.y;
        var slope = item.position.h / item.position.w;
        var quadrant = void 0;
        if (y > slope * x) {
            quadrant = ['w', 's'];
        }
        else {
            quadrant = ['n', 'e'];
        }
        // If the slope of one diagonal is f(x) = (h/w) * x then the slope of the other (intersecting)
        // diagonal is f(x) = -(h/w) * x + h, so we use the later to determine last quadrant
        return y < -slope * x + item.position.h ? quadrant[0] : quadrant[1];
    }
    return null;
};
exports.findQuadrant = findQuadrant;
/**
 * Calculates the updated position values for the viz being moved and dropped onto
 * @param {Object} params
 * @param {Object} params.itemToMove item that is being moved
 * @param {Object} params.itemToDropOn item that the visualization is being dropped onto
 * @param {String} direction direction item is dropped on oneOf('n', 's', 'w', 'e')
 * @returns {Object[]} an Array containing updated itemToMove and itemToDropOn
 */
var updateDropOnViz = function (_a) {
    var itemToMove = _a.itemToMove, itemToDropOn = _a.itemToDropOn, direction = _a.direction;
    if (((direction === 'e' || direction === 'w') &&
        itemToDropOn.position.w < GridLayoutConstants_1.MIN_WIDTH_PX * 2) ||
        ((direction === 'n' || direction === 's') &&
            itemToDropOn.position.h < GridLayoutConstants_1.MIN_WIDTH_PX * 2)) {
        return null;
    }
    var vizToMove = __assign(__assign({}, itemToMove), { position: itemToDropOn.position });
    var vizTarget = __assign({}, itemToDropOn);
    switch (direction) {
        case 'n':
            vizToMove = layoutUtils_1.updateBlockItemSize({
                item: vizToMove,
                offset: {
                    offsetY: -Math.floor(vizToMove.position.h / 2),
                    offsetX: 0,
                },
                dir: 's',
            });
            vizTarget = layoutUtils_1.updateBlockItemSize({
                item: vizTarget,
                offset: {
                    offsetY: Math.ceil(vizTarget.position.h / 2),
                    offsetX: 0,
                },
                dir: 'n',
            });
            break;
        case 's':
            vizToMove = layoutUtils_1.updateBlockItemSize({
                item: vizToMove,
                offset: {
                    offsetY: Math.floor(vizToMove.position.h / 2),
                    offsetX: 0,
                },
                dir: 'n',
            });
            vizTarget = layoutUtils_1.updateBlockItemSize({
                item: vizTarget,
                offset: {
                    offsetY: -Math.ceil(vizTarget.position.h / 2),
                    offsetX: 0,
                },
                dir: 's',
            });
            break;
        case 'w':
            vizToMove = layoutUtils_1.updateBlockItemSize({
                item: vizToMove,
                offset: {
                    offsetX: -Math.floor(vizToMove.position.w / 2),
                    offsetY: 0,
                },
                dir: 'e',
            });
            vizTarget = layoutUtils_1.updateBlockItemSize({
                item: vizTarget,
                offset: {
                    offsetX: Math.ceil(vizTarget.position.w / 2),
                    offsetY: 0,
                },
                dir: 'w',
            });
            break;
        case 'e':
            vizToMove = layoutUtils_1.updateBlockItemSize({
                item: vizToMove,
                offset: {
                    offsetX: Math.floor(vizToMove.position.w / 2),
                    offsetY: 0,
                },
                dir: 'w',
            });
            vizTarget = layoutUtils_1.updateBlockItemSize({
                item: vizTarget,
                offset: {
                    offsetX: -Math.ceil(vizTarget.position.w / 2),
                    offsetY: 0,
                },
                dir: 'e',
            });
            break;
        default:
            // reset viz to original state so nothing changes
            vizToMove = itemToMove;
            break;
    }
    return [vizToMove, vizTarget];
};
exports.updateDropOnViz = updateDropOnViz;
/**
 * Calculates new viz positions after the itemToMove viz is dropped on edge
 * @param {Object} params
 * @param {Object} params.edge edge being dropped onto
 * @param {Object} params.itemToMove visualization Item being moved
 * @param {Object[]} params.items array of all visualization Items
 * @param {String} params.canvasWidth width of canvas
 * @return {Object[]} object of the list of updated visualizations items, updated itemToMove object, and the old itemToMove
 */
var previewDropOnEdge = function (_a) {
    var edge = _a.edge, itemToMove = _a.itemToMove, items = _a.items, canvasWidth = _a.canvasWidth;
    var updatedItems = exports.updateDropOnEdge({
        edge: edge,
        itemToMove: itemToMove,
        items: items,
        canvasWidth: canvasWidth,
    });
    if (!updatedItems) {
        // If it's an invalid drop, return null
        return null;
    }
    var updatedVisualizations = updatedItems.updatedVisualizations;
    var updatedItemToMove = updatedItems.updatedItemToMove;
    // Take out the old visualization from the updated (if it was updated). This is so that
    //  we can add it below with a unique id 'preview-old-item'
    updatedVisualizations = updatedVisualizations.filter(function (viz) { return !isEqual_1.default(viz, updatedItemToMove); });
    // preview-old-item is the position of the initial item before the move. This is so that we render
    //   empty or a custom component in its place during the preview.
    // For edges, we need this item to correctly re-compute edges around it in the preview.
    return __spread(items.filter(function (item) {
        return updatedVisualizations.find(function (viz) { return viz.item === item.item; }) ===
            undefined;
    }), updatedVisualizations, [
        __assign(__assign({}, updatedItemToMove), { item: 'preview-old-item' }),
    ]);
};
exports.previewDropOnEdge = previewDropOnEdge;
/**
 * Calculates the updated position values for the viz being moved and dropped onto
 * @param {Object} params
 * @param {Object} params.itemToMove item that is being moved
 * @param {Object} params.itemToDropOn item that the visualization is being dropped onto
 * @param {String} direction direction item is dropped on oneOf('n', 's', 'w', 'e')
 * @param {Object[]} items list of all visualizations on canvas
 * @returns {Object[]} an Array containing updated itemToMove and itemToDropOn
 */
var previewDropOnViz = function (_a) {
    var itemToDropOn = _a.itemToDropOn, itemToMove = _a.itemToMove, items = _a.items, direction = _a.direction;
    var updatedItems = exports.updateDropOnViz({
        itemToMove: itemToMove,
        itemToDropOn: itemToDropOn,
        direction: direction,
    });
    if (!updatedItems) {
        // If it's an invalid drop, return null
        return null;
    }
    // preview-old-item is the position of the initial item before the move. This is so that we render
    //   empty or a custom component in its place during the preview
    return __spread(items.filter(function (item) {
        return updatedItems.find(function (viz) { return viz.item === item.item; }) === undefined;
    }), updatedItems, [
        __assign(__assign({}, itemToMove), { item: 'preview-old-item' }),
    ]);
};
exports.previewDropOnViz = previewDropOnViz;
/**
 * Finds items that live outside the canvas boundary, and returns an error message for each item.
 * @param {Object} params
 * @param {Object[]} params.items items in the layout structure of the dashboard
 * @param {Object} params.boundary canvas boundary { x, y, w, h }
 * @returns {Object[]} array of objects out of bounds
 */
var findItemsOutsideBoundary = function (_a) {
    var items = _a.items, boundary = _a.boundary;
    var invalidItems = [];
    var message = i18n_1._('is outside of canvas bounds');
    items.forEach(function (item) {
        if (item.position.x < boundary.x ||
            item.position.x + item.position.w > boundary.x + boundary.w ||
            item.position.y < boundary.y ||
            item.position.y + item.position.h > boundary.y + boundary.h) {
            invalidItems.push({
                itemId: item.item,
                messages: ["\"" + item.item + "\" " + message],
            });
        }
    });
    return invalidItems;
};
exports.findItemsOutsideBoundary = findItemsOutsideBoundary;
/**
 * Gets the 4 edges of every item (top, bottom, left, and right)
 * @param {Object} params
 * @param {Object} params.item item positions { x, y, w, h }
 * @param {Object} [params.belongsTo={}] item to which these edges belong
 * @returns {Object[]} array of edges where edge = { start: { x, y }, end: { x, y } }
 */
var getItemEdges = function (_a) {
    var item = _a.item, _b = _a.belongsTo, belongsTo = _b === void 0 ? {} : _b;
    // create edges in the form: edge.start.{x,y} and edge.end.{x,y}
    var topEdge = {
        start: { x: item.x, y: item.y },
        end: { x: item.x + item.w, y: item.y },
        orientation: 'horizontal',
        type: 'above',
        belongsTo: belongsTo,
    };
    var bottomEdge = {
        start: { x: item.x, y: item.y + item.h },
        end: { x: item.x + item.w, y: item.y + item.h },
        orientation: 'horizontal',
        type: 'below',
        belongsTo: belongsTo,
    };
    var leftEdge = {
        start: { x: item.x, y: item.y },
        end: { x: item.x, y: item.y + item.h },
        orientation: 'vertical',
        type: 'left',
        belongsTo: belongsTo,
    };
    var rightEdge = {
        start: { x: item.x + item.w, y: item.y },
        end: { x: item.x + item.w, y: item.y + item.h },
        orientation: 'vertical',
        type: 'right',
        belongsTo: belongsTo,
    };
    return [topEdge, bottomEdge, leftEdge, rightEdge];
};
exports.getItemEdges = getItemEdges;
/**
 * Create all necessary edges for every item in layout as well as for the canvas
 * @param {Object} params
 * @param {Object[]} params.items items in the layout structure of the dashboard
 * @param {Object} params.canvasBounds canvas boundary { x, y, w, h }
 * @returns {Object[]} an array of edge objects as returned from getItemEdges
 */
var createEdges = function (_a) {
    var items = _a.items, canvasBounds = _a.canvasBounds;
    var edges = [];
    // first, add every item edge
    items.forEach(function (item) {
        edges.push.apply(edges, __spread(exports.getItemEdges({ item: item.position, belongsTo: item.position })));
    });
    // second, need to add canvas edges as well
    edges.push.apply(edges, __spread(exports.getItemEdges({ item: canvasBounds })));
    return edges;
};
/**
 * Find the provided item's invalid edges, which indicate there is a gap or overlap between visualizations
 * @param {Object} params
 * @param {Object} params.item item to find invalid edges for
 * @param {Object[]} params.edges all viz and canvas edges
 * @returns {String[]} an array of error message for each invalid edge
 */
var findInvalidItemEdges = function (_a) {
    var item = _a.item, edges = _a.edges;
    var invalidEdges = [];
    // the current edges of the item we're looking at
    var curEdges = exports.getItemEdges({
        item: item.position,
        belongsTo: item.position,
    });
    curEdges.forEach(function (curEdge) {
        // find one edge which it overlaps. The idea is as follows:
        //   if there is an edge that it overlaps, it means that it is adjacent, and thus this edge is valid
        //   if no adjacent edge is found, it means either there is extra space (gap) or the viz are overlapping
        var overlappingEdge = edges.find(function (edge) {
            if (curEdge.orientation !== edge.orientation ||
                isEqual_1.default(curEdge.belongsTo, edge.belongsTo)) {
                // if the edge is not the same orientation, it can't be overlapping
                // or if the edge is the same, meaning it belongs to same item
                // or if the two items are perfectly overlapping
                return false;
            }
            // if the edges are horizontal and on the same y co-ordinate
            if (curEdge.orientation === 'horizontal' &&
                curEdge.start.y === edge.start.y) {
                // if the edges are not overlapping
                if (curEdge.start.x >= edge.end.x ||
                    edge.start.x >= curEdge.end.x) {
                    return false;
                }
                // otherwise they are overlapping
                return true;
            }
            // if the edges are vertical and on the same x co-ordinate
            if (curEdge.orientation === 'vertical' &&
                curEdge.start.x === edge.start.x) {
                // if the edges are not overlapping
                if (curEdge.start.y >= edge.end.y ||
                    edge.start.y >= curEdge.end.y) {
                    return false;
                }
                return true;
            }
            // this means edge is not on the same co-ordinate/line, can't be overlapping
            return false;
        });
        if (overlappingEdge === undefined) {
            // If no edge was found, this means there is an error in the layout structure
            var positionString = curEdge.orientation === 'horizontal'
                ? "y=" + curEdge.start.y
                : "x=" + curEdge.start.x;
            // differentiate between "above/below" and "to its right/left"
            var positionType = curEdge.type === 'below' || curEdge.type === 'above'
                ? curEdge.type
                : "to its " + curEdge.type;
            invalidEdges.push(i18n_1._("\"" + item.item + "\" expected a viz or canvas edge directly " + positionType + " at " + positionString));
        }
    });
    return invalidEdges;
};
/**
 * Find items that have invalid edges indicating a gap/overlap between visualizations
 * @param {Object} params
 * @param {Object[]} params.items items in the layout structure of the dashboard
 * @param {Object} params.canvasBounds canvas boundary { x, y, w, h }
 * @returns {Object[]} Array of objects containing itemId and error messages
 */
var findInvalidItems = function (_a) {
    var items = _a.items, canvasBounds = _a.canvasBounds;
    var invalidItems = [];
    var edges = createEdges({ items: items, canvasBounds: canvasBounds });
    items.forEach(function (item) {
        var invalidEdges = findInvalidItemEdges({ item: item, edges: edges });
        if (invalidEdges.length > 0) {
            invalidItems.push({
                itemId: item.item,
                messages: invalidEdges,
            });
        }
    });
    return invalidItems;
};
/**
 * validate if layout is valid and return the appropriate error object if it is not
 * @param {Object} params
 * @param {Object[]} params.layout layout structure of the dashboard
 * @param {Object} params.canvasBounds canvas boundary { x, y, w, h }
 * @returns {Object[]} Array of objects containing itemId and error messages
 */
var validateLayoutStructure = function (_a) {
    var layout = _a.layout, canvasBounds = _a.canvasBounds;
    if (!layout) {
        return []; // maybe return object with bool false and message?
    }
    var res = exports.findItemsOutsideBoundary({
        items: layout,
        boundary: canvasBounds,
    });
    // if items are out of boundary, return early
    if (!isEmpty_1.default(res)) {
        return res;
    }
    // if all items are in boundary, check which are invalid
    return findInvalidItems({ items: layout, canvasBounds: canvasBounds });
};
exports.validateLayoutStructure = validateLayoutStructure;
var isVerticallyAligned = function (viz, another) {
    return viz.position.y === another.position.y &&
        viz.position.h === another.position.h;
};
var isHorizontallyAligned = function (viz, another) {
    return viz.position.x === another.position.x &&
        viz.position.w === another.position.w;
};
var isInvalidAdjacentVizDrop = function (_a) {
    /* scenario 1: drop on left/right neighbor */
    var itemToMove = _a.itemToMove, itemToDropOn = _a.itemToDropOn, direction = _a.direction, visualizations = _a.visualizations;
    if (direction === 'e' &&
        gridLayoutApiUtils_1.isLeftNeighbor(itemToMove, itemToDropOn) &&
        isVerticallyAligned(itemToMove, itemToDropOn)) {
        return true;
    }
    if (direction === 'w' &&
        gridLayoutApiUtils_1.isRightNeighbor(itemToMove, itemToDropOn) &&
        isVerticallyAligned(itemToMove, itemToDropOn)) {
        return true;
    }
    if (direction === 'e' || direction === 'w') {
        return false;
    }
    /* scenario 2: drop on top/bottom neighbor */
    var _b = gridLayoutApiUtils_1.findHorizontalNeighbors({
        item: itemToMove,
        visualizations: visualizations,
    }), leftNeighbors = _b.leftNeighbors, rightNeighbors = _b.rightNeighbors;
    // neighbors will occupy the vacant space, so it is valid to move the item
    if (leftNeighbors.length > 0 || rightNeighbors.length > 0) {
        return false;
    }
    if (direction === 'n' &&
        gridLayoutApiUtils_1.isBottomNeighbor(itemToMove, itemToDropOn) &&
        isHorizontallyAligned(itemToMove, itemToDropOn)) {
        return true;
    }
    if (direction === 's' &&
        gridLayoutApiUtils_1.isTopNeighbor(itemToMove, itemToDropOn) &&
        isHorizontallyAligned(itemToMove, itemToDropOn)) {
        return true;
    }
    return false;
};
exports.isInvalidAdjacentVizDrop = isInvalidAdjacentVizDrop;


/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var reject_1 = __importDefault(__webpack_require__(76));
var layout_1 = __webpack_require__(6);
var DefaultOptions_1 = __webpack_require__(9);
var GridLayoutConstants_1 = __webpack_require__(26);
var layoutUtils_1 = __webpack_require__(2);
var gridLayoutApiUtils_1 = __webpack_require__(59);
var layoutApiUtils_1 = __webpack_require__(39);
var blockUtils_1 = __webpack_require__(23);
var BaseLayoutApi_1 = __importDefault(__webpack_require__(28));
var GridLayoutApi = /** @class */ (function (_super) {
    __extends(GridLayoutApi, _super);
    function GridLayoutApi(_a) {
        var layoutStructureRef = _a.layoutStructureRef, _b = _a.options, options = _b === void 0 ? {} : _b, userMessage = _a.userMessage, onVizAdded = _a.onVizAdded, getCanvasDomElement = _a.getCanvasDomElement, telemetry = _a.telemetry;
        var _this = _super.call(this) || this;
        /**
         * Add a new item to grid layout
         * @method
         * @param {Object} options
         * @param {String} options.itemId visualization id
         * @returns {Object[]} updated layout structure
         * @public
         */
        _this.addLayoutItem = function () {
            var _a;
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var _b = layoutApiUtils_1.normalizeAddLayoutItemArgs(args), itemId = _b.itemId, metadata = _b.metadata;
            _this.emitTelemetry({
                pageAction: 'addLayoutItem',
                metadata: metadata,
            });
            // always add new item at the bottom of the root container
            // generate a proposed layout structure
            // it's up to the consumer to apply this structure via setting layoutStructure prop
            var width = (_a = _this.options.width) !== null && _a !== void 0 ? _a : DefaultOptions_1.gridLayoutOptions.width;
            var items = _this.layoutStructureRef.current;
            var newItem = layout_1.computeNewGridStructureItem({
                canvasWidth: width,
                layoutItems: items,
                itemId: itemId,
            });
            _this.onVizAdded();
            return __spread(items, [newItem]);
        };
        /**
         * Remove item specified in itemIds list.
         * Note: Only removes one item even though it accepts a list of item ids.
         * @method
         * @param {string[]} item ids to remove.
         * @returns {object[]} updated layout structure
         * @public
         */
        _this.removeLayoutItems = function (itemIds, metadata) {
            var _a;
            if (itemIds === void 0) { itemIds = []; }
            _this.emitTelemetry({
                pageAction: 'removeLayoutItems',
                metadata: metadata,
            });
            var items = _this.layoutStructureRef.current;
            var itemToRemove = blockUtils_1.getBlockItem({
                layoutStructure: items,
                id: itemIds[0],
            });
            var width = (_a = _this.options.width) !== null && _a !== void 0 ? _a : DefaultOptions_1.gridLayoutOptions.width;
            var updatedItems = gridLayoutApiUtils_1.updateRemovedVizNeighbors({
                itemToRemove: itemToRemove,
                items: items,
                width: width,
            });
            var keys = updatedItems.map(function (item) { return item.item; });
            var filteredItems = items.filter(function (vizItem) {
                return vizItem.item !== itemToRemove.item &&
                    keys.indexOf(vizItem.item) < 0;
            });
            return __spread(updatedItems, filteredItems);
        };
        /**
         * There are 3 actors in this cloning algorithm:
         * 1. Clone Ancestor
         * 2. Left-side Descendant
         * 3. Right-side Descendant
         * @method
         * @param {Object} options
         * @param {String[]} options.from List of original viz ids (ancestors). These id's will be re-used to produce left-side descendants.
         * @param {String[]} options.to List of new viz ids. Has the id's of right-side descendants.
         * @returns {Object[]} Layout structure of all known items
         * @public
         */
        _this.cloneLayoutItems = function (_a) {
            var from = _a.from, to = _a.to, metadata = _a.metadata;
            if (!Array.isArray(from) ||
                !Array.isArray(to) ||
                from.length !== to.length) {
                throw new Error("Cannot clone viz, incorrect inputs from " + from + ", to: " + to);
            }
            _this.emitTelemetry({
                pageAction: 'cloneLayoutItems',
                metadata: metadata,
            });
            // generate a proposed layout structure
            // it's up to the consumer to apply this structure via setting layoutStructure prop
            var items = _this.layoutStructureRef.current;
            var reduction = from.reduce(function (accumulator, fromItemId, index) {
                var ancestor = blockUtils_1.getBlockItem({
                    layoutStructure: items,
                    id: fromItemId,
                });
                if (ancestor.position.w < GridLayoutConstants_1.MIN_WIDTH_PX * 2) {
                    _this.userMessage({
                        message: GridLayoutConstants_1.CLONE_LAYOUT_ITEMS_MSG_PANEL_TOO_SMALL,
                        level: 'warning',
                    });
                    return accumulator;
                }
                // Update the Left-side and Right-side Descendant's position values so that they equally share
                // the Ancestor's space.
                var lsDescendant = layoutUtils_1.updateBlockItemSize({
                    item: __assign({}, ancestor),
                    offset: {
                        offsetX: -1 * Math.floor(ancestor.position.w / 2),
                        offsetY: 0,
                    },
                    dir: 'e',
                });
                var rsDescendant = layoutUtils_1.updateBlockItemSize({
                    item: __assign(__assign({}, ancestor), { item: to[index] }),
                    offset: {
                        offsetX: Math.ceil(ancestor.position.w / 2),
                        offsetY: 0,
                    },
                    dir: 'w',
                });
                // Remove the Ancestor from the accumulator.
                var accumulatorSansAncestor = reject_1.default(accumulator, {
                    item: fromItemId,
                });
                return __spread(accumulatorSansAncestor, [lsDescendant, rsDescendant]);
            }, items);
            return reduction;
        };
        /**
         * Return snapshot as an empty object for the time being
         * @method
         */
        _this.snapshot = function () {
            return {};
        };
        /**
         * Return zoom level as null for now
         * @method
         */
        _this.getZoomLevel = function () {
            return null;
        };
        _this.layoutStructureRef = layoutStructureRef;
        _this.options = options;
        _this.userMessage = userMessage;
        _this.onVizAdded = onVizAdded;
        _this.getCanvasDomElement = getCanvasDomElement;
        _this.telemetry = telemetry;
        return _this;
    }
    return GridLayoutApi;
}(BaseLayoutApi_1.default));
exports.default = GridLayoutApi;


/***/ }),
/* 76 */
/***/ (function(module, exports) {

module.exports = require("lodash/reject");

/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Edge = exports.EdgeComponent = exports.EdgeWrapper = void 0;
var react_1 = __importStar(__webpack_require__(0));
var styled_components_1 = __importDefault(__webpack_require__(1));
var themes_1 = __webpack_require__(4);
var customThemeVariables_1 = __webpack_require__(7);
exports.EdgeWrapper = styled_components_1.default.div.attrs(function (_a) {
    var x = _a.x, y = _a.y, w = _a.w, h = _a.h;
    return {
        style: {
            width: w,
            height: h,
            transform: "translate(" + x + "px, " + y + "px)",
        },
    };
})(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n    display: block;\n    position: absolute;\n    background: transparent;\n    box-sizing: border-box;\n\n    &:hover {\n        cursor: ", ";\n        background: ", ";\n        border: ", ";\n        transition: background 0.2s ease-out;\n    }\n"], ["\n    display: block;\n    position: absolute;\n    background: transparent;\n    box-sizing: border-box;\n\n    &:hover {\n        cursor: ",
    ";\n        background: ",
    ";\n        border: ",
    ";\n        transition: background 0.2s ease-out;\n    }\n"])), function (props) {
    return props.orientation === 'vertical' ? 'col-resize' : 'row-resize';
}, themes_1.pickVariant('appearance', {
    invalid: customThemeVariables_1.customThemeVariables.invalidDropTargetBackgroundColor,
    dropTarget: customThemeVariables_1.customThemeVariables.validDropTargetBackgroundColor,
    normal: 'transparent',
    hidden: 'transparent',
}), themes_1.pickVariant('appearance', {
    invalid: "1px solid " + customThemeVariables_1.customThemeVariables.invalidDropTargetBorderColor,
    dropTarget: "1px solid " + customThemeVariables_1.customThemeVariables.validDropTargetBorderColor,
    normal: 'none',
    hidden: 'none',
}));
exports.EdgeComponent = styled_components_1.default.div.attrs(function (_a) {
    var x = _a.x, y = _a.y, w = _a.w, h = _a.h;
    return {
        style: {
            width: w,
            height: h,
            transform: "translate(" + x + "px, " + y + "px)",
        },
    };
})(templateObject_2 || (templateObject_2 = __makeTemplateObject(["\n    display: block;\n    position: absolute;\n    opacity: 0.35;\n    pointer-events: none;\n    background-color: ", ";\n    ", ":hover + & {\n        opacity: 0.7;\n    }\n"], ["\n    display: block;\n    position: absolute;\n    opacity: 0.35;\n    pointer-events: none;\n    background-color: ",
    ";\n    ", ":hover + & {\n        opacity: 0.7;\n    }\n"])), function (props) {
    return props.appearance === 'dropTarget'
        ? customThemeVariables_1.customThemeVariables.validDropTargetBorderColor
        : themes_1.pick({
            enterprise: themes_1.variables.accentColorL10,
            prisma: themes_1.variables.interactiveColorPrimary,
        });
}, exports.EdgeWrapper);
var Edge = function (_a) {
    var itemId = _a.itemId, x = _a.x, y = _a.y, h = _a.h, w = _a.w, orientation = _a.orientation, isCanvasEdge = _a.isCanvasEdge, _b = _a.padding, padding = _b === void 0 ? 0 : _b, _c = _a.appearance, appearance = _c === void 0 ? 'normal' : _c, onMouseDown = _a.onMouseDown, edgePositionTestHook = _a["data-test-edge-position"];
    var handleMouseDown = react_1.useCallback(function (e) {
        e.preventDefault();
        e.stopPropagation();
        onMouseDown(e, { id: itemId });
    }, [onMouseDown, itemId]);
    /**
     * edges are not rendered if:
     * 1. their appearance is hidden OR
     * 2. edge is a canvas edge AND its appearance is not a dropTarget
     * Exception to this case is the bottom canvas edge which is always visible. Other canvas edges (top, left, right) are visible only when a viz is moving
     * TODO: Follow up with design to re-evaluate display condition for canvas edges as they are currently not discoverable
     */
    if (appearance === 'hidden' ||
        (isCanvasEdge &&
            appearance !== 'dropTarget' &&
            (orientation === 'vertical' || y + padding === 0))) {
        return null;
    }
    var coord = { x: x, y: y, w: w, h: h };
    var shift = padding / 2;
    if (orientation === 'horizontal') {
        coord.y += shift;
        coord.h -= padding;
    }
    if (orientation === 'vertical') {
        coord.x += shift;
        coord.w -= padding;
    }
    return (react_1.default.createElement(react_1.default.Fragment, null,
        react_1.default.createElement(exports.EdgeWrapper, { x: x, y: y, w: w, h: h, orientation: orientation, appearance: appearance, onMouseDown: handleMouseDown, "data-test": "edge", "data-test-edge-position": edgePositionTestHook }),
        react_1.default.createElement(exports.EdgeComponent, { x: coord.x, y: coord.y, w: coord.w, h: coord.h, appearance: appearance })));
};
exports.Edge = Edge;
var templateObject_1, templateObject_2;


/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ItemDragPlaceholder = exports.Placeholder = void 0;
var react_1 = __importStar(__webpack_require__(0));
var styled_components_1 = __importDefault(__webpack_require__(1));
var themes_1 = __webpack_require__(4);
var layoutUtils_1 = __webpack_require__(2);
exports.Placeholder = styled_components_1.default.div.attrs(function (_a) {
    var position = _a.position;
    return ({
        style: layoutUtils_1.positionToStyle(position),
    });
})(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n    background-color: ", ";\n    opacity: 0.75;\n    user-select: none;\n    position: absolute;\n    flex-direction: column;\n    top: 0;\n    left: 0;\n    cursor: move;\n"], ["\n    background-color: ",
    ";\n    opacity: 0.75;\n    user-select: none;\n    position: absolute;\n    flex-direction: column;\n    top: 0;\n    left: 0;\n    cursor: move;\n"])), themes_1.pick({
    enterprise: {
        light: themes_1.variables.backgroundColorHover,
        dark: themes_1.variables.neutral300,
    },
    prisma: themes_1.variables.interactiveColorOverlayDrag,
}));
var ItemDragPlaceholder = function (_a) {
    var position = _a.position, _b = _a.size, size = _b === void 0 ? 128 : _b;
    var placeHolderPosition = react_1.useMemo(function () {
        return {
            // update x and y to be the center of the placeholder
            x: position.x - Math.round(size / 2),
            y: position.y - Math.round(size / 2),
            w: size,
            h: size,
        };
    }, [position, size]);
    return (react_1.default.createElement(exports.Placeholder, { "data-test": "item-drag-placeholder", position: placeHolderPosition }));
};
exports.ItemDragPlaceholder = ItemDragPlaceholder;
var templateObject_1;


/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ItemDropTarget = exports.DropTarget = void 0;
var react_1 = __importStar(__webpack_require__(0));
var styled_components_1 = __importDefault(__webpack_require__(1));
var prop_types_1 = __importDefault(__webpack_require__(3));
var themes_1 = __webpack_require__(4);
var customThemeVariables_1 = __webpack_require__(7);
var layoutUtils_1 = __webpack_require__(2);
var GridLayoutConstants_1 = __webpack_require__(26);
exports.DropTarget = styled_components_1.default.div.attrs(function (_a) {
    var position = _a.position;
    return ({
        style: layoutUtils_1.positionToStyle(position),
    });
})(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n    background-color: ", ";\n    border-width: '1px';\n    border-style: 'solid';\n    border-color: ", ";\n    user-select: none;\n    position: absolute;\n    pointer-events: none;\n"], ["\n    background-color: ",
    ";\n    border-width: '1px';\n    border-style: 'solid';\n    border-color: ",
    ";\n    user-select: none;\n    position: absolute;\n    pointer-events: none;\n"])), themes_1.pickVariant('validDropTarget', {
    true: customThemeVariables_1.customThemeVariables.validDropTargetBackgroundColor,
    false: customThemeVariables_1.customThemeVariables.invalidDropTargetBackgroundColor,
}), themes_1.pickVariant('validDropTarget', {
    true: customThemeVariables_1.customThemeVariables.validDropTargetBorderColor,
    false: customThemeVariables_1.customThemeVariables.invalidDropTargetBorderColor,
}));
var ItemDropTarget = function (_a) {
    var position = _a.position, direction = _a.direction;
    var validDropTarget = ((direction === 'e' || direction === 'w') && position.w >= 128) ||
        ((direction === 'n' || direction === 's') && position.h >= 128);
    var dropTargetPosition = react_1.useMemo(function () {
        var updatedPosition = null;
        switch (direction) {
            case 'n':
                updatedPosition = __assign(__assign({}, position), { h: GridLayoutConstants_1.ITEM_DROP_TARGET_PX });
                break;
            case 's':
                updatedPosition = __assign(__assign({}, position), { y: position.y + position.h - GridLayoutConstants_1.ITEM_DROP_TARGET_PX, h: GridLayoutConstants_1.ITEM_DROP_TARGET_PX });
                break;
            case 'w':
                updatedPosition = __assign(__assign({}, position), { w: GridLayoutConstants_1.ITEM_DROP_TARGET_PX });
                break;
            case 'e':
                updatedPosition = __assign(__assign({}, position), { x: position.x + position.w - GridLayoutConstants_1.ITEM_DROP_TARGET_PX, w: GridLayoutConstants_1.ITEM_DROP_TARGET_PX });
                break;
            default:
                updatedPosition = position;
                break;
        }
        return updatedPosition;
    }, [position, direction]);
    // TO DO: currently with this if,
    // we are only rendering the invalid drop target. Refactor file to only use invalid
    if (validDropTarget) {
        return null;
    }
    return (react_1.default.createElement(exports.DropTarget, { "data-test": "item-drop-target", position: dropTargetPosition, validDropTarget: validDropTarget }));
};
exports.ItemDropTarget = ItemDropTarget;
exports.ItemDropTarget.propTypes = {
    position: prop_types_1.default.shape({
        x: prop_types_1.default.number.isRequired,
        y: prop_types_1.default.number.isRequired,
        w: prop_types_1.default.number.isRequired,
        h: prop_types_1.default.number.isRequired,
    }).isRequired,
    direction: prop_types_1.default.oneOf(['n', 's', 'w', 'e']).isRequired,
};
var templateObject_1;


/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PreviewPlaceholderItem = exports.PlaceholderComponent = void 0;
var react_1 = __importDefault(__webpack_require__(0));
var styled_components_1 = __importDefault(__webpack_require__(1));
var prop_types_1 = __importDefault(__webpack_require__(3));
var customThemeVariables_1 = __webpack_require__(7);
exports.PlaceholderComponent = styled_components_1.default.div.attrs(function (_a) {
    var position = _a.position;
    return ({
        style: {
            width: position.w,
            height: position.h,
            transform: "translate(" + position.x + "px, " + position.y + "px)",
        },
    });
})(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n    display: block;\n    position: absolute;\n    pointer-events: none;\n    box-sizing: border-box;\n    border: 1px solid ", ";\n    background-color: ", ";\n"], ["\n    display: block;\n    position: absolute;\n    pointer-events: none;\n    box-sizing: border-box;\n    border: 1px solid ", ";\n    background-color: ", ";\n"])), customThemeVariables_1.customThemeVariables.validDropTargetBorderColor, customThemeVariables_1.customThemeVariables.validDropTargetBackgroundColor);
var PreviewPlaceholderItem = function (_a) {
    var position = _a.position;
    return (react_1.default.createElement(exports.PlaceholderComponent, { position: position, "data-test": "preview-placeholder", "data-test-preview-position": position.x + "," + position.y + "-" + position.w + "," + position.h }));
};
exports.PreviewPlaceholderItem = PreviewPlaceholderItem;
exports.PreviewPlaceholderItem.propTypes = {
    position: prop_types_1.default.shape({
        x: prop_types_1.default.number.isRequired,
        y: prop_types_1.default.number.isRequired,
        w: prop_types_1.default.number.isRequired,
        h: prop_types_1.default.number.isRequired,
    }).isRequired,
};
var templateObject_1;


/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.gridReducer = exports.initializeGridReducer = exports.getFilteredStructure = exports.hasPreviewItem = exports.getItem = exports.getStructureItem = exports.getItemKeys = exports.filterSelectedItems = exports.getBlockItems = exports.updateItemAction = exports.resetLayoutAction = void 0;
var resetLayoutAction = function (payload) { return ({
    type: 'structure/reset',
    payload: payload,
}); };
exports.resetLayoutAction = resetLayoutAction;
var updateItemAction = function (payload) { return ({
    type: 'structure/update',
    payload: payload,
}); };
exports.updateItemAction = updateItemAction;
var getBlockItems = function (state) {
    return Object.values(state);
};
exports.getBlockItems = getBlockItems;
var filterSelectedItems = function (state, selectedItems) {
    if (selectedItems === void 0) { selectedItems = []; }
    var itemKeys = state.map(function (_a) {
        var item = _a.item;
        return item;
    });
    return selectedItems.filter(function (_a) {
        var id = _a.id;
        return itemKeys.indexOf(id) >= 0;
    });
};
exports.filterSelectedItems = filterSelectedItems;
var getItemKeys = function (state) {
    return Object.keys(state);
};
exports.getItemKeys = getItemKeys;
var getStructureItem = function (state, itemId) {
    return state.find(function (_a) {
        var item = _a.item;
        return item === itemId;
    });
};
exports.getStructureItem = getStructureItem;
var getItem = function (state, itemId) { return state[itemId]; };
exports.getItem = getItem;
var hasPreviewItem = function (state, itemId) {
    if (itemId === void 0) { itemId = 'preview-old-item'; }
    return !!state[itemId];
};
exports.hasPreviewItem = hasPreviewItem;
/**
 * Filter out any items not appearing in layoutStructure as they are currently unknown
 * Add any new items in layoutStructure, keep preview items
 * @param {MappedGridLayout} state reducer state
 * @param {GridLayoutStructure} layoutStructure current known state
 * @returns {GridLayoutStructure} filtered state
 */
var getFilteredStructure = function (state, layoutStructure) {
    var result = [];
    layoutStructure.forEach(function (item) {
        result.push(state[item.item] || item);
    });
    if (exports.hasPreviewItem(state)) {
        result.push(state['preview-old-item']);
    }
    return result;
};
exports.getFilteredStructure = getFilteredStructure;
// Reducer
var initializeGridReducer = function (layoutStructure) {
    if (layoutStructure === void 0) { layoutStructure = []; }
    var gridLayout = {};
    layoutStructure.forEach(function (item) {
        gridLayout[item.item] = item;
    });
    return gridLayout;
};
exports.initializeGridReducer = initializeGridReducer;
// TODO: reducer should probably intelligently handle other pieces of content (e.g. edges) and have additional dispatches to handle resize, move, etc
// TODO: reducer should handle updating multiple items, instead of a complete replacement of state (structure/reset should be a last resort)
var gridReducer = function (state, action) {
    var _a;
    switch (action.type) {
        // TODO: handle more actions (above), to further reduce size of grid code
        // TODO: expand set of reduced state, to limit amount of non-layout data tracked in layout component
        case 'structure/reset':
            return exports.initializeGridReducer(action.payload);
        case 'structure/update':
            return __assign(__assign({}, state), (_a = {}, _a[action.payload.item] = action.payload, _a));
        default:
            return state;
    }
};
exports.gridReducer = gridReducer;


/***/ })
/******/ ]);
//# sourceMappingURL=GridLayout.js.map
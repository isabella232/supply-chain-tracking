{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///external \"react\"","webpack:///external \"styled-components\"","webpack:///./src/utils/layoutUtils.ts","webpack:///external \"prop-types\"","webpack:///external \"@splunk/themes\"","webpack:///external \"@splunk/dashboard-utils/console\"","webpack:///external \"@splunk/dashboard-utils/layout\"","webpack:///external \"@splunk/dashboard-ui/customThemeVariables\"","webpack:///external \"@splunk/themes/mixins\"","webpack:///./src/DefaultOptions.ts","webpack:///external \"lodash/get\"","webpack:///./src/utils/edgeUtils.ts","webpack:///external \"@splunk/dashboard-utils/uniqueId\"","webpack:///./src/commonLayoutOptionsSchema.ts","webpack:///external \"@splunk/dashboard-context\"","webpack:///./src/utils/imageUtils.ts","webpack:///external \"lodash/noop\"","webpack:///external \"lodash/findLast\"","webpack:///external \"lodash/isNumber\"","webpack:///external \"lodash/reduce\"","webpack:///external \"lodash/pullAt\"","webpack:///external \"lodash/cloneDeep\"","webpack:///external \"lodash/sortBy\"","webpack:///./src/utils/blockUtils.ts","webpack:///./src/utils/outlineUtils.ts","webpack:///external \"lodash/isEmpty\"","webpack:///./src/GridLayoutConstants.ts","webpack:///external \"@splunk/ui-utils/i18n\"","webpack:///./src/BaseLayoutApi.ts","webpack:///./src/components/Canvas.tsx","webpack:///external \"@splunk/dashboard-utils/style\"","webpack:///external \"@splunk/dashboard-ui/utils/colorUtils\"","webpack:///./src/hooks/useBackgroundImage.ts","webpack:///./src/components/ResponsiveBox.tsx","webpack:///external \"@splunk/dashboard-ui/hooks/useEventCallback\"","webpack:///external \"lodash\"","webpack:///external \"@splunk/dashboard-telemetry\"","webpack:///external \"@splunk/dashboard-ui/hooks/usePrevious\"","webpack:///./src/utils/layoutApiUtils.ts","webpack:///external \"@splunk/dashboard-utils/deprecated\"","webpack:///external \"lodash/isPlainObject\"","webpack:///./src/components/Layer.jsx","webpack:///./src/components/ResponsiveBlockItem.tsx","webpack:///./src/components/ErrorMessageOverlay.jsx","webpack:///./src/components/ResponsiveBlockOutline.tsx","webpack:///./src/components/Port.tsx","webpack:///external \"@splunk/react-icons/Plus\"","webpack:///./src/components/ResizeHandle.tsx","webpack:///external \"lodash/isEqual\"","webpack:///./src/gridLayoutOptionsSchema.ts","webpack:///external \"@splunk/dashboard-ui/hooks/useMouseMoveHandler\"","webpack:///./src/utils/gridLayoutApiUtils.ts","webpack:///./src/GridLayout.tsx","webpack:///external \"memoize-one\"","webpack:///external \"@splunk/dashboard-context/CanvasContext\"","webpack:///./src/components/GridCanvas.tsx","webpack:///./src/utils/gridUtils.ts","webpack:///./src/apis/GridLayoutApi.ts","webpack:///external \"lodash/reject\"","webpack:///./src/components/Edge.tsx","webpack:///./src/components/ItemDragPlaceholder.tsx","webpack:///./src/components/ItemDropTarget.jsx","webpack:///./src/components/PreviewPlaceholderItem.jsx","webpack:///./src/utils/gridLayoutUtils.ts"],"names":[],"mappings":"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","file":"GridLayout.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 70);\n","module.exports = require(\"react\");","module.exports = require(\"styled-components\");","import findLast from 'lodash/findLast';\nimport get from 'lodash/get';\nimport isNumber from 'lodash/isNumber';\nimport reduce from 'lodash/reduce';\nimport pullAt from 'lodash/pullAt';\nimport cloneDeep from 'lodash/cloneDeep';\nimport sortBy from 'lodash/sortBy';\nimport console from '@splunk/dashboard-utils/console';\nimport {\n    collides,\n    computeMaxHeight as utilsComputeMaxHeight,\n} from '@splunk/dashboard-utils/layout';\nimport type {\n    Coordinate,\n    ConnectedPosition,\n    AbsolutePosition,\n    Port,\n    ConnectedLineItem,\n    ConnectedLinePosition,\n    AbsoluteLayoutStructure,\n    AbsoluteBlockItem,\n    AbsoluteLayoutItem,\n    GridLayoutStructure,\n} from '@splunk/dashboard-types';\nimport { applyVizPadding, getAllEdges } from './edgeUtils';\nimport type { Offset, LineDirection, HandleDirection } from '../types';\n\n// export for gridLayout/legacyGridLayout\nexport const computeMaxHeight = utilsComputeMaxHeight;\n\n/**\n *  check if a position is valid\n * @param {Object} position\n */\nexport const isBlockPositionValid = (position: AbsolutePosition): boolean =>\n    !!(\n        position &&\n        Number.isInteger(position.x) &&\n        Number.isInteger(position.y) &&\n        Number.isInteger(position.w) &&\n        Number.isInteger(position.h)\n    );\n\nexport const isValidConnection = (\n    connection: Coordinate | ConnectedPosition\n): boolean => {\n    if (\n        'x' in connection &&\n        'y' in connection &&\n        Number.isInteger(connection.x) &&\n        Number.isInteger(connection.y)\n    ) {\n        return true;\n    }\n    if (\n        'item' in connection &&\n        'port' in connection &&\n        connection.item != null &&\n        connection.port != null\n    ) {\n        return true;\n    }\n    return false;\n};\n\n/**\n * a line should has from and to\n */\nexport const isLinePositionValid = (\n    position: ConnectedLinePosition\n): boolean => {\n    if (position.from != null && position.to != null) {\n        return (\n            isValidConnection(position.from) && isValidConnection(position.to)\n        );\n    }\n    return false;\n};\n\n/**\n * filter invalid position\n * @param {Object[]} layoutStructure - Array of items (viz, edges, lines)\n * @returns {Object[]} - Returns filtered array\n */\nexport const removeInvalidItems = (\n    layoutStructure: AbsoluteLayoutStructure = []\n): AbsoluteLayoutStructure =>\n    layoutStructure.filter((structure) => {\n        if (structure.type === 'line') {\n            return isLinePositionValid(structure.position);\n        }\n        return isBlockPositionValid(structure.position);\n    });\n\ninterface PositionStyle {\n    width: string;\n    height: string;\n    transform: string;\n}\n\n/**\n * convert position to css object\n */\nexport const positionToStyle = (pos: AbsolutePosition): PositionStyle => ({\n    width: `${pos.w}px`,\n    height: `${pos.h}px`,\n    transform: `translate(${pos.x}px, ${pos.y}px)`,\n});\n\n/**\n * convert position to css string\n */\nexport const positionToStyleString = (pos: AbsolutePosition): string => {\n    const style = positionToStyle(pos);\n    return reduce(style, (result, v, k) => `${result} ${k}:${v};`, '');\n};\n\n/**\n * get client position for given event with scale factor\n */\nexport const getClientPosition = (\n    e: {\n        clientX: number;\n        clientY: number;\n    },\n    scaleFactor = 1\n): Coordinate => ({\n    x: Math.round(e.clientX / scaleFactor),\n    y: Math.round(e.clientY / scaleFactor),\n});\n\n/**\n * compute offset from 2 positions\n */\nexport const getOffset = (\n    currentPosition: Coordinate,\n    startPosition: Coordinate\n): Offset => ({\n    offsetX: currentPosition.x - startPosition.x,\n    offsetY: currentPosition.y - startPosition.y,\n});\n\n/**\n * check if a given offset can be considered as 'move'\n * @param {Object} config\n * @param {Number} config.offsetX\n * @param {Number} config.offsetY\n */\nexport const considerMoved = ({\n    offsetX,\n    offsetY,\n}: {\n    offsetX: number;\n    offsetY: number;\n}): boolean => offsetX !== 0 || offsetY !== 0;\n\n/**\n * return a boundary for 2 positions\n * @param {Coordinate} startPos\n * @param {Coordinate} endPos\n */\nexport const positionsToBoundary = (\n    startPos: Coordinate,\n    endPos: Coordinate\n): AbsolutePosition => ({\n    x: Math.min(startPos.x, endPos.x),\n    y: Math.min(startPos.y, endPos.y),\n    w: Math.abs(startPos.x - endPos.x),\n    h: Math.abs(startPos.y - endPos.y),\n});\n\n/**\n * filter abs items within a boundary\n * @param {Array} items\n * @param {Object} boundary\n */\nexport const filterBlockItemsByBoundary = (\n    items: AbsoluteBlockItem[],\n    boundary: AbsolutePosition\n): AbsoluteBlockItem[] =>\n    items.filter((item) => {\n        const itemPosition = item.position;\n        return !(\n            boundary.x > itemPosition.x + itemPosition.w ||\n            boundary.x + boundary.w < itemPosition.x ||\n            boundary.y > itemPosition.y + itemPosition.h ||\n            boundary.y + boundary.h < itemPosition.y\n        );\n    });\n\n/**\n * find the first item that contains the pos.\n */\nexport const findTopBlockItemByPosition = (\n    items: AbsoluteBlockItem[],\n    pos: Coordinate,\n    padding = 0\n): AbsoluteBlockItem | undefined =>\n    findLast(items, (item) => {\n        const itemPosition = padding\n            ? applyVizPadding({ item, padding }).position\n            : item.position;\n        return (\n            itemPosition.x <= pos.x &&\n            itemPosition.x + itemPosition.w >= pos.x &&\n            itemPosition.y <= pos.y &&\n            itemPosition.y + itemPosition.h >= pos.y\n        );\n    });\n\n/**\n * Compute the new offset so current + new offset will be the multiple of snapTo unit\n * For examples:\n * (5, 2, 5) => 0, user moved less than half of the snapTo unit, return 0 so 5 + 0 = 5\n * (5, 3, 5) => 5, user moved more than half of the snapTo unit, return 5 so 5 + 5 = 5 * 2\n * (5, 12, 5) => 10\n * (5, 13, 5) => 15\n * @param {Number} current\n * @param {Number} offset\n * @param {Number} snapTo\n */\nexport const snapOffset = (\n    current: number,\n    offset: number,\n    snapTo: number\n): number => {\n    // return a new offset\n    const remainder = (current + offset) % snapTo;\n    const newOffset =\n        remainder > snapTo / 2\n            ? offset + (snapTo - remainder)\n            : offset - remainder;\n    return newOffset;\n};\n\ninterface SnapOffsetToXYArgs {\n    position: AbsolutePosition;\n    offset: Offset;\n    gridWidth: number;\n    gridHeight: number;\n    spacing?: number;\n    padding?: number;\n}\n\n/**\n * snap item with its top-left corner (represent by x, y)\n * @param {Object} position\n * @param {Object} offset\n * @param {Number} gridWidth\n * @param {Number} gridHeight\n * @param {Number} spacing\n */\nexport const snapOffsetToXY = ({\n    position,\n    offset,\n    gridWidth,\n    gridHeight,\n    spacing = 0,\n    padding = 0,\n}: SnapOffsetToXYArgs): Offset => {\n    let { offsetX, offsetY } = offset;\n    offsetX = snapOffset(position.x, offsetX, gridWidth + spacing) + padding;\n    offsetY = snapOffset(position.y, offsetY, gridHeight + spacing) + padding;\n    return {\n        offsetX,\n        offsetY,\n    };\n};\n\ntype SnapOffsetToWHArgs = SnapOffsetToXYArgs;\n\n/**\n * snap item with its size (represent by w, h)\n * @param {Object} position\n * @param {Object} offset\n * @param {Number} gridWidth\n * @param {Number} gridHeight\n * @param {Number} spacing\n */\nexport const snapOffsetToWH = ({\n    position,\n    offset,\n    gridWidth,\n    gridHeight,\n    spacing = 0,\n    padding = 0,\n}: SnapOffsetToWHArgs): Offset => {\n    let { offsetX, offsetY } = offset;\n    offsetX =\n        snapOffset(position.x + position.w, offsetX, gridWidth + spacing) +\n        (padding - spacing);\n    offsetY =\n        snapOffset(position.y + position.h, offsetY, gridHeight + spacing) +\n        (padding - spacing);\n    return {\n        offsetX,\n        offsetY,\n    };\n};\n\ninterface UpdateBlockItemSizeArgs {\n    item: AbsoluteBlockItem;\n    offset: Offset;\n    dir: HandleDirection;\n    options?: {\n        minWidth?: number;\n        minHeight?: number;\n    };\n}\n\n/**\n * Mutate item coordinates and/or dimensions.\n * This mutation's new dimensions and coordinates are bounded within the original block item real estate.\n * @param {Object} item\n * @param {Object} offset\n * @param {String} dir Cartesian direction to shift item towards.\n * @param {Object} options\n */\nexport const updateBlockItemSize = ({\n    item,\n    offset,\n    dir,\n    options: { minWidth = 0, minHeight = 0 } = {},\n}: UpdateBlockItemSizeArgs): AbsoluteBlockItem => {\n    const { w, h } = item.position;\n    const { offsetX, offsetY } = offset;\n    const updatedPosition = { ...item.position };\n\n    // resizing from north\n    if (['n', 'ne', 'nw'].includes(dir)) {\n        updatedPosition.y += Math.min(h - minHeight, offsetY);\n        updatedPosition.h -= offsetY;\n    }\n    // resizing from the south\n    if (['s', 'se', 'sw'].includes(dir)) {\n        updatedPosition.h += offsetY;\n    }\n    // resizing from the east\n    if (['e', 'ne', 'se'].includes(dir)) {\n        updatedPosition.w += offsetX;\n    }\n    // resizing from west\n    if (['w', 'nw', 'sw'].includes(dir)) {\n        updatedPosition.x += Math.min(w - minWidth, offsetX);\n        updatedPosition.w -= offsetX;\n    }\n\n    updatedPosition.w = Math.max(minWidth, updatedPosition.w);\n    updatedPosition.h = Math.max(minHeight, updatedPosition.h);\n    return {\n        ...item,\n        position: updatedPosition,\n    };\n};\n\nexport const updateBlockItemPosition = (\n    item: AbsoluteBlockItem,\n    offset: Offset\n): AbsoluteBlockItem => {\n    const { offsetX, offsetY } = offset;\n    return {\n        ...item,\n        position: {\n            ...item.position,\n            x: item.position.x + offsetX,\n            y: item.position.y + offsetY,\n        },\n    };\n};\n\n/**\n * create offset based on dir, x and y\n * @method createOffset\n * @param {String} dir\n * @param {Number} x\n * @param {Number} y\n * @returns {Object} offset\n */\nexport const createOffset = (\n    dir: HandleDirection,\n    x: number,\n    y: number\n): Offset => {\n    switch (dir) {\n        case 'n':\n            return {\n                offsetX: 0,\n                offsetY: -y,\n            };\n        case 's':\n            return {\n                offsetX: 0,\n                offsetY: y,\n            };\n        case 'w':\n            return {\n                offsetX: -x,\n                offsetY: 0,\n            };\n        case 'e':\n            return {\n                offsetX: x,\n                offsetY: 0,\n            };\n        default:\n            return {\n                offsetX: 0,\n                offsetY: 0,\n            };\n    }\n};\n\n/**\n * compute scale factor\n * @param {Number} actualWidth\n * @param {Number} canvasWidth\n */\n\nexport const computeScaleToFit = (\n    actualWidth: number,\n    canvasWidth: number\n): number => {\n    if (\n        !(\n            isNumber(canvasWidth) &&\n            canvasWidth > 0 &&\n            isNumber(actualWidth) &&\n            actualWidth > 0\n        )\n    ) {\n        console.warn(\n            `Failed to calculate layout scale: containerWidth=${actualWidth}, width=${canvasWidth}; falling back to scale=1`\n        );\n        return 1;\n    }\n    return actualWidth / canvasWidth;\n};\n\n/**\n *\n * @param {Array} items\n * @param {Number} from  target item index\n * @param {Number} to    where does this item move to\n */\nexport const moveLayoutItem = (\n    items: AbsoluteLayoutItem[],\n    from: number,\n    to: number\n): AbsoluteLayoutItem[] => {\n    const structure = [...items];\n    const removed = pullAt(structure, [from]);\n    structure.splice(to, 0, removed[0]);\n    return structure;\n};\n\ninterface IsLineConnectedArgs {\n    line: ConnectedLineItem;\n    dir: LineDirection;\n}\n\n/**\n * check if a line is connected\n */\nexport const isLineConnected = ({ line, dir }: IsLineConnectedArgs): boolean =>\n    'item' in line.position[dir];\n\ninterface DisconnectLineArgs {\n    line: ConnectedLineItem;\n    dir: LineDirection;\n    absPos: Coordinate;\n}\n\n/**\n *  disconnect a line from item and set it to abs position\n */\nexport const disconnectLine = ({\n    line,\n    dir,\n    absPos,\n}: DisconnectLineArgs): ConnectedLineItem => {\n    const updatePosition = {\n        ...line.position,\n        [dir]: {\n            ...absPos,\n        },\n    };\n    return {\n        ...line,\n        position: updatePosition,\n    };\n};\n\ninterface ConnectLineArgs {\n    line: ConnectedLineItem;\n    dir: LineDirection;\n    itemId: string;\n    port: Port;\n}\n\n/**\n * connect a line with an item and port\n */\nexport const connectLine = ({\n    line,\n    dir,\n    itemId,\n    port,\n}: ConnectLineArgs): ConnectedLineItem => {\n    const { position } = line;\n    const updatedPosition = {\n        ...position,\n        [dir]: {\n            item: itemId,\n            port,\n        },\n    };\n    return {\n        ...line,\n        position: updatedPosition,\n    };\n};\n\ninterface UpdateLineAbsPositionArgs {\n    line: ConnectedLineItem;\n    dir: LineDirection;\n    offset: Offset;\n}\n\n/**\n * update line absolute position\n */\nexport const updateLineAbsPosition = ({\n    line,\n    dir,\n    offset,\n}: UpdateLineAbsPositionArgs): ConnectedLineItem => {\n    const { offsetX, offsetY } = offset;\n    const { position } = line;\n\n    if (!('x' in position[dir])) {\n        throw Error(\n            `line item ${line.item} does not have x value for its direction ${dir}`\n        );\n    }\n\n    if (!('y' in position[dir])) {\n        throw Error(\n            `line item ${line.item} does not have y value for its direction ${dir}`\n        );\n    }\n\n    const { x, y } = position[dir] as Coordinate;\n\n    return {\n        ...line,\n        position: {\n            ...position,\n            [dir]: {\n                x: x + offsetX,\n                y: y + offsetY,\n            },\n        },\n    };\n};\n\n/**\n *\n * @param {Object} from\n * @param {Object} to\n */\nexport const computeLineBoxPosition = (\n    from: Coordinate,\n    to: Coordinate\n): Coordinate => ({\n    x: Math.min(from.x, to.x),\n    y: Math.min(from.y, to.y),\n});\n\n/**\n *\n * @param {Object} from\n * @param {Object} to\n * @param {Object} box\n */\nexport const computeLineRelativePosition = (\n    from: Coordinate,\n    to: Coordinate,\n    box: Coordinate\n): {\n    from: {\n        x: number;\n        y: number;\n    };\n    to: {\n        x: number;\n        y: number;\n    };\n} => ({\n    from: {\n        x: from.x - box.x,\n        y: from.y - box.y,\n    },\n    to: {\n        x: to.x - box.x,\n        y: to.y - box.y,\n    },\n});\n\n/**\n * Return the bottom coordinate of the layout.\n *\n * @param  {Array} layout Layout array.\n * @return {Number}       Bottom coordinate.\n */\nexport const bottom = (layout: AbsoluteBlockItem[]): number => {\n    return layout.length > 0\n        ? Math.max(\n              ...layout.map(({ position }) => {\n                  return position.y + position.h;\n              })\n          )\n        : 1;\n};\n\n/**\n * Before moving item down, it will check if the movement will cause collisions\n * and move those items down before.\n * @method resolveCompactionCollision\n * @param {Array} layout\n * @param {Object} itemToMove current item which need to be moved to solve the collision\n * @param {Number} moveToCoord the destination coordination of y axis\n * @returns {Array} [newLayout, newItem]\n */\nexport const resolveCompactionCollision = (\n    layout: AbsoluteBlockItem[],\n    itemToMove: AbsoluteBlockItem,\n    moveToCoord: number\n): [AbsoluteBlockItem[], AbsoluteBlockItem] => {\n    let axisVal = itemToMove.position.y;\n    axisVal += 1;\n    let newLayout = cloneDeep(layout);\n    const itemIndex = newLayout.findIndex(\n        (layoutItem) => layoutItem.item === itemToMove.item\n    );\n    const newItem = cloneDeep(itemToMove);\n    newItem.position.y = axisVal;\n    // Go through each item we collide with.\n    // If there is a collision, we will move this collision down, otherwise set y = moveToCoord and return\n    for (let i = itemIndex + 1; i < layout.length; i += 1) {\n        // Optimization: we can break early if we know we're past this el\n        // We can do this b/c it's a sorted layout\n        if (newLayout[i].position.y > newItem.position.y + newItem.position.h) {\n            break;\n        }\n        if (collides(newItem, newLayout[i])) {\n            [newLayout, newLayout[i]] = resolveCompactionCollision(\n                layout,\n                layout[i],\n                moveToCoord + newItem.position.h\n            );\n        }\n    }\n\n    newItem.position.y = moveToCoord;\n    newLayout[itemIndex] = newItem;\n    return [newLayout, newItem];\n};\n\n/**\n * get all collisions given an item and current layout\n * @method getAllCollisions\n * @param {Array} layout\n * @param {Object} layoutItem\n * @returns {Array} sorted layout\n */\nexport const getAllCollisions = (\n    layout: AbsoluteBlockItem[],\n    layoutItem: AbsoluteBlockItem\n): AbsoluteBlockItem[] => {\n    return layout.filter((item) => collides(item, layoutItem));\n};\n\ninterface CloneBlockItemArgs {\n    id: string;\n    item: AbsoluteBlockItem;\n    offsetMultiplier: number;\n}\n\n/**\n * clone a block item\n * @param {Number} id\n * @param {Object} item\n * @param {Number} offsetMultiplier\n */\nexport const cloneBlockItem = ({\n    id,\n    item,\n    offsetMultiplier,\n}: CloneBlockItemArgs): AbsoluteBlockItem => {\n    const copiedPosition = item.position;\n    return {\n        ...item,\n        item: id,\n        position: {\n            x: copiedPosition.x + 20 * offsetMultiplier,\n            y: copiedPosition.y + 20 * offsetMultiplier,\n            w: copiedPosition.w,\n            h: copiedPosition.h,\n        },\n    };\n};\n\ninterface CloneLineArgs {\n    id: string;\n    item: ConnectedLineItem;\n    offsetMultiplier: number;\n}\n\n/**\n * clone an line, it assume the line is not connected\n * @param {Number} id\n * @param {Object} item\n * @param {Number} offsetMultiplier\n */\nexport const cloneLine = ({\n    id,\n    item,\n    offsetMultiplier,\n}: CloneLineArgs): ConnectedLineItem => {\n    const copiedPosition = item.position;\n    return {\n        ...item,\n        item: id,\n        position: {\n            from: {\n                x:\n                    (copiedPosition.from as Coordinate).x +\n                    20 * offsetMultiplier,\n                y:\n                    (copiedPosition.from as Coordinate).y +\n                    20 * offsetMultiplier,\n            },\n            to: {\n                x: (copiedPosition.to as Coordinate).x + 20 * offsetMultiplier,\n                y: (copiedPosition.to as Coordinate).y + 20 * offsetMultiplier,\n            },\n        },\n    };\n};\n\ninterface ShiftViewportOnZoomArgs {\n    scrollLeft: number;\n    scrollTop: number;\n    offsetWidth: number;\n    offsetHeight: number;\n    scaleRatio: number;\n}\n\n/**\n * Calculates new viewport position after a zoom event to keep the previous central point in the center of\n * the scaled canvas. See MR #2030 for algorithm details.\n * @param {Number} scrollLeft viewport left edge offset relative to canvas\n * @param {Number} scrollTop viewport top edge offset relative to canvas\n * @param {Number} offsetWidth viewport width\n * @param {Number} offsetHeight viewport height\n * @param {Number} scaleRatio new scale to old scale ratio\n * @returns {Object} object containing new scrollLeft and scrollTop values\n */\nexport const shiftViewportOnZoom = ({\n    scrollLeft,\n    scrollTop,\n    offsetWidth,\n    offsetHeight,\n    scaleRatio,\n}: ShiftViewportOnZoomArgs): {\n    scrollLeft: number;\n    scrollTop: number;\n} => {\n    const middleOffsetWidth = offsetWidth / 2;\n    const middleOffsetHeight = offsetHeight / 2;\n    return {\n        scrollLeft:\n            (scrollLeft + middleOffsetWidth) * scaleRatio - middleOffsetWidth,\n        scrollTop:\n            (scrollTop + middleOffsetHeight) * scaleRatio - middleOffsetHeight,\n    };\n};\n\n/**\n * return position relative to the canvas rect\n */\nexport const computeRelativePosition = (\n    e: {\n        clientX: number;\n        clientY: number;\n    },\n    canvasRef: unknown,\n    scale = 1\n): Coordinate => {\n    const pos = getClientPosition(e, scale);\n    const canvasDomNode = get(canvasRef, ['current']);\n    const rect = canvasDomNode && canvasDomNode.getBoundingClientRect();\n    if (pos && rect) {\n        return {\n            x: pos.x - rect.left / scale,\n            y: pos.y - rect.top / scale,\n        };\n    }\n    return pos;\n};\n\n/**\n * Scales a GridLayout by stretching the width of each item by the scale factor\n * @param {AbsoluteBlockItem[]} items items to scale\n * @param {Number} scale how much to scale\n */\nexport const scaleGridLayoutStructureByWidth = ({\n    layout,\n    scale = 1,\n}: {\n    layout: GridLayoutStructure;\n    scale?: number;\n}): AbsoluteBlockItem[] => {\n    if (scale === 1) {\n        return layout;\n    }\n\n    // Compute the edges of the existing layout. Since we're scaling\n    // just the X and width we only care about vertical edges.\n    const edges = getAllEdges(layout);\n    const verticalEdges = sortBy(\n        edges.filter((edge) => edge.orientation === 'vertical'),\n        ['edgeStart.x']\n    );\n\n    // Scale the vertical edges and than align the\n    // left and right items to the scaled edge position\n    const newLayout: AbsoluteBlockItem[] = [];\n    verticalEdges.forEach((edge) => {\n        const {\n            visualizations,\n            edgeStart: { x },\n        } = edge;\n        const scaledEdgeX = Math.round(x * scale);\n        const left = visualizations.filter((viz) => viz.position.x < x);\n        const right = visualizations.filter((viz) => viz.position.x >= x);\n\n        // Update the Width of the layout items using the difference between the\n        // newly scaled edge and the existing x\n        left.forEach((layoutItem) => {\n            const newLayoutItem = newLayout.find(\n                ({ item: id }) => layoutItem.item === id\n            );\n\n            if (newLayoutItem) {\n                newLayoutItem.position.w =\n                    scaledEdgeX - newLayoutItem.position.x;\n            }\n        });\n\n        // Since we walk the edges from the left to the right we\n        // ALWAYS have to create the new layout item here but won't\n        // ever need to update it.\n        right.forEach((layoutItem) => {\n            newLayout.push({\n                ...layoutItem,\n                position: {\n                    ...layoutItem.position,\n                    x: scaledEdgeX,\n                },\n            });\n        });\n    });\n\n    return newLayout;\n};\n","module.exports = require(\"prop-types\");","module.exports = require(\"@splunk/themes\");","module.exports = require(\"@splunk/dashboard-utils/console\");","module.exports = require(\"@splunk/dashboard-utils/layout\");","module.exports = require(\"@splunk/dashboard-ui/customThemeVariables\");","module.exports = require(\"@splunk/themes/mixins\");","import {\n    DEFAULT_CANVAS_WIDTH,\n    DEFAULT_CANVAS_HEIGHT,\n} from '@splunk/dashboard-utils/layout';\nimport type {\n    AbsoluteLayoutOptions,\n    GridLayoutOptions,\n} from '@splunk/dashboard-types';\n\nexport const absoluteLayoutOptions: Required<\n    Pick<AbsoluteLayoutOptions, 'width' | 'height' | 'display'>\n> = {\n    width: DEFAULT_CANVAS_WIDTH,\n    height: DEFAULT_CANVAS_HEIGHT,\n    display: 'actual-size',\n};\n\nexport const gridLayoutOptions: Required<\n    Pick<GridLayoutOptions, 'width' | 'gutterSize'>\n> = {\n    width: DEFAULT_CANVAS_WIDTH,\n    gutterSize: 8,\n};\n","module.exports = require(\"lodash/get\");","import { uniqueId } from '@splunk/dashboard-utils/uniqueId';\nimport type {\n    AbsoluteBlockItem,\n    AbsolutePosition,\n    Coordinate,\n} from '@splunk/dashboard-types';\nimport {\n    EdgeItem,\n    VerticalBoundaries,\n    HorizontalBoundaries,\n    EdgeBoundaries,\n} from '../types';\n\nconst nextEdgeId = () => `edge_${uniqueId()}`;\n\n/**\n * generate edge id\n */\nconst getNextEdgeId = () => {\n    return nextEdgeId();\n};\n\ntype Intersections = Record<number, Record<number, AbsoluteBlockItem[]>>;\n\n/**\n * Returns a 2D array of every viz corner, indicating which visualizations touch which node(corner)\n * @param {Object} layoutStructure - Array of visualizations from definition\n * @returns {Object[][]} - {x: { y: [vizList] } }\n */\nconst getNodes = (\n    layoutStructure: AbsoluteBlockItem[]\n): Intersections | null => {\n    if (layoutStructure.length === 0) {\n        return null;\n    }\n\n    const nodes: Intersections = {};\n    layoutStructure.forEach((viz) => {\n        const { x, y, w, h } = viz.position;\n        const corners = [\n            { x, y },\n            { x: x + w, y },\n            { x, y: y + h },\n            { x: x + w, y: y + h },\n        ];\n        corners.forEach((corner) => {\n            if (nodes[corner.x] === undefined) {\n                nodes[corner.x] = {};\n            }\n            if (nodes[corner.x][corner.y] === undefined) {\n                nodes[corner.x][corner.y] = [];\n            }\n            nodes[corner.x][corner.y].push(viz);\n        });\n    });\n    return nodes;\n};\n\nconst isTopEdge = (edge: EdgeItem): boolean =>\n    edge.orientation === 'horizontal' && edge.edgeStart.y === 0;\n\nconst isBottomEdge = (edge: EdgeItem, canvasHeight: number) =>\n    edge.orientation === 'horizontal' && edge.edgeStart.y === canvasHeight;\n\nconst isLeftEdge = (edge: EdgeItem): boolean =>\n    edge.orientation === 'vertical' && edge.edgeStart.x === 0;\n\nconst isRightEdge = (edge: EdgeItem, canvasWidth: number): boolean =>\n    edge.orientation === 'vertical' && edge.edgeStart.x === canvasWidth;\n\n/**\n * Returns all the visualizations along a vertical edge\n * @param {Object} param - Param object needed to traverse along vertical edge\n * @param {num} param.x - x-coordinate of the edge\n * @param {num} param.yStart - y-coordinate of the edge start\n * @param {num} param.yEnd - y-coordinate of the edge end\n * @param {num} param.yCurrent - Current y in recursion\n * @param {num} param.nodes - The map of x,y coordinates to visualizations that touch that (x,y)\n * @param {num} param.visualizations - the list to add visualizations to, and then return\n * @returns {Set<Object>} - Set of unique visualizations along the edge\n */\nconst findVizAlongVerticalEdge = ({\n    x,\n    yStart,\n    yEnd,\n    yCurrent = yStart,\n    nodes,\n    visualizations = new Set(),\n}: {\n    x: number;\n    yStart: number;\n    yEnd: number;\n    yCurrent?: number;\n    nodes: Intersections;\n    visualizations?: Set<AbsoluteBlockItem>;\n}) => {\n    nodes[x][yCurrent].forEach((viz) => {\n        if (viz.position.y >= yStart && viz.position.y < yEnd) {\n            visualizations.add(viz);\n        }\n        if (viz.position.y >= yCurrent && yCurrent + viz.position.h <= yEnd) {\n            findVizAlongVerticalEdge({\n                x,\n                yStart,\n                yEnd,\n                yCurrent: yCurrent + viz.position.h,\n                nodes,\n                visualizations,\n            });\n        }\n    });\n    return visualizations;\n};\n\n/**\n * Returns all the visualizations along a horizontal edge\n * @param {Object} param - Param object needed to traverse along horizontal edge\n * @param {num} param.y - x-coordinate of the edge\n * @param {num} param.xStart - x-coordinate of the edge start\n * @param {num} param.xEnd - x-coordinate of the edge end\n * @param {num} param.xCurrent - Current x in recursion\n * @param {num} param.nodes - The map of x,y coordinates to visualizations that touch that (x,y)\n * @param {num} param.visualizations - the list to add visualizations to, and then return\n * @returns {Set<Object>} - Set of unique visualizations along the edge\n */\nconst findVizAlongHorizontalEdge = ({\n    y,\n    xStart,\n    xEnd,\n    xCurrent = xStart,\n    nodes,\n    visualizations = new Set(),\n}: {\n    y: number;\n    xStart: number;\n    xEnd: number;\n    xCurrent?: number;\n    nodes: Intersections;\n    visualizations?: Set<AbsoluteBlockItem>;\n}) => {\n    nodes[xCurrent][y].forEach((viz) => {\n        if (viz.position.x >= xStart && viz.position.x < xEnd) {\n            visualizations.add(viz);\n        }\n        if (viz.position.x >= xCurrent && xCurrent + viz.position.w <= xEnd) {\n            findVizAlongHorizontalEdge({\n                y,\n                xStart,\n                xEnd,\n                xCurrent: xCurrent + viz.position.w,\n                nodes,\n                visualizations,\n            });\n        }\n    });\n    return visualizations;\n};\n\n/**\n * Add edge to the provided list\n * @param {Object} param - Params containing edge info\n * @param {num} param.edges - the list to add the edge to\n * @param {Object} param.edgeStart - the start of the edge\n * @param {Object} param.edgeEnd - the end of the edge\n * @param {Object[][]} param.nodes - The map of x,y coordinates to visualizations that touch that (x,y)\n */\nconst addEdge = ({\n    edges,\n    edgeStart,\n    edgeEnd,\n    nodes,\n}: {\n    edges: EdgeItem[];\n    edgeStart: Coordinate;\n    edgeEnd: Coordinate;\n    nodes: Intersections;\n}): void => {\n    const orientation = edgeStart.y === edgeEnd.y ? 'horizontal' : 'vertical';\n\n    // Find all visualizations that are affected by this edge\n    const visualizations =\n        orientation === 'vertical'\n            ? findVizAlongVerticalEdge({\n                  x: edgeStart.x,\n                  yStart: edgeStart.y,\n                  yEnd: edgeEnd.y,\n                  nodes,\n              })\n            : findVizAlongHorizontalEdge({\n                  y: edgeStart.y,\n                  xStart: edgeStart.x,\n                  xEnd: edgeEnd.x,\n                  nodes,\n              });\n\n    edges.push({\n        item: getNextEdgeId(),\n        edgeStart,\n        edgeEnd,\n        visualizations: Array.from(visualizations),\n        orientation,\n    });\n};\n\n/**\n * If there is no incoming edge from the top, return true\n * @param {num} y - Current y position to compare against\n * @param {Object[]} visualizations - Array of visualizations attached to the node at (x, y). Length will be 1 to 4.\n * @returns {boolean}\n */\nconst shouldTraverseDown = (\n    y: number,\n    visualizations: AbsoluteBlockItem[]\n): boolean => {\n    return visualizations.every((viz) => viz.position.y >= y);\n};\n\n/**\n * If there is no incoming edge from the left, return true\n * @param {num} x - Current x position to compare against\n * @param {Object[]} visualizations - Array of visualizations attached to the node at (x, y). Length will be 1 to 4.\n * @returns {boolean}\n */\nconst shouldTraverseRight = (\n    x: number,\n    visualizations: AbsoluteBlockItem[]\n): boolean => {\n    return visualizations.every((viz) => viz.position.x >= x);\n};\n\n/**\n * Find the offset to the next node.\n * @param {Object} param - Param object to find offset to next node\n * @param {Number} param.x - The x co-ordinate of the current position to find offset from\n * @param {Number} param.y - The y co-ordinate of the current position to find offset from\n * @param {Object[]} param.visualizations - Array of visualizations attached to the node at (x, y). Length will be 1 to 4.\n * @param {Object} param.visualizations[].position - Position information of the visualization\n * @param {String} param.type - The type of co-ordinate. One of 'w' or 'h'.\n * @returns {number}\n */\nconst findOffset = ({\n    x,\n    y,\n    visualizations,\n    type,\n}: {\n    x: number;\n    y: number;\n    visualizations: AbsoluteBlockItem[];\n    type: 'w' | 'h';\n}): number => {\n    for (let i = 0; i < visualizations.length; i += 1) {\n        const { position } = visualizations[i];\n        if (position.y === y && position.x === x) {\n            return position[type];\n        }\n    }\n\n    // This for-loop is only for finding the bottom canvas edge and the right canvas edge\n    for (let i = 0; i < visualizations.length; i += 1) {\n        const { position } = visualizations[i];\n        if (type === 'w' && position.x === x) {\n            // horizontal canvas edge\n            return position.w;\n        }\n        if (type === 'h' && position.y === y) {\n            // vertical canvas edge\n            return position.h;\n        }\n    }\n\n    return 0;\n};\n\n/**\n * Traverse right along nodes, creating or extending edges\n * @param {Object} param - Param object to traverse right along layout\n * @param {Object[][]} param.nodes - An object that maps {x, y} coord to an array of visualizations. Indexed as nodes[x][y].\n * @param {Object[]} param.edges - The resulting array of edges that gets mutated\n * @param {Number} param.x - x coordinate of current node\n * @param {Number} param.y - y coordinate of current node\n * @param {Object} param.edgeStart - The { x, y } coordinates of start of edge\n * @param {Boolean} param.canTraverseDown - Used to prevent loops during indirect recursion\n */\nfunction traverseRight({\n    x,\n    y,\n    nodes,\n    edges,\n    edgeStart,\n    canTraverseDown = true,\n}: {\n    x: number;\n    y: number;\n    nodes: Intersections;\n    edges: EdgeItem[];\n    edgeStart: Coordinate;\n    canTraverseDown?: boolean;\n}) {\n    // Check if we should traverse down (if there is no incoming edge)\n    // canTraverseRight must be false to avoid endless loop\n    if (canTraverseDown && shouldTraverseDown(y, nodes[x][y])) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        traverseDown({\n            x,\n            y,\n            nodes,\n            edges,\n            edgeStart: { x, y }, // Start new edge when changing directions\n            canTraverseRight: false,\n        });\n    }\n\n    // Check if horizontal edge ends here\n    // 'w' signifies we want width offset returned as opposed to height\n    const offset = findOffset({ x, y, visualizations: nodes[x][y], type: 'w' });\n\n    // Case 1 for ending edge: can't go right anymore (hit a viz OR end of dashboard), create edge up to this point.\n    if (!offset) {\n        addEdge({ edges, edgeStart, edgeEnd: { x, y }, nodes });\n        return;\n    }\n\n    // Case 2 for ending edge: reached window, need to create edge and start new one to avoid merging across window\n    const isWindow = nodes[x][y].length === 4; // 4-way intersection\n    if (isWindow) {\n        addEdge({ edges, edgeStart, edgeEnd: { x, y }, nodes });\n        // Continue traversing right, starting with a new edge from current position\n        traverseRight({\n            x: x + offset,\n            y,\n            nodes,\n            edges,\n            edgeStart: { x, y },\n        });\n        return;\n    }\n\n    // Continue traversing right, merging the past edge with the next\n    traverseRight({\n        x: x + offset,\n        y,\n        nodes,\n        edges,\n        edgeStart,\n    });\n}\n\n/**\n * Traverse right along nodes, creating or extending edges\n * @param {Object} param - Param object to traverse down along layout\n * @param {Object[][]} param.nodes - An object that maps {x, y} coord to an array of visualizations. Indexed as nodes[x][y].\n * @param {Object[]} param.edges - The resulting array of edges that gets mutated\n * @param {Number} param.x - x coordinate of current node\n * @param {Number} param.y - y coordinate of current node\n * @param {Object} param.edgeStart - The { x, y } coordinates of start of edge\n * @param {Boolean} param.canTraverseRight - Used to prevent loops during indirect recursion\n */\nfunction traverseDown({\n    x,\n    y,\n    nodes,\n    edges,\n    edgeStart,\n    canTraverseRight = true,\n}: {\n    x: number;\n    y: number;\n    nodes: Intersections;\n    edges: EdgeItem[];\n    edgeStart: Coordinate;\n    canTraverseRight?: boolean;\n}) {\n    if (canTraverseRight && shouldTraverseRight(x, nodes[x][y])) {\n        traverseRight({\n            x,\n            y,\n            nodes,\n            edges,\n            edgeStart: { x, y }, // Start new edge when changing directions\n            canTraverseDown: false,\n        });\n    }\n\n    // Check if vertical edge ends here\n    const offset = findOffset({ x, y, visualizations: nodes[x][y], type: 'h' });\n\n    // Case 1 for ending edge: can't go down anymore (hit a viz OR end of dashboard), create edge up to this point.\n    if (!offset) {\n        addEdge({ edges, edgeStart, edgeEnd: { x, y }, nodes });\n        return;\n    }\n\n    // Case 2 for ending edge: reached window, need to create edge and start new one to avoid merging across window\n    const isWindow = nodes[x][y].length === 4;\n    if (isWindow) {\n        addEdge({ edges, edgeStart, edgeEnd: { x, y }, nodes });\n        // Start a new edge from current position\n        traverseDown({\n            x,\n            y: y + offset,\n            nodes,\n            edges,\n            edgeStart: { x, y },\n        });\n        return;\n    }\n\n    // Continue traversing, thus \"merging\" edges\n    traverseDown({\n        x,\n        y: y + offset,\n        nodes,\n        edges,\n        edgeStart,\n    });\n}\n\n/**\n * Compute the vertical edges for every canvas row - a row that spans the entire width of the canvas\n * @param {Object} param\n * @param {AbsoluteBlockItem[]} param.layout - Layout structure\n * @param {EdgeItem[]} param.edges - The resulting array of edges that gets mutated\n * @param {Number} param.canvasWidth - Canvas width\n */\nconst computeVerticalCanvasEdges = ({\n    edges,\n    canvasWidth,\n    layout,\n}: {\n    edges: EdgeItem[];\n    canvasWidth: number;\n    layout: AbsoluteBlockItem[];\n}): void => {\n    const nodes = getNodes(layout);\n    if (nodes == null) {\n        return;\n    }\n    // get all the horizontal edges that span the entire canvas width\n    const sortedRowEdges = edges\n        .filter(\n            (edge) =>\n                edge.orientation === 'horizontal' &&\n                edge.edgeStart.x === 0 &&\n                edge.edgeEnd.x === canvasWidth\n        )\n        .sort((a, b) => a.edgeStart.y - b.edgeStart.y);\n\n    /**\n     * iterate through the sorted horizontal edges to get their start and end coordinates\n     * vertical edges between canvas row A and canvas row B will span from edgeStartA to edgeStartB and edgeEndA to edgeEndB\n     */\n    for (let i = 0; i < sortedRowEdges.length - 1; i += 1) {\n        const { edgeStart: edgeStartA, edgeEnd: edgeEndA } = sortedRowEdges[i];\n        const { edgeStart: edgeStartB, edgeEnd: edgeEndB } = sortedRowEdges[\n            i + 1\n        ];\n        addEdge({\n            edges,\n            edgeStart: edgeStartA,\n            edgeEnd: edgeStartB,\n            nodes,\n        });\n        addEdge({\n            edges,\n            edgeStart: edgeEndA,\n            edgeEnd: edgeEndB,\n            nodes,\n        });\n    }\n};\n\n/**\n * Gets all the edges given a layout of AbsoluteBlockItems\n * @param {AbsoluteBlockItem[]} layout - Array of AbsoluteBlockItems\n * @returns {EdgeItem[]} - Array of computed edges\n */\nexport const getAllEdges = (layout: AbsoluteBlockItem[]): EdgeItem[] => {\n    const edges: EdgeItem[] = [];\n    const nodes = getNodes(layout);\n\n    if (nodes === null || nodes[0] === undefined || nodes[0][0] === undefined) {\n        // When no visualizations in the layout structure\n        // OR when there is no visualization at (0,0), which this algorithm assumes\n        return [];\n    }\n    // run the algorithm\n    traverseRight({\n        x: 0,\n        y: 0,\n        nodes,\n        edges,\n        edgeStart: { x: 0, y: 0 },\n    });\n\n    return edges;\n};\n\n/**\n * Compute edges given a valid layout, canvasHeight, and canvasWidth\n * @param {Object} param - Param object containing layout, canvasHeight, canvasWidth\n * @param {Object[]} param.layout - Array of visualizations from the dashboard layout definition\n * @param {Number} param.canvasHeight - Canvas height\n * @param {Number} param.canvasWidth - Canvas width\n * @returns {Object[]} - Array of computed edges\n */\nexport const computeEdges = ({\n    layout,\n    canvasHeight,\n    canvasWidth,\n}: {\n    layout?: AbsoluteBlockItem[];\n    canvasHeight: number;\n    canvasWidth: number;\n}): EdgeItem[] => {\n    if (layout === undefined) {\n        return [];\n    }\n\n    let edges = getAllEdges(layout);\n\n    // remove the computed left and right vertical canvas edges as they span the entire height of the canvas\n    edges = edges.filter((edge) => {\n        return !(isLeftEdge(edge) || isRightEdge(edge, canvasWidth));\n    });\n\n    // recompute the vertical canvas edges for each canvas row where the row spans the entire width of the canvas\n    computeVerticalCanvasEdges({ edges, layout, canvasWidth });\n\n    // Additionally, the top and bottom edge are there, but set to hidden\n    edges = edges.map((edge) => {\n        let isCanvasEdge = false;\n        if (\n            isTopEdge(edge) ||\n            isRightEdge(edge, canvasWidth) ||\n            isBottomEdge(edge, canvasHeight) ||\n            isLeftEdge(edge)\n        ) {\n            isCanvasEdge = true;\n        }\n        return { ...edge, isCanvasEdge };\n    });\n\n    return edges;\n};\n\n/**\n * Format edge according to a given padding and edge thickness\n * @param {Object} param - Param object containing edge, padding, and edgeThickness\n * @param {Object} param.edge - Edge object\n * @param {Number} param.padding - Layout padding\n * @param {Number} param.edgeThickness - Thickness of edge\n * @returns {Object} - Returns formatted edge object\n */\nexport const formatEdge = ({\n    edge,\n    padding = 0,\n    edgeThickness = 0,\n}: {\n    edge: EdgeItem;\n    padding?: number;\n    edgeThickness?: number;\n}): EdgeItem => {\n    // Formatted edges are centered between visualizations and respect the padding (gutter-size) between them\n    const formattedEdgeStart = { ...edge.edgeStart };\n    const formattedEdgeEnd = { ...edge.edgeEnd };\n    if (edge.orientation === 'horizontal') {\n        formattedEdgeStart.x += padding;\n        formattedEdgeStart.y -= edgeThickness / 2;\n        formattedEdgeEnd.x -= padding;\n        formattedEdgeEnd.y -= edgeThickness / 2;\n    } else {\n        formattedEdgeStart.y += padding;\n        formattedEdgeStart.x -= edgeThickness / 2;\n        formattedEdgeEnd.y -= padding;\n        formattedEdgeEnd.x -= edgeThickness / 2;\n    }\n\n    return {\n        ...edge,\n        edgeStart: formattedEdgeStart,\n        edgeEnd: formattedEdgeEnd,\n    };\n};\n\n/**\n * Format visualization according to a given padding\n * @param {Object} param - Param object containing item and padding\n * @param {Object} param.item - Visualization object\n * @param {Number} param.padding - Layout padding\n * @returns {AbsoluteBlockItem} - Returns formatted edge object\n */\nexport const applyVizPadding = ({\n    item,\n    padding = 0,\n}: {\n    item: AbsoluteBlockItem;\n    padding?: number;\n}): AbsoluteBlockItem => {\n    const { x, y, w, h } = item.position;\n    return {\n        ...item,\n        position: {\n            x: x + padding,\n            y: y + padding,\n            w: w - 2 * padding,\n            h: h - 2 * padding,\n        },\n    };\n};\n\n/**\n * Determines Upper and Lower boundaries of an edge given its visualizations around it\n * @param {Object[]} visualizations - The visualizations surrounding the edge\n * @param {Number} y - The y position of the selected edge\n * @param {Number} minHeight - minimum Item Height Value\n * @param {Boolean} isFullWidthEdge - If the edge we are getting boundaries of is the size of canvas width\n * @returns {Object} - returns the boundaries in an object\n */\nexport const getVerticalBoundaries = ({\n    visualizations,\n    y,\n    minHeight,\n    isFullWidthEdge = false,\n}: {\n    visualizations: AbsoluteBlockItem[];\n    y: number;\n    minHeight: number;\n    isFullWidthEdge?: boolean;\n}): VerticalBoundaries => {\n    const boundaries = {\n        upperBoundary: Number.NEGATIVE_INFINITY,\n        lowerBoundary: Number.POSITIVE_INFINITY,\n    };\n\n    const comparePosition = (position: AbsolutePosition) => {\n        // If viz is below of the edge\n        // When the edge is a full width edge, there is no lower boundary\n        //  since dragging down increases canvas size\n        if (position.y >= y && !isFullWidthEdge) {\n            boundaries.lowerBoundary = Math.min(\n                boundaries.lowerBoundary,\n                position.y + position.h - minHeight\n            );\n        }\n        // If viz is above the edge\n        if (position.y < y) {\n            boundaries.upperBoundary = Math.max(\n                boundaries.upperBoundary,\n                position.y + minHeight\n            );\n        }\n    };\n\n    visualizations.forEach((viz) => comparePosition(viz.position));\n    return boundaries;\n};\n\n/**\n * Determines Left and Right boundaries of an edge given its visualizations around it\n * @param {Object[]} visualizations - The visualizations surrounding the edge\n * @param {Number} x - The x position of the selected edge\n * @param {Number} minWidth - minimum Item Width Value\n * @returns {Object} - returns the boundaries in an object\n */\nexport const getHorizontalBoundaries = ({\n    visualizations,\n    x,\n    minWidth,\n}: {\n    visualizations: AbsoluteBlockItem[];\n    x: number;\n    minWidth: number;\n}): HorizontalBoundaries => {\n    const boundaries = {\n        rightBoundary: Number.POSITIVE_INFINITY,\n        leftBoundary: Number.NEGATIVE_INFINITY,\n    };\n\n    const comparePosition = (position: AbsolutePosition) => {\n        if (position.x >= x) {\n            // If viz is to the right of the edge\n            boundaries.rightBoundary = Math.min(\n                boundaries.rightBoundary,\n                position.x + position.w - minWidth\n            );\n        }\n        if (position.x < x) {\n            // If viz is to the left of the edge\n            boundaries.leftBoundary = Math.max(\n                boundaries.leftBoundary,\n                position.x + minWidth\n            );\n        }\n    };\n\n    visualizations.forEach((viz) => comparePosition(viz.position));\n    return boundaries;\n};\n\n/**\n * Determines the next edge position for movement up and down of a horizontal edge\n * @param {Object} edge - the current moving edge\n * @param {Number} offset - offset to move edge\n * @param {Object} options.edgeBoundaries Object with lower/upper boundaries\n * @returns {Object} - returns edge with updated position\n */\nexport const moveHorizontalEdge = ({\n    edge,\n    offset,\n    edgeBoundaries: { upperBoundary, lowerBoundary },\n}: {\n    edge: EdgeItem;\n    offset: number;\n    edgeBoundaries: VerticalBoundaries;\n}): EdgeItem => {\n    // Update edge to either the offset value,\n    // or the defined maximum/minimum based on min viz height/width\n    const updatedY =\n        offset < 0\n            ? Math.max(upperBoundary, edge.edgeStart.y + offset)\n            : Math.min(lowerBoundary, edge.edgeStart.y + offset);\n\n    return {\n        ...edge,\n        edgeStart: {\n            x: edge.edgeStart.x,\n            y: updatedY,\n        },\n        edgeEnd: {\n            x: edge.edgeEnd.x,\n            y: updatedY,\n        },\n    };\n};\n\n/**\n * Determines the next edge position for movement left and right of a vertical edge\n * @param {Object} edge - the current moving edge\n * @param {Number} offset - offset to move edge\n * @param {Object} options.edgeBoundaries Object with left/right boundaries\n * @returns {Object} - returns edge with updated position\n */\nexport const moveVerticalEdge = ({\n    edge,\n    offset,\n    edgeBoundaries: { leftBoundary, rightBoundary },\n}: {\n    edge: EdgeItem;\n    offset: number;\n    edgeBoundaries: HorizontalBoundaries;\n}): EdgeItem => {\n    const updatedX =\n        offset < 0\n            ? Math.max(leftBoundary, edge.edgeStart.x + offset)\n            : Math.min(rightBoundary, edge.edgeStart.x + offset);\n\n    return {\n        ...edge,\n        edgeStart: {\n            x: updatedX,\n            y: edge.edgeStart.y,\n        },\n        edgeEnd: {\n            x: updatedX,\n            y: edge.edgeEnd.y,\n        },\n    };\n};\n\n/**\n * find edges that the given edge should snap to, according to the snap range\n * @param {Object} options\n * @param {Object} options.edge the edge being dragged, edge has the structure\n * @param {array}  options.edges all the edges that are parallel to target edge and within the boundary\n * @param {Number} options.snapRange the range within which that triggers snapping\n * @returns {Object} updatedEdge and snappableEdges\n */\nexport const findSnappableEdges = ({\n    edge,\n    edges,\n    snapRange,\n}: {\n    edge: EdgeItem;\n    edges: EdgeItem[];\n    snapRange: number;\n}): { updatedEdge: EdgeItem; snappableEdges: EdgeItem[] } => {\n    const coordinate = edge.orientation === 'horizontal' ? 'y' : 'x';\n\n    const snappableEdges = edges.reduce<EdgeItem[]>(\n        (currentSnappableEdges, nextEdge) => {\n            const nextEdgeDistance = Math.abs(\n                nextEdge.edgeStart[coordinate] - edge.edgeStart[coordinate]\n            );\n\n            // nextEdge is in range\n            if (nextEdgeDistance <= snapRange) {\n                if (currentSnappableEdges.length === 0) {\n                    return [nextEdge];\n                }\n\n                const lastEdge =\n                    currentSnappableEdges[currentSnappableEdges.length - 1];\n                const lastEdgeDistance = Math.abs(\n                    lastEdge.edgeStart[coordinate] - edge.edgeStart[coordinate]\n                );\n\n                // find new closest snappable edge\n                if (nextEdgeDistance < lastEdgeDistance) {\n                    return [nextEdge];\n                }\n\n                // it is possible there are several snappable edges having the same x or y value\n                if (nextEdgeDistance === lastEdgeDistance) {\n                    return [...currentSnappableEdges, nextEdge];\n                }\n            }\n\n            // nextEdge is out of range\n            return [...currentSnappableEdges];\n        },\n        []\n    );\n\n    // if no snappable edge, snap to itself\n    const firstSnappableEdge =\n        snappableEdges.length > 0 ? snappableEdges[0] : edge;\n\n    return {\n        updatedEdge: {\n            ...edge,\n            edgeStart: {\n                ...edge.edgeStart,\n                [coordinate]: firstSnappableEdge.edgeStart[coordinate],\n            },\n            edgeEnd: {\n                ...edge.edgeEnd,\n                [coordinate]: firstSnappableEdge.edgeEnd[coordinate],\n            },\n        },\n        snappableEdges,\n    };\n};\n\n/**\n * Find all the edges that could be snapped to, given the limitations enforced by the surrounding visualizations.\n * @param {Object} options\n * @param {Object} options.edge the edge being dragged\n * @param {array}  options.edges all the edges on canvas\n * @param {Object} options.edgeBoundaries Object with either lower/upper or left/right boundaries\n * @returns {array} the edges that are within the boundary of the edge being moved\n */\nexport const findEdgesInBoundary = ({\n    edge,\n    edges,\n    edgeBoundaries,\n}: {\n    edge: EdgeItem;\n    edges: EdgeItem[];\n    edgeBoundaries: EdgeBoundaries;\n}): EdgeItem[] => {\n    const { orientation } = edge;\n\n    if (orientation === 'horizontal') {\n        return edges.filter(\n            (e) =>\n                e.orientation === 'horizontal' &&\n                e.edgeStart.y >=\n                    (edgeBoundaries as VerticalBoundaries).upperBoundary &&\n                e.edgeStart.y <=\n                    (edgeBoundaries as VerticalBoundaries).lowerBoundary &&\n                e !== edge\n        );\n    }\n    if (orientation === 'vertical') {\n        return edges.filter(\n            (e) =>\n                e.orientation === 'vertical' &&\n                e.edgeStart.x >=\n                    (edgeBoundaries as HorizontalBoundaries).leftBoundary &&\n                e.edgeStart.x <=\n                    (edgeBoundaries as HorizontalBoundaries).rightBoundary &&\n                e !== edge\n        );\n    }\n    // can't match any edge because the orientation is invalid, this shouldn't happen.\n    return [];\n};\n","module.exports = require(\"@splunk/dashboard-utils/uniqueId\");","export default {\n    showTitleAndDescription: {\n        type: 'boolean',\n        default: true,\n        description:\n            'A Boolean value to determine whether to display the Canvas Title and Description or not.',\n    },\n    submitButton: {\n        type: 'boolean',\n        description:\n            'You can also specify the layout option \"submitButton\". When set to true, a user must click a Submit button in order for the change in input selection to take effect (e.g. rerun searches with new dropdown values). If set to false, or if not specified at all, the dashboard will immediately refresh when a user makes a change in input selection.',\n    },\n    submitOnDashboardLoad: {\n        type: 'boolean',\n        default: false,\n        description:\n            'A Boolean value to determine whether inputs should submit their default values (if they exist) on initial dashboard load in order to allow searches to run once before requiring submit button to be used. To be used when `submitButton` is set to true.',\n    },\n};\n","module.exports = require(\"@splunk/dashboard-context\");","import console from '@splunk/dashboard-utils/console';\nimport isEmpty from 'lodash/isEmpty';\nimport type { BackgroundImageOptions } from '@splunk/dashboard-types';\n\n// /**\n//  * Check whether image src url is valid or not\n//  * @method validImageSrc\n//  * @param {String} src\n//  */\n// export const validImageSrc = src => {\n//     const img = new Image();\n//     img.onerror = () => {\n//         console.error(`Background image url ${src} is invalid`);\n//     };\n//     img.src = src\n// };\n\n/**\n * check if an image is from Image Registry\n * @param {*} src\n */\nexport const isFromImageRegistry = (src = ''): boolean => {\n    const [type] = src.split('://');\n    return (\n        src.indexOf('://') > -1 &&\n        type !== 'http' &&\n        type !== 'https' &&\n        type !== 'ftp' &&\n        type !== 'file'\n    );\n};\n\ninterface ValidImagePosArgs {\n    x?: number;\n    y?: number;\n    canvasWidth: number;\n    canvasHeight: number;\n}\n\n/**\n * Check whether image position is valid or not\n * @method validImagePos\n * @param {Number} x\n * @param {Number} y\n * @param {Number} canvasWidth\n * @param {Number} canvasHeight\n * @returns {Boolean}\n */\nexport const validImagePos = ({\n    x,\n    y,\n    canvasWidth,\n    canvasHeight,\n}: ValidImagePosArgs): boolean =>\n    !!(\n        x != null &&\n        Number.isInteger(x) &&\n        y != null &&\n        Number.isInteger(y) &&\n        x <= canvasWidth &&\n        y <= canvasHeight &&\n        x >= 0 &&\n        y >= 0\n    );\n\n/**\n * Check whether image width and height is valid or not\n * @method validImageWidthHeight\n * @param {Number} imageWidth //Defaulted to 1 because w can't be undefined\n * @param {Number} imageHeight //Defaulted to 1 because h can't be undefined\n * @param {Number} canvasWidth\n * @param {Number} canvasHeight\n * @returns {Boolean}\n */\nexport const validImageWidthHeight = (\n    imageWidth = 1,\n    imageHeight = 1\n): boolean =>\n    !!(\n        Number.isInteger(imageWidth) &&\n        Number.isInteger(imageHeight) &&\n        imageWidth > 0 &&\n        imageHeight > 0\n    );\n\n/**\n * Check whether image size type is valid or not (cover/auto/contain/undefined)\n * @method invalidImageSizeType\n * @param {String} sizeType\n * @returns {Boolean}\n */\nexport const invalidImageSizeType = (sizeType: string): boolean =>\n    !!(\n        sizeType !== 'cover' &&\n        sizeType !== 'contain' &&\n        sizeType !== 'auto' &&\n        sizeType !== undefined\n    );\n\n/**\n * Return the original width and height of a valid image\n * @method getImageWidthHeight\n * @param {String} imgSrc\n * @returns {Number. Number} Image width and height\n */\nexport const getImageDimension = (\n    imgSrc: string\n): { width: number; height: number } => {\n    const img = new Image();\n    try {\n        img.src = imgSrc;\n        img.style.position = 'absolute';\n        img.style.left = '-9999'; // Image width must not exceed 9999 pixels\n        img.style.visibility = 'hidden';\n        document.body.appendChild(img);\n        const height = img.naturalHeight;\n        const width = img.naturalWidth;\n        return { width, height };\n    } catch (ex) {\n        return { width: 0, height: 0 };\n    } finally {\n        if (document.body.contains(img)) {\n            document.body.removeChild(img); // Removes the image from the DOM\n        }\n    }\n};\n\ninterface ValidateBackgroundImageArgs {\n    backgroundImage: BackgroundImageOptions;\n    canvasWidth: number;\n    canvasHeight: number;\n}\n\n/**\n * Check whether background image options are valid or not. Default to x:0, y:0, w:0, h:0 and sizeType:'auto'\n * @method validateBackgroundImage\n * @param {Object} backgroundImage\n * @param {String} backgroundImage.src\n * @param {Number} backgroundImage.x\n * @param {Number} backgroundImage.y\n * @param {Number} backgroundImage.w\n * @param {Number} backgroundImage.h\n * @param {String} backgroundImage.sizeType\n * @param {Number} width\n * @param {Number} height\n * @returns {Object}\n */\nexport const validateBackgroundImage = ({\n    backgroundImage = {},\n    canvasWidth,\n    canvasHeight,\n}: ValidateBackgroundImageArgs): BackgroundImageOptions => {\n    const { src } = backgroundImage;\n    let { x, y, w, h, sizeType } = backgroundImage;\n    if (isEmpty(backgroundImage)) {\n        return { src, x, y, w, h, sizeType };\n    }\n    if (src == null) {\n        return { src, x, y, w, h, sizeType };\n    }\n    // validImageSrc(src); make no sense to validate but not display errors.\n    if (!validImagePos({ x, y, canvasWidth, canvasHeight })) {\n        console.warn(\n            `Invalid background image position, x: ${x} y: ${y}. Defaulting to x: 0, y: 0`\n        );\n        x = 0;\n        y = 0;\n    }\n\n    if (\n        w == null &&\n        h == null &&\n        (sizeType == null || invalidImageSizeType(sizeType))\n    ) {\n        console.warn(\n            `Invalid background image sizeType, ${sizeType}. Defaulting to contain`\n        );\n        sizeType = 'contain';\n    } else if (\n        (sizeType == null || invalidImageSizeType(sizeType)) &&\n        ((w != null && h == null) ||\n            (w == null && h != null) ||\n            !validImageWidthHeight(w, h))\n    ) {\n        console.warn(\n            `Invalid background image width and height, w: ${w} h: ${h}. Defaulting to image original size`\n        );\n        w = w || 0;\n        h = h || 0;\n    }\n    return { src, x, y, w, h, sizeType };\n};\n","module.exports = require(\"lodash/noop\");","module.exports = require(\"lodash/findLast\");","module.exports = require(\"lodash/isNumber\");","module.exports = require(\"lodash/reduce\");","module.exports = require(\"lodash/pullAt\");","module.exports = require(\"lodash/cloneDeep\");","module.exports = require(\"lodash/sortBy\");","import type {\n    AbsoluteLayoutStructure,\n    SelectedItem,\n    AbsoluteBlockItem,\n    Port,\n    Coordinate,\n} from '@splunk/dashboard-types';\nimport type { LayoutStructureState } from '../types';\n\ninterface FindSelectedBlockItemsArgs {\n    layoutStructure: AbsoluteLayoutStructure;\n    selectedItems: SelectedItem[];\n}\n\nexport const findSelectedBlockItems = ({\n    layoutStructure,\n    selectedItems,\n}: FindSelectedBlockItemsArgs): AbsoluteBlockItem[] =>\n    layoutStructure.filter(\n        ({ item, type }) =>\n            selectedItems.findIndex(\n                ({ id }) => item === id && (type === 'block' || !type)\n            ) >= 0\n    ) as AbsoluteBlockItem[];\n\ninterface GetAllBlockItemsArgs {\n    layoutStructure: AbsoluteLayoutStructure;\n    layoutStructureState?: LayoutStructureState;\n}\n\nexport const getAllBlockItems = ({\n    layoutStructure,\n    layoutStructureState = {},\n}: GetAllBlockItemsArgs): AbsoluteBlockItem[] => {\n    return layoutStructure\n        .map((item) => layoutStructureState[item.item] ?? item)\n        .filter(({ type }) => type === 'block' || !type) as AbsoluteBlockItem[];\n};\n\n/**\n * compute port position for a given block item\n * @param {Object} blockItem\n * @param {String} port\n */\nexport const computePortPosition = (\n    blockItem: AbsoluteBlockItem,\n    port: Port\n): Coordinate => {\n    const blockPosition = blockItem.position;\n    switch (port) {\n        case 'n':\n            return {\n                x: Math.round(blockPosition.x + blockPosition.w / 2),\n                y: blockPosition.y,\n            };\n        case 'w':\n            return {\n                x: blockPosition.x,\n                y: Math.round(blockPosition.y + blockPosition.h / 2),\n            };\n        case 'e':\n            return {\n                x: blockPosition.x + blockPosition.w,\n                y: Math.round(blockPosition.y + blockPosition.h / 2),\n            };\n        case 's':\n        default:\n            return {\n                x: Math.round(blockPosition.x + blockPosition.w / 2),\n                y: blockPosition.y + blockPosition.h,\n            };\n    }\n};\n\ninterface GetBlockItemArgs {\n    layoutStructure: AbsoluteLayoutStructure;\n    id: string;\n}\n\nexport const getBlockItem = ({\n    layoutStructure,\n    id,\n}: GetBlockItemArgs): AbsoluteBlockItem => {\n    const blockItem = layoutStructure.find(({ item }) => item === id);\n\n    if (!blockItem || blockItem.type === 'line') {\n        throw Error(`${id} refers to an invalid block item`);\n    }\n\n    return blockItem;\n};\n","/**\n * Compute absolute horizontal position (top/bottom) based on dir\n * @param {String} dir\n * @param {Number} offset\n * @returns {String}\n */\nexport const getVerticalPosition = (dir: string, offset: number): string => {\n    if (dir[0] === 'n') {\n        return `top: -${offset}px`;\n    }\n    if (dir[0] === 's') {\n        return `bottom: -${offset}px`;\n    }\n    return `top: calc(50% - ${offset}px)`;\n};\n\n/**\n * Compute absolute vertical position (left/right) based on dir\n * @param {String} dir\n * @param {Number} offset\n * @returns {String}\n */\nexport const getHorizontalPosition = (dir: string, offset: number): string => {\n    if (dir.slice(-1) === 'w') {\n        return `left: -${offset}px`;\n    }\n    if (dir.slice(-1) === 'e') {\n        return `right: -${offset}px`;\n    }\n    return `left: calc(50% - ${offset}px)`;\n};\n\nexport const HANDLE_DIRECTIONS = [\n    'n',\n    'ne',\n    'e',\n    'se',\n    's',\n    'sw',\n    'w',\n    'nw',\n] as const;\n","module.exports = require(\"lodash/isEmpty\");","import { _ } from '@splunk/ui-utils/i18n';\n\nexport const CLONE_LAYOUT_ITEMS_MSG_PANEL_TOO_SMALL = _(\n    'This panel is too small to be split into duplicates. Stretch or move the panel to make it bigger first.'\n);\nexport const EDGE_THICKNESS_PX = 4;\nexport const GRID_PADDING_PX = 1;\nexport const GRID_SIZE_PX = 10;\nexport const MIN_HEIGHT_PX = 64;\nexport const MIN_WIDTH_PX = 64;\nexport const SNAP_RANGE_PX = 8;\nexport const PLACEHOLDER_SIZE_PX = 128;\nexport const ITEM_DROP_TARGET_PX = 12;\nexport const VIZ_DEFAULT_HEIGHT_PX = 400;\nexport const VIZ_PREVIEW_DELAY_MS = 50;\nexport const EDGE_PREVIEW_DELAY_MS = 500;\n","module.exports = require(\"@splunk/ui-utils/i18n\");","import type { TelemetryAPI } from '@splunk/dashboard-telemetry/';\nimport type { EmittableEvent } from '@splunk/dashboard-telemetry/EventTypes';\nimport type {\n    AbsoluteLayoutOptions,\n    AbsoluteLayoutStructure,\n    GridLayoutStructure,\n} from '@splunk/dashboard-types';\n\n/**\n *\n */\nabstract class BaseLayoutApi {\n    telemetry?: TelemetryAPI;\n\n    emitTelemetry = (payload: EmittableEvent): boolean => {\n        if (!this.telemetry) {\n            return false;\n        }\n\n        this.telemetry.emit({\n            source: 'layoutApi',\n            ...payload,\n        });\n\n        return true;\n    };\n\n    /**\n     * add new layout item\n     */\n    abstract addLayoutItem(\n        ...args: unknown[]\n    ): Promise<AbsoluteLayoutStructure> | GridLayoutStructure;\n\n    /**\n     * copies item w/h and position with an offset\n     */\n    abstract cloneLayoutItems({\n        from,\n        to,\n    }: {\n        from: string[];\n        to: string[];\n    }): Promise<AbsoluteLayoutStructure> | GridLayoutStructure;\n\n    /**\n     * remove an item from layout\n     */\n    abstract removeLayoutItems(\n        vizIds: string[]\n    ): Promise<AbsoluteLayoutStructure> | GridLayoutStructure;\n\n    /**\n     * get dashboard canvas dom element\n     */\n    abstract getCanvasDomElement(): HTMLElement;\n\n    /**\n     * compute snapshot of this layout\n     */\n    abstract snapshot(): AbsoluteLayoutOptions;\n}\n\nexport default BaseLayoutApi;\n","import React, { forwardRef } from 'react';\nimport styled from 'styled-components';\nimport { reset } from '@splunk/themes/mixins';\nimport { variables, pick } from '@splunk/themes';\nimport { toPx, toDimension } from '@splunk/dashboard-utils/style';\nimport { sanitizeColor } from '@splunk/dashboard-ui/utils/colorUtils';\nimport { customThemeVariables } from '@splunk/dashboard-ui/customThemeVariables';\nimport { getImageDimension } from '../utils/imageUtils';\nimport { CanvasProps } from '../types';\nimport { useBackgroundImage } from '../hooks/useBackgroundImage';\n\nconst GRID_LINE_OPACITY = 0.1;\n\ninterface BackgroundProps {\n    width: number;\n    height: number;\n    scale?: number;\n    bgColor?: string | null;\n    bgImageSrc?: string;\n    bgImageWidth?: number;\n    bgImageHeight?: number;\n    bgImageSizeType?: string;\n    bgImagePositionX?: number;\n    bgImagePositionY?: number;\n}\n\ninterface GridLinesProps {\n    width: number;\n    height: number;\n    gridWidth: number;\n    gridHeight: number;\n    gridPadding: number;\n    gridLineWidth: number;\n    gridLineColor?: string;\n    gridLineOpacity?: number;\n}\n\ninterface CanvasContainerProps {\n    width: number;\n    height: number;\n    userSelect: boolean;\n    showOverflowContent: boolean;\n}\n\n/**\n * logic for background image size css.\n * @param {BackgroundProps} props\n */\nconst toBackgroundImageSize = (props: BackgroundProps) => {\n    const { width, height } = getImageDimension(props.bgImageSrc ?? '');\n    if (props.bgImageWidth && props.bgImageHeight) {\n        return `${toPx(props.bgImageWidth)} ${toPx(props.bgImageHeight)}`;\n    }\n    if (props.bgImageWidth || props.bgImageHeight) {\n        return `${toPx(props.bgImageWidth || width)} ${toPx(\n            props.bgImageHeight || height\n        )}`;\n    }\n    if (props.bgImageSizeType) {\n        return props.bgImageSizeType;\n    }\n    return 'contain';\n};\n\n/**\n * make sure to only include image related css when backgroundImageSrc is specified.\n * @param {BackgroundProps} props\n */\nconst toBackgroundImage = (props: BackgroundProps) => {\n    if (props.bgImageSrc) {\n        return `\n            background-repeat: no-repeat;\n            background-image: url(\"${props.bgImageSrc}\");\n            background-size: ${toBackgroundImageSize(props)};\n            background-position:\n                ${toPx(props.bgImagePositionX)} ${toPx(props.bgImagePositionY)};\n        `;\n    }\n    return '';\n};\n\nconst toScale = (scale?: number) => {\n    if (scale) {\n        return `\n            transform: scale(${scale});\n            transform-origin: 0 0;\n        `;\n    }\n    return '';\n};\n\nconst CanvasContainer = styled.div<CanvasContainerProps>`\n    ${reset('block')};\n    ${(prop) => toDimension({ width: prop.width, height: prop.height })};\n    overflow: ${(prop) => (prop.showOverflowContent ? 'visible' : 'hidden')};\n    user-select: ${(prop) => (prop.userSelect ? 'text' : 'none')};\n    position: relative;\n`;\n\n/**\n * A layer that renders canvas with background color/image\n */\nconst Background = styled.div<BackgroundProps>`\n    ${reset('inline-block')};\n    ${(prop) => toDimension({ width: prop.width, height: prop.height })};\n    position: relative;\n    background: ${(prop) =>\n        prop.bgColor ||\n        // NOTE: this needs to match packages/dashboard-editors/src/layouts/AbsoluteLayoutEditor.jsx\n        customThemeVariables.dashboardBackgroundColor};\n    ${(prop) => toBackgroundImage(prop)};\n    ${(prop) => toScale(prop.scale)};\n`;\n\n/**\n * A layer that renders border\n */\nconst Border = styled.div<{ width: number; height: number }>`\n    position: absolute;\n    box-sizing: border-box;\n    border: 2px dashed\n        ${pick({\n            enterprise: {\n                light: variables.gray80,\n                dark: variables.gray30,\n            },\n            prisma: variables.interactiveColorBorder,\n        })};\n    left: 0px;\n    top: 0px;\n    right: 0px;\n    bottom: 0px;\n    ${(prop) => toDimension({ width: prop.width, height: prop.height })};\n`;\n\nconst getGridLineColor = (props: GridLinesProps) =>\n    props.gridLineColor ||\n    pick({\n        light: '#D8D8D8',\n        dark: '#9B9B9B',\n    });\n\n/**\n * A layer that renders grid\n */\nconst GridLines = styled.div<GridLinesProps>`\n    position: absolute;\n    box-sizing: border-box;\n    left: 0px;\n    top: 0px;\n    right: 0px;\n    bottom: 0px;\n    opacity: ${(prop) => prop.gridLineOpacity || GRID_LINE_OPACITY};\n    ${(prop) => toDimension({ width: prop.width, height: prop.height })};\n    background-size: ${(prop) => prop.gridWidth + prop.gridLineWidth}px\n        ${(prop) => prop.gridHeight + prop.gridLineWidth}px;\n    background-image: repeating-linear-gradient(\n            0deg,\n            ${getGridLineColor},\n            ${getGridLineColor} ${(prop) => toPx(prop.gridLineWidth)},\n            transparent ${(prop) => prop.gridLineWidth}px,\n            transparent ${(prop) => prop.gridHeight + prop.gridLineWidth}px\n        ),\n        repeating-linear-gradient(\n            -90deg,\n            ${getGridLineColor},\n            ${getGridLineColor} ${(prop) => toPx(prop.gridLineWidth)},\n            transparent ${(prop) => prop.gridLineWidth}px,\n            transparent ${(prop) => prop.gridWidth + prop.gridLineWidth}px\n        );\n`;\n\n/**\n * Canvas is a component that render background for a layout.\n * All visualizations will be displayed on top of a canvas\n */\nconst Canvas = (\n    {\n        width,\n        height,\n        scale,\n        backgroundColor: unsanitizedBgColor = '',\n        backgroundImageSrc,\n        backgroundImageSizeType,\n        backgroundImageWidth,\n        backgroundImageHeight,\n        backgroundImagePositionX,\n        backgroundImagePositionY,\n        gridLineOpacity,\n        children,\n        showOverflowContent = false,\n        userSelect = false,\n        showGrid = false,\n        gridPadding = 0,\n        gridLineWidth = 1,\n        gridLineColor,\n        gridWidth = 9,\n        gridHeight = 9,\n        showBorder = false,\n        cssScaling = true,\n        ...others\n    }: CanvasProps,\n    canvasRef: React.Ref<HTMLDivElement>\n): JSX.Element => {\n    const imageSrc = useBackgroundImage(backgroundImageSrc);\n\n    const containerWidth = scale != null ? width * scale : width;\n    const containerHeight =\n        scale != null && cssScaling ? height * scale : height;\n    const backgroundColor = sanitizeColor(unsanitizedBgColor);\n\n    return (\n        <CanvasContainer\n            data-test=\"canvas-container\"\n            data-width={containerWidth}\n            data-height={containerHeight}\n            width={cssScaling ? containerWidth : width}\n            height={containerHeight}\n            showOverflowContent={showOverflowContent}\n            userSelect={userSelect}\n            ref={canvasRef}\n            {...others}\n        >\n            <Background\n                data-test=\"canvas\"\n                data-width={width}\n                data-height={height}\n                data-scale={scale}\n                width={cssScaling ? width : containerWidth}\n                height={height}\n                scale={cssScaling ? scale : undefined}\n                bgColor={backgroundColor}\n                bgImageSrc={imageSrc}\n                bgImageSizeType={backgroundImageSizeType}\n                bgImageWidth={backgroundImageWidth}\n                bgImageHeight={backgroundImageHeight}\n                bgImagePositionX={backgroundImagePositionX}\n                bgImagePositionY={backgroundImagePositionY}\n            >\n                {showBorder && <Border width={width} height={height} />}\n                {showGrid && (\n                    <GridLines\n                        width={width}\n                        height={height}\n                        gridLineOpacity={gridLineOpacity}\n                        gridPadding={gridPadding}\n                        gridLineWidth={gridLineWidth}\n                        gridLineColor={gridLineColor}\n                        gridWidth={gridWidth}\n                        gridHeight={gridHeight}\n                    />\n                )}\n                {children}\n            </Background>\n        </CanvasContainer>\n    );\n};\n\nexport default forwardRef(Canvas);\n","module.exports = require(\"@splunk/dashboard-utils/style\");","module.exports = require(\"@splunk/dashboard-ui/utils/colorUtils\");","import { useContext, useEffect, useState } from 'react';\nimport DashboardContext from '@splunk/dashboard-context';\nimport console from '@splunk/dashboard-utils/console';\n\n// temp until the ImageRegistry is typed\ninterface ImageRegistry {\n    getByURL: (url: string) => Promise<{ dataURI: string }>;\n    isResourceURL: (imgSrc: string) => boolean;\n}\n\nexport const useBackgroundImage = (backgroundImageSrc?: string): string => {\n    const [imageSrc, setImageSrc] = useState('');\n    const { imageRegistry } = useContext(DashboardContext);\n\n    /**\n     * Check whether backgroundImage src is a remote image url or stored in the image registry. Fetch if its the latter\n     * @param string backgroundImageSrc\n     */\n    const fetchBackgroundImage = async (\n        registry: ImageRegistry,\n        bgImageSrc: string\n    ) => {\n        try {\n            // use imageRegistry to fetch the image if it's there\n            if (registry) {\n                if (registry.isResourceURL(bgImageSrc)) {\n                    const imageObject = await registry.getByURL(bgImageSrc);\n                    setImageSrc(imageObject.dataURI);\n                } else {\n                    setImageSrc(bgImageSrc);\n                }\n            } else {\n                setImageSrc(bgImageSrc);\n            }\n        } catch (error) {\n            console.error(error); // TODO Refactor error display\n        }\n    };\n\n    useEffect(() => {\n        if (backgroundImageSrc) {\n            fetchBackgroundImage(\n                imageRegistry as ImageRegistry,\n                backgroundImageSrc\n            );\n        }\n    }, [imageRegistry, backgroundImageSrc]);\n\n    return imageSrc;\n};\n","import React from 'react';\nimport styled from 'styled-components';\n\nexport type BorderType = 'hover' | 'select' | 'move' | 'none';\n// TODO: in the new implementation we want to let the parent calculate xywh based on the padding, i.e., call the applyVizPadding() in parent\nexport interface ResponsiveBoxProps {\n    itemId: string;\n    appearance?: 'hidden' | 'visible' | 'highlighted';\n    x: number;\n    y: number;\n    w: number;\n    h: number;\n    'data-test'?: string;\n    children: React.ReactNode;\n}\n\nconst ResponsiveBox = styled.div.attrs<ResponsiveBoxProps>(\n    ({ itemId, x, y, w, h, 'data-test': dataTest }) => ({\n        'data-test': dataTest ?? 'responsive-box',\n        'data-id': itemId,\n        'data-test-viz-item-position': `${x},${y},${w},${h}`,\n        style: {\n            width: `${w}px`,\n            height: `${h}px`,\n            top: `${y}px`,\n            left: `${x}px`,\n        },\n    })\n)<ResponsiveBoxProps>`\n    display: block;\n    position: absolute;\n    background: transparent;\n    pointer-events: none;\n    box-sizing: border-box;\n    visibility: ${(props) => {\n        return props.appearance === 'hidden' ? 'hidden' : 'visible';\n    }};\n    opacity: ${(props) => (props.appearance === 'highlighted' ? 1 : 0.5)};\n`;\n\nResponsiveBox.defaultProps = {\n    appearance: 'highlighted',\n};\n\nexport default ResponsiveBox;\n","module.exports = require(\"@splunk/dashboard-ui/hooks/useEventCallback\");","module.exports = require(\"lodash\");","module.exports = require(\"@splunk/dashboard-telemetry\");","module.exports = require(\"@splunk/dashboard-ui/hooks/usePrevious\");","import type { EmittableEvent } from '@splunk/dashboard-telemetry/EventTypes';\nimport deprecated from '@splunk/dashboard-utils/deprecated';\nimport type { VizContract, VizConfig } from 'dashboard-types';\nimport isPlainObject from 'lodash/isPlainObject';\n\ntype ItemType = 'block' | 'line' | undefined;\n\nexport interface NormalizedAddLayoutItemArgs {\n    itemId: string;\n    vizContract?: VizContract;\n    type: ItemType;\n    config?: VizConfig;\n    metadata?: EmittableEvent['metadata'];\n}\n\nexport type LegacyLayoutApiArgs = [string, VizContract, ItemType];\n\nexport const normalizeAddLayoutItemArgs = (\n    args: [NormalizedAddLayoutItemArgs] | LegacyLayoutApiArgs\n): NormalizedAddLayoutItemArgs => {\n    // make it backward compatible\n    if (args.length === 1 && isPlainObject(args[0])) {\n        return args[0];\n    }\n\n    deprecated(\n        'Calling addLayoutItem with multiple parameters is deprecated. Please use the object form instead.'\n    );\n\n    const [itemId, vizContract, type] = args as LegacyLayoutApiArgs;\n    return {\n        itemId,\n        vizContract,\n        type,\n    };\n};\n","module.exports = require(\"@splunk/dashboard-utils/deprecated\");","module.exports = require(\"lodash/isPlainObject\");","import styled from 'styled-components';\n\n/**\n * A layer that does not block events\n */\nconst Layer = styled.div`\n    position: absolute;\n    top: 0px;\n    left: 0px;\n    right: 0px;\n    bottom: 0px;\n    pointer-events: none;\n`;\n\nexport default Layer;\n","import React, { useMemo } from 'react';\nimport type { ReactElement } from 'react';\nimport ResponsiveBox from './ResponsiveBox';\nimport { ErrorMessageOverlay } from './ErrorMessageOverlay';\nimport type { RenderLayoutItem, OnItemSelected } from '../types';\n\nexport interface ResponsiveBlockItemProps {\n    x: number;\n    y: number;\n    w: number;\n    h: number;\n    canvasHeight: number;\n    itemId: string;\n    renderLayoutItem: RenderLayoutItem;\n    onItemSelected: OnItemSelected;\n    appearance?: 'hidden' | 'visible' | 'highlighted';\n    errorMessages?: string[];\n}\n\n/**\n * layout item that renders block element\n */\nconst ResponsiveBlockItem = (props: ResponsiveBlockItemProps): ReactElement => {\n    const {\n        x,\n        y,\n        w,\n        h,\n        canvasHeight,\n        itemId,\n        errorMessages,\n        onItemSelected,\n        renderLayoutItem,\n        appearance = 'highlighted',\n    } = props;\n\n    const layoutItem = useMemo(\n        () =>\n            renderLayoutItem(\n                itemId,\n                {\n                    width: w,\n                    height: h,\n                    y,\n                    canvasHeight,\n                },\n                'block',\n                onItemSelected\n            ),\n        [renderLayoutItem, itemId, w, h, y, canvasHeight, onItemSelected]\n    );\n\n    return (\n        <ResponsiveBox\n            data-test=\"absolute-item\"\n            itemId={itemId}\n            appearance={appearance}\n            x={x}\n            y={y}\n            w={w}\n            h={h}\n        >\n            {layoutItem}\n            <ErrorMessageOverlay messages={errorMessages} />\n        </ResponsiveBox>\n    );\n};\n\nexport default ResponsiveBlockItem;\n","import React from 'react';\nimport styled from 'styled-components';\nimport T from 'prop-types';\nimport { pick } from '@splunk/themes';\n\nconst ErrorOverlay = styled.div`\n    position: absolute;\n    box-sizing: border-box;\n    top: 0;\n    left: 0;\n    height: 100%;\n    width: 100%;\n    pointer-events: none;\n    background-color: ${pick({\n        light: '#a81916cc',\n        dark: '#a81916b3',\n    })};\n    color: white;\n    overflow: hidden;\n    padding: 8px;\n    z-index: 2;\n`;\n\nexport const MessageContainer = styled.div`\n    padding-top: 8px;\n`;\n\nconst OverlayTitle = styled.div`\n    font-weight: bold;\n`;\n\nexport const ErrorMessageOverlay = ({ messages }) => {\n    if (!messages || messages.length === 0) {\n        return null;\n    }\n    return (\n        <ErrorOverlay data-test=\"error-overlay\">\n            <OverlayTitle>Layout Errors:</OverlayTitle>\n            {messages.map((message) => (\n                <MessageContainer\n                    data-test=\"error-overlay-message\"\n                    key={message}\n                >\n                    {message}\n                </MessageContainer>\n            ))}\n        </ErrorOverlay>\n    );\n};\n\nErrorMessageOverlay.propTypes = {\n    messages: T.arrayOf(T.string),\n};\n","import React, { useState, useCallback, useMemo, useEffect } from 'react';\nimport type { HandleDirection } from '../types';\nimport { HANDLE_DIRECTIONS } from '../utils/outlineUtils';\nimport ResponsiveBox from './ResponsiveBox';\nimport { getClientPosition, getOffset } from '../utils/layoutUtils';\nimport { Port, PORT_DIRECTIONS } from './Port';\nimport type { PortDirection } from './Port';\nimport { ResizeHandle } from './ResizeHandle';\n\nconst noop = (): void => undefined;\n\nexport interface ResponsiveBlockOutlineProps {\n    itemId: string;\n    x: number;\n    y: number;\n    w: number;\n    h: number;\n    scale?: number;\n    connectable?: boolean;\n    resizable?: boolean;\n    onResize?: (\n        e: MouseEvent,\n        itemId: string,\n        offset: { offsetX: number; offsetY: number },\n        resizeDir: HandleDirection\n    ) => void;\n    onResized?: (\n        e: MouseEvent,\n        itemId: string,\n        offset: { offsetX: number; offsetY: number },\n        resizeDir: HandleDirection\n    ) => void;\n    onLineConnect?: (itemId: string, port: PortDirection) => void;\n    onLineDisconnect?: (itemId: string, port: PortDirection) => void;\n    handleDirections?: HandleDirection[];\n}\n\nconst ResponsiveBlockOutline = ({\n    itemId,\n    scale = 1,\n    connectable = false,\n    resizable = false,\n    onResize = noop,\n    onResized = noop,\n    onLineConnect = noop,\n    onLineDisconnect = noop,\n    handleDirections,\n    x,\n    y,\n    w,\n    h,\n}: ResponsiveBlockOutlineProps): JSX.Element => {\n    const [startPosition, setStartPosition] = useState<ReturnType<\n        typeof getClientPosition\n    > | null>(null);\n    const [resizing, setResizing] = useState(false);\n    const [resizeDir, setResizeDir] = useState<HandleDirection | null>(null);\n\n    // Setup start of resize operation\n    const handleResizeMouseDown = useCallback(\n        (e: React.MouseEvent, dir: HandleDirection) => {\n            e.preventDefault();\n            e.stopPropagation();\n            setStartPosition(getClientPosition(e, scale));\n            setResizing(true);\n            setResizeDir(dir);\n        },\n        [scale]\n    );\n\n    // Update size when resizing\n    const handleMouseMove = useCallback(\n        (e: MouseEvent) => {\n            if (startPosition && resizing && resizeDir) {\n                e.preventDefault();\n                const currentPosition = getClientPosition(e, scale);\n                const offset = getOffset(currentPosition, startPosition);\n                onResize(e, itemId, offset, resizeDir);\n            }\n        },\n        [scale, startPosition, resizing, onResize, itemId, resizeDir]\n    );\n\n    // Update final position at end of resize\n    const handleMouseUp = useCallback(\n        (e: MouseEvent) => {\n            if (startPosition && resizing && resizeDir) {\n                e.preventDefault();\n                const currentPosition = getClientPosition(e, scale);\n                const offset = getOffset(currentPosition, startPosition);\n                setStartPosition(null);\n                setResizing(false);\n                setResizeDir(null);\n                onResized(e, itemId, offset, resizeDir);\n            }\n        },\n        [itemId, startPosition, resizing, resizeDir, scale, onResized]\n    );\n\n    // Update line when connecting to port\n    const handlePortEnter = useCallback(\n        (port: PortDirection) => (e: React.MouseEvent) => {\n            e.preventDefault();\n            onLineConnect(itemId, port);\n        },\n        [itemId, onLineConnect]\n    );\n\n    // Update line when disconnecting from port\n    const handlePortLeave = useCallback(\n        (port: PortDirection) => (e: React.MouseEvent) => {\n            e.preventDefault();\n            onLineDisconnect(itemId, port);\n        },\n        [itemId, onLineDisconnect]\n    );\n\n    useEffect(() => {\n        if (resizable) {\n            document.addEventListener('mousemove', handleMouseMove);\n            document.addEventListener('mouseup', handleMouseUp);\n        }\n        return () => {\n            document.removeEventListener('mousemove', handleMouseMove);\n            document.removeEventListener('mouseup', handleMouseUp);\n        };\n    }, [resizable, handleMouseMove, handleMouseUp]);\n\n    // Memoized resize handles\n    const ResizeHandles = useMemo(() => {\n        if (!resizable) {\n            return null;\n        }\n\n        const directions = Array.isArray(handleDirections)\n            ? (handleDirections as Readonly<HandleDirection[]>) // casting as readonly so typescript doesn't think this is mutable\n            : HANDLE_DIRECTIONS;\n\n        return directions.map((dir) => (\n            <ResizeHandle\n                key={`handle-${dir}`}\n                onMouseDown={handleResizeMouseDown}\n                direction={dir}\n            />\n        ));\n    }, [handleDirections, resizable, handleResizeMouseDown]);\n\n    // Memoized connection ports\n    const Ports = useMemo(() => {\n        if (!connectable) {\n            return null;\n        }\n        return PORT_DIRECTIONS.map((port) => (\n            <Port\n                key={`port-${port}`}\n                port={port}\n                onMouseEnter={handlePortEnter(port)}\n                onMouseLeave={handlePortLeave(port)}\n            />\n        ));\n    }, [connectable, handlePortEnter, handlePortLeave]);\n\n    return (\n        <ResponsiveBox itemId={itemId} x={x} y={y} w={w} h={h}>\n            {ResizeHandles}\n            {Ports}\n        </ResponsiveBox>\n    );\n};\n\nexport default ResponsiveBlockOutline;\n","import React from 'react';\nimport styled from 'styled-components';\nimport Plus from '@splunk/react-icons/Plus';\nimport { variables, pick } from '@splunk/themes';\nimport {\n    getVerticalPosition,\n    getHorizontalPosition,\n} from '../utils/outlineUtils';\n\nconst portOffset = 8;\nexport const PORT_DIRECTIONS = ['n', 'e', 's', 'w'] as const;\nexport type PortDirection = typeof PORT_DIRECTIONS[number];\n\nexport interface PortProps {\n    port: PortDirection;\n    onMouseEnter: React.MouseEventHandler<HTMLDivElement>;\n    onMouseLeave: React.MouseEventHandler<HTMLDivElement>;\n}\n\nconst PortContainer = styled.div.attrs<PortProps>(({ port }) => ({\n    'data-test': 'port',\n    'data-test-port': port,\n}))<PortProps & { children: React.ReactElement }>`\n    text-align: center;\n    width: 16px;\n    height: 16px;\n    line-height: 16px;\n    box-sizing: border-box;\n    border-radius: 50%;\n    position: absolute;\n    color: ${pick({\n        enterprise: variables.accentColorL10,\n        prisma: variables.interactiveColorPrimary,\n    })};\n    ${({ port }) => getVerticalPosition(port, portOffset)};\n    ${({ port }) => getHorizontalPosition(port, portOffset)};\n    z-index: 999;\n    pointer-events: auto;\n    user-select: none;\n    &:hover {\n        background-color: ${pick({\n            enterprise: variables.accentColorL10,\n            prisma: variables.interactiveColorPrimary,\n        })};\n    }\n`;\n\nexport const Port = ({\n    port,\n    onMouseEnter,\n    onMouseLeave,\n}: PortProps): JSX.Element => (\n    <PortContainer\n        port={port}\n        onMouseEnter={onMouseEnter}\n        onMouseLeave={onMouseLeave}\n    >\n        <Plus />\n    </PortContainer>\n);\n","module.exports = require(\"@splunk/react-icons/Plus\");","import React, { useCallback } from 'react';\nimport styled from 'styled-components';\nimport { variables, pick } from '@splunk/themes';\nimport type { HandleDirection } from '../types';\nimport {\n    getVerticalPosition,\n    getHorizontalPosition,\n} from '../utils/outlineUtils';\n\nconst resizeHandleOffset = 7;\n/**\n * compute cursor base on resize dir\n * @param {String} dir\n */\nconst computeCursor = (dir: HandleDirection): string => {\n    switch (dir) {\n        case 'n':\n        case 's':\n            return 'ns-resize';\n        case 'e':\n        case 'w':\n            return 'ew-resize';\n        case 'ne':\n        case 'sw':\n            return 'nesw-resize';\n        case 'se':\n        case 'nw':\n        default:\n            return 'nwse-resize';\n    }\n};\n\ninterface ContainerProps {\n    direction: HandleDirection;\n    onMouseDown: React.MouseEventHandler<HTMLAnchorElement>;\n}\n\nconst Handle = styled.a.attrs<ContainerProps>(({ direction }) => ({\n    'data-test': 'handle',\n    'data-test-direction': direction,\n}))<ContainerProps>`\n    width: 10px;\n    height: 10px;\n    background-color: ${pick({\n        enterprise: variables.accentColorL10,\n        prisma: variables.interactiveColorPrimary,\n    })};\n    border-radius: 20%;\n    position: absolute;\n    ${({ direction }) => getVerticalPosition(direction, resizeHandleOffset)};\n    ${({ direction }) => getHorizontalPosition(direction, resizeHandleOffset)};\n    cursor: ${({ direction }) => computeCursor(direction)};\n    z-index: 999;\n    pointer-events: auto;\n    user-select: none;\n`;\n\nexport interface ResizeHandleProps {\n    direction: HandleDirection;\n    onMouseDown: (e: React.MouseEvent, dir: HandleDirection) => void;\n}\n\nexport const ResizeHandle = ({\n    onMouseDown,\n    direction,\n}: ResizeHandleProps): JSX.Element => {\n    const handleMouseDown = useCallback(\n        (e: React.MouseEvent) => {\n            onMouseDown(e, direction);\n        },\n        [onMouseDown, direction]\n    );\n\n    return <Handle direction={direction} onMouseDown={handleMouseDown} />;\n};\n","module.exports = require(\"lodash/isEqual\");","import commonLayoutOptionsSchema from './commonLayoutOptionsSchema';\n\nexport default {\n    ...commonLayoutOptionsSchema,\n    gutterSize: {\n        type: 'number',\n        default: 8,\n        minimum: 8,\n        maximum: 16,\n        description:\n            'A number that represents the size of the gutter between visualizations in pixels. The minimum value is 8 and maximum value is 16.',\n    },\n};\n","module.exports = require(\"@splunk/dashboard-ui/hooks/useMouseMoveHandler\");","import isEqual from 'lodash/isEqual';\nimport type {\n    AbsoluteBlockItem,\n    AbsolutePosition,\n} from '@splunk/dashboard-types';\n/**\n * @param {Object} itemPosition\n * @param {Object} vizPosition\n * @returns {boolean} whether viz is contained with the y bounds of item\n */\nconst isInVerticalRange = (\n    itemPosition: AbsolutePosition,\n    vizPosition: AbsolutePosition\n) => {\n    return (\n        vizPosition.y >= itemPosition.y &&\n        vizPosition.y + vizPosition.h <= itemPosition.y + itemPosition.h\n    );\n};\n\n/**\n * @param {Object} itemPosition\n * @param {Object} vizPosition\n * @returns {boolean} whether viz is contained with the x bounds of item\n */\nconst isInHorizontalRange = (\n    itemPosition: AbsolutePosition,\n    vizPosition: AbsolutePosition\n) => {\n    return (\n        vizPosition.x >= itemPosition.x &&\n        vizPosition.x + vizPosition.w <= itemPosition.x + itemPosition.w\n    );\n};\n\n/**\n * @param {Object} item\n * @param {Object} viz\n * @returns {boolean} whether viz is left neighbor of item\n */\nexport const isLeftNeighbor = (\n    item: AbsoluteBlockItem,\n    viz: AbsoluteBlockItem\n): boolean => {\n    const isLeftOf = viz.position.x + viz.position.w === item.position.x;\n    return isLeftOf && isInVerticalRange(item.position, viz.position);\n};\n\n/**\n * @param {Object} item\n * @param {Object} viz\n * @returns {boolean} whether viz is right neighbor of item\n */\nexport const isRightNeighbor = (\n    item: AbsoluteBlockItem,\n    viz: AbsoluteBlockItem\n): boolean => {\n    const isRightOf = viz.position.x === item.position.x + item.position.w;\n    return isRightOf && isInVerticalRange(item.position, viz.position);\n};\n\n/**\n * @param {Object} item\n * @param {Object} viz\n * @returns {boolean} whether viz is top neighbor of item\n */\nexport const isTopNeighbor = (\n    item: AbsoluteBlockItem,\n    viz: AbsoluteBlockItem\n): boolean => {\n    const isAbove = viz.position.y + viz.position.h === item.position.y;\n    return isAbove && isInHorizontalRange(item.position, viz.position);\n};\n\n/**\n * @param {Object} item\n * @param {Object} viz\n * @returns {boolean} whether viz is bottom neighbor of item\n */\nexport const isBottomNeighbor = (\n    item: AbsoluteBlockItem,\n    viz: AbsoluteBlockItem\n): boolean => {\n    const isBelow = viz.position.y === item.position.y + item.position.h;\n    return isBelow && isInHorizontalRange(item.position, viz.position);\n};\n\n/**\n * Finds left and right neighbors of the given item and list of visualizations.\n * Note: This is *not* a generic function to find all neighbors. It is customized for remove\n * items and only returns neighbors that are contained with the y bounds of item.\n * @param {Object} item\n * @param {object[]} visualizations\n * @returns {{leftNeighbors: object[], rightNeighbors: object[]}}} list of horizontal neighbors that are within the y bounds of item\n */\nexport const findHorizontalNeighbors = ({\n    item,\n    visualizations,\n}: {\n    item: AbsoluteBlockItem;\n    visualizations: AbsoluteBlockItem[];\n}): {\n    leftNeighbors: AbsoluteBlockItem[];\n    rightNeighbors: AbsoluteBlockItem[];\n} => {\n    let leftHeight = 0;\n    let rightHeight = 0;\n    let leftNeighbors: AbsoluteBlockItem[] = [];\n    let rightNeighbors: AbsoluteBlockItem[] = [];\n\n    visualizations.forEach((viz) => {\n        if (isEqual(item, viz)) {\n            return;\n        }\n\n        if (isLeftNeighbor(item, viz)) {\n            leftHeight += viz.position.h;\n            leftNeighbors.push(viz);\n        }\n\n        if (isRightNeighbor(item, viz)) {\n            rightHeight += viz.position.h;\n            rightNeighbors.push(viz);\n        }\n    });\n    if (leftHeight !== item.position.h) {\n        leftNeighbors = [];\n    }\n    if (rightHeight !== item.position.h) {\n        rightNeighbors = [];\n    }\n    return { leftNeighbors, rightNeighbors };\n};\n\n/**\n * Finds top and bottom neighbors of the given item and list of visualizations.\n * Note: This is *not* a generic function to find all neighbors. It is customized for remove\n * items and only returns neighbors that are contained with the x bounds of item.\n * @param {Object} item\n * @param {object[]} visualizations\n * @returns {{topNeighbors: object[], bottomNeighbors: object[]}} list of vertical neighbors that are within the y bounds of item\n */\nexport const findVerticalNeighbors = ({\n    item,\n    visualizations,\n}: {\n    item: AbsoluteBlockItem;\n    visualizations: AbsoluteBlockItem[];\n}): {\n    topNeighbors: AbsoluteBlockItem[];\n    bottomNeighbors: AbsoluteBlockItem[];\n} => {\n    let topWidth = 0;\n    let bottomWidth = 0;\n    let topNeighbors: AbsoluteBlockItem[] = [];\n    let bottomNeighbors: AbsoluteBlockItem[] = [];\n    visualizations.forEach((viz) => {\n        if (isEqual(item, viz)) {\n            return;\n        }\n\n        if (isTopNeighbor(item, viz)) {\n            topWidth += viz.position.w;\n            topNeighbors.push(viz);\n        }\n\n        if (isBottomNeighbor(item, viz)) {\n            bottomWidth += viz.position.w;\n            bottomNeighbors.push(viz);\n        }\n    });\n    if (topWidth !== item.position.w) {\n        topNeighbors = [];\n    }\n    if (bottomWidth !== item.position.w) {\n        bottomNeighbors = [];\n    }\n    return { topNeighbors, bottomNeighbors };\n};\n\n/**\n * Returns the updated positions of visualizations when an item that spans an entire row is deleted.\n * Essentially all visualizations are shifted up.\n * @param {Object} obj\n * @param {Object} obj.itemToRemove\n * @param {object[]} obj.visualizations\n * @returns {object[]} visualizations with updated positions\n */\nexport const getItemsWithUpdatedPositions = ({\n    itemToRemove,\n    visualizations,\n}: {\n    itemToRemove: AbsoluteBlockItem;\n    visualizations: AbsoluteBlockItem[];\n}): AbsoluteBlockItem[] => {\n    const updatedVisualizations: AbsoluteBlockItem[] = [];\n    visualizations.forEach((viz) => {\n        // Item is below removed row\n        if (itemToRemove.position.y < viz.position.y) {\n            updatedVisualizations.push({\n                ...viz,\n                position: {\n                    ...viz.position,\n                    y: viz.position.y - itemToRemove.position.h,\n                },\n            });\n        }\n    });\n    return updatedVisualizations;\n};\n\n/**\n * Update the items around the item that is removed to fill the space\n * @param {Object} params\n * @param {Object} params.itemToRemove - The item that is being removed\n * @param {object[]} params.items - All the items on the canvas\n * @param {Number} params.width - The width of the entire canvas\n * @returns {object[]} - Array of updated items, filling the space of itemToRemove\n */\nexport const updateRemovedVizNeighbors = ({\n    itemToRemove,\n    items,\n    width,\n}: {\n    itemToRemove: AbsoluteBlockItem;\n    items: AbsoluteBlockItem[];\n    width: number;\n}): AbsoluteBlockItem[] => {\n    const updatedItems: AbsoluteBlockItem[] = [];\n\n    // viz spans entire row, delete it & move rows below in its place\n    if (itemToRemove.position.w === width) {\n        return getItemsWithUpdatedPositions({\n            itemToRemove,\n            visualizations: items,\n        });\n    }\n\n    const { leftNeighbors, rightNeighbors } = findHorizontalNeighbors({\n        item: itemToRemove,\n        visualizations: items,\n    });\n\n    if (leftNeighbors.length || rightNeighbors.length) {\n        if (leftNeighbors.length && rightNeighbors.length) {\n            const leftWidthToAdd = Math.floor(itemToRemove.position.w / 2);\n            // if itemToRemove.position.w is odd, we give 1 px extra to the right neighbor\n            const rightWidthToAdd = Math.ceil(itemToRemove.position.w / 2);\n            leftNeighbors.forEach((viz) => {\n                updatedItems.push({\n                    ...viz,\n                    position: {\n                        ...viz.position,\n                        w: viz.position.w + leftWidthToAdd,\n                    },\n                });\n            });\n            rightNeighbors.forEach((viz) => {\n                updatedItems.push({\n                    ...viz,\n                    position: {\n                        ...viz.position,\n                        x: viz.position.x - rightWidthToAdd,\n                        w: viz.position.w + rightWidthToAdd,\n                    },\n                });\n            });\n        } else if (leftNeighbors.length) {\n            leftNeighbors.forEach((viz) => {\n                updatedItems.push({\n                    ...viz,\n                    position: {\n                        ...viz.position,\n                        w: viz.position.w + itemToRemove.position.w,\n                    },\n                });\n            });\n        } else {\n            rightNeighbors.forEach((viz) => {\n                updatedItems.push({\n                    ...viz,\n                    position: {\n                        ...viz.position,\n                        x: viz.position.x - itemToRemove.position.w,\n                        w: viz.position.w + itemToRemove.position.w,\n                    },\n                });\n            });\n        }\n    } else {\n        const { topNeighbors, bottomNeighbors } = findVerticalNeighbors({\n            item: itemToRemove,\n            visualizations: items,\n        });\n        if (topNeighbors.length || bottomNeighbors.length) {\n            if (topNeighbors.length && bottomNeighbors.length) {\n                const topHeightToAdd = Math.floor(itemToRemove.position.h / 2);\n                // if itemToRemove.position.h is odd, we give 1 px extra to the bottom neighbor\n                const bottomHeightToAdd = Math.ceil(\n                    itemToRemove.position.h / 2\n                );\n                topNeighbors.forEach((viz) => {\n                    updatedItems.push({\n                        ...viz,\n                        position: {\n                            ...viz.position,\n                            h: viz.position.h + topHeightToAdd,\n                        },\n                    });\n                });\n                bottomNeighbors.forEach((viz) => {\n                    updatedItems.push({\n                        ...viz,\n                        position: {\n                            ...viz.position,\n                            y: viz.position.y - bottomHeightToAdd,\n                            h: viz.position.h + bottomHeightToAdd,\n                        },\n                    });\n                });\n            } else if (topNeighbors.length) {\n                topNeighbors.forEach((viz) => {\n                    updatedItems.push({\n                        ...viz,\n                        position: {\n                            ...viz.position,\n                            h: viz.position.h + itemToRemove.position.h,\n                        },\n                    });\n                });\n            } else {\n                bottomNeighbors.forEach((viz) => {\n                    updatedItems.push({\n                        ...viz,\n                        position: {\n                            ...viz.position,\n                            y: viz.position.y - itemToRemove.position.h,\n                            h: viz.position.h + itemToRemove.position.h,\n                        },\n                    });\n                });\n            }\n        }\n    }\n\n    return updatedItems;\n};\n","import React, {\n    useState,\n    useEffect,\n    useLayoutEffect,\n    useRef,\n    useCallback,\n    useContext,\n    useMemo,\n    useReducer,\n} from 'react';\nimport memoizeOne from 'memoize-one';\nimport get from 'lodash/get';\nimport isEqual from 'lodash/isEqual';\nimport noop from 'lodash/noop';\nimport CanvasContext from '@splunk/dashboard-context/CanvasContext';\nimport DashboardContext, { useFeatureFlags } from '@splunk/dashboard-context';\nimport { TelemetryContext } from '@splunk/dashboard-telemetry';\n\nimport type {\n    SelectedItem,\n    AbsoluteBlockItem,\n    Coordinate,\n    AbsolutePosition,\n    GridLayoutStructure,\n    GridLayoutOptions,\n    Mode,\n} from '@splunk/dashboard-types';\nimport usePrevious from '@splunk/dashboard-ui/hooks/usePrevious';\nimport type { CountableEvent } from '@splunk/dashboard-telemetry/EventTypes';\n\nimport useEventCallback from '@splunk/dashboard-ui/hooks/useEventCallback';\nimport useMouseMoveHandler from '@splunk/dashboard-ui/hooks/useMouseMoveHandler';\nimport {\n    GRID_PADDING_PX,\n    GRID_SIZE_PX,\n    MIN_HEIGHT_PX,\n    MIN_WIDTH_PX,\n    SNAP_RANGE_PX,\n    PLACEHOLDER_SIZE_PX,\n    VIZ_PREVIEW_DELAY_MS,\n    EDGE_PREVIEW_DELAY_MS,\n} from './GridLayoutConstants';\nimport GridCanvas from './components/GridCanvas';\nimport Layer from './components/Layer';\nimport ResponsiveBlockOutline from './components/ResponsiveBlockOutline';\nimport ResponsiveBlockItem, {\n    ResponsiveBlockItemProps,\n} from './components/ResponsiveBlockItem';\nimport {\n    computeScaleToFit,\n    computeMaxHeight,\n    updateBlockItemSize,\n    getOffset,\n    getClientPosition,\n    findTopBlockItemByPosition,\n    updateBlockItemPosition,\n    scaleGridLayoutStructureByWidth,\n} from './utils/layoutUtils';\nimport {\n    computeEdges,\n    findEdgesInBoundary,\n    findSnappableEdges,\n    moveVerticalEdge,\n    moveHorizontalEdge,\n    getVerticalBoundaries,\n    getHorizontalBoundaries,\n    applyVizPadding,\n} from './utils/edgeUtils';\nimport {\n    isMouseOnEdge,\n    updateDropOnEdge,\n    findQuadrant,\n    updateDropOnViz,\n    updateItems,\n    previewDropOnEdge,\n    previewDropOnViz,\n    validateLayoutStructure,\n    getDimensions,\n    formatEdgeWrapper,\n    isInvalidAdjacentVizDrop,\n    isDropOnOwnEdge,\n} from './utils/gridUtils';\nimport GridLayoutApi from './apis/GridLayoutApi';\nimport { gridLayoutOptions } from './DefaultOptions';\nimport gridLayoutOptionsSchema from './gridLayoutOptionsSchema';\nimport { Edge } from './components/Edge';\nimport { ItemDragPlaceholder } from './components/ItemDragPlaceholder';\nimport { ItemDropTarget } from './components/ItemDropTarget';\nimport { PreviewPlaceholderItem } from './components/PreviewPlaceholderItem';\n\nimport type {\n    EdgeItem,\n    Quadrant,\n    LayoutError,\n    EdgeBoundaries,\n    VerticalBoundaries,\n    HorizontalBoundaries,\n    EdgeAppearance,\n    HandleDirection,\n    Offset,\n} from './types';\nimport {\n    filterSelectedItems,\n    getBlockItems,\n    getFilteredStructure,\n    getItem,\n    getStructureItem,\n    gridReducer,\n    hasPreviewItem,\n    initializeGridReducer,\n    resetLayoutAction,\n    updateItemAction,\n} from './utils/gridLayoutUtils';\n\nexport interface GridLayoutProps {\n    layoutApiRef: (api: GridLayoutApi | null) => void;\n    onLayoutItemsSelect: (selectedItems: SelectedItem[]) => void;\n    selectedItems?: SelectedItem[];\n    layoutStructure: GridLayoutStructure;\n    onLayoutStructureChange: (layoutStructure: GridLayoutStructure) => void;\n    options?: GridLayoutOptions;\n    renderLayoutItem: (...args: unknown[]) => JSX.Element;\n    mode: Mode;\n    containerWidth: number;\n    showGrid: boolean;\n}\n\nconst HANDLE_DIRECTIONS: HandleDirection[] = [];\n\ninterface RenderBlockItemsProps {\n    layoutStructure: GridLayoutStructure;\n    renderLayoutItem: (...args: unknown[]) => JSX.Element;\n    handleItemSelected: ResponsiveBlockItemProps['onItemSelected'];\n    isBlockItemMoving: boolean;\n    selectedItem: SelectedItem;\n    mode: Mode;\n    errors: { itemId: string; messages: string[] }[];\n    padding: number;\n    canvasHeight: number;\n}\n\nconst MemoizedBlockItem = React.memo(ResponsiveBlockItem);\nconst MemoizedBlockOutline = React.memo(ResponsiveBlockOutline);\nconst MemoizedEdge = React.memo(Edge);\n\n/**\n * loop through structure to render each block. Memoized block rendering to prevent rerender of each block\n */\nconst renderBlockItems = memoizeOne(\n    ({\n        layoutStructure,\n        renderLayoutItem,\n        handleItemSelected,\n        isBlockItemMoving,\n        selectedItem,\n        mode,\n        errors,\n        padding,\n        canvasHeight,\n    }: RenderBlockItemsProps): React.ReactNode => {\n        return layoutStructure.map((item) => {\n            const key = item.item;\n            if (key === 'preview-old-item') {\n                return null;\n            }\n\n            const isSelected = get(selectedItem, 'id') === key;\n\n            // Highlight the item if:\n            // 1. in view mode\n            // 2. in edit mode and no item is selected\n            // 3. in edit mode and the item is selected\n            let appearance: ResponsiveBlockItemProps['appearance'] =\n                mode === 'view' || !selectedItem || isSelected\n                    ? 'highlighted'\n                    : 'visible';\n\n            // If the selected visualization is moving, then we want to hide the viz itself since the\n            //   preview placeholder will be rendered on top. The hiding is done using `visibility: hidden`, to avoid\n            //   causing the viz to unmount, which would re-run the search.\n            if (isSelected && isBlockItemMoving) {\n                appearance = 'hidden';\n            }\n\n            // find the error object belonging to this viz if the error exists\n            let errorMessages;\n            if (errors) {\n                const vizErrors = errors.find(({ itemId }) => itemId === key);\n                errorMessages = get(vizErrors, 'messages');\n            }\n\n            const paddedItem = applyVizPadding({\n                item,\n                padding,\n            });\n\n            return (\n                <MemoizedBlockItem\n                    key={key}\n                    itemId={key}\n                    x={paddedItem.position.x}\n                    y={paddedItem.position.y}\n                    h={paddedItem.position.h}\n                    w={paddedItem.position.w}\n                    canvasHeight={canvasHeight}\n                    renderLayoutItem={renderLayoutItem}\n                    onItemSelected={handleItemSelected}\n                    appearance={appearance}\n                    errorMessages={errorMessages}\n                />\n            );\n        });\n    },\n    isEqual\n);\n\nconst BaseGridLayout = ({\n    layoutApiRef,\n    onLayoutItemsSelect,\n    selectedItems: selectedLayoutItems,\n    layoutStructure,\n    onLayoutStructureChange,\n    options = {},\n    renderLayoutItem,\n    mode,\n    showGrid,\n    scale,\n    canvasWidth,\n}: Omit<\n    GridLayoutProps & { scale: number; canvasWidth: number },\n    'containerWidth'\n>): JSX.Element => {\n    const canvasContext = useContext(CanvasContext);\n    const { keyboardListener, userMessage = noop } = useContext(\n        DashboardContext\n    );\n    const telemetryAPI = useContext(TelemetryContext);\n    const {\n        enableGridLayoutErrors,\n        enableGridLayoutCssScaling,\n    } = useFeatureFlags();\n\n    const { gutterSize = gridLayoutOptions.gutterSize } = options;\n    // gutterSize is split between the two panels it shares\n    const panelPadding = gutterSize / 2;\n\n    const [gridState, dispatch] = useReducer(\n        gridReducer,\n        layoutStructure,\n        initializeGridReducer\n    );\n    const maxHeight = computeMaxHeight(getBlockItems(gridState));\n\n    const [isBlockItemMoving, setIsBlockItemMoving] = useState(false);\n\n    const [edges, setEdges] = useState<EdgeItem[]>(\n        computeEdges({\n            layout: layoutStructure,\n            canvasWidth,\n            canvasHeight: computeMaxHeight(layoutStructure), // need to recompute height on layout change\n        })\n    );\n    const [snappableEdges, setSnappableEdges] = useState<EdgeItem[]>([]);\n    const [scrollToBottom, setScrollToBottom] = useState(false);\n    const [mousePosition, setMousePosition] = useState<Coordinate | null>(null);\n    const [isVizAdded, setIsVizAdded] = useState(false);\n    const [edgesBeforeMove, setEdgesBeforeMove] = useState<EdgeItem[] | null>(\n        null\n    );\n    const [invalidEdgeId, setInvalidEdgeId] = useState<string | null>(null);\n    const [hoveredEdge, setHoveredEdge] = useState<EdgeItem | null>(null);\n\n    const [\n        initialItemToMove,\n        setInitialItemToMove,\n    ] = useState<AbsoluteBlockItem | null>(null);\n    const [hoveredBlock, setHoveredBlock] = useState<AbsoluteBlockItem | null>(\n        null\n    );\n    const [hoveredQuadrant, setHoveredQuadrant] = useState<Quadrant | null>(\n        null\n    );\n    const [, setForceUpdate] = useState(0);\n    const [selectedItemsForEdge, setSelectedItemsForEdge] = useState<string[]>(\n        []\n    );\n\n    const [isInvalidVizDrop, setIsInvalidVizDrop] = useState(false);\n    const [showPreviewPlaceholder, setShowPreviewPlaceholder] = useState(true);\n    const [layoutErrors, setLayoutErrors] = useState<LayoutError[]>([]);\n\n    const isDraggingEdge = useRef(false);\n    const delayPreviewEdge = useRef<NodeJS.Timeout | null>(null);\n    const delayPreviewViz = useRef<NodeJS.Timeout | null>(null);\n    /**\n     * the follow values are saved in refs instead of states for two reasons:\n     *     1. they don't affect rendering;\n     *     2. they should be updated synchronously in order to handle mouse events https://jira.splunk.com/browse/SCP-25610\n     */\n    // mouseDownEdge is tracking the initial edge state when mouse down event happens, it is a snapshot, it won't update when mouse moves\n    // the reason we need it is because we use the initial edge position and latest mouse position to calculate latest edge position\n    const mouseDownEdge = useRef<EdgeItem | null>(null);\n    const edgeMouseDownPosition = useRef<Coordinate | null>(null);\n    const edgeBoundaries = useRef<EdgeBoundaries | null>(null);\n    const edgesInBoundary = useRef<EdgeItem[] | null>(null);\n\n    const containsPreviewItem = hasPreviewItem(gridState);\n\n    const sendTelemetry = useCallback(\n        (eventData: CountableEvent) => {\n            telemetryAPI.collect(eventData);\n        },\n        [telemetryAPI]\n    );\n\n    const onVizAdded = useCallback(() => {\n        setIsVizAdded(true);\n    }, [setIsVizAdded]);\n\n    const canvasRef = useRef<HTMLDivElement>(null);\n\n    const getCanvasDomElement = (): HTMLDivElement => {\n        return canvasRef.current as HTMLDivElement;\n    };\n\n    const layoutApi = useRef<GridLayoutApi | null>(null);\n    const layoutStructureRef = useRef<GridLayoutStructure>(layoutStructure);\n\n    const firstSelectedItemStructure = useMemo(\n        () =>\n            selectedLayoutItems?.length\n                ? getItem(gridState, selectedLayoutItems[0].id)\n                : null,\n        [gridState, selectedLayoutItems]\n    );\n\n    const initializeLayoutApi = useCallback(() => {\n        if (layoutApi.current === null) {\n            layoutApi.current = new GridLayoutApi({\n                layoutStructureRef,\n                options,\n                userMessage,\n                onVizAdded,\n                getCanvasDomElement,\n                telemetry: telemetryAPI,\n            });\n        }\n    }, [telemetryAPI, userMessage, onVizAdded, options]);\n\n    const prevLayoutStructure = usePrevious(layoutStructure);\n\n    useEffect(() => {\n        if (isEqual(prevLayoutStructure, layoutStructure)) {\n            return;\n        }\n\n        dispatch(resetLayoutAction(layoutStructure));\n        // Adding/removing/cloning is done by using this reference to the layoutStructure\n        // so we need to make sure it reflects the unscaled versions of the visualizations\n        layoutStructureRef.current = enableGridLayoutCssScaling\n            ? layoutStructure\n            : scaleGridLayoutStructureByWidth({\n                  scale: 1 / scale,\n                  layout: layoutStructure,\n              });\n    }, [\n        enableGridLayoutCssScaling,\n        layoutStructure,\n        prevLayoutStructure,\n        scale,\n    ]);\n\n    // Need to do this after initializing layout structure ref!\n    initializeLayoutApi();\n\n    useEffect(() => {\n        // only show errors when we're in edit mode\n        if (mode === 'edit' && enableGridLayoutErrors) {\n            const errors = validateLayoutStructure({\n                layout: layoutStructure,\n                canvasBounds: { x: 0, y: 0, w: canvasWidth, h: maxHeight },\n            });\n            setLayoutErrors(errors);\n        } else if (mode === 'view') {\n            // in case we had errors in edit mode, remove them when going to view mode\n            setLayoutErrors([]);\n        }\n        // We only want this to run when we commit changes to item position/size.\n        //  For example, we want it to run after resizing (on mouse up), not during.\n        //  And also when we switch modes, since we only want to show errors in edit mode\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [layoutStructure, mode, enableGridLayoutErrors]);\n\n    // we must use `useLayoutEffect` because we need to guarantee `layoutApiRef` is called before `componentDidMount()` is called on\n    // the parent component (namely LayoutContainer). Otherwise LayoutContainer will not get the api.\n    useLayoutEffect(() => {\n        layoutApiRef(layoutApi.current);\n\n        return () => {\n            layoutApiRef(null);\n        };\n    }, [layoutApiRef]);\n\n    // this ensures the layout reducer gets the latest layoutStructure\n    useEffect(() => {\n        // TODO: we should look into how to make `layoutStructure` not constantly change if the actual content of the layoutStructure did not change.\n        // Currently, we have to do a deep comparison, because `layoutStructure` as an object reference is always changing.\n        if (isEqual(prevLayoutStructure, layoutStructure)) {\n            return;\n        }\n        dispatch(resetLayoutAction(layoutStructure));\n\n        const canvasHeight = computeMaxHeight(layoutStructure);\n        const prevCanvasHeight = computeMaxHeight(prevLayoutStructure || []);\n\n        setEdges(\n            computeEdges({\n                layout: layoutStructure,\n                canvasWidth,\n                canvasHeight, // need to recompute height on layout change\n            })\n        );\n\n        if (\n            prevLayoutStructure &&\n            canvasHeight > prevCanvasHeight &&\n            isVizAdded\n        ) {\n            // when we add a new viz to canvas, we want to scroll to it\n            setScrollToBottom(true);\n            setIsVizAdded(false);\n        }\n    }, [isVizAdded, layoutStructure, canvasWidth, prevLayoutStructure]);\n\n    useEffect(() => {\n        if (scrollToBottom) {\n            const layoutContainer = canvasContext.current;\n            layoutContainer.scrollTop = layoutContainer.scrollHeight;\n            setScrollToBottom(false);\n        }\n    }, [canvasContext, layoutStructure, scrollToBottom]);\n\n    // Not idempotent, but doesn't matter because this will only result in resetting a mouseup handler, not a rerender of any component\n    const handleLayoutStructureChange = useCallback(() => {\n        const layout = getBlockItems(gridState);\n        onLayoutStructureChange(layout);\n    }, [onLayoutStructureChange, gridState]);\n\n    /**\n     * return valid selected items, this needs to be a function because we cannot detect structureRegistry change.\n     */\n    const getSelectedItems = useMemo(() => {\n        let itemsCache: SelectedItem[];\n\n        return () => {\n            const filteredItems = filterSelectedItems(\n                layoutStructure,\n                selectedLayoutItems\n            );\n\n            if (!isEqual(itemsCache, filteredItems)) {\n                itemsCache = filteredItems;\n            }\n\n            return itemsCache;\n        };\n    }, [layoutStructure, selectedLayoutItems]);\n\n    /**\n     * set selected items\n     * @param {Object} e mouse event\n     * @param {Array} selectedItems list of selected Items\n     */\n    const handleItemSelected = useCallback(\n        (_e: React.MouseEvent, selectedItems: SelectedItem[] = []) => {\n            // filter out other Items as we do not currently support multi selecting Items\n            const selectedItem =\n                selectedItems.length > 0\n                    ? [selectedItems[selectedItems.length - 1]]\n                    : [];\n            onLayoutItemsSelect(selectedItem);\n        },\n        [onLayoutItemsSelect]\n    );\n\n    // If we're not scaling the grid via CSS we don't need to scale the mouse position\n    const mouseScale = enableGridLayoutCssScaling ? scale : 1;\n\n    /**\n     * Handles scrolling in Canvas when a Viz is being dragged to the top or bottom of the visible Canvas\n     */\n    // TODO: something is a little odd here...when showing an edge preview on canvas bottom causes scrolling things break a little\n    useEffect(() => {\n        let delayed: NodeJS.Timeout;\n        if (!isBlockItemMoving || !mousePosition || !canvasContext) {\n            return () => undefined;\n        }\n        const layoutContainer = canvasContext.current;\n        const visibleCanvasHeight = layoutContainer.clientHeight / mouseScale;\n\n        const hasScrolledToBottom =\n            layoutContainer.scrollTop / mouseScale + visibleCanvasHeight >=\n            maxHeight;\n\n        const isInBottomScrollArea =\n            layoutContainer.scrollTop / mouseScale +\n                visibleCanvasHeight -\n                mousePosition.y <\n            MIN_HEIGHT_PX;\n\n        const hasScrolledToTop = layoutContainer.scrollTop <= 0;\n\n        const isInTopScrollArea =\n            mousePosition.y - layoutContainer.scrollTop / mouseScale <\n            MIN_HEIGHT_PX;\n        if (!hasScrolledToBottom && isInBottomScrollArea) {\n            const increment = Math.min(\n                Math.abs(\n                    maxHeight -\n                        (layoutContainer.scrollTop / mouseScale +\n                            visibleCanvasHeight)\n                ),\n                10\n            );\n            delayed = setTimeout(() => {\n                layoutContainer.scrollTop += increment;\n                setMousePosition((pos) =>\n                    pos\n                        ? {\n                              ...pos,\n                              y: pos.y + increment / mouseScale,\n                          }\n                        : null\n                );\n            }, 32);\n        } else if (!hasScrolledToTop && isInTopScrollArea) {\n            const decrement = Math.min(layoutContainer.scrollTop, 10);\n            delayed = setTimeout(() => {\n                layoutContainer.scrollTop -= decrement;\n                setMousePosition((pos) =>\n                    pos\n                        ? {\n                              ...pos,\n                              y: pos.y - decrement / mouseScale,\n                          }\n                        : null\n                );\n            }, 32);\n        }\n\n        return () => {\n            clearTimeout(delayed);\n        };\n    }, [\n        isBlockItemMoving,\n        mousePosition,\n        canvasContext,\n        mouseScale,\n        maxHeight,\n    ]);\n\n    /*\n        Reset the preview states to original values for edge preview\n    */\n    const resetEdgePreviewState = useCallback(() => {\n        if (edgesBeforeMove) {\n            // If there was an update, stop it from happening\n            if (delayPreviewEdge.current) {\n                clearTimeout(delayPreviewEdge.current);\n            }\n            // Set edges back to original ones before the move happened\n            setEdges(edgesBeforeMove);\n            // Set visualizations to original\n            dispatch(resetLayoutAction(layoutStructure));\n        }\n    }, [edgesBeforeMove, layoutStructure]);\n\n    const showEdgeDropPreview = useCallback(\n        ({ mousePos }: { mousePos: Coordinate }) => {\n            if (edgesBeforeMove === null) {\n                // Only update the edges before move once, since it will always be the same\n                setEdgesBeforeMove(edges);\n            }\n            // Compute against the initial edges before we started moving, unless they haven't been set yet\n            const validEdges = edgesBeforeMove || edges;\n            // find if the mouse is on the edge\n            const edge = validEdges.find((edgeToFind) => {\n                return isMouseOnEdge({\n                    edge: edgeToFind,\n                    mousePosition: mousePos,\n                    padding: panelPadding,\n                });\n            });\n\n            if (!edge) {\n                /* If edge is undefined, there is no edge being hovered */\n                // If an edge was previously hovered, then undo the state changes made, and revert back to original\n                // This deals with hovering on an edge and then hovering off it\n                if (hoveredEdge) {\n                    setHoveredEdge(null);\n                    setInvalidEdgeId(null);\n                    resetEdgePreviewState();\n                }\n                return;\n            }\n\n            // Only compute preview if this is the first time we are hovering this particular edge\n            // which means either the edge is undefined or it's a different edge than the last one that was hovered\n            if (!hoveredEdge || hoveredEdge.item !== edge.item) {\n                let itemToMove = firstSelectedItemStructure;\n                if (!initialItemToMove) {\n                    // We need to keep the original item to move since the 'selectedItem' will change positions\n                    //  to the new position inserted in the preview\n                    setInitialItemToMove(itemToMove);\n                } else {\n                    // use the original item to move\n                    itemToMove = initialItemToMove;\n                }\n                // hide preview when an item is dropped on its own edge that has the same width/height as item\n                if (\n                    isDropOnOwnEdge({\n                        edge,\n                        itemToMove: itemToMove as AbsoluteBlockItem,\n                    })\n                ) {\n                    return;\n                }\n\n                // Compute the preview when hovering over the edge\n                const updatedItems = previewDropOnEdge({\n                    edge,\n                    itemToMove: itemToMove as AbsoluteBlockItem,\n                    items: layoutStructure,\n                    canvasWidth,\n                });\n                // If the move was valid, update state to render the preview\n                if (updatedItems) {\n                    // clear invalid edge if it exists\n                    setInvalidEdgeId(null);\n                    if (delayPreviewEdge.current) {\n                        clearTimeout(delayPreviewEdge.current);\n                    }\n                    // When we set timeout, it means it is a valid drop, thus hide preview placeholder until the preview is shown\n                    setShowPreviewPlaceholder(false);\n                    delayPreviewEdge.current = setTimeout(() => {\n                        // Update layout reducer with the new structure\n                        dispatch(resetLayoutAction(updatedItems));\n                        // render the new edges using the new updated layout structure\n                        setEdges(\n                            computeEdges({\n                                layout: updatedItems,\n                                canvasWidth,\n                                canvasHeight: computeMaxHeight(updatedItems),\n                            })\n                        );\n                        // When preview is computed and shown, bring back the placeholder\n                        setShowPreviewPlaceholder(true);\n                    }, EDGE_PREVIEW_DELAY_MS);\n                } else {\n                    // if the move was invalid, highlight the hovered edge to red\n                    setShowPreviewPlaceholder(true);\n                    setInvalidEdgeId(edge.item);\n                    // if user moved from a valid preview directly on an invalid edge, reset\n                    //  the currently shown preview\n                    resetEdgePreviewState();\n                }\n            }\n            // This state is used to keep track of which edge is being hovered, so that we can track\n            //  when we switch to a different edge (to re-compute preview)\n            setHoveredEdge(edge);\n        },\n        [\n            firstSelectedItemStructure,\n            edgesBeforeMove,\n            edges,\n            hoveredEdge,\n            panelPadding,\n            resetEdgePreviewState,\n            initialItemToMove,\n            layoutStructure,\n            canvasWidth,\n        ]\n    );\n\n    const showVizDropPreview = useCallback(\n        ({ mousePos }: { mousePos: Coordinate }) => {\n            // Find the viz that the Mouse is hovering over\n            const block = findTopBlockItemByPosition(\n                layoutStructure,\n                mousePos,\n                panelPadding\n            );\n\n            let itemToMove = firstSelectedItemStructure;\n            if (!initialItemToMove) {\n                // We need to keep the original item to move since the 'selectedItem' will change positions\n                //  to the new position inserted in the preview\n                setInitialItemToMove(itemToMove);\n            } else {\n                // use the original item to move\n                itemToMove = initialItemToMove;\n            }\n\n            if (block === undefined || block.item === itemToMove?.item) {\n                if (delayPreviewViz.current) {\n                    clearTimeout(delayPreviewViz.current);\n                }\n                setHoveredQuadrant(null);\n                setHoveredBlock(null);\n                setIsInvalidVizDrop(false);\n                if (hoveredBlock) {\n                    // only reset to original if there was a preview computed\n                    dispatch(resetLayoutAction(layoutStructure));\n                }\n                return;\n            }\n\n            const currentQuadrant = findQuadrant({\n                item: applyVizPadding({ item: block, padding: panelPadding }),\n                position: mousePos,\n            });\n\n            // Only compute (or re-compute) preview if either it's the first time user hovers a viz,\n            //   or if the quadrant changed, or if the viz that is being hovered changed.\n            if (\n                (!hoveredBlock && !hoveredQuadrant) ||\n                hoveredQuadrant !== currentQuadrant ||\n                hoveredBlock?.item !== block.item\n            ) {\n                if (\n                    isInvalidAdjacentVizDrop({\n                        itemToMove: itemToMove as AbsoluteBlockItem,\n                        itemToDropOn: block,\n                        visualizations: layoutStructure,\n                        direction: currentQuadrant as Quadrant,\n                    })\n                ) {\n                    return;\n                }\n\n                // get the updated position of the items that are changing as a result of the Viz drop on Viz\n                const updatedItems = previewDropOnViz({\n                    itemToDropOn: block,\n                    itemToMove: itemToMove as AbsoluteBlockItem,\n                    items: layoutStructure,\n                    direction: currentQuadrant as Quadrant,\n                });\n                // clear previous preview if it's queued up\n                if (delayPreviewViz.current) {\n                    clearTimeout(delayPreviewViz.current);\n                }\n                if (updatedItems) {\n                    setIsInvalidVizDrop(false);\n                    // The quadrant of the current visualization we are hovering while dragging a viz\n                    setHoveredQuadrant(currentQuadrant);\n                    // the visualization we are hovering over\n                    setHoveredBlock(block);\n                    // Same as with edge preview, hide the placeholder until the timeout has run to avoid 'flashing' of the green preview\n                    setShowPreviewPlaceholder(false);\n                    delayPreviewViz.current = setTimeout(() => {\n                        // If the move was valid, show preview of new layout\n                        dispatch(resetLayoutAction(updatedItems));\n                        // While structure registry exists, we need to force an update. This is a clear indication that it needs to be removed, asap!\n                        setForceUpdate(\n                            (prevForceUpdate) => prevForceUpdate + 1\n                        );\n                        setShowPreviewPlaceholder(true);\n                    }, VIZ_PREVIEW_DELAY_MS);\n                } else {\n                    setHoveredQuadrant(null);\n                    setHoveredBlock(null);\n                    setIsInvalidVizDrop(true);\n                    if (hoveredBlock) {\n                        // only reset to original if there was a preview computed\n                        dispatch(resetLayoutAction(layoutStructure));\n                    }\n                }\n            }\n        },\n        [\n            firstSelectedItemStructure,\n            panelPadding,\n            hoveredBlock,\n            hoveredQuadrant,\n            initialItemToMove,\n            layoutStructure,\n        ]\n    );\n\n    /**\n     * Renders the Item Drop Target\n     * @param {Object} params\n     * @param {Object} params.position position of Item being hovered over\n     * @param {String} params.direction direction of where Drop Target should be rendered\n     */\n    const renderItemDropTarget = memoizeOne(\n        ({\n            position,\n            direction,\n        }: {\n            position: AbsolutePosition;\n            direction: Quadrant;\n        }) => {\n            return <ItemDropTarget position={position} direction={direction} />;\n        }\n    );\n\n    /**\n     * Handles rendering for Item Drop Targets when an Item is being dragged and hovers on top of another Item\n     */\n    const handleRenderItemDropTarget = useCallback(() => {\n        let block = findTopBlockItemByPosition(\n            layoutStructure,\n            mousePosition as Coordinate,\n            panelPadding\n        );\n\n        const selectedItems = getSelectedItems();\n        if (\n            block !== undefined &&\n            selectedItems.length > 0 &&\n            block.item !== selectedItems[0].id &&\n            // disables drop targets when showing preview\n            !hoveredQuadrant\n        ) {\n            // apply padding to Viz to get accurate mouse hover\n            block = applyVizPadding({ item: block, padding: panelPadding });\n            return renderItemDropTarget({\n                position: block.position,\n                direction: findQuadrant({\n                    item: block,\n                    position: mousePosition as Coordinate,\n                }) as Quadrant,\n            });\n        }\n        return null;\n    }, [\n        layoutStructure,\n        panelPadding,\n        getSelectedItems,\n        hoveredQuadrant,\n        mousePosition,\n        renderItemDropTarget,\n    ]);\n\n    const handleShowPreviewPlaceholder = useCallback(\n        ({ mousePos }: { mousePos: Coordinate }) => {\n            const selectedItem = getSelectedItems()[0];\n            if (!selectedItem) {\n                setShowPreviewPlaceholder(false);\n                return;\n            }\n            // Find the viz that the Mouse is hovering over\n            const hoveredViz = findTopBlockItemByPosition(\n                layoutStructure,\n                mousePos,\n                panelPadding\n            );\n            // case 1 to show placeholder: mouse is on original viz\n            if (hoveredViz && hoveredViz.item === selectedItem.id) {\n                setShowPreviewPlaceholder(true);\n                return;\n            }\n            // case 2 to show placeholder: mouse is on an invalid drop zone\n            if (invalidEdgeId !== null || isInvalidVizDrop) {\n                setShowPreviewPlaceholder(true);\n                return;\n            }\n\n            // case 3 to show placeholder: preview has been computed\n            // Note: preview stays on screen as long as mouse hovers on the drop zone where it was created\n            //   so as soon as user moves mouse off, preview goes back to original position (case 1 or 2)\n            if (containsPreviewItem) {\n                setShowPreviewPlaceholder(true);\n                return;\n            }\n            // If neither of those three cases, hide preview placeholder\n            setShowPreviewPlaceholder(false);\n        },\n        [\n            containsPreviewItem,\n            panelPadding,\n            getSelectedItems,\n            invalidEdgeId,\n            isInvalidVizDrop,\n            layoutStructure,\n        ]\n    );\n\n    /**\n     * set isBlockItemMoving state to true for selected Items\n     */\n    const handleBlockItemMove = useCallback(\n        (\n            _e: React.MouseEvent,\n            { currentPosition }: { currentPosition: Coordinate }\n        ) => {\n            if (getSelectedItems().length > 0) {\n                handleShowPreviewPlaceholder({ mousePos: currentPosition });\n                setIsBlockItemMoving(true);\n                setMousePosition(currentPosition);\n                showEdgeDropPreview({ mousePos: currentPosition });\n                showVizDropPreview({ mousePos: currentPosition });\n            }\n        },\n        [\n            getSelectedItems,\n            showEdgeDropPreview,\n            showVizDropPreview,\n            handleShowPreviewPlaceholder,\n        ]\n    );\n\n    /**\n     * Handler to deal with when a Visualization that is being dragged gets dropped on mouseUp Event\n     */\n    const handleVizDrop = useCallback(() => {\n        const validEdges = edgesBeforeMove || edges;\n\n        const selectedItems = getSelectedItems();\n        // return early if there are no selected Items\n        if (selectedItems.length === 0) {\n            return;\n        }\n        // Find if the viz is being moved on an edge, return that edge\n        const edge = validEdges.find((e) => {\n            return isMouseOnEdge({\n                edge: e,\n                mousePosition: mousePosition as Coordinate,\n                padding: panelPadding,\n            });\n        });\n        // Find the viz that the Mouse is hovering over\n        const block = findTopBlockItemByPosition(\n            layoutStructure,\n            mousePosition as Coordinate,\n            panelPadding\n        );\n        const itemToMove = layoutStructure.find(\n            ({ item }) => item === selectedItems[0].id\n        ) as AbsoluteBlockItem;\n        // nothing changed as a result of the Viz drop on itself - return early\n        if (block === itemToMove) {\n            sendTelemetry({\n                source: 'canvas',\n                event: 'viz_drop_on_self_successful',\n            });\n            return;\n        }\n        const itemsSelected = layoutStructure;\n        let updatedItems = null;\n        if (edge !== undefined) {\n            // handle drop on Edge\n            // get the updated position of the items that are changing as a result of the Viz drop on Edge\n            updatedItems = updateDropOnEdge({\n                edge,\n                itemToMove,\n                items: itemsSelected,\n                canvasWidth,\n            });\n            // nothing changed as a result of the Viz drop on Edge - return early\n            if (updatedItems === null) {\n                sendTelemetry({\n                    source: 'canvas',\n                    event: 'viz_drop_on_edge_unsuccessful',\n                });\n                return;\n            }\n            // updated the entire definition with the updated Items\n            updatedItems = updateItems({\n                updatedVisualizations: updatedItems.updatedVisualizations,\n                itemToMove: updatedItems.updatedItemToMove,\n                items: itemsSelected,\n                canvasWidth,\n            });\n            sendTelemetry({\n                source: 'canvas',\n                event: 'viz_drop_on_edge_successful',\n            });\n        } else if (block !== undefined && block.item !== selectedItems[0].id) {\n            // handle drop on Viz\n            // apply padding to Viz to get accurate mouse hover position\n            const direction = findQuadrant({\n                item: applyVizPadding({ item: block, padding: panelPadding }),\n                position: mousePosition as Coordinate,\n            });\n\n            if (\n                isInvalidAdjacentVizDrop({\n                    itemToMove,\n                    itemToDropOn: block,\n                    direction: direction as Quadrant,\n                    visualizations: layoutStructure,\n                })\n            ) {\n                return;\n            }\n\n            // get the updated position of the items that are changing as a result of the Viz drop on Viz\n            const updatedVisualizations = updateDropOnViz({\n                itemToMove,\n                itemToDropOn: block,\n                direction: direction as Quadrant,\n            });\n            if (updatedVisualizations === null) {\n                sendTelemetry({\n                    source: 'canvas',\n                    event: 'viz_drop_on_viz_unsuccessful',\n                });\n                return;\n            }\n            // updated the entire definition with the updated Items\n            updatedItems = updateItems({\n                updatedVisualizations,\n                itemToMove,\n                items: itemsSelected,\n                canvasWidth,\n            });\n            sendTelemetry({\n                source: 'canvas',\n                event: 'viz_drop_on_viz_successful',\n            });\n        }\n        if (updatedItems != null) {\n            onLayoutStructureChange(updatedItems);\n        }\n    }, [\n        layoutStructure,\n        edgesBeforeMove,\n        edges,\n        getSelectedItems,\n        mousePosition,\n        panelPadding,\n        sendTelemetry,\n        canvasWidth,\n        onLayoutStructureChange,\n    ]);\n\n    /*\n        Clean up the state from the preview, and undo any changes by reverting to original state before the item move\n    */\n    const cleanupAfterPreview = useCallback(() => {\n        if (delayPreviewViz.current) {\n            clearTimeout(delayPreviewViz.current);\n        }\n        if (delayPreviewEdge.current) {\n            clearTimeout(delayPreviewEdge.current);\n        }\n        setInvalidEdgeId(null);\n        setIsInvalidVizDrop(false);\n        setInitialItemToMove(null);\n        setHoveredBlock(null);\n        setHoveredQuadrant(null);\n        if (edgesBeforeMove) {\n            // If a preview was shown, revert back to original\n            setEdges(edgesBeforeMove);\n            setEdgesBeforeMove(null);\n            dispatch(resetLayoutAction(layoutStructure));\n        }\n        if (hoveredBlock) {\n            dispatch(resetLayoutAction(layoutStructure));\n        }\n    }, [edgesBeforeMove, hoveredBlock, layoutStructure]);\n\n    /**\n     * update the blocks when it finished moving\n     */\n    const handleBlockItemMoved = useCallback(() => {\n        cleanupAfterPreview();\n        if (mousePosition !== null) {\n            // updates layout structure\n            handleVizDrop();\n        }\n        setIsBlockItemMoving(false);\n        setMousePosition(null);\n    }, [cleanupAfterPreview, mousePosition, handleVizDrop]);\n\n    const handleBlockItemPositionUpdate = useCallback(({ item, offset }) => {\n        const newItem = updateBlockItemPosition(item, offset);\n\n        // update runtime structure\n        dispatch(updateItemAction(newItem));\n    }, []);\n\n    /**\n     * Block Items resize and move Handler\n     * @param {Object} e mouse event\n     * @param {Object} options\n     * @param {Object} options.itemId itemId for selected Viz\n     * @param {Object} options.offset offset amount to move Viz\n     * @param {Object} options.dir direction to resize Viz\n     */\n    const handleBlockItemResize = useCallback(\n        (\n            e: MouseEvent,\n            {\n                itemId,\n                offset,\n                dir,\n            }: { itemId: string; offset: Offset; dir: HandleDirection }\n        ) => {\n            // all computation is done against last committed items!\n            const item = getStructureItem(layoutStructure, itemId);\n            const newItem = updateBlockItemSize({\n                item,\n                offset,\n                dir,\n                options: {\n                    minHeight: MIN_HEIGHT_PX,\n                    minWidth: MIN_WIDTH_PX,\n                },\n            });\n\n            // update runtime structure\n            dispatch(updateItemAction(newItem));\n        },\n        [layoutStructure]\n    );\n\n    /**\n     * handler for when Block is finished Resizing\n     */\n    const handleBlockItemResized = useCallback(() => {\n        // resize completed\n        handleLayoutStructureChange();\n        sendTelemetry({\n            source: 'canvas',\n            event: 'edge_resize',\n        });\n    }, [handleLayoutStructureChange, sendTelemetry]);\n\n    const handleMouseDownOnEdge = useCallback(\n        (e, { id }) => {\n            isDraggingEdge.current = true;\n\n            const edge = edges.find(({ item }) => item === id);\n\n            if (!edge) {\n                return;\n            }\n\n            // set selected visualizations\n            // select proper viz items and also proper edge orientation for viz\n            const visualizationIds = edge.visualizations.map((viz) => viz.item);\n\n            // find boundaries, either horizontal boundary - { leftBoundary, rightBoundary }\n            // or vertical boundary - { upperBoundary, lowerBoundary }\n            const newEdgeBoundaries =\n                edge.orientation === 'horizontal'\n                    ? getVerticalBoundaries({\n                          visualizations: edge.visualizations,\n                          y: edge.edgeStart.y,\n                          minHeight: MIN_HEIGHT_PX,\n                          isFullWidthEdge:\n                              edge.edgeEnd.x - edge.edgeStart.x === canvasWidth,\n                      })\n                    : getHorizontalBoundaries({\n                          visualizations: edge.visualizations,\n                          x: edge.edgeStart.x,\n                          minWidth: MIN_WIDTH_PX,\n                      });\n            // save new boundary\n            edgeBoundaries.current = newEdgeBoundaries;\n\n            // compute edges in boundary\n            edgesInBoundary.current = findEdgesInBoundary({\n                edge,\n                edges,\n                edgeBoundaries: newEdgeBoundaries,\n            });\n\n            edgeMouseDownPosition.current = getClientPosition(e, mouseScale);\n            mouseDownEdge.current = { ...edge };\n            setSelectedItemsForEdge(visualizationIds);\n        },\n        [edges, mouseScale, canvasWidth]\n    );\n\n    /**\n     * handle resizing for selected edge and visualizations\n     */\n    const handleEdgeMove = useEventCallback((e: MouseEvent) => {\n        e.preventDefault();\n        e.stopPropagation();\n\n        // update selected edge location\n        if (!isDraggingEdge.current || !mouseDownEdge.current) {\n            return;\n        }\n\n        const currentPosition = getClientPosition(e, mouseScale);\n        const offset = getOffset(\n            currentPosition,\n            edgeMouseDownPosition.current as Coordinate\n        );\n\n        let updatedEdge =\n            mouseDownEdge?.current?.orientation === 'vertical'\n                ? moveVerticalEdge({\n                      edge: mouseDownEdge.current,\n                      offset: offset.offsetX,\n                      edgeBoundaries: edgeBoundaries.current as HorizontalBoundaries,\n                  })\n                : moveHorizontalEdge({\n                      edge: mouseDownEdge.current,\n                      offset: offset.offsetY,\n                      edgeBoundaries: edgeBoundaries.current as VerticalBoundaries,\n                  });\n\n        let updatedSnappableEdges: EdgeItem[] = [];\n        if (!e.shiftKey) {\n            const { updatedEdge: ue, snappableEdges: se } = findSnappableEdges({\n                edge: updatedEdge,\n                edges: edgesInBoundary.current ?? [],\n                snapRange: SNAP_RANGE_PX,\n            });\n            updatedEdge = ue;\n            updatedSnappableEdges = se;\n        }\n\n        setEdges((prevEdges) =>\n            prevEdges.map((anEdge) => {\n                if (anEdge.item === updatedEdge.item) {\n                    return updatedEdge;\n                }\n\n                return anEdge;\n            })\n        );\n\n        // update visualizations locations\n        const vizOffset = {\n            offsetX:\n                updatedEdge.edgeStart.x - mouseDownEdge.current.edgeStart.x,\n            offsetY:\n                updatedEdge.edgeStart.y - mouseDownEdge.current.edgeStart.y,\n        };\n\n        const isFullWidthEdge =\n            mouseDownEdge.current.edgeEnd.x -\n                mouseDownEdge.current.edgeStart.x ===\n            canvasWidth;\n        if (isFullWidthEdge) {\n            // If user is dragging full width edge, update ALL the visualizations below the edge by\n            //  shifting them downwards/upwards, including the ones that are not directly touching the edge\n            // The block items need to be the committed versions\n            layoutStructure.forEach((item) => {\n                if (\n                    mouseDownEdge.current &&\n                    item.position.y >= mouseDownEdge.current.edgeStart.y\n                ) {\n                    handleBlockItemPositionUpdate({\n                        item,\n                        offset: vizOffset,\n                    });\n                }\n            });\n        }\n\n        if (selectedItemsForEdge.length > 0) {\n            selectedItemsForEdge.forEach((itemId) => {\n                const item = getStructureItem(layoutStructure, itemId);\n                if (\n                    !mouseDownEdge.current ||\n                    (isFullWidthEdge &&\n                        item.position.y >= mouseDownEdge.current.edgeStart.y)\n                ) {\n                    // if the moving edge is a full width edge, we already took care of the visualizations\n                    //   below that edge, thus ignore them here, and only resize the items above the edge\n                    return;\n                }\n                let resizeDir: HandleDirection;\n                if (mouseDownEdge.current?.orientation === 'horizontal') {\n                    resizeDir =\n                        item.position.y >= mouseDownEdge.current.edgeStart.y\n                            ? 'n'\n                            : 's';\n                } else {\n                    resizeDir =\n                        item.position.x >= mouseDownEdge.current.edgeStart.x\n                            ? 'w'\n                            : 'e';\n                }\n                handleBlockItemResize(e, {\n                    itemId,\n                    offset: vizOffset,\n                    dir: resizeDir,\n                });\n            });\n        }\n\n        // check for snappable edges\n        // highlight snappable edges\n        setSnappableEdges(updatedSnappableEdges);\n    });\n\n    useMouseMoveHandler({\n        onMouseMove: handleEdgeMove,\n        isEnabled: mode === 'edit',\n        throttledMs: 32,\n    });\n\n    /**\n     * handler for when Edge is finished Moving\n     */\n    const handleEdgeMoved = useEventCallback((e: MouseEvent) => {\n        // DO NOT stop propagation, because visualizations are listening to mouse up to tell\n        // whether it stopped moving. Refer to GridCanvas.jsx for the logic.\n        e.preventDefault();\n\n        // need to reset this before updating state\n        mouseDownEdge.current = null;\n        edgeMouseDownPosition.current = null;\n        edgeBoundaries.current = null;\n        edgesInBoundary.current = null;\n\n        if (isDraggingEdge.current) {\n            isDraggingEdge.current = false;\n            // only unset select viz when resizing edge is done,\n            // not on clicking a viz.\n            setSelectedItemsForEdge([]);\n            handleBlockItemResized();\n        }\n\n        if (snappableEdges.length > 0) {\n            setSnappableEdges([]);\n        }\n    });\n\n    useEffect(() => {\n        if (mode !== 'edit') {\n            return undefined;\n        }\n\n        document.addEventListener('mouseup', handleEdgeMoved);\n\n        return () => {\n            document.removeEventListener('mouseup', handleEdgeMoved);\n        };\n    }, [handleEdgeMoved, mode]);\n\n    useEffect(() => {\n        if (!keyboardListener) {\n            return () => undefined;\n        }\n\n        const unsubscribeKeyboardListener = keyboardListener.subscribe(\n            'cancel',\n            () => {\n                if (isBlockItemMoving) {\n                    cleanupAfterPreview();\n                    setIsBlockItemMoving(false);\n                    setMousePosition(null);\n                } else {\n                    // deselect all selected items;\n                    onLayoutItemsSelect([]);\n                }\n            }\n        );\n\n        return () => {\n            unsubscribeKeyboardListener();\n        };\n    }, [\n        cleanupAfterPreview,\n        isBlockItemMoving,\n        onLayoutItemsSelect,\n        keyboardListener,\n    ]);\n\n    /**\n     * render outline for block items\n     * @param {Number} scale scale value\n     */\n    const renderOutline = () => {\n        const selectedItems =\n            selectedItemsForEdge.length > 0\n                ? selectedItemsForEdge\n                : getSelectedItems().map(({ id }) => id);\n        const blockItems = getBlockItems(gridState);\n        return blockItems.map((item) => {\n            // 1. item must be selected AND\n            // 2. either the item is not moving (user just selected it)\n            //   OR the item is moving and the preview is shown (to show green outline around preview placeholder)\n            const displayOutline =\n                selectedItems.includes(item.item) &&\n                (!isBlockItemMoving || showPreviewPlaceholder);\n            if (displayOutline) {\n                const paddedItem = applyVizPadding({\n                    item,\n                    padding: panelPadding,\n                });\n                return (\n                    <MemoizedBlockOutline\n                        handleDirections={HANDLE_DIRECTIONS}\n                        key={item.item}\n                        itemId={item.item}\n                        scale={mouseScale}\n                        x={paddedItem.position.x}\n                        y={paddedItem.position.y}\n                        w={paddedItem.position.w}\n                        h={paddedItem.position.h}\n                    />\n                );\n            }\n            // for all other block items, no outline will be displayed.\n            return null;\n        });\n    };\n\n    const getEdgeAppearance = useCallback(\n        ({ edge }: { edge: EdgeItem }): EdgeAppearance => {\n            const renderAllEdges = !mouseDownEdge.current;\n            let appearance: EdgeAppearance =\n                renderAllEdges ||\n                edge.item === get(mouseDownEdge.current, 'item') ||\n                snappableEdges.find((e) => e.item === edge.item)\n                    ? 'normal'\n                    : 'hidden';\n\n            if (isBlockItemMoving) {\n                const itemToMove = layoutStructure.find(\n                    ({ item }) => item === getSelectedItems()[0]?.id\n                );\n                // hide edge if it's adjacent to the moving item and has the same width/height as item\n                if (\n                    itemToMove &&\n                    isDropOnOwnEdge({\n                        edge,\n                        itemToMove: itemToMove as AbsoluteBlockItem,\n                    })\n                ) {\n                    appearance = 'hidden';\n                } else {\n                    appearance = 'dropTarget';\n                }\n            }\n            if (invalidEdgeId === edge.item) {\n                appearance = 'invalid';\n            }\n            return appearance;\n        },\n        [\n            invalidEdgeId,\n            isBlockItemMoving,\n            mouseDownEdge,\n            snappableEdges,\n            getSelectedItems,\n            layoutStructure,\n        ]\n    );\n\n    /**\n     * Renders the Edges\n     * @param {Object} options\n     * @param {Number} options.edgeThickness edgeThickness\n     * @param {Number} options.scale scale value\n     * @returns {Object} returns edge with updated position\n     */\n    const edgeItems = useMemo(() => {\n        if (mode !== 'edit') {\n            return null;\n        }\n\n        // if no edge is selected, render all edges\n        return edges.map((edge) => {\n            const formattedEdge = formatEdgeWrapper({\n                edge,\n                padding: panelPadding,\n            });\n            const { width, height } = getDimensions({\n                edge: formattedEdge,\n                thickness: 2 * panelPadding,\n            });\n            const { x, y } = formattedEdge.edgeStart;\n\n            return (\n                <MemoizedEdge\n                    key={edge.item}\n                    itemId={edge.item}\n                    x={x}\n                    y={y}\n                    w={width}\n                    h={height}\n                    padding={panelPadding}\n                    orientation={edge.orientation}\n                    isCanvasEdge={edge.isCanvasEdge}\n                    appearance={getEdgeAppearance({ edge })}\n                    onMouseDown={handleMouseDownOnEdge}\n                    // use the raw coordinates as test hook, so that it is easier to triage and is compatible with the previous implementation\n                    data-test-edge-position={`${edge.edgeStart.x},${edge.edgeStart.y}-${edge.edgeEnd.x},${edge.edgeEnd.y}`}\n                />\n            );\n        });\n    }, [mode, edges, getEdgeAppearance, panelPadding, handleMouseDownOnEdge]);\n\n    const handleRenderPreviewPlaceholderItem = useCallback(() => {\n        if (!firstSelectedItemStructure || !showPreviewPlaceholder) {\n            return null;\n        }\n\n        const item = applyVizPadding({\n            item: firstSelectedItemStructure,\n            padding: panelPadding,\n        });\n        return (\n            <PreviewPlaceholderItem\n                key={`${firstSelectedItemStructure.item}-preview`}\n                position={item.position}\n            />\n        );\n    }, [firstSelectedItemStructure, panelPadding, showPreviewPlaceholder]);\n\n    // TODO: this is an ugly hack to make deleting a viz not break the layout\n    /**\n     * History:\n     * layoutStructure prop changes will cause a rerender.\n     * The renderBlockItems method needs to receive the modified structure (e.g. from dragging) stored in the reducer state.\n     * Removing a viz will result in a layoutStructure change and render before the reducer updates, referencing a viz that no longer exists.\n     * This will throw an error when trying to resolve tokens in the unknown viz config.\n     * An undo operation after a delete will restore a viz that does not exist in gridState, so a filtered structure must account for this case.\n     */\n    const filteredState = useMemo(\n        () => getFilteredStructure(gridState, layoutStructure),\n        [gridState, layoutStructure]\n    );\n\n    const items = getSelectedItems();\n\n    // no need to memoize because it is destructured before passing to GridCanvas\n    const commonProps = {\n        width: canvasWidth,\n        height: maxHeight,\n        scale,\n        selectable: true,\n        selectedLayoutItems: items,\n        onItemSelected: handleItemSelected,\n        panelPadding,\n        ref: canvasRef,\n    };\n    const modeSpecificProps =\n        mode === 'edit'\n            ? {\n                  movable: true,\n                  showOverflowContent: false,\n                  showGrid,\n                  showBorder: true,\n                  gridWidth: GRID_SIZE_PX - 1,\n                  gridHeight: GRID_SIZE_PX - 1,\n                  gridLineWidth: 1,\n                  gridPadding: GRID_PADDING_PX,\n                  onItemMove: handleBlockItemMove,\n                  onItemMoved: handleBlockItemMoved,\n                  userSelect: false,\n              }\n            : {\n                  movable: false,\n                  showOverflowContent: false,\n                  showGrid: false,\n                  showBorder: false,\n                  userSelect: true,\n              };\n\n    return (\n        <GridCanvas\n            data-test=\"grid-layout\"\n            blockItems={filteredState}\n            data-test-scale={scale}\n            {...commonProps}\n            {...modeSpecificProps}\n        >\n            <Layer key=\"block-item-layer\" data-test=\"block-item-layer\">\n                {renderBlockItems({\n                    layoutStructure: filteredState,\n                    renderLayoutItem,\n                    handleItemSelected,\n                    isBlockItemMoving,\n                    selectedItem: getSelectedItems()[0],\n                    mode,\n                    errors: layoutErrors,\n                    padding: panelPadding,\n                    canvasHeight: maxHeight,\n                })}\n            </Layer>\n            {edgeItems}\n            <Layer key=\"outline-layer\" data-test=\"outline-layer\">\n                {renderOutline()}\n            </Layer>\n            {mousePosition && isBlockItemMoving && handleRenderItemDropTarget()}\n            {mousePosition &&\n                isBlockItemMoving &&\n                handleRenderPreviewPlaceholderItem()}\n            {mousePosition && isBlockItemMoving && (\n                <ItemDragPlaceholder\n                    position={mousePosition}\n                    size={PLACEHOLDER_SIZE_PX}\n                />\n            )}\n        </GridCanvas>\n    );\n};\n\n// Wrapper function that primarily handles the enableGridLayoutCssScaling functionality.\nconst GridLayout = (props: GridLayoutProps): JSX.Element => {\n    const {\n        containerWidth,\n        options: { width: canvasWidth = gridLayoutOptions.width } = {},\n        onLayoutStructureChange,\n        layoutStructure,\n    } = props;\n    const { enableGridLayoutCssScaling } = useFeatureFlags();\n\n    const scale = computeScaleToFit(containerWidth, canvasWidth);\n\n    // Undo the scaling when we change the layoutStructure. With the enableGridLayoutCssScaling\n    // flag we're now modifying the actual width of the BlockItem so we want to ensure\n    // we are using the original unscaled values (1 / scale)\n    const handleLayoutStructureChange = useCallback(\n        (layout) => {\n            onLayoutStructureChange(\n                scaleGridLayoutStructureByWidth({\n                    layout,\n                    scale: 1 / scale,\n                })\n            );\n        },\n        [scale, onLayoutStructureChange]\n    );\n\n    // If we're not scaling the layout we have to scale each blockItem\n    const scaledLayoutStructure = useMemo(\n        () =>\n            !enableGridLayoutCssScaling\n                ? scaleGridLayoutStructureByWidth({\n                      layout: layoutStructure,\n                      scale,\n                  })\n                : layoutStructure,\n        [enableGridLayoutCssScaling, layoutStructure, scale]\n    );\n\n    return (\n        <BaseGridLayout\n            {...props}\n            scale={scale}\n            canvasWidth={canvasWidth}\n            {...(!enableGridLayoutCssScaling\n                ? {\n                      canvasWidth: containerWidth,\n                      layoutStructure: scaledLayoutStructure,\n                      onLayoutStructureChange: handleLayoutStructureChange,\n                  }\n                : null)}\n        />\n    );\n};\n\nGridLayout.schema = gridLayoutOptionsSchema;\n\nexport default GridLayout;\n","module.exports = require(\"memoize-one\");","module.exports = require(\"@splunk/dashboard-context/CanvasContext\");","import React, {\n    useState,\n    useCallback,\n    Ref,\n    forwardRef,\n    useEffect,\n} from 'react';\nimport { uniqBy } from 'lodash';\nimport type {\n    Coordinate,\n    AbsoluteBlockItem as BlockItem,\n    SelectedItem,\n} from '@splunk/dashboard-types';\nimport { useFeatureFlags } from '@splunk/dashboard-context';\nimport useEventCallback from '@splunk/dashboard-ui/hooks/useEventCallback';\nimport useMouseMoveHandler from '@splunk/dashboard-ui/hooks/useMouseMoveHandler';\nimport Canvas from './Canvas';\nimport { CanvasProps, Offset } from '../types';\nimport {\n    getOffset,\n    considerMoved,\n    positionsToBoundary,\n    computeRelativePosition,\n    findTopBlockItemByPosition,\n    filterBlockItemsByBoundary,\n} from '../utils/layoutUtils';\nimport { applyVizPadding } from '../utils/edgeUtils';\n\ninterface GridCanvasState {\n    startPosition: Coordinate | null;\n    isMoving: boolean;\n}\n\nconst defaultState: GridCanvasState = {\n    startPosition: null,\n    isMoving: false,\n};\n\nexport interface GridCanvasProps extends CanvasProps {\n    panelPadding?: number;\n    movable?: boolean;\n    selectable?: boolean;\n    blockItems: BlockItem[];\n    selectedLayoutItems?: SelectedItem[];\n    onItemSelected: (e: React.MouseEvent, items: SelectedItem[]) => void;\n    onItemMove?: (\n        e: React.MouseEvent,\n        { currentPosition }: { currentPosition: Coordinate }\n    ) => void;\n    onItemMoved?: (e: React.MouseEvent, offset: Offset) => void;\n    children: React.ReactNode;\n}\n\nconst DEFAULT_SELECTED_LAYOUT_ITEMS: SelectedItem[] = [];\nconst noop = () => undefined;\n\nconst GridCanvas = (\n    props: GridCanvasProps & { canvasRef: Ref<HTMLDivElement> }\n): JSX.Element => {\n    const {\n        movable = false,\n        selectable = false,\n        selectedLayoutItems = DEFAULT_SELECTED_LAYOUT_ITEMS,\n        panelPadding = 0,\n        scale = 1,\n        onItemMove = noop,\n        onItemMoved = noop,\n        onItemSelected,\n        children,\n        canvasRef,\n        blockItems,\n        ...canvasProps\n    } = props;\n\n    const { enableGridLayoutCssScaling } = useFeatureFlags();\n\n    const [startPosition, setStartPosition] = useState(\n        defaultState.startPosition\n    );\n    const [isMoving, setIsMoving] = useState(defaultState.isMoving);\n\n    const resetState = useCallback(() => {\n        setIsMoving(defaultState.isMoving);\n        setStartPosition(defaultState.startPosition);\n    }, []);\n\n    const mouseScale = enableGridLayoutCssScaling ? scale : 1;\n\n    const handleItemSelected = useCallback(\n        (e, itemIds = []) => {\n            if (e.metaKey) {\n                // Do not allow selecting block item with meta+click\n                const selectedItems = selectedLayoutItems.filter(\n                    ({ type }) => type === 'block'\n                );\n                onItemSelected(e, uniqBy([...selectedItems, ...itemIds], 'id'));\n            } else {\n                onItemSelected(e, itemIds);\n            }\n        },\n        [selectedLayoutItems, onItemSelected]\n    );\n\n    // Track starting position of mouse down event and select blockItem if it's not selected\n    const handleMouseDown = useCallback(\n        (e) => {\n            const pos = computeRelativePosition(e, canvasRef, mouseScale);\n            const block = findTopBlockItemByPosition(\n                blockItems,\n                pos,\n                panelPadding\n            );\n            // always track start position\n            if (selectable) {\n                setStartPosition(pos);\n            }\n            if (block) {\n                // mouse down on an item, start moving.\n                if (!selectedLayoutItems.find(({ id }) => id === block.item)) {\n                    // select the block item right away if it's not selected.\n                    handleItemSelected(e, [{ id: block.item, type: 'block' }]);\n                }\n                if (movable) {\n                    setIsMoving(true);\n                }\n            }\n        },\n        [\n            canvasRef,\n            mouseScale,\n            blockItems,\n            selectable,\n            selectedLayoutItems,\n            handleItemSelected,\n            movable,\n            panelPadding,\n        ]\n    );\n\n    // Trigger onItemMove (callback) with move offset\n    const handleMouseMove = useEventCallback((e: React.MouseEvent) => {\n        if (startPosition) {\n            const currentPosition = computeRelativePosition(\n                e,\n                canvasRef,\n                mouseScale\n            );\n            if (currentPosition) {\n                const offset = getOffset(currentPosition, startPosition);\n                if (isMoving && considerMoved(offset)) {\n                    e.preventDefault();\n                    onItemMove(e, { currentPosition });\n                }\n            }\n        }\n    });\n\n    // Trigger onItemMoved (callback) with final offset if an item was moved OR multiselect items within a boundary\n    const handleMouseUp = useEventCallback((e: React.MouseEvent) => {\n        if (startPosition) {\n            const currentPosition = computeRelativePosition(\n                e,\n                canvasRef,\n                mouseScale\n            );\n            if (currentPosition) {\n                // if will be either complete a move or a multi select\n                const offset = getOffset(currentPosition, startPosition);\n                if (isMoving && considerMoved(offset)) {\n                    onItemMoved(e, offset);\n                } else {\n                    // todo: we shouldn't need to use absolute coordinates to figure out which item is clicked, given there's no overlapped visualizations in grid layout. Ideally, we should let the actual viz being clicked update the selectedItem state.\n                    let blocks = blockItems;\n                    if (panelPadding) {\n                        blocks = blocks.map((block) =>\n                            applyVizPadding({\n                                item: block,\n                                padding: panelPadding,\n                            })\n                        );\n                    }\n                    const boundary = positionsToBoundary(\n                        startPosition,\n                        currentPosition\n                    );\n                    const selectedBlocks = filterBlockItemsByBoundary(\n                        blocks,\n                        boundary\n                    ).map(({ item }) => ({\n                        id: item,\n                        type: 'block',\n                    }));\n\n                    // select single item\n                    const topItem = selectedBlocks[selectedBlocks.length - 1];\n                    handleItemSelected(e, topItem ? [topItem] : []);\n                }\n                resetState();\n            }\n        }\n    });\n\n    useEffect(() => {\n        document.addEventListener('mouseup', handleMouseUp);\n        return () => {\n            document.removeEventListener('mouseup', handleMouseUp);\n        };\n    }, [handleMouseUp]);\n\n    useMouseMoveHandler({ onMouseMove: handleMouseMove, isEnabled: movable });\n\n    return (\n        <Canvas\n            ref={canvasRef}\n            {...canvasProps}\n            scale={scale}\n            onMouseDown={handleMouseDown}\n            onContextMenu={resetState}\n            cssScaling={enableGridLayoutCssScaling}\n        >\n            {children}\n        </Canvas>\n    );\n};\n\nexport default forwardRef(\n    (props: GridCanvasProps, ref: React.Ref<HTMLDivElement>) => (\n        <GridCanvas canvasRef={ref} {...props} />\n    )\n);\n","/**\n * This file is a central location for all shared utility functions related to Grid Layout.\n * If a certain function requires a dependency that lives in another utility file, then\n * that function should live here. If it does not have any dependencies, then it can live\n * in a separate utility file.\n */\n\nimport isEqual from 'lodash/isEqual';\nimport isEmpty from 'lodash/isEmpty';\nimport { _ } from '@splunk/ui-utils/i18n';\nimport type {\n    AbsoluteBlockItem,\n    Coordinate,\n    AbsolutePosition,\n} from '@splunk/dashboard-types';\n\nimport {\n    updateRemovedVizNeighbors,\n    isLeftNeighbor,\n    isRightNeighbor,\n    findHorizontalNeighbors,\n    isTopNeighbor,\n    isBottomNeighbor,\n} from './gridLayoutApiUtils';\nimport { updateBlockItemSize } from './layoutUtils';\nimport { MIN_WIDTH_PX, MIN_HEIGHT_PX } from '../GridLayoutConstants';\n\nimport type { EdgeItem, LayoutError, Quadrant } from '../types';\n\n/**\n * Return a wrapper for the edge, such that this wrapper fills the entire gutter between 2 viz\n * @param {Object} params\n * @param {EdgeItem} params.edge - The edge that this wrapper will go \"around\"\n * @param {Number} params.padding - The amount of padding between two visualizations\n * @returns {EdgeItem} - Formatted edge such that it fills the gutter space between two visualizations\n */\nexport const formatEdgeWrapper = ({\n    edge,\n    padding = 0,\n}: {\n    edge: EdgeItem;\n    padding?: number;\n}): EdgeItem => {\n    const wrapperStart: Coordinate = { ...edge.edgeStart };\n    const wrapperEnd: Coordinate = { ...edge.edgeEnd };\n    if (edge.orientation === 'horizontal') {\n        // Add padding to the ends of the edge, to make it line up with visualizations\n        wrapperStart.x += padding;\n        wrapperEnd.x -= padding;\n        // make edge y the top of the gutter (so that when thickness === 2*padding it will fill whole gutter)\n        wrapperStart.y -= padding;\n        wrapperEnd.y -= padding;\n    } else {\n        // Add padding to the ends of the edge, to make it line up with visualizations\n        wrapperStart.y += padding;\n        wrapperEnd.y -= padding;\n        // make edge x the left-most of the gutter (so that when thickness === 2*padding it will fill whole gutter)\n        wrapperStart.x -= padding;\n        wrapperEnd.x -= padding;\n    }\n\n    return { ...edge, edgeStart: wrapperStart, edgeEnd: wrapperEnd };\n};\n\nexport const getDimensions = ({\n    edge,\n    thickness,\n}: {\n    edge: EdgeItem;\n    thickness: number;\n}): { width: number; height: number } => {\n    return {\n        width:\n            edge.orientation === 'horizontal'\n                ? edge.edgeEnd.x - edge.edgeStart.x\n                : thickness,\n        height:\n            edge.orientation === 'vertical'\n                ? edge.edgeEnd.y - edge.edgeStart.y\n                : thickness,\n    };\n};\n\n/**\n * Check whether the mouse is on top of the edge\n * @param {Object} params\n * @param {EdgeItem} params.edge - The edge that is being checked\n * @param {Coordinate} params.mousePosition - The position of the mouse on the screen, scaled\n * @param {Number} params.padding - The amount of padding between two visualizations\n * @returns {boolean}\n */\nexport const isMouseOnEdge = ({\n    edge,\n    mousePosition,\n    padding = 0,\n}: {\n    edge: EdgeItem;\n    mousePosition: Coordinate;\n    padding?: number;\n}): boolean => {\n    const formattedEdge = formatEdgeWrapper({ edge, padding });\n    const { width, height } = getDimensions({\n        edge: formattedEdge,\n        thickness: 2 * padding,\n    });\n    return (\n        mousePosition.x <= formattedEdge.edgeStart.x + width &&\n        mousePosition.x >= formattedEdge.edgeStart.x &&\n        mousePosition.y <= formattedEdge.edgeStart.y + height &&\n        mousePosition.y >= formattedEdge.edgeStart.y\n    );\n};\n\n/**\n * When dropping a viz on a full-width edge, shift all the visualizations below that edge down\n * instead of taking size from the nearby visualizations\n * @param {Object}\n * @param {EdgeItem} params.edge - The edge that is being dropped on. Spans full width of canvas\n * @param {AbsoluteBlockItem} params.itemToMove - The item that is being removed\n * @param {AbsoluteBlockItem[]} params.items - All the items on the canvas\n * @returns {AbsoluteBlockItem[]} - Array of updated items, shifted down to create space for the added viz.\n */\nexport const computeNewVizPositionsGutterCase = ({\n    edge,\n    itemToMove,\n    items,\n}: {\n    edge: EdgeItem;\n    itemToMove: AbsoluteBlockItem;\n    items: AbsoluteBlockItem[];\n}): AbsoluteBlockItem[] => {\n    const updatedVisualizations: AbsoluteBlockItem[] = [];\n    items.forEach((item) => {\n        if (item.position.y >= edge.edgeStart.y) {\n            const viz =\n                item.item === itemToMove.item\n                    ? { ...item, item: 'itemToRemove' }\n                    : item;\n\n            updatedVisualizations.push({\n                ...viz,\n                position: {\n                    ...viz.position,\n                    y: viz.position.y + itemToMove.position.h,\n                },\n            });\n        }\n    });\n    // Now let's push the moved viz on the updatedVisualizations array\n    updatedVisualizations.push({\n        ...itemToMove,\n        position: {\n            ...itemToMove.position, // height is preserved\n            y: edge.edgeStart.y,\n            x: edge.edgeStart.x,\n            w: edge.edgeEnd.x - edge.edgeStart.x,\n        },\n    });\n\n    return updatedVisualizations;\n};\n\ntype AccumulatedSize = {\n    firstHalf: number[];\n    secondHalf: number[];\n} | null;\n\n/**\n * Determine the amount to take from each viz surrounding an edge that itemToMove is being dropped on\n * @param {Object}\n * @param {EdgeItem} params.edge - The edge that is being dropped on\n * @param {Number} params.amountToTake - The proportion of each viz to take. ex: 1/3\n * @param {Number} params.minWidth - Minimum width a viz can have\n * @param {Number} params.minHeight - Minimum height a viz can have\n * @returns {Object}\n */\nexport const sizeToTakeFromViz = ({\n    amountToTake,\n    edge,\n    minWidth,\n    minHeight,\n}: {\n    amountToTake: number;\n    edge: EdgeItem;\n    minWidth: number;\n    minHeight: number;\n}): {\n    firstHalf: number | null;\n    secondHalf: number | null;\n} => {\n    // When a visualization is dropped, it takes `amountToTake` from each visualization. Thus\n    //   it gets 1 size (firstHalf) from one side, and another (secondHalf) from the other side of the edge.\n    //    It's not entirely accurate to call them halves, as they are not typically equal.\n    const reduction = edge.visualizations.reduce<AccumulatedSize>(\n        (acc: AccumulatedSize, viz: AbsoluteBlockItem): AccumulatedSize => {\n            if (acc === null) {\n                return null;\n            }\n            if (edge.orientation === 'vertical') {\n                const widthToTake = Math.ceil(viz.position.w * amountToTake);\n                if (viz.position.w - widthToTake < minWidth) {\n                    return null; // if viz is too small, return null\n                }\n                if (viz.position.x < edge.edgeStart.x) {\n                    return {\n                        ...acc,\n                        firstHalf: [...acc.firstHalf, widthToTake],\n                    };\n                }\n                return {\n                    ...acc,\n                    secondHalf: [...acc.secondHalf, widthToTake],\n                };\n            }\n            // if edge.orientation === horizontal\n            const heightToTake = Math.ceil(viz.position.h * amountToTake);\n            if (viz.position.h - heightToTake < minHeight) {\n                return null;\n            }\n            if (viz.position.y < edge.edgeStart.y) {\n                return {\n                    ...acc,\n                    firstHalf: [...acc.firstHalf, heightToTake],\n                };\n            }\n            return {\n                ...acc,\n                secondHalf: [...acc.secondHalf, heightToTake],\n            };\n        },\n        { firstHalf: [], secondHalf: [] }\n    );\n\n    if (reduction === null) {\n        // then there was an invalid edge drop because a viz is too small to give its size\n        // return null to indicate invalid edge drop\n        return {\n            firstHalf: null,\n            secondHalf: null,\n        };\n    }\n\n    // If there were no viz on one of the sides, return 0 for the amount to take from that side\n    // Otherwise, return the minimum amount to take, to respect the smallest viz on that side\n    return {\n        firstHalf:\n            reduction.firstHalf.length === 0\n                ? 0\n                : Math.min(...reduction.firstHalf),\n        secondHalf:\n            reduction.secondHalf.length === 0\n                ? 0\n                : Math.min(...reduction.secondHalf),\n    };\n};\n\n/**\n * When dropping a viz on a normal edge (not full canvas width), take a proportion from each of the visualizations\n * around the edge, updating those items and inserting the moved viz in the space created\n * @param {Object}\n * @param {EdgeItem} params.edge - The edge that is being dropped on. Spans full width of canvas\n * @param {AbsoluteBlockItem} params.itemToMove - The item that is being moved\n * @param {Number} params.firstHalf - The amount of space moved viz will take up on the left/top sides\n * @param {Number} params.secondHalf - The amount of space moved viz will take up on the right/bottom sides\n * @returns {AbsoluteBlockItem[]} - Array of updated items after the moved viz was added\n */\nexport const computeNewVizPositions = ({\n    edge,\n    itemToMove,\n    firstHalf,\n    secondHalf,\n}: {\n    edge: EdgeItem;\n    itemToMove: AbsoluteBlockItem;\n    firstHalf: number;\n    secondHalf: number;\n}): AbsoluteBlockItem[] => {\n    // add width to the visualizations surrounding the edge\n    const updatedVisualizations = [];\n\n    // Update the visualizations touching the edge that is being dropped on\n    edge.visualizations.forEach((edgeViz) => {\n        // Check if the viz is the one that is being moved. This would be the old position of it,\n        // since we still need to update the \"placeholder\".\n        const viz =\n            edgeViz.item === itemToMove.item\n                ? { ...edgeViz, item: 'itemToRemove' }\n                : edgeViz;\n\n        if (edge.orientation === 'horizontal') {\n            if (viz.position.y < edge.edgeStart.y) {\n                updatedVisualizations.push(\n                    updateBlockItemSize({\n                        item: {\n                            ...viz,\n                        },\n                        offset: { offsetY: -1 * firstHalf, offsetX: 0 },\n                        dir: 's',\n                    })\n                );\n            }\n            if (viz.position.y >= edge.edgeStart.y) {\n                updatedVisualizations.push(\n                    updateBlockItemSize({\n                        item: {\n                            ...viz,\n                        },\n                        offset: { offsetY: secondHalf, offsetX: 0 },\n                        dir: 'n',\n                    })\n                );\n            }\n        } else {\n            if (viz.position.x < edge.edgeStart.x) {\n                updatedVisualizations.push(\n                    updateBlockItemSize({\n                        item: {\n                            ...viz,\n                        },\n                        offset: { offsetX: -1 * firstHalf, offsetY: 0 },\n                        dir: 'e',\n                    })\n                );\n            }\n            if (viz.position.x >= edge.edgeStart.x) {\n                updatedVisualizations.push(\n                    updateBlockItemSize({\n                        item: {\n                            ...viz,\n                        },\n                        offset: { offsetX: secondHalf, offsetY: 0 },\n                        dir: 'w',\n                    })\n                );\n            }\n        }\n    });\n\n    // update the moving viz to the new position\n    // The offsets represent how much to the left/right (same as up/down)\n    //  to offset the new viz from the EDGE position\n    updatedVisualizations.push({\n        ...itemToMove,\n        position: {\n            x:\n                edge.edgeStart.x -\n                (edge.orientation === 'vertical' ? firstHalf : 0),\n            y:\n                edge.edgeStart.y -\n                (edge.orientation === 'horizontal' ? firstHalf : 0),\n            w:\n                edge.orientation === 'vertical'\n                    ? firstHalf + secondHalf\n                    : edge.edgeEnd.x - edge.edgeStart.x,\n            h:\n                edge.orientation === 'horizontal'\n                    ? firstHalf + secondHalf\n                    : edge.edgeEnd.y - edge.edgeStart.y,\n        },\n    });\n    return updatedVisualizations;\n};\n\nconst isResultingVizSizeGreaterThanMin = ({\n    size,\n    edgeOrientation,\n}: {\n    size: number;\n    edgeOrientation: EdgeItem['orientation'];\n}): boolean => {\n    if (edgeOrientation === 'vertical') {\n        return size >= MIN_WIDTH_PX;\n    }\n    return size >= MIN_HEIGHT_PX;\n};\n\n/**\n * updates the Items into a valid Grid Layout Items List\n * @param {Object} params\n * @param {Object} params.updatedVisualizations visualizations that have been updated\n * @param {Object} params.itemToMove visualization that is being moved (removed)\n * @param {Array} params.items list of visualization items\n * @param {Number} params.canvasWidth width of canvas\n * @returns {Array{}} - returns a combined array of Viz Item Objects\n */\nexport const updateItems = ({\n    updatedVisualizations,\n    itemToMove,\n    items,\n    canvasWidth,\n}: {\n    updatedVisualizations: AbsoluteBlockItem[];\n    itemToMove: AbsoluteBlockItem;\n    items: AbsoluteBlockItem[];\n    canvasWidth: number;\n}): AbsoluteBlockItem[] => {\n    // make sure to use the up to date item instead of the old\n    const updatedItems = [\n        ...items.filter(\n            (item) =>\n                updatedVisualizations.find((viz) => viz.item === item.item) ===\n                undefined\n        ),\n        ...updatedVisualizations,\n    ];\n\n    const updatedNeighbors = updateRemovedVizNeighbors({\n        itemToRemove: itemToMove,\n        items: updatedItems,\n        width: canvasWidth,\n    });\n\n    // Now that we've updated the neighbors of the removed viz, we need\n    // to make sure we use the most up to date viz (since updatedVisualizations could potentially be stale)\n    const filteredUpdatedVisualizations = updatedVisualizations.filter(\n        (viz) =>\n            updatedNeighbors.find((neighbor) => neighbor.item === viz.item) ===\n                undefined && viz.item !== 'itemToRemove'\n    );\n\n    // items are all visualizations, filter out:\n    // 1. the visualizations we updated when we removed the viz from its initial position (updatedNeighbors)\n    // 2. the visualizations we updated when we inserted viz into its new position (filteredUpdatedVisualizations)\n    // 3. the visualization that was moved to its new position (itemToMove)\n    const filteredItems = items.filter(\n        (viz) =>\n            updatedNeighbors.find((neighbor) => neighbor.item === viz.item) ===\n                undefined &&\n            filteredUpdatedVisualizations.find(\n                (updatedViz) => updatedViz.item === viz.item\n            ) === undefined &&\n            viz.item !== itemToMove.item\n    );\n    return [\n        ...filteredItems,\n        ...filteredUpdatedVisualizations,\n        ...updatedNeighbors,\n    ];\n};\n\n/**\n * check if the moving item is dropping on its own edge and the edge has same width/height as item\n * @param {Object} params\n * @param {Object} edge edge being dropped onto\n * @param {Object} itemToMove visualization item being moved\n * @return {Boolean}\n */\nexport const isDropOnOwnEdge = ({\n    edge,\n    itemToMove,\n}: {\n    edge: EdgeItem;\n    itemToMove: AbsoluteBlockItem;\n}): boolean =>\n    edge.visualizations.find((viz) => viz.item === itemToMove.item) != null &&\n    ((edge.orientation === 'horizontal' &&\n        itemToMove.position.w === edge.edgeEnd.x - edge.edgeStart.x) ||\n        (edge.orientation === 'vertical' &&\n            itemToMove.position.h === edge.edgeEnd.y - edge.edgeStart.y));\n\n/**\n * Calculates new position values for visualizations being affected from a Visualization being dropped on an Edge\n * @param {Object} params\n * @param {Object} edge edge being dropped onto\n * @param {Object} itemToMove visualization Item being moved\n * @param {Object[]} items array of all visualization Items\n * @param {String} canvasWidth width of canvas\n * @return {Object[]} object of the list of updated visualizations items and updated itemToMove object\n */\nexport const updateDropOnEdge = ({\n    edge,\n    itemToMove,\n    items,\n    canvasWidth,\n}: {\n    edge: EdgeItem;\n    itemToMove: AbsoluteBlockItem;\n    items: AbsoluteBlockItem[];\n    canvasWidth: number;\n}): {\n    updatedVisualizations: AbsoluteBlockItem[];\n    updatedItemToMove: AbsoluteBlockItem;\n} | null => {\n    // Do not let user drop a viz on an edge it owns (exactly spans the width/height of that viz)\n    if (isDropOnOwnEdge({ edge, itemToMove })) {\n        return null;\n    }\n\n    // The amount to take from each surrounding visualization\n    const amountToTake = 1 / 3;\n\n    let updatedVisualizations = [];\n    if (\n        edge.orientation === 'horizontal' &&\n        edge.edgeEnd.x - edge.edgeStart.x === canvasWidth\n    ) {\n        // if we are dropping the visualization on an edge that spans the full width of\n        //  the canvas, then we have different behavior: shift all visualizations down\n        updatedVisualizations = computeNewVizPositionsGutterCase({\n            edge,\n            itemToMove,\n            items,\n        });\n    } else {\n        // Check if the visualizations surrounding the drop-target edge have enough space to give in order to insert the moving viz\n        // The moved viz gets one half of its size from the visualizations on one side of the edge, and the second half from the\n        //  visualizations on the other side of the edge\n        const { firstHalf, secondHalf } = sizeToTakeFromViz({\n            amountToTake,\n            edge,\n            minWidth: MIN_WIDTH_PX,\n            minHeight: MIN_HEIGHT_PX,\n        });\n        if (\n            firstHalf === null ||\n            secondHalf === null ||\n            // Check if the moved viz resulting size will be greater than the minimum width/height\n            // This particular case occurs when adding to the top and bottom canvas edge\n            !isResultingVizSizeGreaterThanMin({\n                size: firstHalf + secondHalf,\n                edgeOrientation: edge.orientation,\n            })\n        ) {\n            // invalid edge drop, one of the visualizations was too small to give up size\n            return null;\n        }\n        updatedVisualizations = computeNewVizPositions({\n            edge,\n            itemToMove,\n            firstHalf,\n            secondHalf,\n        });\n    }\n\n    // If the edge we move to caused an update to the old position of itemToMove, we need to update that\n    // position in order to correctly handle removing the viz in that old position.\n    const updatedItemToMove =\n        updatedVisualizations.find((viz) => viz.item === 'itemToRemove') ||\n        itemToMove;\n\n    return { updatedVisualizations, updatedItemToMove };\n};\n\n/**\n * Given a rectangular Item, determine whether the position is within bounds of the item\n * @param {Object} params\n * @param {Object} params.item visualization item being hovered over\n * @param {Object} params.position position of the mouse over the visualization\n * @returns {Boolean} whether the position is in bounds of the Item\n */\nexport const positionInItemBoundary = ({\n    item,\n    position,\n}: {\n    item: AbsoluteBlockItem;\n    position: Coordinate;\n}): boolean => {\n    return (\n        position.x >= item.position.x &&\n        position.x <= item.position.x + item.position.w &&\n        position.y >= item.position.y &&\n        position.y <= item.position.y + item.position.h\n    );\n};\n\n/**\n * Given a rectangular Item, find the quadrant where position is located on an item\n * where the quadrants are divided by diagonal lines creating four triangles\n * Dividing Line 1: (start: {top left corner}, end: {bottom right corner}) y = f(x) = slope * x\n * Dividing Line 2: (start: {bottom left corner}, end: {top right corner}) y = f(x) = -slope * x\n * @param {Object} params\n * @param {Object} params.item visualization item being hovered over\n * @param {Object} params.position position of the mouse over the visualization\n * @returns {String} returns the quadrant position is in Item oneOf('n', 's', 'w', 'e'), if not in quadrant it returns null\n */\nexport const findQuadrant = ({\n    item,\n    position,\n}: {\n    item: AbsoluteBlockItem;\n    position: Coordinate;\n}): Quadrant | null => {\n    if (positionInItemBoundary({ item, position })) {\n        let { x, y } = position;\n        x -= item.position.x;\n        y -= item.position.y;\n        const slope = item.position.h / item.position.w;\n        let quadrant: Quadrant[];\n        if (y > slope * x) {\n            quadrant = ['w', 's'];\n        } else {\n            quadrant = ['n', 'e'];\n        }\n        // If the slope of one diagonal is f(x) = (h/w) * x then the slope of the other (intersecting)\n        // diagonal is f(x) = -(h/w) * x + h, so we use the later to determine last quadrant\n        return y < -slope * x + item.position.h ? quadrant[0] : quadrant[1];\n    }\n    return null;\n};\n\n/**\n * Calculates the updated position values for the viz being moved and dropped onto\n * @param {Object} params\n * @param {Object} params.itemToMove item that is being moved\n * @param {Object} params.itemToDropOn item that the visualization is being dropped onto\n * @param {String} direction direction item is dropped on oneOf('n', 's', 'w', 'e')\n * @returns {Object[]} an Array containing updated itemToMove and itemToDropOn\n */\nexport const updateDropOnViz = ({\n    itemToMove,\n    itemToDropOn,\n    direction,\n}: {\n    itemToMove: AbsoluteBlockItem;\n    itemToDropOn: AbsoluteBlockItem;\n    direction: Quadrant;\n}): [AbsoluteBlockItem, AbsoluteBlockItem] | null => {\n    if (\n        ((direction === 'e' || direction === 'w') &&\n            itemToDropOn.position.w < MIN_WIDTH_PX * 2) ||\n        ((direction === 'n' || direction === 's') &&\n            itemToDropOn.position.h < MIN_WIDTH_PX * 2)\n    ) {\n        return null;\n    }\n    let vizToMove = {\n        ...itemToMove,\n        position: itemToDropOn.position,\n    };\n    let vizTarget = { ...itemToDropOn };\n    switch (direction) {\n        case 'n':\n            vizToMove = updateBlockItemSize({\n                item: vizToMove,\n                offset: {\n                    offsetY: -Math.floor(vizToMove.position.h / 2),\n                    offsetX: 0,\n                },\n                dir: 's',\n            });\n            vizTarget = updateBlockItemSize({\n                item: vizTarget,\n                offset: {\n                    offsetY: Math.ceil(vizTarget.position.h / 2),\n                    offsetX: 0,\n                },\n                dir: 'n',\n            });\n            break;\n        case 's':\n            vizToMove = updateBlockItemSize({\n                item: vizToMove,\n                offset: {\n                    offsetY: Math.floor(vizToMove.position.h / 2),\n                    offsetX: 0,\n                },\n                dir: 'n',\n            });\n            vizTarget = updateBlockItemSize({\n                item: vizTarget,\n                offset: {\n                    offsetY: -Math.ceil(vizTarget.position.h / 2),\n                    offsetX: 0,\n                },\n                dir: 's',\n            });\n            break;\n        case 'w':\n            vizToMove = updateBlockItemSize({\n                item: vizToMove,\n                offset: {\n                    offsetX: -Math.floor(vizToMove.position.w / 2),\n                    offsetY: 0,\n                },\n                dir: 'e',\n            });\n            vizTarget = updateBlockItemSize({\n                item: vizTarget,\n                offset: {\n                    offsetX: Math.ceil(vizTarget.position.w / 2),\n                    offsetY: 0,\n                },\n                dir: 'w',\n            });\n            break;\n        case 'e':\n            vizToMove = updateBlockItemSize({\n                item: vizToMove,\n                offset: {\n                    offsetX: Math.floor(vizToMove.position.w / 2),\n                    offsetY: 0,\n                },\n                dir: 'w',\n            });\n            vizTarget = updateBlockItemSize({\n                item: vizTarget,\n                offset: {\n                    offsetX: -Math.ceil(vizTarget.position.w / 2),\n                    offsetY: 0,\n                },\n                dir: 'e',\n            });\n            break;\n        default:\n            // reset viz to original state so nothing changes\n            vizToMove = itemToMove;\n            break;\n    }\n\n    return [vizToMove, vizTarget];\n};\n\n/**\n * Calculates new viz positions after the itemToMove viz is dropped on edge\n * @param {Object} params\n * @param {Object} params.edge edge being dropped onto\n * @param {Object} params.itemToMove visualization Item being moved\n * @param {Object[]} params.items array of all visualization Items\n * @param {String} params.canvasWidth width of canvas\n * @return {Object[]} object of the list of updated visualizations items, updated itemToMove object, and the old itemToMove\n */\nexport const previewDropOnEdge = ({\n    edge,\n    itemToMove,\n    items,\n    canvasWidth,\n}: {\n    edge: EdgeItem;\n    itemToMove: AbsoluteBlockItem;\n    items: AbsoluteBlockItem[];\n    canvasWidth: number;\n}): AbsoluteBlockItem[] | null => {\n    const updatedItems = updateDropOnEdge({\n        edge,\n        itemToMove,\n        items,\n        canvasWidth,\n    });\n\n    if (!updatedItems) {\n        // If it's an invalid drop, return null\n        return null;\n    }\n\n    let { updatedVisualizations } = updatedItems;\n    const { updatedItemToMove } = updatedItems;\n\n    // Take out the old visualization from the updated (if it was updated). This is so that\n    //  we can add it below with a unique id 'preview-old-item'\n    updatedVisualizations = updatedVisualizations.filter(\n        (viz) => !isEqual(viz, updatedItemToMove)\n    );\n\n    // preview-old-item is the position of the initial item before the move. This is so that we render\n    //   empty or a custom component in its place during the preview.\n    // For edges, we need this item to correctly re-compute edges around it in the preview.\n    return [\n        ...items.filter(\n            (item) =>\n                updatedVisualizations.find((viz) => viz.item === item.item) ===\n                undefined\n        ),\n        ...updatedVisualizations,\n        {\n            ...updatedItemToMove,\n            item: 'preview-old-item',\n        },\n    ];\n};\n\n/**\n * Calculates the updated position values for the viz being moved and dropped onto\n * @param {Object} params\n * @param {Object} params.itemToMove item that is being moved\n * @param {Object} params.itemToDropOn item that the visualization is being dropped onto\n * @param {String} direction direction item is dropped on oneOf('n', 's', 'w', 'e')\n * @param {Object[]} items list of all visualizations on canvas\n * @returns {Object[]} an Array containing updated itemToMove and itemToDropOn\n */\nexport const previewDropOnViz = ({\n    itemToDropOn,\n    itemToMove,\n    items,\n    direction,\n}: {\n    itemToDropOn: AbsoluteBlockItem;\n    itemToMove: AbsoluteBlockItem;\n    items: AbsoluteBlockItem[];\n    direction: Quadrant;\n}): AbsoluteBlockItem[] | null => {\n    const updatedItems = updateDropOnViz({\n        itemToMove,\n        itemToDropOn,\n        direction,\n    });\n\n    if (!updatedItems) {\n        // If it's an invalid drop, return null\n        return null;\n    }\n\n    // preview-old-item is the position of the initial item before the move. This is so that we render\n    //   empty or a custom component in its place during the preview\n    return [\n        ...items.filter(\n            (item) =>\n                updatedItems.find((viz) => viz.item === item.item) === undefined\n        ),\n        ...updatedItems,\n        {\n            ...itemToMove,\n            item: 'preview-old-item',\n        },\n    ];\n};\n\n/**\n * Finds items that live outside the canvas boundary, and returns an error message for each item.\n * @param {Object} params\n * @param {Object[]} params.items items in the layout structure of the dashboard\n * @param {Object} params.boundary canvas boundary { x, y, w, h }\n * @returns {Object[]} array of objects out of bounds\n */\nexport const findItemsOutsideBoundary = ({\n    items,\n    boundary,\n}: {\n    items: AbsoluteBlockItem[];\n    boundary: AbsolutePosition;\n}): LayoutError[] => {\n    const invalidItems: LayoutError[] = [];\n    const message = _('is outside of canvas bounds');\n    items.forEach((item) => {\n        if (\n            item.position.x < boundary.x ||\n            item.position.x + item.position.w > boundary.x + boundary.w ||\n            item.position.y < boundary.y ||\n            item.position.y + item.position.h > boundary.y + boundary.h\n        ) {\n            invalidItems.push({\n                itemId: item.item,\n                messages: [`\"${item.item}\" ${message}`],\n            });\n        }\n    });\n    return invalidItems;\n};\n\n// TODO: Should this be more aligned with EdgeItem?\ninterface EdgeValidationItem {\n    start: Coordinate;\n    end: Coordinate;\n    orientation: EdgeItem['orientation'];\n    type: 'above' | 'below' | 'left' | 'right';\n    belongsTo: AbsolutePosition;\n}\n\n/**\n * Gets the 4 edges of every item (top, bottom, left, and right)\n * @param {Object} params\n * @param {Object} params.item item positions { x, y, w, h }\n * @param {Object} [params.belongsTo={}] item to which these edges belong\n * @returns {Object[]} array of edges where edge = { start: { x, y }, end: { x, y } }\n */\nexport const getItemEdges = ({\n    item,\n    belongsTo = {} as AbsolutePosition,\n}: {\n    item: AbsolutePosition;\n    belongsTo?: AbsolutePosition;\n}): EdgeValidationItem[] => {\n    // create edges in the form: edge.start.{x,y} and edge.end.{x,y}\n    const topEdge: EdgeValidationItem = {\n        start: { x: item.x, y: item.y },\n        end: { x: item.x + item.w, y: item.y },\n        orientation: 'horizontal',\n        type: 'above',\n        belongsTo,\n    };\n    const bottomEdge: EdgeValidationItem = {\n        start: { x: item.x, y: item.y + item.h },\n        end: { x: item.x + item.w, y: item.y + item.h },\n        orientation: 'horizontal',\n        type: 'below',\n        belongsTo,\n    };\n    const leftEdge: EdgeValidationItem = {\n        start: { x: item.x, y: item.y },\n        end: { x: item.x, y: item.y + item.h },\n        orientation: 'vertical',\n        type: 'left',\n        belongsTo,\n    };\n    const rightEdge: EdgeValidationItem = {\n        start: { x: item.x + item.w, y: item.y },\n        end: { x: item.x + item.w, y: item.y + item.h },\n        orientation: 'vertical',\n        type: 'right',\n        belongsTo,\n    };\n\n    return [topEdge, bottomEdge, leftEdge, rightEdge];\n};\n\n/**\n * Create all necessary edges for every item in layout as well as for the canvas\n * @param {Object} params\n * @param {Object[]} params.items items in the layout structure of the dashboard\n * @param {Object} params.canvasBounds canvas boundary { x, y, w, h }\n * @returns {Object[]} an array of edge objects as returned from getItemEdges\n */\nconst createEdges = ({\n    items,\n    canvasBounds,\n}: {\n    items: AbsoluteBlockItem[];\n    canvasBounds: AbsolutePosition;\n}): EdgeValidationItem[] => {\n    const edges = [];\n\n    // first, add every item edge\n    items.forEach((item) => {\n        edges.push(\n            ...getItemEdges({ item: item.position, belongsTo: item.position })\n        );\n    });\n\n    // second, need to add canvas edges as well\n    edges.push(...getItemEdges({ item: canvasBounds }));\n\n    return edges;\n};\n\n/**\n * Find the provided item's invalid edges, which indicate there is a gap or overlap between visualizations\n * @param {Object} params\n * @param {Object} params.item item to find invalid edges for\n * @param {Object[]} params.edges all viz and canvas edges\n * @returns {String[]} an array of error message for each invalid edge\n */\nconst findInvalidItemEdges = ({\n    item,\n    edges,\n}: {\n    item: AbsoluteBlockItem;\n    edges: EdgeValidationItem[];\n}): string[] => {\n    const invalidEdges: string[] = [];\n    // the current edges of the item we're looking at\n    const curEdges = getItemEdges({\n        item: item.position,\n        belongsTo: item.position,\n    });\n    curEdges.forEach((curEdge) => {\n        // find one edge which it overlaps. The idea is as follows:\n        //   if there is an edge that it overlaps, it means that it is adjacent, and thus this edge is valid\n        //   if no adjacent edge is found, it means either there is extra space (gap) or the viz are overlapping\n        const overlappingEdge = edges.find((edge) => {\n            if (\n                curEdge.orientation !== edge.orientation ||\n                isEqual(curEdge.belongsTo, edge.belongsTo)\n            ) {\n                // if the edge is not the same orientation, it can't be overlapping\n                // or if the edge is the same, meaning it belongs to same item\n                // or if the two items are perfectly overlapping\n                return false;\n            }\n            // if the edges are horizontal and on the same y co-ordinate\n            if (\n                curEdge.orientation === 'horizontal' &&\n                curEdge.start.y === edge.start.y\n            ) {\n                // if the edges are not overlapping\n                if (\n                    curEdge.start.x >= edge.end.x ||\n                    edge.start.x >= curEdge.end.x\n                ) {\n                    return false;\n                }\n                // otherwise they are overlapping\n                return true;\n            }\n            // if the edges are vertical and on the same x co-ordinate\n            if (\n                curEdge.orientation === 'vertical' &&\n                curEdge.start.x === edge.start.x\n            ) {\n                // if the edges are not overlapping\n                if (\n                    curEdge.start.y >= edge.end.y ||\n                    edge.start.y >= curEdge.end.y\n                ) {\n                    return false;\n                }\n                return true;\n            }\n            // this means edge is not on the same co-ordinate/line, can't be overlapping\n            return false;\n        });\n        if (overlappingEdge === undefined) {\n            // If no edge was found, this means there is an error in the layout structure\n            const positionString =\n                curEdge.orientation === 'horizontal'\n                    ? `y=${curEdge.start.y}`\n                    : `x=${curEdge.start.x}`;\n            // differentiate between \"above/below\" and \"to its right/left\"\n            const positionType =\n                curEdge.type === 'below' || curEdge.type === 'above'\n                    ? curEdge.type\n                    : `to its ${curEdge.type}`;\n            invalidEdges.push(\n                _(\n                    `\"${item.item}\" expected a viz or canvas edge directly ${positionType} at ${positionString}`\n                )\n            );\n        }\n    });\n    return invalidEdges;\n};\n\n/**\n * Find items that have invalid edges indicating a gap/overlap between visualizations\n * @param {Object} params\n * @param {Object[]} params.items items in the layout structure of the dashboard\n * @param {Object} params.canvasBounds canvas boundary { x, y, w, h }\n * @returns {Object[]} Array of objects containing itemId and error messages\n */\nconst findInvalidItems = ({\n    items,\n    canvasBounds,\n}: {\n    items: AbsoluteBlockItem[];\n    canvasBounds: AbsolutePosition;\n}) => {\n    const invalidItems: LayoutError[] = [];\n    const edges = createEdges({ items, canvasBounds });\n    items.forEach((item) => {\n        const invalidEdges = findInvalidItemEdges({ item, edges });\n        if (invalidEdges.length > 0) {\n            invalidItems.push({\n                itemId: item.item,\n                messages: invalidEdges,\n            });\n        }\n    });\n    return invalidItems;\n};\n\n/**\n * validate if layout is valid and return the appropriate error object if it is not\n * @param {Object} params\n * @param {Object[]} params.layout layout structure of the dashboard\n * @param {Object} params.canvasBounds canvas boundary { x, y, w, h }\n * @returns {Object[]} Array of objects containing itemId and error messages\n */\nexport const validateLayoutStructure = ({\n    layout,\n    canvasBounds,\n}: {\n    layout?: AbsoluteBlockItem[];\n    canvasBounds: AbsolutePosition;\n}): LayoutError[] => {\n    if (!layout) {\n        return []; // maybe return object with bool false and message?\n    }\n\n    const res = findItemsOutsideBoundary({\n        items: layout,\n        boundary: canvasBounds,\n    });\n\n    // if items are out of boundary, return early\n    if (!isEmpty(res)) {\n        return res;\n    }\n\n    // if all items are in boundary, check which are invalid\n    return findInvalidItems({ items: layout, canvasBounds });\n};\n\nconst isVerticallyAligned = (\n    viz: AbsoluteBlockItem,\n    another: AbsoluteBlockItem\n) =>\n    viz.position.y === another.position.y &&\n    viz.position.h === another.position.h;\n\nconst isHorizontallyAligned = (\n    viz: AbsoluteBlockItem,\n    another: AbsoluteBlockItem\n) =>\n    viz.position.x === another.position.x &&\n    viz.position.w === another.position.w;\n\nexport const isInvalidAdjacentVizDrop = ({\n    itemToMove,\n    itemToDropOn,\n    direction,\n    visualizations,\n}: {\n    itemToMove: AbsoluteBlockItem;\n    itemToDropOn: AbsoluteBlockItem;\n    direction: Quadrant;\n    visualizations: AbsoluteBlockItem[];\n}): boolean => {\n    /* scenario 1: drop on left/right neighbor */\n\n    if (\n        direction === 'e' &&\n        isLeftNeighbor(itemToMove, itemToDropOn) &&\n        isVerticallyAligned(itemToMove, itemToDropOn)\n    ) {\n        return true;\n    }\n\n    if (\n        direction === 'w' &&\n        isRightNeighbor(itemToMove, itemToDropOn) &&\n        isVerticallyAligned(itemToMove, itemToDropOn)\n    ) {\n        return true;\n    }\n\n    if (direction === 'e' || direction === 'w') {\n        return false;\n    }\n\n    /* scenario 2: drop on top/bottom neighbor */\n\n    const { leftNeighbors, rightNeighbors } = findHorizontalNeighbors({\n        item: itemToMove,\n        visualizations,\n    });\n\n    // neighbors will occupy the vacant space, so it is valid to move the item\n    if (leftNeighbors.length > 0 || rightNeighbors.length > 0) {\n        return false;\n    }\n\n    if (\n        direction === 'n' &&\n        isBottomNeighbor(itemToMove, itemToDropOn) &&\n        isHorizontallyAligned(itemToMove, itemToDropOn)\n    ) {\n        return true;\n    }\n\n    if (\n        direction === 's' &&\n        isTopNeighbor(itemToMove, itemToDropOn) &&\n        isHorizontallyAligned(itemToMove, itemToDropOn)\n    ) {\n        return true;\n    }\n\n    return false;\n};\n","import reject from 'lodash/reject';\nimport type { MutableRefObject } from 'react';\nimport type TelemetryAPI from '@splunk/dashboard-telemetry/TelemetryAPI';\nimport type { EmittableEvent } from '@splunk/dashboard-telemetry/EventTypes';\nimport { computeNewGridStructureItem } from '@splunk/dashboard-utils/layout';\nimport type {\n    GridLayoutStructure,\n    GridLayoutOptions,\n} from '@splunk/dashboard-types';\nimport { gridLayoutOptions } from '../DefaultOptions';\nimport {\n    CLONE_LAYOUT_ITEMS_MSG_PANEL_TOO_SMALL,\n    MIN_WIDTH_PX,\n} from '../GridLayoutConstants';\nimport { updateBlockItemSize } from '../utils/layoutUtils';\nimport { updateRemovedVizNeighbors } from '../utils/gridLayoutApiUtils';\nimport {\n    normalizeAddLayoutItemArgs,\n    LegacyLayoutApiArgs,\n} from '../utils/layoutApiUtils';\nimport type { NormalizedAddLayoutItemArgs } from '../utils/layoutApiUtils';\nimport { getBlockItem } from '../utils/blockUtils';\nimport BaseLayoutApi from '../BaseLayoutApi';\n\ninterface LayoutApiArgs {\n    layoutStructureRef: MutableRefObject<GridLayoutStructure>;\n    options?: GridLayoutOptions;\n    userMessage: (args: { message: string; level: string }) => void;\n    onVizAdded: () => void;\n    getCanvasDomElement: () => HTMLElement;\n    telemetry?: TelemetryAPI;\n}\n\nclass GridLayoutApi extends BaseLayoutApi {\n    private layoutStructureRef: MutableRefObject<GridLayoutStructure>;\n\n    private options: GridLayoutOptions;\n\n    private userMessage: (args: { message: string; level: string }) => void;\n\n    private onVizAdded: () => void;\n\n    getCanvasDomElement: () => HTMLElement;\n\n    constructor({\n        layoutStructureRef,\n        options = {},\n        userMessage,\n        onVizAdded,\n        getCanvasDomElement,\n        telemetry,\n    }: LayoutApiArgs) {\n        super();\n        this.layoutStructureRef = layoutStructureRef;\n        this.options = options;\n        this.userMessage = userMessage;\n        this.onVizAdded = onVizAdded;\n        this.getCanvasDomElement = getCanvasDomElement;\n        this.telemetry = telemetry;\n    }\n\n    /**\n     * Add a new item to grid layout\n     * @method\n     * @param {Object} options\n     * @param {String} options.itemId visualization id\n     * @returns {Object[]} updated layout structure\n     * @public\n     */\n    addLayoutItem = (\n        ...args: [NormalizedAddLayoutItemArgs] | LegacyLayoutApiArgs\n    ): GridLayoutStructure => {\n        const { itemId, metadata } = normalizeAddLayoutItemArgs(args);\n\n        this.emitTelemetry({\n            pageAction: 'addLayoutItem',\n            metadata,\n        });\n\n        // always add new item at the bottom of the root container\n\n        // generate a proposed layout structure\n        // it's up to the consumer to apply this structure via setting layoutStructure prop\n        const width = this.options.width ?? gridLayoutOptions.width;\n        const items = this.layoutStructureRef.current;\n        const newItem = computeNewGridStructureItem({\n            canvasWidth: width,\n            layoutItems: items,\n            itemId,\n        });\n        this.onVizAdded();\n        return [...items, newItem];\n    };\n\n    /**\n     * Remove item specified in itemIds list.\n     * Note: Only removes one item even though it accepts a list of item ids.\n     * @method\n     * @param {string[]} item ids to remove.\n     * @returns {object[]} updated layout structure\n     * @public\n     */\n    removeLayoutItems = (\n        itemIds: string[] = [],\n        metadata?: EmittableEvent['metadata']\n    ): GridLayoutStructure => {\n        this.emitTelemetry({\n            pageAction: 'removeLayoutItems',\n            metadata,\n        });\n\n        const items = this.layoutStructureRef.current;\n        const itemToRemove = getBlockItem({\n            layoutStructure: items,\n            id: itemIds[0],\n        });\n        const width = this.options.width ?? gridLayoutOptions.width;\n\n        const updatedItems = updateRemovedVizNeighbors({\n            itemToRemove,\n            items,\n            width,\n        });\n\n        const keys = updatedItems.map((item) => item.item);\n        const filteredItems = items.filter(\n            (vizItem) =>\n                vizItem.item !== itemToRemove.item &&\n                keys.indexOf(vizItem.item) < 0\n        );\n\n        return [...updatedItems, ...filteredItems];\n    };\n\n    /**\n     * There are 3 actors in this cloning algorithm:\n     * 1. Clone Ancestor\n     * 2. Left-side Descendant\n     * 3. Right-side Descendant\n     * @method\n     * @param {Object} options\n     * @param {String[]} options.from List of original viz ids (ancestors). These id's will be re-used to produce left-side descendants.\n     * @param {String[]} options.to List of new viz ids. Has the id's of right-side descendants.\n     * @returns {Object[]} Layout structure of all known items\n     * @public\n     */\n    cloneLayoutItems = ({\n        from,\n        to,\n        metadata,\n    }: {\n        from: string[];\n        to: string[];\n        metadata?: EmittableEvent['metadata'];\n    }): GridLayoutStructure => {\n        if (\n            !Array.isArray(from) ||\n            !Array.isArray(to) ||\n            from.length !== to.length\n        ) {\n            throw new Error(\n                `Cannot clone viz, incorrect inputs from ${from}, to: ${to}`\n            );\n        }\n        this.emitTelemetry({\n            pageAction: 'cloneLayoutItems',\n            metadata,\n        });\n\n        // generate a proposed layout structure\n        // it's up to the consumer to apply this structure via setting layoutStructure prop\n        const items = this.layoutStructureRef.current;\n\n        const reduction = from.reduce((accumulator, fromItemId, index) => {\n            const ancestor = getBlockItem({\n                layoutStructure: items,\n                id: fromItemId,\n            });\n            if (ancestor.position.w < MIN_WIDTH_PX * 2) {\n                this.userMessage({\n                    message: CLONE_LAYOUT_ITEMS_MSG_PANEL_TOO_SMALL,\n                    level: 'warning',\n                });\n                return accumulator;\n            }\n\n            // Update the Left-side and Right-side Descendant's position values so that they equally share\n            // the Ancestor's space.\n            const lsDescendant = updateBlockItemSize({\n                item: {\n                    ...ancestor,\n                },\n                offset: {\n                    offsetX: -1 * Math.floor(ancestor.position.w / 2),\n                    offsetY: 0,\n                },\n                dir: 'e',\n            });\n            const rsDescendant = updateBlockItemSize({\n                item: {\n                    ...ancestor,\n                    item: to[index],\n                },\n                offset: {\n                    offsetX: Math.ceil(ancestor.position.w / 2),\n                    offsetY: 0,\n                },\n                dir: 'w',\n            });\n\n            // Remove the Ancestor from the accumulator.\n            const accumulatorSansAncestor = reject(accumulator, {\n                item: fromItemId,\n            });\n\n            return [...accumulatorSansAncestor, lsDescendant, rsDescendant];\n        }, items);\n\n        return reduction;\n    };\n\n    /**\n     * Return snapshot as an empty object for the time being\n     * @method\n     */\n    snapshot = (): Record<string, never> => {\n        return {};\n    };\n\n    /**\n     * Return zoom level as null for now\n     * @method\n     */\n    getZoomLevel = (): null => {\n        return null;\n    };\n}\n\nexport default GridLayoutApi;\n","module.exports = require(\"lodash/reject\");","import React, { useCallback } from 'react';\nimport styled from 'styled-components';\nimport { pick, variables, pickVariant } from '@splunk/themes';\nimport { customThemeVariables } from '@splunk/dashboard-ui/customThemeVariables';\nimport type { AbsolutePosition } from '@splunk/dashboard-types';\nimport type { EdgeItem, EdgeAppearance } from '../types';\n\ninterface EdgeWrapperProps extends AbsolutePosition {\n    orientation: EdgeItem['orientation'];\n    appearance: EdgeAppearance;\n}\n\nexport const EdgeWrapper = styled.div.attrs<EdgeWrapperProps>(\n    ({ x, y, w, h }) => {\n        return {\n            style: {\n                width: w,\n                height: h,\n                transform: `translate(${x}px, ${y}px)`,\n            },\n        };\n    }\n)`\n    display: block;\n    position: absolute;\n    background: transparent;\n    box-sizing: border-box;\n\n    &:hover {\n        cursor: ${(props) =>\n            props.orientation === 'vertical' ? 'col-resize' : 'row-resize'};\n        background: ${pickVariant<EdgeWrapperProps>('appearance', {\n            invalid: customThemeVariables.invalidDropTargetBackgroundColor,\n            dropTarget: customThemeVariables.validDropTargetBackgroundColor,\n            normal: 'transparent',\n            hidden: 'transparent',\n        })};\n        border: ${pickVariant<EdgeWrapperProps>('appearance', {\n            invalid: `1px solid ${customThemeVariables.invalidDropTargetBorderColor}`,\n            dropTarget: `1px solid ${customThemeVariables.validDropTargetBorderColor}`,\n            normal: 'none',\n            hidden: 'none',\n        })};\n        transition: background 0.2s ease-out;\n    }\n`;\n\ntype EdgeComponentProps = AbsolutePosition & { appearance: EdgeAppearance };\n\nexport const EdgeComponent = styled.div.attrs<EdgeComponentProps>(\n    ({ x, y, w, h }) => {\n        return {\n            style: {\n                width: w,\n                height: h,\n                transform: `translate(${x}px, ${y}px)`,\n            },\n        };\n    }\n)<EdgeComponentProps>`\n    display: block;\n    position: absolute;\n    opacity: 0.35;\n    pointer-events: none;\n    background-color: ${(props) =>\n        props.appearance === 'dropTarget'\n            ? customThemeVariables.validDropTargetBorderColor\n            : pick({\n                  enterprise: variables.accentColorL10,\n                  prisma: variables.interactiveColorPrimary,\n              })};\n    ${EdgeWrapper}:hover + & {\n        opacity: 0.7;\n    }\n`;\n\ninterface EdgeProps {\n    itemId: string;\n    x: number;\n    y: number;\n    w: number;\n    h: number;\n    orientation: EdgeItem['orientation'];\n    isCanvasEdge?: boolean;\n    padding?: number;\n    appearance: EdgeAppearance;\n    onMouseDown: (e: React.MouseEvent, { id }: { id: string }) => void;\n    'data-test-edge-position': string;\n}\n\nexport const Edge = ({\n    itemId,\n    x,\n    y,\n    h,\n    w,\n    orientation,\n    isCanvasEdge,\n    padding = 0,\n    appearance = 'normal',\n    onMouseDown,\n    'data-test-edge-position': edgePositionTestHook,\n}: EdgeProps): JSX.Element | null => {\n    const handleMouseDown = useCallback(\n        (e) => {\n            e.preventDefault();\n            e.stopPropagation();\n            onMouseDown(e, { id: itemId });\n        },\n        [onMouseDown, itemId]\n    );\n\n    /**\n     * edges are not rendered if:\n     * 1. their appearance is hidden OR\n     * 2. edge is a canvas edge AND its appearance is not a dropTarget\n     * Exception to this case is the bottom canvas edge which is always visible. Other canvas edges (top, left, right) are visible only when a viz is moving\n     * TODO: Follow up with design to re-evaluate display condition for canvas edges as they are currently not discoverable\n     */\n    if (\n        appearance === 'hidden' ||\n        (isCanvasEdge &&\n            appearance !== 'dropTarget' &&\n            (orientation === 'vertical' || y + padding === 0))\n    ) {\n        return null;\n    }\n\n    const coord = { x, y, w, h };\n    const shift = padding / 2;\n\n    if (orientation === 'horizontal') {\n        coord.y += shift;\n        coord.h -= padding;\n    }\n\n    if (orientation === 'vertical') {\n        coord.x += shift;\n        coord.w -= padding;\n    }\n\n    return (\n        <>\n            <EdgeWrapper\n                x={x}\n                y={y}\n                w={w}\n                h={h}\n                orientation={orientation}\n                appearance={appearance}\n                onMouseDown={handleMouseDown}\n                data-test=\"edge\"\n                data-test-edge-position={edgePositionTestHook}\n            />\n            <EdgeComponent\n                x={coord.x}\n                y={coord.y}\n                w={coord.w}\n                h={coord.h}\n                appearance={appearance}\n            />\n        </>\n    );\n};\n","import React, { useMemo } from 'react';\nimport styled from 'styled-components';\nimport { pick, variables } from '@splunk/themes';\nimport type { AbsolutePosition, Coordinate } from '@splunk/dashboard-types';\nimport { positionToStyle } from '../utils/layoutUtils';\n\ninterface PlaceholderProps {\n    position: AbsolutePosition;\n}\n\nexport const Placeholder = styled.div.attrs<PlaceholderProps>(\n    ({ position }) => ({\n        style: positionToStyle(position),\n    })\n)<PlaceholderProps>`\n    background-color: ${pick({\n        enterprise: {\n            light: variables.backgroundColorHover,\n            dark: variables.neutral300,\n        },\n        prisma: variables.interactiveColorOverlayDrag,\n    })};\n    opacity: 0.75;\n    user-select: none;\n    position: absolute;\n    flex-direction: column;\n    top: 0;\n    left: 0;\n    cursor: move;\n`;\n\nexport const ItemDragPlaceholder = ({\n    position,\n    size = 128,\n}: {\n    position: Coordinate;\n    size?: number;\n}): JSX.Element => {\n    const placeHolderPosition = useMemo(() => {\n        return {\n            // update x and y to be the center of the placeholder\n            x: position.x - Math.round(size / 2),\n            y: position.y - Math.round(size / 2),\n            w: size,\n            h: size,\n        };\n    }, [position, size]);\n    return (\n        <Placeholder\n            data-test=\"item-drag-placeholder\"\n            position={placeHolderPosition}\n        />\n    );\n};\n","import React, { useMemo } from 'react';\nimport styled from 'styled-components';\nimport T from 'prop-types';\nimport { pickVariant } from '@splunk/themes';\nimport { customThemeVariables } from '@splunk/dashboard-ui/customThemeVariables';\nimport { positionToStyle } from '../utils/layoutUtils';\nimport { ITEM_DROP_TARGET_PX } from '../GridLayoutConstants';\n\nexport const DropTarget = styled.div.attrs(({ position }) => ({\n    style: positionToStyle(position),\n}))`\n    background-color: ${pickVariant('validDropTarget', {\n        true: customThemeVariables.validDropTargetBackgroundColor,\n        false: customThemeVariables.invalidDropTargetBackgroundColor,\n    })};\n    border-width: '1px';\n    border-style: 'solid';\n    border-color: ${pickVariant('validDropTarget', {\n        true: customThemeVariables.validDropTargetBorderColor,\n        false: customThemeVariables.invalidDropTargetBorderColor,\n    })};\n    user-select: none;\n    position: absolute;\n    pointer-events: none;\n`;\n\nexport const ItemDropTarget = ({ position, direction }) => {\n    const validDropTarget =\n        ((direction === 'e' || direction === 'w') && position.w >= 128) ||\n        ((direction === 'n' || direction === 's') && position.h >= 128);\n\n    const dropTargetPosition = useMemo(() => {\n        let updatedPosition = null;\n        switch (direction) {\n            case 'n':\n                updatedPosition = {\n                    ...position,\n                    h: ITEM_DROP_TARGET_PX,\n                };\n                break;\n            case 's':\n                updatedPosition = {\n                    ...position,\n                    y: position.y + position.h - ITEM_DROP_TARGET_PX,\n                    h: ITEM_DROP_TARGET_PX,\n                };\n                break;\n            case 'w':\n                updatedPosition = {\n                    ...position,\n                    w: ITEM_DROP_TARGET_PX,\n                };\n                break;\n            case 'e':\n                updatedPosition = {\n                    ...position,\n                    x: position.x + position.w - ITEM_DROP_TARGET_PX,\n                    w: ITEM_DROP_TARGET_PX,\n                };\n                break;\n            default:\n                updatedPosition = position;\n                break;\n        }\n        return updatedPosition;\n    }, [position, direction]);\n\n    // TO DO: currently with this if,\n    // we are only rendering the invalid drop target. Refactor file to only use invalid\n    if (validDropTarget) {\n        return null;\n    }\n\n    return (\n        <DropTarget\n            data-test=\"item-drop-target\"\n            position={dropTargetPosition}\n            validDropTarget={validDropTarget}\n        />\n    );\n};\n\nItemDropTarget.propTypes = {\n    position: T.shape({\n        x: T.number.isRequired,\n        y: T.number.isRequired,\n        w: T.number.isRequired,\n        h: T.number.isRequired,\n    }).isRequired,\n    direction: T.oneOf(['n', 's', 'w', 'e']).isRequired,\n};\n","import React from 'react';\nimport styled from 'styled-components';\nimport T from 'prop-types';\nimport { customThemeVariables } from '@splunk/dashboard-ui/customThemeVariables';\n\nexport const PlaceholderComponent = styled.div.attrs(({ position }) => ({\n    style: {\n        width: position.w,\n        height: position.h,\n        transform: `translate(${position.x}px, ${position.y}px)`,\n    },\n}))`\n    display: block;\n    position: absolute;\n    pointer-events: none;\n    box-sizing: border-box;\n    border: 1px solid ${customThemeVariables.validDropTargetBorderColor};\n    background-color: ${customThemeVariables.validDropTargetBackgroundColor};\n`;\n\nexport const PreviewPlaceholderItem = ({ position }) => {\n    return (\n        <PlaceholderComponent\n            position={position}\n            data-test=\"preview-placeholder\"\n            data-test-preview-position={`${position.x},${position.y}-${position.w},${position.h}`}\n        />\n    );\n};\n\nPreviewPlaceholderItem.propTypes = {\n    position: T.shape({\n        x: T.number.isRequired,\n        y: T.number.isRequired,\n        w: T.number.isRequired,\n        h: T.number.isRequired,\n    }).isRequired,\n};\n","import type {\n    AbsoluteBlockItem,\n    GridLayoutStructure,\n    SelectedItem,\n} from '@splunk/dashboard-types';\n\n// TODO: Possibly: { blockItems, edges, ... }\nexport type MappedGridLayout = Record<string, AbsoluteBlockItem>;\n\n// Seems expensive, needs multi-block update\ntype ResetStructureAction = {\n    type: 'structure/reset';\n    payload: GridLayoutStructure;\n};\n\ntype UpdateItemAction = {\n    type: 'structure/update';\n    payload: AbsoluteBlockItem;\n};\nexport const resetLayoutAction = (\n    payload: GridLayoutStructure\n): ResetStructureAction => ({\n    type: 'structure/reset',\n    payload,\n});\n\nexport const updateItemAction = (\n    payload: AbsoluteBlockItem\n): UpdateItemAction => ({\n    type: 'structure/update',\n    payload,\n});\n\nexport type GridActions = ResetStructureAction | UpdateItemAction;\n\nexport const getBlockItems = (state: MappedGridLayout): GridLayoutStructure =>\n    Object.values(state);\n\nexport const filterSelectedItems = (\n    state: GridLayoutStructure,\n    selectedItems: SelectedItem[] = []\n): SelectedItem[] => {\n    const itemKeys = state.map(({ item }) => item);\n    return selectedItems.filter(({ id }) => itemKeys.indexOf(id) >= 0);\n};\n\nexport const getItemKeys = (state: MappedGridLayout): string[] =>\n    Object.keys(state);\n\nexport const getStructureItem = (\n    state: GridLayoutStructure,\n    itemId: string\n): AbsoluteBlockItem =>\n    state.find(({ item }) => item === itemId) as AbsoluteBlockItem;\n\nexport const getItem = (\n    state: MappedGridLayout,\n    itemId: string\n): AbsoluteBlockItem => state[itemId];\n\nexport const hasPreviewItem = (\n    state: MappedGridLayout,\n    itemId = 'preview-old-item'\n): boolean => !!state[itemId];\n\n/**\n * Filter out any items not appearing in layoutStructure as they are currently unknown\n * Add any new items in layoutStructure, keep preview items\n * @param {MappedGridLayout} state reducer state\n * @param {GridLayoutStructure} layoutStructure current known state\n * @returns {GridLayoutStructure} filtered state\n */\nexport const getFilteredStructure = (\n    state: MappedGridLayout,\n    layoutStructure: GridLayoutStructure\n): GridLayoutStructure => {\n    const result: GridLayoutStructure = [];\n    layoutStructure.forEach((item) => {\n        result.push(state[item.item] || item);\n    });\n\n    if (hasPreviewItem(state)) {\n        result.push(state['preview-old-item']);\n    }\n\n    return result;\n};\n\n// Reducer\nexport const initializeGridReducer = (\n    layoutStructure: GridLayoutStructure = []\n): MappedGridLayout => {\n    const gridLayout: MappedGridLayout = {};\n    layoutStructure.forEach((item) => {\n        gridLayout[item.item] = item;\n    });\n    return gridLayout;\n};\n\n// TODO: reducer should probably intelligently handle other pieces of content (e.g. edges) and have additional dispatches to handle resize, move, etc\n// TODO: reducer should handle updating multiple items, instead of a complete replacement of state (structure/reset should be a last resort)\nexport const gridReducer = (\n    state: MappedGridLayout,\n    action: GridActions\n): MappedGridLayout => {\n    switch (action.type) {\n        // TODO: handle more actions (above), to further reduce size of grid code\n        // TODO: expand set of reduced state, to limit amount of non-layout data tracked in layout component\n        case 'structure/reset':\n            return initializeGridReducer(action.payload);\n        case 'structure/update':\n            return {\n                ...state,\n                [action.payload.item]: action.payload,\n            };\n        default:\n            return state;\n    }\n};\n"],"sourceRoot":""}
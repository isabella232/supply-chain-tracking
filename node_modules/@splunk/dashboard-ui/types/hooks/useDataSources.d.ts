import type { DataSet } from '@splunk/datasource-utils';
interface DataSourceError {
    level: 'error';
    message: string;
}
export declare type Meta = Record<string, unknown>;
export declare type RequestParams = Record<string, unknown>;
interface BindingErrorPayload {
    binding: string;
    error: DataSourceError;
}
interface BindingUpdatePayload {
    binding: string;
    data: DataSet;
    meta: Meta;
    requestParams: RequestParams;
}
interface StateItem {
    error: DataSourceError | null;
    data: DataSet | null;
    meta: Meta | null;
    requestParams: RequestParams | null;
}
declare type BindingType = string;
declare type State = Record<BindingType, StateItem>;
interface DataSourceDefinition {
    type: string;
    name?: string;
    options?: Record<string, unknown>;
}
export interface Binding {
    bindingType: string;
    dataSourceId: string;
    dataSource: DataSourceDefinition;
    initialRequestParams: RequestParams;
}
interface AllocateArgs {
    dataSourceId: string;
}
interface SubscribeArgs {
    consumerId: string;
    initialRequestParams: RequestParams;
}
declare type Refresh = () => void;
interface DataSourceController {
    subscribe: ({ consumerId, initialRequestParams, }: SubscribeArgs) => Promise<DataSourceSubscription>;
    refresh: Refresh;
}
declare type HandleDataPayload = Omit<BindingUpdatePayload, 'binding'>;
interface SubscribeToDataArgs {
    onData: (payload: HandleDataPayload) => void;
    onError: (error: DataSourceError) => void;
}
interface DataSourceSubscription {
    subscribeToData: ({ onData, onError }: SubscribeToDataArgs) => void;
    cancel: () => void;
    updateRequestParams: (requestParams: RequestParams) => void;
    dataSource: DataSourceController;
    consumerId: string;
}
export interface DataSourceRegistry {
    allocate: ({ dataSourceId }: AllocateArgs) => DataSourceController;
}
declare type Consumers = Record<string, DataSourceSubscription>;
export declare type OnUpdate = (payload: BindingUpdatePayload | BindingErrorPayload) => void;
interface UseDataSourcesArgs {
    consumerId: string;
    bindings: Binding[];
    dataSourceRegistry: DataSourceRegistry;
    onUpdate?: OnUpdate;
}
interface UseDataSourcesReturn {
    loading: boolean;
    dataSources: State;
    updateRequestParams: (binding: string, newRequestParams: RequestParams) => void;
    refresh: Refresh;
    getSubscribers: () => Consumers;
}
declare const useDataSources: ({ consumerId, bindings, dataSourceRegistry, onUpdate, }: UseDataSourcesArgs) => UseDataSourcesReturn;
export default useDataSources;
//# sourceMappingURL=useDataSources.d.ts.map
import { MetricsCollector, CollectorData } from './MetricsCollector';
import { EmittableEvent, CountableEvent } from './EventTypes';
import { FilterStrategyCollection } from './filters/filterStrategies';
declare type Logger = {
    error: (...value: unknown[]) => void;
};
/**
 * a collection of counted events, e.g. { canvasEvents: { edgeResize: 1 } }
 */
declare type EventCollection = Record<string, Record<string, number>>;
declare type TelemetryAPIProps = {
    metricsCollectors?: MetricsCollector[];
    customFilters?: FilterStrategyCollection;
    logger?: Logger;
};
export declare const TELEMETRY_ERROR = "Failed to send telemetry event to collector";
/**
 * This class provides a common telemetry and filtering interface to UDF components,
 * and sends filtered data to MetricsCollectors
 *
 * Example:
 *
 * ```
 * const collector = new MyMetricsCollector();
 * const api = new TelemetryApi({ metricsCollectors: [collector] });
 *
 * // Send data immediately to the metrics service defined in the collector
 * api.emit({ pageAction: "myPageAction", metaData: { myData: 'foo' } });
 *
 * // Send data that should be collected and counted for later use
 * api.collect({ source: "canvas", event: "edge_resize" });
 *
 * // Send data immediately, and send all the collected event counts
 * api.flush({ pageAction: "myFlushAction" });
 * ```
 *
 * @class TelemetryAPI
 */
export declare class TelemetryAPI {
    protected collectedEvents: EventCollection;
    protected metricsCollectors: MetricsCollector[];
    private filters;
    private logger;
    /**
     * TelemetryApi constructor
     * @param {Object} config
     * @param {MetricsCollector[]} [config.metricsCollectors=[]] A set of handlers that talk to backend services
     * @param {FilterStrategyCollection} [config.customFilters={}] A set of functions that will process the contents of a key
     * @param {Logger} [config.logger=console] A logging utility
     * @method
     * @constructor
     */
    constructor({ metricsCollectors, customFilters, logger, }?: TelemetryAPIProps);
    /**
     * Reset the counted event data
     * @method
     * @protected
     */
    protected resetEvents(): void;
    /**
     * Shared helper method to send data to MetricsCollector instances
     * @param {CollectorData} payload Processed data sent by an event emitter
     * @protected
     */
    protected sendEvent(payload: CollectorData): void;
    /**
     * Filter all the payload information to prevent exposure of PII
     * @param {EmittableEvent} payload The data that was sent by an event emitter
     * @returns {CollectorData} Filtered data
     * @private
     */
    private processEmittedEvent;
    /**
     * Add any special handling to process the collected events.
     * In our case, we want to ensure our selected groupings are always in the output (canvas, keyboard, actionMenu).
     * We may add more groupings later
     * @private
     * @method
     */
    private processCountableEvents;
    /**
     * Send the current event data along with counts of other collected events
     * @param {EmittableEvent} payload Data from an event emitter
     */
    flush(payload: EmittableEvent): void;
    /**
     * Immediately send the current event data
     * @param {EmittableEvent} payload Data from an event emitter
     */
    emit(payload: EmittableEvent): void;
    /**
     * Count the event amongst other counted events for later use
     * @param {CountableEvent} payload Data from an event emitter
     */
    collect(payload: CountableEvent): void;
}
export default TelemetryAPI;
//# sourceMappingURL=TelemetryAPI.d.ts.map
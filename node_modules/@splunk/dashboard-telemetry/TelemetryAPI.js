/*!
 * Copyright © 2020 Splunk Inc.
 * SPLUNK CONFIDENTIAL – Use or disclosure of this material in whole or
 * in part without a valid written license from Splunk Inc. is PROHIBITED.
 */
module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 14);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

module.exports = require("@splunk/dashboard-utils");

/***/ }),
/* 1 */
/***/ (function(module, exports) {

module.exports = require("lodash/mapValues");

/***/ }),
/* 2 */,
/* 3 */
/***/ (function(module, exports) {

module.exports = require("lodash/get");

/***/ }),
/* 4 */,
/* 5 */,
/* 6 */,
/* 7 */
/***/ (function(module, exports) {

module.exports = require("lodash/isPlainObject");

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.hashStringOnObject = exports.categoryToPrefix = void 0;
var mapValues_1 = __importDefault(__webpack_require__(1));
var isPlainObject_1 = __importDefault(__webpack_require__(7));
var dashboard_utils_1 = __webpack_require__(0);
exports.categoryToPrefix = {
    inputs: 'input_',
    visualizations: 'viz_',
    dataSources: 'ds_',
};
/**
 * Recursively hash string values in a JSON object
 */
var hashStringOnObject = function (obj, k) {
    if (typeof obj === 'string') {
        if (dashboard_utils_1.isDynamicOption(obj)) {
            return dashboard_utils_1.DYNAMIC_STRING_SUBSTITUTE;
        }
        return dashboard_utils_1.hashString(obj);
    }
    if (Array.isArray(obj)) {
        return obj.map(function (v) { return exports.hashStringOnObject(v); });
    }
    if (isPlainObject_1.default(obj)) {
        if (k === 'context') {
            return {};
        }
        return mapValues_1.default(obj, function (value, key) {
            return exports.hashStringOnObject(value, key);
        });
    }
    return obj;
};
exports.hashStringOnObject = hashStringOnObject;


/***/ }),
/* 9 */
/***/ (function(module, exports) {

module.exports = require("lodash/mapKeys");

/***/ }),
/* 10 */,
/* 11 */,
/* 12 */
/***/ (function(module, exports) {

module.exports = require("lodash/omit");

/***/ }),
/* 13 */,
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TelemetryAPI = exports.TELEMETRY_ERROR = void 0;
/* eslint-disable  no-underscore-dangle */
var dashboard_utils_1 = __webpack_require__(0);
var omit_1 = __importDefault(__webpack_require__(12));
var filterStrategies_1 = __webpack_require__(15);
var extractDefinitionInfo_1 = __webpack_require__(26);
exports.TELEMETRY_ERROR = 'Failed to send telemetry event to collector';
/**
 * This class provides a common telemetry and filtering interface to UDF components,
 * and sends filtered data to MetricsCollectors
 *
 * Example:
 *
 * ```
 * const collector = new MyMetricsCollector();
 * const api = new TelemetryApi({ metricsCollectors: [collector] });
 *
 * // Send data immediately to the metrics service defined in the collector
 * api.emit({ pageAction: "myPageAction", metaData: { myData: 'foo' } });
 *
 * // Send data that should be collected and counted for later use
 * api.collect({ source: "canvas", event: "edge_resize" });
 *
 * // Send data immediately, and send all the collected event counts
 * api.flush({ pageAction: "myFlushAction" });
 * ```
 *
 * @class TelemetryAPI
 */
var TelemetryAPI = /** @class */ (function () {
    /**
     * TelemetryApi constructor
     * @param {Object} config
     * @param {MetricsCollector[]} [config.metricsCollectors=[]] A set of handlers that talk to backend services
     * @param {FilterStrategyCollection} [config.customFilters={}] A set of functions that will process the contents of a key
     * @param {Logger} [config.logger=console] A logging utility
     * @method
     * @constructor
     */
    function TelemetryAPI(_a) {
        var _this = this;
        var _b = _a === void 0 ? {} : _a, _c = _b.metricsCollectors, metricsCollectors = _c === void 0 ? [] : _c, _d = _b.customFilters, customFilters = _d === void 0 ? {} : _d, _e = _b.logger, logger = _e === void 0 ? dashboard_utils_1.console : _e;
        // A set of events that are retained until a "flush", e.g. { canvasEvents: { edgeResize: 1 }}
        this.collectedEvents = {};
        /**
         * Filter all the payload information to prevent exposure of PII
         * @param {EmittableEvent} payload The data that was sent by an event emitter
         * @returns {CollectorData} Filtered data
         * @private
         */
        this.processEmittedEvent = function (payload) {
            var result = {
                pageAction: 'unknown',
                metadata: {},
                udfVersion: "23.3.0",
                definitionInfo: payload.definition && extractDefinitionInfo_1.extractDefinitionInfo(payload.definition),
            };
            Object.keys(payload).forEach(function (key) {
                var fn = _this.filters[key];
                if (fn) {
                    result[key] = fn(payload[key]);
                }
            });
            return result;
        };
        this.metricsCollectors = metricsCollectors;
        // Set up the filters we will use to process event data,
        // omit udfVersion because we will always set version ourselves
        this.filters = omit_1.default(__assign(__assign({}, customFilters), filterStrategies_1.filterStrategies), ['udfVersion']);
        this.logger = logger;
        this.resetEvents();
    }
    /**
     * Reset the counted event data
     * @method
     * @protected
     */
    TelemetryAPI.prototype.resetEvents = function () {
        this.collectedEvents = {};
    };
    /**
     * Shared helper method to send data to MetricsCollector instances
     * @param {CollectorData} payload Processed data sent by an event emitter
     * @protected
     */
    TelemetryAPI.prototype.sendEvent = function (payload) {
        var _this = this;
        this.metricsCollectors.forEach(function (collector) {
            try {
                collector.sendEvent({
                    eventType: 'udf.telemetry',
                    level: 'info',
                    data: __assign({}, payload),
                });
            }
            catch (err) {
                _this.logger.error(exports.TELEMETRY_ERROR, err.message);
            }
        });
    };
    /**
     * Add any special handling to process the collected events.
     * In our case, we want to ensure our selected groupings are always in the output (canvas, keyboard, actionMenu).
     * We may add more groupings later
     * @private
     * @method
     */
    TelemetryAPI.prototype.processCountableEvents = function () {
        return {
            canvasEvents: this.collectedEvents.canvasEvents || {},
            keyboardEvents: this.collectedEvents.keyboardEvents || {},
            actionMenuEvents: this.collectedEvents.actionMenuEvents || {},
        };
    };
    /**
     * Send the current event data along with counts of other collected events
     * @param {EmittableEvent} payload Data from an event emitter
     */
    TelemetryAPI.prototype.flush = function (payload) {
        var processedPayload = this.processEmittedEvent(payload);
        this.sendEvent(__assign(__assign({}, this.processCountableEvents()), { metadata: processedPayload.metadata, udfVersion: processedPayload.udfVersion, definitionInfo: processedPayload.definitionInfo }));
        this.resetEvents();
        this.sendEvent(processedPayload);
    };
    /**
     * Immediately send the current event data
     * @param {EmittableEvent} payload Data from an event emitter
     */
    TelemetryAPI.prototype.emit = function (payload) {
        this.sendEvent(this.processEmittedEvent(payload));
    };
    /**
     * Count the event amongst other counted events for later use
     * @param {CountableEvent} payload Data from an event emitter
     */
    TelemetryAPI.prototype.collect = function (payload) {
        var _a;
        var sourceKey = payload.source + "Events";
        if (!this.collectedEvents[sourceKey]) {
            this.collectedEvents[sourceKey] = (_a = {}, _a[payload.event] = 0, _a);
        }
        if (this.collectedEvents[sourceKey][payload.event] === undefined) {
            this.collectedEvents[sourceKey][payload.event] = 0;
        }
        this.collectedEvents[sourceKey][payload.event] += 1;
    };
    return TelemetryAPI;
}());
exports.TelemetryAPI = TelemetryAPI;
exports.default = TelemetryAPI;


/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.filterStrategies = void 0;
var isPlainObject_1 = __importDefault(__webpack_require__(7));
var filterDefinitionEdits_1 = __importDefault(__webpack_require__(16));
var filterSearchMetrics_1 = __importDefault(__webpack_require__(17));
var filterDefinition_1 = __importDefault(__webpack_require__(19));
// Placeholder function for just returning the input
var returnIt = function (value) { return value; };
var metaFilter = function (metadata) {
    return metadata && isPlainObject_1.default(metadata)
        ? metadata
        : {};
};
exports.filterStrategies = {
    definition: filterDefinition_1.default,
    definitionEdits: filterDefinitionEdits_1.default,
    searchMetrics: filterSearchMetrics_1.default,
    pageAction: returnIt,
    loadTime: returnIt,
    error: returnIt,
    source: returnIt,
    event: returnIt,
    metadata: metaFilter,
    undoActions: returnIt,
    redoActions: returnIt,
};


/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var dashboard_utils_1 = __webpack_require__(0);
var utils_1 = __webpack_require__(8);
/**
 * Remove PII data from a json patch generated by diffing dashboard definitions. Refer to https://tools.ietf.org/html/rfc6902
 * @param {Object} patch
 * @param {String} patch.op
 * @param {String} patch.path
 * @param {String} patch.value
 */
var filterDefinitionEdit = function (_a) {
    var op = _a.op, path = _a.path;
    // json patch always starts with / and uses / as delimiter.
    var parts = path.split('/');
    if (['inputs', 'visualizations', 'dataSources'].includes(parts[1]) &&
        parts.length >= 3) {
        parts[2] = dashboard_utils_1.hashString(parts[2], utils_1.categoryToPrefix[parts[1]]);
    }
    else if (parts[1] === 'layout' &&
        parts[2] === 'structure' &&
        parts.length >= 4) {
        parts[3] = dashboard_utils_1.hashString(parts[3], utils_1.categoryToPrefix.visualizations);
    }
    return {
        op: op,
        path: parts.join('/'),
    };
};
var filterDefinitionEdits = function (patches) {
    return Array.isArray(patches)
        ? patches.map(function (patch) { return filterDefinitionEdit(patch); })
        : null;
};
exports.default = filterDefinitionEdits;


/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/* eslint no-param-reassign: ["error", { "props": false }] */
var dashboard_utils_1 = __webpack_require__(0);
var cloneDeep_1 = __importDefault(__webpack_require__(18));
var get_1 = __importDefault(__webpack_require__(3));
/**
 * Filter datasource id & viz id (as consumer id) which can contain PII from search metrics.
 * @param {Array} searchMetrics
 */
var filterSearchMetrics = function (searchMetrics) {
    if (!Array.isArray(searchMetrics)) {
        return [];
    }
    var clonedMetrics = cloneDeep_1.default(searchMetrics);
    return clonedMetrics.map(function (metric) {
        var consumerId = get_1.default(metric, 'consumerId');
        if (consumerId) {
            metric.consumerId = dashboard_utils_1.hashString(consumerId, 'viz_');
        }
        var dataSourceId = get_1.default(metric, 'dataSourceId');
        if (dataSourceId) {
            metric.dataSourceId = dashboard_utils_1.hashString(dataSourceId, 'ds_');
        }
        return metric;
    });
};
exports.default = filterSearchMetrics;


/***/ }),
/* 18 */
/***/ (function(module, exports) {

module.exports = require("lodash/cloneDeep");

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var filterTitleAndDescriptions_1 = __importDefault(__webpack_require__(20));
var filterIds_1 = __importDefault(__webpack_require__(21));
var filterEncodings_1 = __importDefault(__webpack_require__(22));
var filterOptions_1 = __importDefault(__webpack_require__(23));
var filterEventHandlers_1 = __importDefault(__webpack_require__(24));
var filterDataSources_1 = __importDefault(__webpack_require__(25));
var filterDefinition = function (definition) {
    if (definition === void 0) { definition = {}; }
    return filterDataSources_1.default(filterEventHandlers_1.default(filterEncodings_1.default(filterOptions_1.default(filterIds_1.default(filterTitleAndDescriptions_1.default(definition))))));
};
exports.default = filterDefinition;


/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var mapKeys_1 = __importDefault(__webpack_require__(9));
var mapValues_1 = __importDefault(__webpack_require__(1));
var titleDescriptionNameMapping = {
    title: 'titleLength',
    description: 'descriptionLength',
    name: 'titleLength',
};
/**
 * A helper function designed to work with `lodash.mapValues` to hash title and description in a viz, dataSource or input.
 */
var hashTitleOrDescription = function (item) {
    var itemWithValueReplaced = mapValues_1.default(item, function (value, key) {
        if (key === 'title' || key === 'description' || key === 'name') {
            return typeof value === 'string' ? value.length : 0;
        }
        return value;
    });
    return mapKeys_1.default(itemWithValueReplaced, function (value, key) {
        if (key === 'title' || key === 'description' || key === 'name') {
            return titleDescriptionNameMapping[key];
        }
        return key;
    });
};
var filterTitleAndDescriptions = function (definition) {
    var definitionWithValueReplaced = mapValues_1.default(definition, function (value, key) {
        if (key === 'title' || key === 'description') {
            return typeof value === 'string' ? value.length : 0;
        }
        if (['dataSources', 'visualizations', 'inputs'].includes(key)) {
            return mapValues_1.default(value, hashTitleOrDescription);
        }
        if (key === 'defaults') {
            return mapValues_1.default(value, function (v) {
                return mapValues_1.default(v, hashTitleOrDescription);
            });
        }
        return value;
    });
    return mapKeys_1.default(definitionWithValueReplaced, function (_value, key) {
        if (key === 'title' || key === 'description') {
            return titleDescriptionNameMapping[key];
        }
        return key;
    });
};
exports.default = filterTitleAndDescriptions;


/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var mapKeys_1 = __importDefault(__webpack_require__(9));
var mapValues_1 = __importDefault(__webpack_require__(1));
var dashboard_utils_1 = __webpack_require__(0);
var utils_1 = __webpack_require__(8);
var hashDataSourceIdInViz = function (viz) {
    return mapValues_1.default(viz, function (optionValue, optionKey) {
        return optionKey === 'dataSources'
            ? mapValues_1.default(optionValue, function (dsId) {
                return dashboard_utils_1.hashString(dsId, utils_1.categoryToPrefix.dataSources);
            })
            : optionValue;
    });
};
var filterIds = function (definition) {
    return mapValues_1.default(definition, function (value, category) {
        var hashKey = function (_value, key) {
            return dashboard_utils_1.hashString(key, utils_1.categoryToPrefix[category]);
        };
        if (['visualizations', 'inputs'].includes(category)) {
            return mapValues_1.default(mapKeys_1.default(value, hashKey), hashDataSourceIdInViz);
        }
        if (category === 'dataSources') {
            return mapKeys_1.default(value, hashKey);
        }
        if (category === 'layout') {
            return mapValues_1.default(value, function (v, k) {
                if (k === 'globalInputs' && Array.isArray(v)) {
                    return v.map(function (inputId) {
                        return dashboard_utils_1.hashString(inputId, utils_1.categoryToPrefix.inputs);
                    });
                }
                if (k === 'structure') {
                    return v.map(function (item) { return (__assign(__assign({}, item), { item: dashboard_utils_1.hashString(item.item, utils_1.categoryToPrefix.visualizations) })); });
                }
                return v;
            });
        }
        return value;
    });
};
exports.default = filterIds;


/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var mapValues_1 = __importDefault(__webpack_require__(1));
var get_1 = __importDefault(__webpack_require__(3));
var dashboard_utils_1 = __webpack_require__(0);
var MAX_ENCODING_RECURSION_LEVEL = 2;
/**
 * This is copied from previous implementation.
 */
var filterEncodingHelper = function (encoding, recursionLevel) {
    if (recursionLevel === void 0) { recursionLevel = 0; }
    // no valid encoding exists where the root value is an array
    if (Array.isArray(encoding) && recursionLevel === 0) {
        return encoding;
    }
    if (encoding && typeof encoding === 'object') {
        return mapValues_1.default(encoding, function (val) {
            if (recursionLevel < MAX_ENCODING_RECURSION_LEVEL) {
                if (typeof val === 'string') {
                    return true;
                }
                if (Array.isArray(val)) {
                    return val.length;
                }
                if (val && typeof val === 'object') {
                    return filterEncodingHelper(val, recursionLevel + 1);
                }
            }
            return val;
        });
    }
    return encoding;
};
/**
 * anonymize field value while keeping the color settings.
 */
var filterMatchValues = function (encoding) {
    if (get_1.default(encoding, ['majorColor', 'format', 'type']) !== 'matchvalue') {
        return encoding;
    }
    var encodingCopy = JSON.parse(JSON.stringify(encoding));
    encodingCopy.majorColor.format.matches = encodingCopy.majorColor.format.matches.map(function (_a) {
        var match = _a.match, value = _a.value;
        return ({
            match: dashboard_utils_1.hashString(match, 'field_'),
            value: value,
        });
    });
    return encodingCopy;
};
var filterEncodingOnItem = function (item) {
    return mapValues_1.default(item, function (v, k) {
        return k === 'encoding' ? filterMatchValues(filterEncodingHelper(v)) : v;
    });
};
var filterEncodings = function (definition) {
    return mapValues_1.default(definition, function (value, key) {
        if (['visualizations', 'inputs'].includes(key)) {
            return mapValues_1.default(value, filterEncodingOnItem);
        }
        if (key === 'defaults') {
            return mapValues_1.default(value, filterEncodingOnItem);
        }
        return value;
    });
};
exports.default = filterEncodings;


/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var mapValues_1 = __importDefault(__webpack_require__(1));
var mapKeys_1 = __importDefault(__webpack_require__(9));
var dashboard_utils_1 = __webpack_require__(0);
var isPlainObject_1 = __importDefault(__webpack_require__(7));
var utils_1 = __webpack_require__(8);
// the following two lists are copied from previous implementation
// NOTE: denyLists will have to be updated periodically if options change
// TODO: figure out a better way to block options with confidential information
// a more specific way to handle this is defining a denyList object with key-value pairs of option names and a boolean stating whether it should be removed
// however, this comes with the caveat of having to update this list each time a new option is added
var denyListStrings = [
    'src',
    'content',
    'markdown',
    'unit',
    'chart.overlayFields',
    'icon',
    'axisY2.fields',
    'svg',
];
// NOTE: these substrings cover all the options that could hold confidential info, but will strip out additional options that otherwise do not hold confidential info
var denyListSubstrings = /(label|text)/i;
var filterOptionsOnItem = function (item, filter) {
    return mapValues_1.default(item, function (value, key) {
        if (key === 'options') {
            return filter(value);
        }
        if (key === 'context') {
            return {};
        }
        return value;
    });
};
var filterVisualizationOptions = function (options) {
    return mapValues_1.default(options, function (value, key) {
        if (['fieldColors', 'annotation.categoryColors'].includes(key)) {
            var obj = void 0;
            if (typeof value === 'string') {
                try {
                    obj = JSON.parse(value);
                }
                catch (e) {
                    // anonymize the value to be extra safe
                    return true;
                }
            }
            else {
                obj = value;
            }
            return mapKeys_1.default(obj, function (_fieldColor, fieldName) {
                return dashboard_utils_1.hashString(fieldName, 'field_');
            });
        }
        if (denyListStrings.includes(key) || denyListSubstrings.test(key)) {
            // return true instead of hash string, to be consistent with previous implementation
            return true;
        }
        if (dashboard_utils_1.isDynamicOption(value)) {
            return dashboard_utils_1.DYNAMIC_STRING_SUBSTITUTE;
        }
        if (isPlainObject_1.default(value)) {
            var x = filterVisualizationOptions(value);
            if (key === 'columnFormat') {
                return mapKeys_1.default(x, function (v, fieldName) {
                    return dashboard_utils_1.hashString(fieldName, 'field_');
                });
            }
            return x;
        }
        return value;
    });
};
var filterInputOptions = function (options) {
    return mapValues_1.default(options, function (value, key) {
        if (key === 'defaultValue') {
            return dashboard_utils_1.hashString(value);
        }
        if (key === 'token') {
            return dashboard_utils_1.hashString(value, 'token_');
        }
        if (key === 'items') {
            return Array.isArray(value) ? value.length : 0;
        }
        return value;
    });
};
var filterDataSourceOptions = function (options) {
    return mapValues_1.default(options, function (value, key) {
        if (key === 'queryParameters') {
            return mapValues_1.default(value, function (queryParameterValue, queryParameterKey) {
                if (['earliest', 'latest', 'timezone'].includes(queryParameterKey)) {
                    return queryParameterValue;
                }
                return utils_1.hashStringOnObject(value);
            });
        }
        if (key === 'refresh' ||
            key === 'refreshType' ||
            key === 'requiredFreshness') {
            return value;
        }
        return utils_1.hashStringOnObject(value);
    });
};
var filterLayoutOptions = function (options) {
    return mapValues_1.default(options, function (value, key) {
        if (key === 'backgroundImage') {
            // previous implementation deleted this option. Here we use true to indicate the option is used.
            return mapValues_1.default(value, function (v, k) {
                if (k === 'src') {
                    return true;
                }
                return v;
            });
        }
        return value;
    });
};
var filterOptions = function (definition) {
    return mapValues_1.default(definition, function (value, key) {
        if (key === 'visualizations') {
            return mapValues_1.default(value, function (viz) {
                return filterOptionsOnItem(viz, filterVisualizationOptions);
            });
        }
        if (key === 'dataSources') {
            return mapValues_1.default(value, function (ds) {
                return filterOptionsOnItem(ds, filterDataSourceOptions);
            });
        }
        if (key === 'inputs') {
            return mapValues_1.default(value, function (input) {
                return filterOptionsOnItem(input, filterInputOptions);
            });
        }
        if (key === 'defaults') {
            return mapValues_1.default(value, function (v) {
                return mapValues_1.default(v, utils_1.hashStringOnObject);
            });
        }
        if (key === 'layout') {
            return filterOptionsOnItem(value, filterLayoutOptions);
        }
        return value;
    });
};
exports.default = filterOptions;


/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var mapValues_1 = __importDefault(__webpack_require__(1));
var dashboard_utils_1 = __webpack_require__(0);
var filterEventHandlerOptions = function (eventHandler) {
    return mapValues_1.default(eventHandler, function (value, key) {
        if (key === 'options') {
            return mapValues_1.default(value, function (v, k) {
                if (k === 'url') {
                    return dashboard_utils_1.hashString(v, 'url_');
                }
                return v;
            });
        }
        return value;
    });
};
var filterEventHandlersOnItem = function (item) {
    return mapValues_1.default(item, function (value, key) {
        return key === 'eventHandlers'
            ? value.map(function (handler) { return filterEventHandlerOptions(handler); })
            : value;
    });
};
var filterEventHandlers = function (definition) {
    return mapValues_1.default(definition, function (value, key) {
        if (key === 'visualizations') {
            return mapValues_1.default(value, filterEventHandlersOnItem);
        }
        return value;
    });
};
exports.default = filterEventHandlers;


/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var omit_1 = __importDefault(__webpack_require__(12));
var mapValues_1 = __importDefault(__webpack_require__(1));
var filterDataSources = function (definition) {
    var def = omit_1.default(definition, ['dataSources']);
    return mapValues_1.default(def, function (value, key) {
        if (['visualizations', 'inputs'].includes(key)) {
            return mapValues_1.default(value, function (item) {
                return omit_1.default(item, ['dataSources']);
            });
        }
        if (key === 'defaults') {
            return omit_1.default(value, ['dataSources']);
        }
        return value;
    });
};
exports.default = filterDataSources;


/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.extractDefinitionInfo = exports.getTypeCounts = void 0;
var getTypeCounts = function (dataObject) {
    if (dataObject === void 0) { dataObject = {}; }
    var dataCount = {};
    Object.keys(dataObject).forEach(function (data) {
        var dataType = dataObject[data] && dataObject[data].type;
        if (!dataType) {
            return;
        }
        if (!dataCount[dataType]) {
            dataCount[dataType] = 0;
        }
        dataCount[dataType] += 1;
    });
    return dataCount;
};
exports.getTypeCounts = getTypeCounts;
var extractDefinitionInfo = function (definition) {
    if (definition === void 0) { definition = {}; }
    var visualizations = definition.visualizations || {};
    var inputs = definition.inputs || {};
    var dataSources = definition.dataSources || {};
    var dataSourceTypeCounts = exports.getTypeCounts(dataSources);
    var inputTypeCounts = exports.getTypeCounts(inputs);
    var vizTypeCounts = exports.getTypeCounts(visualizations);
    return {
        componentCounts: {
            dataSourceTypeCounts: dataSourceTypeCounts,
            inputTypeCounts: inputTypeCounts,
            vizTypeCounts: vizTypeCounts,
        },
        numDataSources: Object.keys(dataSources).length,
        numInputs: Object.keys(inputs).length,
        numViz: Object.keys(visualizations).length,
    };
};
exports.extractDefinitionInfo = extractDefinitionInfo;


/***/ })
/******/ ]);
//# sourceMappingURL=TelemetryAPI.js.map
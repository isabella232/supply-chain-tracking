/*!
 * Copyright © 2021 Splunk Inc.
 * SPLUNK CONFIDENTIAL – Use or disclosure of this material in whole or in part
 * without a valid written license from Splunk Inc. is PROHIBITED.
 */
module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 8);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */,
/* 1 */
/***/ (function(module, exports) {

module.exports = require("lodash");

/***/ }),
/* 2 */,
/* 3 */
/***/ (function(module, exports) {

module.exports = require("@splunk/ui-utils/i18n");

/***/ }),
/* 4 */,
/* 5 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "insertMatchForCommand", function() { return insertMatchForCommand; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "insertMatchForHistory", function() { return insertMatchForHistory; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "insertMatchForArg", function() { return insertMatchForArg; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "insertMatchForArgValue", function() { return insertMatchForArgValue; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "insertMatchForTerm", function() { return insertMatchForTerm; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "insertMatchForSearch", function() { return insertMatchForSearch; });
/* harmony import */ var _splunk_react_search_components_Ace__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6);
/* harmony import */ var _splunk_react_search_components_Ace__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_splunk_react_search_components_Ace__WEBPACK_IMPORTED_MODULE_0__);

/**
 * insertMatchForCommand handles the insertion of a command name.
 * @param {Object} editor  Ace editor
 * @param {Object} data  The selected command option
 */

function insertMatchForCommand(editor, data) {
  // Find the pipe for this command, and the current token the cursor is in.
  var cursorRange = editor.selection.getRange();
  var pipeRange = editor.find('|', {
    backwards: true,
    start: cursorRange
  });
  var token = editor.session.getTokenAt(cursorRange.start.row, cursorRange.start.column); // Set start position of the cursor range to be the end position of the pipe.

  cursorRange.setStart(pipeRange.end.row, pipeRange.end.column);

  if (token) {
    // Find the first whitespace on the right side of the cursor within the token.
    // If it exists, set end position of the cursor range to the poisiton of this whitespace.
    // Otherwise, the end position will be the end poisiton of the token.
    var rightOfCursor = token.value.substring(cursorRange.end.column - token.start);
    var matches = rightOfCursor.match(/\s/);

    if (matches) {
      cursorRange.setEnd(cursorRange.end.row, cursorRange.end.column + matches.index);
    } else {
      cursorRange.setEnd(cursorRange.end.row, token.start + token.value.length);
    }
  }

  editor.session.replace(cursorRange, data.replacement);
  editor.clearSelection();
}
/**
 * insertMatchForHistory handles the insertion of a command history.
 * @param {Object} editor  Ace editor
 * @param {Object} data  The selected history option
 */

function insertMatchForHistory(editor, data) {
  var TokenIterator = _splunk_react_search_components_Ace__WEBPACK_IMPORTED_MODULE_0___default.a.acerequire('ace/token_iterator').TokenIterator;
  var cursorPosition = editor.getCursorPosition();
  var iter = new TokenIterator(editor.session, cursorPosition.row, cursorPosition.column);
  var subsearchOpen = 0;
  var token;
  var position;
  var endPosition;

  while (iter.stepForward()) {
    token = iter.getCurrentToken();
    position = iter.getCurrentTokenPosition();

    if (token.type === 'subsearch' && token.value === '[') {
      subsearchOpen += 1;
    }

    if (token.type === 'subsearch' && token.value[0] === ']') {
      // If number of open bracket of subsearches is less than the token.value.length,
      // it means this command is inside a subsearch.
      // We find the close bracket of a subsearch earlier than the next pipe
      if (token.value.length > subsearchOpen) {
        endPosition = position;
        endPosition.column += subsearchOpen;
        break;
      } else {
        subsearchOpen -= token.value.length;
      }
    } // This will be the start of next command.


    if (token.type === 'pipe' && subsearchOpen === 0) {
      endPosition = position;
      break;
    }
  }

  if (endPosition) {
    editor.selection.moveCursorToPosition(endPosition);
  } else {
    editor.selection.moveCursorFileEnd();
  }

  editor.selection.selectFileStart();
  editor.insert(data.replacement);
}
/**
 * insertMatchForArg handles the insertion of a command argument.
 * @param {Object} editor  Ace editor
 * @param {Object} data  The selected argument option
 * e.g, if user inputs "| top li", and selects "limit=" from completion list,
 * it will find substring "li", and replace it with "limit=".
 */

function insertMatchForArg(editor, data) {
  var cursorPosition = editor.getCursorPosition();
  var token = editor.session.getTokenAt(cursorPosition.row, cursorPosition.column);
  var line = editor.session.doc.getLine(cursorPosition.row);
  var value = data.replacement;
  var start = token ? token.start : cursorPosition.column;
  var end = token ? token.start + token.value.length : cursorPosition.column;

  if (token && token.type !== 'quoted') {
    start = cursorPosition.column - data.relatedArg.length;

    if (cursorPosition.column !== line.length) {
      var rightOfStart = line.substring(start);
      var rex = new RegExp("^".concat(data.relatedArg, "[^=(\\s]*(?:=(\\w*)|(\\(\\w*\\)?))?"));
      var matches = rightOfStart.match(rex); // If user has already typed a value for this argument

      if (matches[1] || matches[2]) {
        value += matches[1] || matches[2];
      }

      end = start + matches[0].length;
    } else {
      end = cursorPosition.column;
    }
  }

  editor.selection.moveCursorToPosition({
    row: cursorPosition.row,
    column: start
  });
  editor.selection.selectToPosition({
    row: cursorPosition.row,
    column: end
  });
  editor.insert(value);
}
/**
 * insertMatchForArgValue handles the insertion of a command argument value.
 * @param {Object} editor  Ace editor
 * @param {Object} data  The selected argument value option
 */

function insertMatchForArgValue(editor, data) {
  var range = editor.selection.getRange();
  var cursorPosition = editor.getCursorPosition();
  var line = editor.session.doc.getLine(cursorPosition.row);
  var rightOfCursor = line.substring(cursorPosition.column);
  var textRange = editor.find(data.relatedArg, {
    backwards: true,
    wholeWord: true,
    start: range
  }); // Set the start of replacement range

  range.setStart(textRange.start.row, textRange.start.column); // Set the end of replacement range

  var matches = /\s/.exec(rightOfCursor);
  var endColumn = line.length;

  if (matches) {
    var matchesColumn = cursorPosition.column + matches.index;
    var token = editor.session.getTokenAt(cursorPosition.row, matchesColumn + 1);

    if (token) {
      endColumn = token.type !== 'invalid' ? matchesColumn + 1 : token.start + token.value.length;
    }
  }

  range.setEnd(cursorPosition.row, endColumn);
  editor.session.replace(range, data.replacement);
}
/**
 * insertMatchForTerm handles the insertion of a matched term.
 * @param {Object} editor  Ace editor
 * @param {Object} data  The selected matched term option
 */

function insertMatchForTerm(editor, data) {
  var range = editor.selection.getRange();
  var cursorPosition = editor.getCursorPosition();
  var token = editor.session.getTokenAt(cursorPosition.row, cursorPosition.column);
  var line = editor.session.doc.getLine(cursorPosition.row);
  var leftOfCursor = line.substring(0, cursorPosition.column);
  var rightOfCursor = line.substring(cursorPosition.column);
  var whitespaceRex = /\s/;

  if (!token) {
    editor.session.replace(range, data.replacement);
    return;
  } // Set left boundary of the range.


  var start;
  var matches;

  if (token.type === 'quoted') {
    var leftOfToken = leftOfCursor.substring(0, token.start);
    matches = leftOfToken.match(/(\w) ?= ?$/); // If matches exists, it will be one of the cases similar to
    // "index=", "index =", or "index = ". start will be set to
    // the index of 'x'.

    start = matches ? matches.index : token.start - 1;
  } else {
    matches = leftOfCursor.match(/(\w) ?= ?$/);
    start = matches ? matches.index : leftOfCursor.length - 1;
  }

  while (start > 0) {
    if (whitespaceRex.test(leftOfCursor[start])) {
      break;
    }

    start -= 1;
  }

  range.start.column = start > 0 ? start + 1 : 0; // Set right boundary of the range.

  var tokenLastIndex = token.value.length - 1;

  if (token.type === 'quoted' && token.value[tokenLastIndex] === '"') {
    range.end.column = token.start + token.value.length;
  } else if (cursorPosition.column !== line.length) {
    matches = rightOfCursor.match(whitespaceRex);

    if (matches) {
      range.end.column += matches.index;
    } else {
      range.end.column = line.length;
    }
  }

  editor.session.replace(range, data.replacement);
}
/**
 * insertMatchForSearch handles the insertion of a matched search.
 * @param {Object} editor  Ace editor
 * @param {Object} data  The selected matched term/search option
 */

function insertMatchForSearch(editor, data) {
  editor.setValue(data.replacement);
  editor.clearSelection(); // TODO: If autoFormat is not on, exec this command should not do anything.

  editor.execCommand('autoFormat');
}

/***/ }),
/* 6 */
/***/ (function(module, exports) {

module.exports = require("@splunk/react-search/components/Ace");

/***/ }),
/* 7 */,
/* 8 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addNextCommands", function() { return addNextCommands; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addCommandArgs", function() { return addCommandArgs; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addCommandHistory", function() { return addCommandHistory; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addMatchingTerms", function() { return addMatchingTerms; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addMatchingSearches", function() { return addMatchingSearches; });
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _splunk_ui_utils_i18n__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);
/* harmony import */ var _splunk_ui_utils_i18n__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_splunk_ui_utils_i18n__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _insertCompletions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(5);


 // TODO: move this to a util?

function removeNewlines(str) {
  return str.replace(/[\t ]*(\r\n|\r|\n)\s*/g, ' ');
}
/**
 * addNextCommands gets avaliable commands from data and add them to completions array
 * @param {Object} data  Data from search helper endpoint
 * @param {Array} completions  An array of all available options
 */


function addNextCommands(data, completions) {
  var commonNextCommands = data.commonNextCommands;
  var commandErrors = data.commandErrors;
  var typedCommand = commandErrors.length > 0 ? commandErrors[0].unknown : '';
  var escaped = Object(lodash__WEBPACK_IMPORTED_MODULE_0__["escapeRegExp"])(typedCommand);
  var regex = new RegExp(escaped);
  commonNextCommands.forEach(function (item) {
    if (item.nextCommand !== 'test' && (!typedCommand || regex.test(item.nextCommand))) {
      // TODO: Need get example and short description of this command from searchBNF collection.
      // TODO: this part needs be rechecked.
      completions.push({
        value: item.nextCommand,
        replacement: " ".concat(item.nextCommand, " "),
        meta: Object(_splunk_ui_utils_i18n__WEBPACK_IMPORTED_MODULE_1__["_"])('Command'),
        type: 'next',
        command: {
          name: item.nextCommand,
          shortDesc: item.description
        },
        completer: {
          insertMatch: _insertCompletions__WEBPACK_IMPORTED_MODULE_2__["insertMatchForCommand"]
        },
        hideDocTooltip: true
      });
    }
  });
}
/**
 * addCommandArgs gets command arguments, arguments values or value type from data and add them to completions array.
 * @param {Object} data  Data from search helper endpoint
 * @param {Array} completions  An array of all available options
 */

function addCommandArgs(data, completions) {
  var commandArgs = data.commandArgs;
  var name = data.command.name || '';
  var shortDesc = data.command.shortdesc || '';
  var examples = data.command.examples;
  var example = examples && examples.length > 0 && examples[0][0];
  commandArgs.forEach(function (item) {
    if (item.valueChoice && item.valueChoice.length > 0) {
      var valueChoice = item.valueChoice;
      valueChoice.forEach(function (value) {
        completions.push({
          value: value,
          replacement: "".concat(item.replacement).concat(value, " "),
          relatedArg: item.arg,
          meta: Object(_splunk_ui_utils_i18n__WEBPACK_IMPORTED_MODULE_1__["_"])('Command Args'),
          type: 'commandArgs',
          command: {
            name: name,
            shortDesc: shortDesc,
            example: example
          },
          completer: {
            insertMatch: _insertCompletions__WEBPACK_IMPORTED_MODULE_2__["insertMatchForArgValue"]
          }
        });
      });
    } else if (item.valueType) {
      completions.push({
        value: item.valueType,
        meta: Object(_splunk_ui_utils_i18n__WEBPACK_IMPORTED_MODULE_1__["_"])('Command Args'),
        type: 'commandArgs',
        command: {
          name: name,
          shortDesc: shortDesc,
          example: example
        },
        completer: {
          insertMatch: function insertMatch() {
            return undefined;
          }
        }
      });
    } else {
      var matchingSearch = data.matchingSearch;
      var escaped = Object(lodash__WEBPACK_IMPORTED_MODULE_0__["escapeRegExp"])(item.replacement);
      var regex = new RegExp("".concat(escaped, "$"));

      if (!regex.test(matchingSearch)) {
        completions.push({
          relatedArg: item.arg,
          value: item.replacement,
          replacement: item.replacement,
          meta: Object(_splunk_ui_utils_i18n__WEBPACK_IMPORTED_MODULE_1__["_"])('Command Args'),
          type: 'commandArgs',
          command: {
            name: name,
            shortDesc: shortDesc,
            example: example
          },
          completer: {
            insertMatch: _insertCompletions__WEBPACK_IMPORTED_MODULE_2__["insertMatchForArg"],
            keepPopupAfterInsert: true // After inserts a matched search, keep completion popup open

          }
        });
      }
    }
  });
}
/**
 * addCommandHistory gets history of a specific command from data and add them to completions array.
 * @param {Object} data  Data from search helper endpoint
 * @param {Array} completions  An array of all available options
 */

function addCommandHistory(data, completions) {
  var commandHistory = data.commandHistory;
  var name = data.command.name || '';
  var shortDesc = data.command.shortdesc || '';
  var examples = data.command.examples;
  var example = examples && examples.length > 0 && examples[0][0];
  commandHistory.forEach(function (item) {
    var arg = item.arg.trim();
    arg = removeNewlines(arg);
    completions.push({
      value: "".concat(name, " ").concat(arg),
      replacement: "".concat(item.replacement.trim(), " "),
      command: {
        name: name,
        shortDesc: shortDesc,
        example: example
      },
      meta: Object(_splunk_ui_utils_i18n__WEBPACK_IMPORTED_MODULE_1__["_"])('Command History'),
      type: 'command',
      completer: {
        insertMatch: _insertCompletions__WEBPACK_IMPORTED_MODULE_2__["insertMatchForHistory"]
      }
    });
  });
}
/**
 * addMatchingTerms gets terms which match user input from data and add them to completions array
 * @param {Object} data  Data from search helper endpoint
 * @param {Array} completions  An array of all available options
 */

function addMatchingTerms(data, completions) {
  var matchingTerms = data.matchingTerms;
  var mainSearch = data.matchingSearch.trim();
  matchingTerms.forEach(function (item) {
    var term = item.term.trim();

    if (term !== mainSearch) {
      completions.push({
        value: term,
        replacement: "".concat(term, " "),
        meta: Object(_splunk_ui_utils_i18n__WEBPACK_IMPORTED_MODULE_1__["_"])('Matching Term'),
        type: 'term',
        completer: {
          insertMatch: _insertCompletions__WEBPACK_IMPORTED_MODULE_2__["insertMatchForTerm"]
        },
        hideDocTooltip: true
      });
    }
  });
}
/**
 * addMatchingSearches gets full searches which match user input from data and add them to completions array.
 * @param {Object} data  Data from search helper endpoint
 * @param {Array} completions  An array of all available options
 */

function addMatchingSearches(data, completions) {
  var matchingSearches = data.matchingSearches;
  var mainSearch = data.matchingSearch.trim();
  var escaped = Object(lodash__WEBPACK_IMPORTED_MODULE_0__["escapeRegExp"])(mainSearch);
  var regex = new RegExp("^".concat(escaped));
  matchingSearches.forEach(function (item) {
    var search = item.trim();
    search = removeNewlines(search);

    if (search !== mainSearch && regex.test(search)) {
      completions.push({
        value: item,
        replacement: "".concat(search, " "),
        meta: Object(_splunk_ui_utils_i18n__WEBPACK_IMPORTED_MODULE_1__["_"])('Matching Search'),
        type: 'search',
        completer: {
          insertMatch: _insertCompletions__WEBPACK_IMPORTED_MODULE_2__["insertMatchForSearch"]
        },
        hideDocTooltip: true
      });
    }
  });
}

/***/ })
/******/ ]);
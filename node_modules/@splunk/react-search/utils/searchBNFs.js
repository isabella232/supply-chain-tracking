/*!
 * Copyright © 2021 Splunk Inc.
 * SPLUNK CONFIDENTIAL – Use or disclosure of this material in whole or in part
 * without a valid written license from Splunk Inc. is PROHIBITED.
 */
module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 36);
/******/ })
/************************************************************************/
/******/ ({

/***/ 1:
/***/ (function(module, exports) {

module.exports = require("lodash");

/***/ }),

/***/ 10:
/***/ (function(module, exports) {

module.exports = require("@splunk/splunk-utils/url");

/***/ }),

/***/ 36:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var querystring__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9);
/* harmony import */ var querystring__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(querystring__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _splunk_splunk_utils_url__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(10);
/* harmony import */ var _splunk_splunk_utils_url__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_splunk_splunk_utils_url__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _splunk_splunk_utils_fetch__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(7);
/* harmony import */ var _splunk_splunk_utils_fetch__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_splunk_splunk_utils_fetch__WEBPACK_IMPORTED_MODULE_3__);





function getParsedSyntax(syntax, parsedSyntaxes, data) {
  /* eslint-disable no-continue, no-param-reassign, no-useless-escape */
  var index = 0;
  var parsedSyntax = {
    isList: false,
    args: [],
    functions: [],
    keywords: [],
    other: [],
    list: [],
    addSubSyntax: function addSubSyntax(parsedSubSyntax, options) {
      if (parsedSubSyntax.isList) {
        if (options.isFunction) {
          var functions = Object(lodash__WEBPACK_IMPORTED_MODULE_0__["map"])(parsedSubSyntax.list, function (listItem) {
            return {
              name: listItem,
              parenOptional: options.optionalParen || false
            };
          });
          this.functions = Object(lodash__WEBPACK_IMPORTED_MODULE_0__["union"])(this.functions, functions);
        } else if (this.isList) {
          // if command rules are just list of strings then just append list
          this.list = Object(lodash__WEBPACK_IMPORTED_MODULE_0__["union"])(this.list, parsedSubSyntax.list);
        } else if (this.isEmpty()) {
          // if command rules is empty just set it to array
          this.list = parsedSubSyntax.list.slice(0);
          this.isList = true;
        } else {// this is a case where a list of strings were the syntax but not functions,
          // could be keywords or valid values for an argument.
          // example syntax = <int>(<timescale>)? where timescale is a list
          // for now skip
        }
      } else {
        this.args = Object(lodash__WEBPACK_IMPORTED_MODULE_0__["union"])(this.args, parsedSubSyntax.args);
        this.functions = Object(lodash__WEBPACK_IMPORTED_MODULE_0__["union"])(this.functions, parsedSubSyntax.functions);
        this.keywords = Object(lodash__WEBPACK_IMPORTED_MODULE_0__["union"])(this.keywords, parsedSubSyntax.keywords);
        this.other = Object(lodash__WEBPACK_IMPORTED_MODULE_0__["union"])(this.other, parsedSubSyntax.other);
      }
    },
    isEmpty: function isEmpty() {
      return !(this.args.length + this.functions.length + this.keywords.length + this.other.length + this.list.length);
    }
  }; // Check if the syntax is a list of strings
  // This is either a list of functions or a list of allowable values/part of value to an argument.
  // Currently only using if it is a list of functions.
  // matches foo foo_bar and foo-baz

  var listItemRegex = '[\\w\\-_]+'; // matches (perc|p|exactperc|upperperc)<int>, (perc)<int> and pert<int>

  var dynamicListItemRegex = "(?:(?:\\(".concat(listItemRegex, "(?:\\|").concat(listItemRegex, ")*\\))|").concat(listItemRegex, ")<int>"); // matches a list of functions that match the listItemRegex and synamicListItemRegex

  var listRegex = new RegExp("^((?:(?:".concat(dynamicListItemRegex, ")|\\(?").concat(listItemRegex, ")(?:\\|(?:(?:").concat(dynamicListItemRegex, ")|").concat(listItemRegex, "))*\\)?)((\\(?)\\s*\"\\(\"(.+?)\"\\)\"s*(\\))?s*(\\?)?)?$"));
  var listMatch = syntax.match(listRegex);

  if (listMatch) {
    var list = listMatch[1];
    var functionMatch = listMatch[2]; // replace all functions that match (perc|p|exactperc|upperperc)<int>,
    // (perc)<int> or pert<int> with a regex for the function name

    list = list.replace(/(\(?[\w\-_]+\)?|(?:\([\w\-_]+(?:\|[\w\-_]+)+)\))<int>/g, function (fullMatch, match) {
      var functionsArray = match.replace(/[\(\)]/g, '').split('|');
      var replaceText = '';
      functionsArray.forEach(function (currentValue) {
        replaceText += replaceText ? "|".concat(currentValue, "\\d+") : "".concat(currentValue, "\\d+");
      });
      return replaceText;
    }); // If list is wrapped in () remove them. For example (perc) or (p|perc).

    var listArray = list.replace(/[\(\)]/g, '').split('|');

    if (functionMatch) {
      var parenOptional = listMatch[3] === '(' && listMatch[5] === ')' && listMatch[6] === '?';
      listArray.forEach(function (currentValue) {
        parsedSyntax.functions.push({
          name: currentValue,
          parenOptional: parenOptional
        });
      });
      index += listMatch[1].length + listMatch[3].length;
    } else {
      parsedSyntax.list = listArray;
      parsedSyntax.isList = true;
      return parsedSyntax;
    }
  }

  while (index < syntax.length) {
    // go to next char if the current ch is in the skip list
    var subSytax = syntax.substr(index);
    var skipRegex = /^(\s|\?|\*|">"|"<")/;
    var skipMatch = subSytax.match(skipRegex);

    if (skipMatch) {
      index += skipMatch[0].length;
      continue;
    } // check if the next part of the syntax matches <token-name> where token-name is a stanza in the bnf.


    var stanzaRe = /^<([^>]+)>/;
    var stanzaMatch = subSytax.match(stanzaRe);

    if (stanzaMatch) {
      var _ret = function () {
        // get stanza name
        var stanza = stanzaMatch[1]; // Look a head to determine if the stanza being looked up will be used to define a function.
        // This would be a case like were the syntax = <some-token> "(" <int> ")" or syntax = <some-token> ("(" <int> ")")?
        // The "(" following the <some-token> indicated that <some-token> will be used as a function.

        var addOptions = {
          isFunction: false
        };
        var stanzaFunctionRegex = /^\s*(\(?)\s*"\("(.+)"\)"\s*(\))?\s*(\?)?/;
        var stanzaFunctionMatch = syntax.substr(index + stanzaMatch[0].length).match(stanzaFunctionRegex);

        if (stanzaFunctionMatch) {
          addOptions.isFunction = true;
          addOptions.optionalParen = stanzaFunctionMatch[1] === '(' && stanzaFunctionMatch[3] === ')' && stanzaFunctionMatch[4] === '?';
        }

        if (!parsedSyntaxes[stanza]) {
          // if stanza is not defined yet and it has a syntax get it and define it
          var stanzaEntry = Object(lodash__WEBPACK_IMPORTED_MODULE_0__["find"])(data.entry, function (entry) {
            return entry.name === stanza;
          });

          if (stanzaEntry) {
            var stanzaSyntax = stanzaEntry.content.syntax;

            if (stanzaSyntax) {
              // set to building to avoid infinite loops caused by syntax that references its self.
              parsedSyntaxes[stanza] = 'building';
              parsedSyntaxes[stanza] = getParsedSyntax(stanzaSyntax, parsedSyntaxes, data);
            }
          } else {
            // if the stanza does not have an entry push on the other list
            // so consumer can determine what to do with it
            parsedSyntax.other.push(stanza);
          }
        }

        if (parsedSyntaxes[stanza] && parsedSyntaxes[stanza] !== 'building') {
          // merge sub parsedSyntaxes into parsedSyntax
          parsedSyntax.addSubSyntax(parsedSyntaxes[stanza], addOptions);
        }

        index += stanzaMatch[0].length;
        return "continue";
      }();

      if (_ret === "continue") continue;
    } // check next part of syntax is an argument
    // args in the syntax must match this regex


    var argumentRegex = /^(\(?)\b([^\s=()]+)(\)?)=/;
    var argumentsMatch = subSytax.match(argumentRegex);

    if (argumentsMatch) {
      var _ret2 = function () {
        // arguments could be a list for example (maxrows|maxcols)=<int>
        var argumentKeys = argumentsMatch[2].split('|'); // advance index to after =

        index += argumentsMatch[0].length;
        var valueSyntax = syntax.substr(index);
        var endOfValueSynax = 0; // Find syntax for the value of the argument. For example
        // labelfield=<int>(d|m|h) the syntax for the value is <int>(d|m|h)
        // and for foo=<bar> the syntax of the value <bar>

        if (argumentsMatch[1] === '(' && argumentsMatch[3] !== ')') {
          // If argument is surrounded by parentheses like (labelfield=<int>(d|m|h)) or (foo=<bar>)
          // endOfValueSynax should be the at the closing parenthesis that
          // matches argumentsMatch[1] or a space not in a nested parentheses.
          // This if statement handles the following cases:
          // * (sup=<int>)|(conf=<num>) finding the syntax value for sup is <int>
          // * (override=<bool> | <subsearch-options>)* finding the syntax value for override is <bool>
          // * (time=(foo | bar)) finding the syntax value for time is (foo | bar)
          var paren = 0;

          while (endOfValueSynax < valueSyntax.length) {
            if (valueSyntax[endOfValueSynax] === ')' || valueSyntax[endOfValueSynax] === ' ') {
              if (paren === 0) {
                break;
              }

              if (valueSyntax[endOfValueSynax] === ')') {
                paren -= 1;
              }
            } else if (valueSyntax[endOfValueSynax] === '(') {
              paren += 1;
            }

            endOfValueSynax += 1;
          }
        } else {
          // This else statement handles the following cases and more:
          // * (maxrows|maxcols)=<int> syntax value <bool>
          // * type=(inner|outer|left) | usetime=<bool> | earlier=<bool>
          endOfValueSynax = valueSyntax.indexOf(' ');
        }

        valueSyntax = endOfValueSynax > -1 ? valueSyntax.substr(0, endOfValueSynax) : valueSyntax; // If value syntax is a simple value = <token> set it to the valueType

        var simpleValueRegex = /^\s*<([^>]+)>$/;
        var simpleValueMatch = valueSyntax.match(simpleValueRegex);
        index += valueSyntax.length + 1;
        argumentKeys.forEach(function (argumentKey) {
          parsedSyntax.args.push({
            key: argumentKey.replace(/<int>/, '\\d+'),
            valueType: simpleValueMatch && simpleValueMatch[1] || ''
          });
        });
        return "continue";
      }();

      if (_ret2 === "continue") continue;
    } // check next part of syntax is a keyword
    // keywords in the syntax must match this regex


    var keywordRegex = /^\(?(\w+(?:\|\w+)*)\s*\)?\??\s+\(*<([^>]+)>\)*/;
    var keywordMatch = subSytax.match(keywordRegex);

    if (keywordMatch) {
      parsedSyntax.keywords.push(keywordMatch[1].replace(/[\(\)]/g, ''));
      index += keywordMatch[1].length + 1;
      continue;
    }

    index += 1;
  }

  return parsedSyntax;
}

function isCommand(name) {
  return /^.+-command$/.test(name);
}

function getParsedSyntaxes(data) {
  var parsedSyntaxes = {};
  var entries = data.entry;
  entries.forEach(function (entry) {
    var name = entry.name;
    var syntax = entry.content.syntax || '';

    if (parsedSyntaxes[name]) {
      return;
    }

    if (isCommand(name)) {
      // strip the command name from the syntax since it should not be parsed
      // -7 to get the length of the "-command" plus one space
      syntax = syntax.substr(name.length - 7);
    }

    parsedSyntaxes[name] = getParsedSyntax(syntax, parsedSyntaxes, data);
  }); // Only return parsed syntaxes for commands

  var commandsParsedSyntax = {};
  entries.forEach(function (entry) {
    var name = entry.name;

    if (isCommand(name)) {
      var parsedSyntax = Object(lodash__WEBPACK_IMPORTED_MODULE_0__["pick"])(parsedSyntaxes[name], ['isList', 'args', 'functions', 'keywords', 'other', 'list']);
      var aliasStr = entry.content.alias;

      if (aliasStr) {
        var aliases = aliasStr.replace(/\s*,\s*/g, ',').split(',');
        aliases.forEach(function (alias) {
          commandsParsedSyntax["".concat(alias, "-command")] = parsedSyntax;
        });
      }

      commandsParsedSyntax[name] = parsedSyntax;
    }
  });
  return commandsParsedSyntax;
}

var path = Object(_splunk_splunk_utils_url__WEBPACK_IMPORTED_MODULE_2__["createRESTURL"])('configs/conf-searchbnf');
/**
 * Fetches the searchbnf end point.
 * @public
 * @param {boolean} parseSyntax
 * @return {promise}
 */

function fetchSearchBNFs(parseSyntax) {
  var qs = querystring__WEBPACK_IMPORTED_MODULE_1___default.a.stringify({
    output_mode: 'json',
    // eslint-disable-line @typescript-eslint/camelcase
    count: 0
  });
  return fetch("".concat(path, "?").concat(qs), _splunk_splunk_utils_fetch__WEBPACK_IMPORTED_MODULE_3__["defaultFetchInit"]).then(Object(_splunk_splunk_utils_fetch__WEBPACK_IMPORTED_MODULE_3__["handleResponse"])(200)).then(function (data) {
    if (parseSyntax) {
      return getParsedSyntaxes(data);
    }

    return data;
  }, Object(_splunk_splunk_utils_fetch__WEBPACK_IMPORTED_MODULE_3__["handleError"])('Fetching SearchBNFs failed.'));
}

/* harmony default export */ __webpack_exports__["default"] = (fetchSearchBNFs);

/***/ }),

/***/ 7:
/***/ (function(module, exports) {

module.exports = require("@splunk/splunk-utils/fetch");

/***/ }),

/***/ 9:
/***/ (function(module, exports) {

module.exports = require("querystring");

/***/ })

/******/ });
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.track = exports.setSplunkConfig = exports.setIntervalTest = exports.setBaseFetchInit = exports.resetTest = void 0;

var _lodash = require("lodash");

var _rxjs = require("rxjs");

var _search = require("@splunk/splunk-utils/search");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * A class that polls the server for the status of one or more jobs. This module only exports
 * a singleton of this class, not the class itself.
 * @private
 */
var ProgressTracker =
/*#__PURE__*/
function () {
  function ProgressTracker() {
    var _this = this;

    _classCallCheck(this, ProgressTracker);

    _defineProperty(this, "setSplunkConfig", function (splunkConfig) {
      _this.splunkConfig = splunkConfig;
    });

    _defineProperty(this, "setBaseFetchInit", function (baseFetchInit) {
      _this.baseFetchInit = baseFetchInit;
    });

    _defineProperty(this, "setIntervalTest", function (longInterval) {
      var shortInterval = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : longInterval;

      if (process.env.NODE_ENV === 'test') {
        _this.longInterval = longInterval;
        _this.shortInterval = shortInterval;

        _this.queueNextFetch();
      } else {
        throw new Error('progressTracker#setIntervalTest is only available in test environment.');
      }
    });

    _defineProperty(this, "resetTest", function () {
      if (process.env.NODE_ENV === 'test') {
        _this.initialize();
      } else {
        throw new Error('progressTracker#resetTest is only available in test environment.');
      }
    });

    _defineProperty(this, "track", function (sid) {
      // If we already have an observable for the requested search, return it.
      if (_this.observableCache[sid]) {
        return _this.observableCache[sid];
      } // Otherwise, create a new observable for the search, add it to the cache, and return it.


      return _this.observableCache[sid] = _rxjs.Observable.create(function (observer) {
        _this.searchSubscribers[sid] = observer;

        _this.queueNextFetch(); // Return the unsubscribe function.


        return function () {
          delete _this.searchSubscribers[sid];
          delete _this.observableCache[sid];

          if ((0, _lodash.isEmpty)(_this.searchSubscribers)) {
            _this.unqueueNextFetch();
          }
        };
      }) // Use publish replay to make this Observable shareable, with the last update cached.
      // New subscribers will recieve the last update immediately.
      .publishReplay(1) // Use refCount to simplify handling multiple subscribers. The creation function will
      // be called when the first subscriber subscribes and unsubscribe will be called when
      // the last subscriber unsubscribes.
      .refCount();
    });

    _defineProperty(this, "unqueueNextFetch", function () {
      if (_this.heartbeatSubscription) {
        _this.heartbeatSubscription.unsubscribe();

        _this.heartbeatSubscription = null;
      }
    });

    _defineProperty(this, "queueNextFetch", function () {
      _this.unqueueNextFetch(); // Only queue a fetch if there are subscribers.


      if (!(0, _lodash.isEmpty)(_this.searchSubscribers)) {
        _this.heartbeatSubscription = _this.createHeartbeat().subscribe(_this.handleProgress);
      }
    });

    _defineProperty(this, "handleProgress", function (res) {
      if (!res || !(0, _lodash.isArray)(res.entry)) {
        if (process.env.NODE_ENV !== 'production') {
          // eslint-disable-next-line no-console
          console.log(new Error('Unrecognized response.'));
        }
      } else {
        res.entry.forEach(function (entry) {
          var sid = entry.content.sid; // Check that the subscriber is still subscribed. It could have
          // unsubscribed between the fetch call and response.

          if (_this.searchSubscribers[sid]) {
            _this.searchSubscribers[sid].next(entry);
          } // Check that the subscriber is still subscribed. It could have
          // unsubscribed in the `next` call.


          if (_this.searchSubscribers[sid]) {
            // A search is complete when it is done or has been finalized
            if (entry.content.isDone || entry.content.isFinalized) {
              _this.searchSubscribers[sid].complete();
            }
          }
        }); // Reconcile returned searches with requested ones and trigger an error for
        // searches that were requested but not returned.

        var returnedSearches = res.entry.map(function (entry) {
          return entry.content.sid;
        });
        (0, _lodash.difference)(_this.requestedSearches, returnedSearches).forEach(function (sid) {
          if (_this.searchSubscribers[sid]) {
            _this.searchSubscribers[sid].error(new Error("Search ".concat(sid, " not found. The search may have been cancelled while there are still subscribers.")));
          }
        });
      }
    });

    this.initialize();
  }
  /**
   * Initializes the instance. Used by the constructor and resetTest.
   * @private
   */


  _createClass(ProgressTracker, [{
    key: "initialize",
    value: function initialize() {
      this.unqueueNextFetch();
      this.longInterval = 1000;
      this.shortInterval = 100;
      this.heartbeatSubscription = null;
      this.requestedSearches = null;
      this.searchSubscribers = {};
      this.observableCache = {};
      this.splunkConfig = undefined;
      this.baseFetchInit = undefined;
    }
    /**
     * Set the Splunk config values used for requests to the server.
     *
     * @param {Object} [splunkConfig]
     * @public
     */

  }, {
    key: "createHeartbeat",

    /**
     * Fetches the searches from the server and emits the appropriate response the the appropriate
     * observers.
     *
     * TODO: Consider accepting a TestScheduler here that would be passed to `Observable.interval`.
     * This could simplify the unit tests.
     *
     * @param interval {Number} - The polling interval.
     * @private
     */
    value: function createHeartbeat() {
      var _this2 = this;

      return _rxjs.Observable.timer(this.shortInterval, this.longInterval) // Make a request for the current jobs each heart beat. Use exhaustMap to avoid the
      // unlikely situation where the response from the server takes longer than the
      // interval length.
      .exhaustMap(function () {
        if ((0, _lodash.isEmpty)(_this2.searchSubscribers)) {
          return _rxjs.Observable.empty();
        }

        _this2.requestedSearches = (0, _lodash.keys)(_this2.searchSubscribers);
        return _rxjs.Observable.fromPromise((0, _search.batchGetSearches)(_this2.requestedSearches, {}, _this2.splunkConfig, _this2.baseFetchInit));
      }) // Something went wrong with the fetch. Log the error to the console, but don't
      // throw. Continue polling next inerval.
      .catch(function (err, caught) {
        if (process.env.NODE_ENV !== 'production') {
          // eslint-disable-next-line no-console
          console.log(err);
        }

        return caught;
      });
    }
  }]);

  return ProgressTracker;
}();

var progressTracker = new ProgressTracker();
var resetTest = progressTracker.resetTest,
    setBaseFetchInit = progressTracker.setBaseFetchInit,
    setIntervalTest = progressTracker.setIntervalTest,
    setSplunkConfig = progressTracker.setSplunkConfig,
    track = progressTracker.track;
exports.track = track;
exports.setSplunkConfig = setSplunkConfig;
exports.setIntervalTest = setIntervalTest;
exports.setBaseFetchInit = setBaseFetchInit;
exports.resetTest = resetTest;
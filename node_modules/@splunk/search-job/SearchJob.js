"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

var _rxjs = require("rxjs");

var _search = require("@splunk/splunk-utils/search");

var _savedSearch = require("@splunk/splunk-utils/savedSearch");

var _progressTracker = require("./progressTracker");

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * A class that simplifies creating and accessing Splunk search jobs. All of the instance
 * methods return [Observables](http://reactivex.io/rxjs/manual/overview.html#introduction).
 *
 * Although `SearchJob`'s instance methods return Observables, `SearchJob` itself is not an
 * Observable. Calling `SearchJob.create` or `SearchJob.fromSavedSearch` will make the appropriate
 * request(s) to the server immediately, rather than waiting for a subscriber to one of its instance methods.
 * @file
 */
function returnTrue() {
  return true;
}

function isDone(searchState) {
  return (0, _lodash.get)(searchState, ['content', 'isDone'], false) || (0, _lodash.get)(searchState, ['content', 'isFailed'], false) || (0, _lodash.get)(searchState, ['content', 'isFinalized'], false);
}

var maxSafeInterval = Math.pow(2, 31) - 1;

var SearchJob =
/*#__PURE__*/
function () {
  _createClass(SearchJob, null, [{
    key: "create",

    /**
     * Create a new `SearchJob` instance. This instance may represent a new *or* an existing search job
     * on the server depending on the cache option and the current search jobs on the server.
     *
     * Some things to keep in mind when working with search jobs and the cache.
     * * Never call `cancel` (or set `cancelOnUnload`) when `cache` is `true`. This could cancel a search job used elsewhere.
     * * When `cache` is `false`, call `cancel` on the search job when done with it to free up resources.
     * * When `cache` is `true` and the search job is no longer needed locally, call `stopKeepAlive` to free up resources.
     * * If there won't be any follow up actions on the search job, consider setting `keepAlive` to `false`.
     *
     * Examples
     * ```js
     * // Create a simple search
     * const mySearchJob = SearchJob.create({
     *     search: 'index=_internal | head 10',
     *     earliest_time: '-60m@m',
     *     latest_time: 'now',
     * });
     *
     * // Create a search in a specific context
     * const mySearchJob = SearchJob.create({
     *     search: 'index=_internal | head 10',
     *     earliest_time: '-60m@m',
     *     latest_time: 'now',
     * }, {
     *     app: 'awesome_app',
     *     owner: 'admin',
     * });
     * ```
     *
     * @param {Object} searchParams - Search parameters. See the [Splunk documentation on the
     * `search/jobs` REST endpoint](http://docs.splunk.com/Documentation/Splunk/latest/RESTREF/RESTsearch#search.2Fjobs)
     * for available parameters.
     * @param {String} searchParams.search - The search string. This is the only required search param.
     * @param {Object} [dispatchOptions] - Dispatch options.
     * @param {String} [dispatchOptions.app] - App namespace to use.
     * @param {String} [dispatchOptions.owner] - User namespace to use.
     * @param {String} [dispatchOptions.sharing] - Must be one of [ 'app' | 'global' | 'system' ].
     * @param {Boolean} [dispatchOptions.keepAlive=false] - Keep the search alive after it completes by polling
     * the touch endpoint. Call `stopKeepAlive` (or `cancel`) when the search job is no longer needed.
     * @param {Boolean} [dispatchOptions.cache=false] - If true, will try and reuse an existing
     * search job if it has the same request params.
     * @param {Boolean} [options.cancelOnUnload=!options.cache] - Cancel the search job when the page
     * unloads. Defaults to true if cache is false. Do not use with cached search jobs.
     * @param {Number} [dispatchOptions.cacheLimit=600] - The maximum age (in seconds) of a search
     * job to use if using a cached job.
     * @returns {SearchJob} A new SearchJob instance.
     * @public
     */
    value: function create(searchParams) {
      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var app = _ref.app,
          owner = _ref.owner,
          sharing = _ref.sharing,
          _ref$cache = _ref.cache,
          cache = _ref$cache === void 0 ? false : _ref$cache,
          _ref$cacheLimit = _ref.cacheLimit,
          cacheLimit = _ref$cacheLimit === void 0 ? 600 : _ref$cacheLimit,
          _ref$cancelOnUnload = _ref.cancelOnUnload,
          cancelOnUnload = _ref$cancelOnUnload === void 0 ? !cache : _ref$cancelOnUnload,
          constructorOptions = _objectWithoutProperties(_ref, ["app", "owner", "sharing", "cache", "cacheLimit", "cancelOnUnload"]);

      var search = (0, _search.addLeadingSearchCommand)(searchParams.search);

      var qualifiedSearchParams = _objectSpread({}, searchParams, {
        search: search
      });

      var searchJobSid = cache ? (0, _search.getCachedSearch)(qualifiedSearchParams, {
        cacheLimit: cacheLimit
      }, SearchJob.splunkConfig, SearchJob.baseFetchInit).then(function (cachedSearch) {
        var sid = (0, _lodash.get)(cachedSearch, ['content', 'sid'], null);

        if ((0, _lodash.isNull)(sid)) {
          return (0, _search.createSearchJob)(_objectSpread({
            'webframework.cache.hash': (0, _search.createJava5HashForString)(search)
          }, qualifiedSearchParams), {
            app: app,
            owner: owner,
            sharing: sharing
          }, SearchJob.splunkConfig, SearchJob.baseFetchInit);
        }

        return {
          sid: sid
        };
      }) : (0, _search.createSearchJob)(qualifiedSearchParams, {
        app: app,
        owner: owner,
        sharing: sharing
      }, SearchJob.splunkConfig, SearchJob.baseFetchInit);
      return new SearchJob(searchJobSid, _objectSpread({
        cancelOnUnload: cancelOnUnload
      }, constructorOptions));
    }
    /**
     * Creates a search job from a saved search.
     *
     * Example:
     * ```js
     * const mySearchJob = SearchJob.fromSavedSearch({
     *     name: 'My Saved Search',
     *     app: 'search',
     *     owner: 'me',
     * }, { cache: 'scheduled' });
     * ```
     *
     * @param {Object} savedSearch - Identify the target saved search by its name, app, and owner.
     * Name is always required. App and owner may be required depending on the permissions of the
     * target saved search.
     * @param {String} savedSearch.name - The name of the target saved search.
     * @param {String} [savedSearch.app] - The app of the target saved search.
     * @param {String} [savedSearch.owner] - The owner of the target saved search.
     * @param {Object} [options={}]
     * @param {Object} [options.dispatchParams={}] - Parameters to use when dispatching a new the
     * search job. Ignored if a cached search job is used. See [Splunk REST API docs for the
     * `saved/searches/${name}/dispatch` endpoint](http://docs.splunk.com/Documentation/Splunk/latest/RESTREF/RESTsearch#saved.2Fsearches.2F.7Bname.7D.2Fdispatch)
     * for available parameters.
     * @param {Boolean} [options.keepAlive=false] - Keep the search alive after it completes by polling
     * the touch endpoint. Call `stopKeepAlive` (or `cancel`) when the search job is no longer needed.
     * @param {Boolean} [options.cancelOnUnload=false] - Cancel the search job when the page
     * unloads. This will impact others if the search job is shared.
     * @param {String} [options.cache='any'] - Use a search job that already exists. Accepted values:
     * * none - Dispatch a new job
     * * scheduled - Use the most recent scheduled search job.
     * * any - Use the most recent search job.
     * @param {Number} [options.cacheLimit=Infinity] - The maximum age (in seconds) of a search
     * job to use if using a cached job.
     * @returns {SearchJob} A new SearchJob instance.
     * @public
     */

  }, {
    key: "fromSavedSearch",
    value: function fromSavedSearch(savedSearch) {
      var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var _ref2$cache = _ref2.cache,
          cache = _ref2$cache === void 0 ? 'any' : _ref2$cache,
          _ref2$cacheLimit = _ref2.cacheLimit,
          cacheLimit = _ref2$cacheLimit === void 0 ? Infinity : _ref2$cacheLimit,
          _ref2$dispatchParams = _ref2.dispatchParams,
          dispatchParams = _ref2$dispatchParams === void 0 ? {} : _ref2$dispatchParams,
          constructorOptions = _objectWithoutProperties(_ref2, ["cache", "cacheLimit", "dispatchParams"]);

      if (cache !== 'any' && cache !== 'none' && cache !== 'scheduled') {
        throw new Error("Invalid value for cache: '".concat(cache, "'. cache must be 'none', 'any', or 'scheduled'"));
      }

      var searchJobSid;

      if (cache === 'none') {
        searchJobSid = (0, _savedSearch.dispatch)(savedSearch, dispatchParams, SearchJob.splunkConfig, SearchJob.baseFetchInit);
      } else {
        var params = cache === 'scheduled' ? {
          search: 'isScheduled=true'
        } : {};
        searchJobSid = (0, _savedSearch.getLatest)(savedSearch, params, SearchJob.splunkConfig, SearchJob.baseFetchInit).then(function (latestSearch) {
          var sid = (0, _lodash.get)(latestSearch, ['name'], null);

          if ((0, _lodash.isNull)(sid)) {
            return (0, _savedSearch.dispatch)(savedSearch, dispatchParams, SearchJob.splunkConfig, SearchJob.baseFetchInit);
          }

          if (cacheLimit > 0) {
            var threshold = Date.now() / 1000 - cacheLimit;

            if (threshold > latestSearch.content.start) {
              return (0, _savedSearch.dispatch)(savedSearch, dispatchParams, SearchJob.splunkConfig, SearchJob.baseFetchInit);
            }
          }

          return {
            sid: sid
          };
        });
      }

      return new SearchJob(searchJobSid, constructorOptions);
    }
    /**
     * Creates a SearchJob instance from a search job that already exists on the server.
     *
     * Example:
     * ```js
     * const mySearchJob = SearchJob.fromSid('sid-of-search-job-that-already-exists');
     * ```
     *
     * @param {String} sid - The search job sid.
     * @param {Object} [options]
     * @param {Boolean} [options.keepAlive=false] - Keep the search alive after it completes by polling
     * the touch endpoint. Call `stopKeepAlive` (or `cancel`) when the search job is no longer needed.
     * @returns {SearchJob} A new SearchJob instance.
     * @public
     */

  }, {
    key: "fromSid",
    value: function fromSid(sid) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return new SearchJob(_rxjs.Observable.of({
        sid: sid
      }), options);
    }
    /**
     * Sets the splunk config values used when creating requests to the server. Defaults to the
     * values provided by `@splunk/splunk-utils/config`.
     *
     * This can be used to run searches outside of a Splunkweb environment.
     *
     * This is an advanced API and not relevant for typical usage.
     *
     * **Warning:** The configuration will be set for all requests made by all `SearchJob` instances. It
     * is not possible at this time to set the splunk config on an individual `SearchJob` instance due to
     * batching of requests.
     *
     * @param {Object} [splunkConfig]
     * @public
     */

  }, {
    key: "setSplunkConfig",
    value: function setSplunkConfig(splunkConfig) {
      SearchJob.splunkConfig = splunkConfig;
      (0, _progressTracker.setSplunkConfig)(splunkConfig);
    }
    /**
     * Sets the base fetch init used when creating requests to the server. Defaults to the
     * defaultFetchInit provided by `@splunk/splunk-utils/fetch`.
     *
     * This can be used to set up authentication when running searches outside of a Splunkweb
     * environment.
     *
     * This is an advanced API and not relevant for typical usage.
     *
     * **Warning:** The base fetch init will be set for all requests made by all `SearchJob` instances. It
     * is not possible at this time to set the base fetch init on an individual `SearchJob` instance due to
     * batching of requests.
     *
     * @param {Object} [baseFetchInit]
     * @public
     */

  }, {
    key: "setBaseFetchInit",
    value: function setBaseFetchInit(baseFetchInit) {
      SearchJob.baseFetchInit = baseFetchInit;
      (0, _progressTracker.setBaseFetchInit)(baseFetchInit);
    }
  }, {
    key: "defaultPreviewFetchPredicate",

    /**
     * The default fetch predicate for `SearchJob#getResultsPreview`.
     *
     * @param {Object} searchState
     * @returns {Boolean} - True if it is a real time search or there are preview results.
     * @private
     */
    value: function defaultPreviewFetchPredicate(searchState) {
      if ((0, _lodash.get)(searchState, ['content', 'isRealTimeSearch'], false)) {
        return true;
      }

      return (0, _lodash.get)(searchState, ['content', 'resultPreviewCount'], 0) > 0;
    }
    /**
     * An internal utility method that makes a request to `search/jobs/job/${endpoint}`.
     *
     * @param {String} sid - The sid of the search job.
     * @param {String} endpoint - The endpoint to poll.
     * @param {Object} [requestParams] - Specific to the endpoint.
     * @returns {Observable}
     * @private
     */

  }, {
    key: "getData",
    value: function getData(sid, endpoint, requestParams) {
      return _rxjs.Observable.fromPromise((0, _search.getData)(sid, endpoint, requestParams, SearchJob.splunkConfig, SearchJob.baseFetchInit));
    }
    /**
     * Constructor. Generally the static create methods should be used instead.
     *
     * @param {Promise|Observable} searchJobSid - Resolves with an object containing the sid of a
     * search job on the server.
     * @param {Object} [options={}]
     * @param {Boolean} [options.cancelOnUnload=false] - Cancel the search job when the page unloads.
     * Do not use with cached search jobs.
     * @param {Boolean} [options.keepAlive=false] - Keep the search alive after it completes by polling
     * the touch endpoint. Call `stopKeepAlive` (or `cancel`) when the search job is no longer needed.
     * @returns {SearchJob} this
     * @private
     */

  }]);

  function SearchJob(searchJobSid) {
    var _this = this;

    var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        _ref3$cancelOnUnload = _ref3.cancelOnUnload,
        cancelOnUnload = _ref3$cancelOnUnload === void 0 ? false : _ref3$cancelOnUnload,
        _ref3$keepAlive = _ref3.keepAlive,
        keepAlive = _ref3$keepAlive === void 0 ? false : _ref3$keepAlive;

    _classCallCheck(this, SearchJob);

    _defineProperty(this, "handleUnload", function () {
      _this.cancel();
    });

    this.searchJobSid = _rxjs.Observable.from(searchJobSid);
    ['getSid', 'getProgress', 'whenDone'].forEach(function (method) {
      _this[method] = (0, _lodash.memoize)(_this[method]);
    });
    this.ttl = null;

    if (cancelOnUnload && typeof window !== 'undefined' && (0, _lodash.has)(window, 'addEventListener')) {
      window.addEventListener('beforeunload', this.handleUnload);
    }

    if (keepAlive) {
      this.startKeepAlive();
    } else {
      this.keepAliveSubscription = null;
    }
  }
  /**
   * Returns an Observable that emits the sid once the search is created on the server.
   *
   * Example:
   * ```js
   * const sidSubscription = mySearchJob.getSid().subscribe(sid => {
   *     // Do something with the sid.
   * });
   * ```
   *
   * @returns {Observable}
   * @public
   */


  _createClass(SearchJob, [{
    key: "getSid",
    value: function getSid() {
      return this.searchJobSid.map(function (_ref4) {
        var sid = _ref4.sid;
        return sid;
      });
    }
    /**
     * Returns an Observable that emits search progress updates.
     *
     * Simple Example:
     * ```js
     * const progressSubscription = mySearchJob.getProgress().subscribe(searchState => {
     *     // Do something with the searchState.
     * });
     *
     * // If the search is not done, but is not longer needed, unsubscribe to release resources.
     * progressSubscription.unsubscribe();
     * ```
     *
     * Example handling errors and completion:
     * ```js
     * const progressSubscription = mySearchJob.getProgress().subscribe({
     *     next: searchState => {
     *         // Do something with the search state.
     *     },
     *     error: err => {
     *         // The search failed. Do something with the err.
     *     },
     *     complete: () => {
     *         // The search has completed successfully.
     *     },
     * });
     * ```
     *
     * @returns {Observable}
     * @public
     */

  }, {
    key: "getProgress",
    value: function getProgress() {
      return this.getSid().concatMap(_progressTracker.track).publishReplay(1).refCount();
    }
    /**
     * Returns an Observable that emits when the search is done.
     *
     * Example:
     * ```js
     * const doneSubscription = mySearchJob.whenDone().subscribe(searchState => {
     *     // Do something with the searchState.
     * });
     *
     * // If the search is not done, but is not longer needed, unsubscribe to release resources.
     * doneSubscription.unsubscribe();
     * ```
     * @returns {Observable}
     * @public
     */

  }, {
    key: "whenDone",
    value: function whenDone() {
      return this.getProgress().last().publishReplay(1).refCount();
    }
    /**
     * Returns an Observable that emits results when the search is done.
     *
     * Example:
     * ```js
     * const resultsSubscription = mySearchJob.getResults().subscribe(results => {
     *     // Do something with the results.
     * });
     *
     * // If the search is not done, but is not longer needed, unsubscribe to release resources.
     * resultsSubscription.unsubscribe();
     * ```
     * @param requestParams {Object} - [See documentation for available parameters.
     * ](http://docs.splunk.com/Documentation/Splunk/latest/RESTREF/RESTsearch#search.2Fjobs.2F.7Bsearch_id.7D.2Fresults)
     * @returns {Observable}
     * @public
     */

  }, {
    key: "getResults",
    value: function getResults() {
      var requestParams = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      return this.whenDone().concatMap(function (searchState) {
        return SearchJob.getData(searchState.content.sid, 'results', requestParams);
      }).publishReplay(1).refCount();
    }
    /**
     * An internal utility method that polls search/jobs/job/${endpoint} on prgress updates emitted by
     * getProgress.
     *
     * @param {String} endpoint - The endpoint to poll.
     * @param {Object} [requestParams] - Specific to the endpoint.
     * @param {Object} [dispatchOptions]
     * @param {Function} [dispatchOptions.fetchPredicate] - Return false to skip fetching for a
     * particular beat of progress. The function is passed the search state.
     * @returns {Observable}
     * @private
     */

  }, {
    key: "pollData",
    value: function pollData(endpoint) {
      var requestParams = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var dispatchOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var fetchPredicate = dispatchOptions.fetchPredicate || returnTrue; // About this implementation:
      // `exhaustMap` is used to avoid race conditions. This will ignore a progress update if
      // data is still being fetched for the previous progress update. Ignoring a random progress
      // update to let the result data catch up is fine, as long as it is not the final progress
      // update. To avoid skipping the final update, we filter it out of the initial Observable
      // and concat it after exhaustMap. This ensures that the final progress update executes
      // once and only once.

      return this.getProgress().filter(fetchPredicate).filter(function (searchState) {
        return !isDone(searchState);
      }).exhaustMap(function (searchState) {
        return SearchJob.getData(searchState.content.sid, endpoint, requestParams);
      }).concat(this.whenDone().filter(fetchPredicate).concatMap(function (searchState) {
        return SearchJob.getData(searchState.content.sid, endpoint, requestParams);
      })).publishReplay(1).refCount();
    }
    /**
     * Returns an Observable that emits emits result previews.
     *
     * Example:
     * ```js
     * const resultsPreviewSubscription = mySearchJob.getResultsPreview().subscribe(results => {
     *     // Do something with the results.
     * });
     *
     * // If the search is not done, but is not longer needed, unsubscribe to release resources.
     * resultsPreviewSubscription.unsubscribe();
     * ```
     *
     * @param {Object} requestParams - [See documentation for available parameters.
     * ](http://docs.splunk.com/Documentation/Splunk/latest/RESTREF/RESTsearch#search.2Fjobs.2F.7Bsearch_id.7D.2Fresults_preview)
     * @param {Object} [dispatchOptions]
     * @param {Function} [dispatchOptions.fetchPredicate] - Return false to skip fetching for a
     * particular beat of progress. The function is passed the search state.
     * @returns {Observable}
     * @public
     */

  }, {
    key: "getResultsPreview",
    value: function getResultsPreview() {
      var requestParams = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var dispatchOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return this.pollData('results_preview', requestParams, _objectSpread({
        fetchPredicate: SearchJob.defaultPreviewFetchPredicate
      }, dispatchOptions));
    }
    /**
     * Returns an Observable that emits events.
     *
     * Example:
     * ```js
     * const eventsSubscription = mySearchJob.getEvents().subscribe(events => {
     *     // Do something with the events.
     * });
     *
     * // If the search is not done, but is not longer needed, unsubscribe to release resources.
     * eventsSubscription.unsubscribe();
     * ```
     *
     * @param {Object} requestParams - [See documentation for available parameters.
     * ](http://docs.splunk.com/Documentation/Splunk/latest/RESTREF/RESTsearch#search.2Fjobs.2F.7Bsearch_id.7D.2Fevents)
     * @param {Object} [dispatchOptions]
     * @param {Function} [dispatchOptions.fetchPredicate] - Return false to skip fetching for a
     * particular beat of progress. The function is passed the search state.
     * @public
     */

  }, {
    key: "getEvents",
    value: function getEvents() {
      var requestParams = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var dispatchOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return this.pollData('events', requestParams, dispatchOptions);
    }
    /**
     * Returns an Observable that emits the search summary.
     *
     * Example:
     * ```js
     * const summarySubscription = mySearchJob.getSummary().subscribe(summary => {
     *     // Do something with the summary.
     * });
     *
     * // If the search is not done, but is not longer needed, unsubscribe to release resources.
     * summarySubscription.unsubscribe();
     * ```
     *
     * @param {Object} requestParams - [See documentation for available parameters.
     * ](http://docs.splunk.com/Documentation/Splunk/latest/RESTREF/RESTsearch#search.2Fjobs.2F.7Bsearch_id.7D.2Fsummary)
     * @param {Object} [dispatchOptions]
     * @param {Function} [dispatchOptions.fetchPredicate] - Return false to skip fetching for a
     * particular beat of progress. The function is passed the search state.
     * @returns {Observable}
     * @public
     */

  }, {
    key: "getSummary",
    value: function getSummary() {
      var requestParams = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var dispatchOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return this.pollData('summary', requestParams, dispatchOptions);
    }
    /**
     * Returns an Observable that emits the search timeline.
     *
     * Example:
     * ```js
     * const timelineSubscription = mySearchJob.getTimeline().subscribe(timeline => {
     *     // Do something with the timeline.
     * });
     *
     * // If the search is not done, but is not longer needed, unsubscribe to release resources.
     * timelineSubscription.unsubscribe();
     * ```
     *
     * @param {Object} requestParams - [See documentation for available parameters.
     * ](http://docs.splunk.com/Documentation/Splunk/latest/RESTREF/RESTsearch#search.2Fjobs.2F.7Bsearch_id.7D.2Ftimeline)
     * @param {Object} [dispatchOptions]
     * @param {Function} [dispatchOptions.fetchPredicate] - Return false to skip fetching for a
     * particular beat of progress. The function is passed the search state.
     * @returns {Observable}
     * @public
     */

  }, {
    key: "getTimeline",
    value: function getTimeline() {
      var requestParams = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var dispatchOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return this.pollData('timeline', requestParams, dispatchOptions);
    }
    /**
     * Helper method for applying actions to a search.
     *
     * @param {String} action - The action to take.
     * @param {Object} [params] - Any additional params supported by the particular action.
     * @returns {Observable} A hot Observable.
     * @private
     */

  }, {
    key: "control",
    value: function control(action) {
      var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var obs = this.getSid().concatMap(function (sid) {
        return _rxjs.Observable.fromPromise((0, _search.postAction)(sid, _objectSpread({
          action: action
        }, params), SearchJob.splunkConfig, SearchJob.baseFetchInit));
      }).publishReplay(1);
      obs.connect();
      return obs;
    }
    /**
     * Pauses the search.
     *
     * Example:
     * ```js
     * mySearchJob.pause();
     * ```
     *
     * Example with server response:
     * ```js
     * mySearchJob.pause().subscribe(response => {
     *     // Do something with the response.
     * })
     * ```
     *
     * @returns {Observable} A "hot" Observable that emits the server response.
     * @public
     */

  }, {
    key: "pause",
    value: function pause() {
      return this.control('pause');
    }
    /**
     * Unpauses the search.
     *
     * Example:
     * ```js
     * mySearchJob.unpause();
     * ```
     *
     * Example with server response:
     * ```js
     * mySearchJob.unpause().subscribe(response => {
     *     // Do something with the response.
     * })
     * ```
     *
     * @returns {Observable} A "hot" Observable that emits the server response.
     * @public
     */

  }, {
    key: "unpause",
    value: function unpause() {
      return this.control('unpause');
    }
    /**
     * Finalizes the search.
     *
     * Example:
     * ```js
     * mySearchJob.finalize();
     * ```
     *
     * Example with server response:
     * ```js
     * mySearchJob.finalize().subscribe(response => {
     *     // Do something with the response.
     * })
     * ```
     *
     * @returns {Observable} A "hot" Observable that emits the server response.
     * @public
     */

  }, {
    key: "finalize",
    value: function finalize() {
      return this.control('finalize');
    }
    /**
     * Cancels the search.
     *
     * Warning: Make sure there are no subscribers to the search job before cancelling it.
     *
     * Example:
     * ```js
     * mySearchJob.cancel();
     * ```
     *
     * Example with server response:
     * ```js
     * mySearchJob.cancel().subscribe(response => {
     *     // Do something with the response.
     * })
     * ```
     *
     * @returns {Observable} A "hot" Observable that emits the server response.
     * @public
     */

  }, {
    key: "cancel",
    value: function cancel() {
      this.stopKeepAlive();

      if (typeof window !== 'undefined' && (0, _lodash.has)(window, 'removeEventListener')) {
        window.removeEventListener('beforeunload', this.handleUnload);
      }

      return this.control('cancel');
    }
    /**
     * Touches the search.
     *
     * Example:
     * ```js
     * mySearchJob.touch();
     * ```
     *
     * Example with server response:
     * ```js
     * mySearchJob.touch().subscribe(response => {
     *     // Do something with the response.
     * })
     * ```
     *
     * @returns {Observable} A "hot" Observable that emits the server response.
     * @public
     */

  }, {
    key: "touch",
    value: function touch() {
      return this.control('touch');
    }
    /**
     * Sets the TTL (time to live) of the search.
     *
     * Example:
     * ```js
     * mySearchJob.setTTL(100);
     * ```
     *
     * Example with server response:
     * ```js
     * mySearchJob.setTTL(100).subscribe(response => {
     *     // Do something with the response.
     * })
     * ```
     *
     * @param {Number} nextTTL
     * @returns {Observable} A "hot" Observable that emits the server response.
     * @public
     */

  }, {
    key: "setTTL",
    value: function setTTL(nextTTL) {
      this.ttl = nextTTL;

      if (this.keepAliveSubscription) {
        this.startKeepAlive();
      }

      return this.control('setttl', {
        ttl: nextTTL
      });
    }
    /**
     * Sets the priority of the search.
     *
     * Example:
     * ```js
     * mySearchJob.setPriority(1);
     * ```
     *
     * Example with server response:
     * ```js
     * mySearchJob.setPriority(1).subscribe(response => {
     *     // Do something with the response.
     * })
     * ```
     *
     * @param {Number} nextPriority
     * @returns {Observable} A "hot" Observable that emits the server response.
     * @public
     */

  }, {
    key: "setPriority",
    value: function setPriority(nextPriority) {
      return this.control('setpriority', {
        priority: nextPriority
      });
    }
    /**
     * Enables previews of the search results.
     *
     * Example:
     * ```js
     * mySearchJob.enablePreview();
     * ```
     *
     * Example with server response:
     * ```js
     * mySearchJob.enablePreview().subscribe(response => {
     *     // Do something with the response.
     * })
     * ```
     *
     * @returns {Observable} A "hot" Observable that emits the server response.
     * @public
     */

  }, {
    key: "enablePreview",
    value: function enablePreview() {
      return this.control('enablepreview');
    }
    /**
     * Disables previews of the search results.
     *
     * Example:
     * ```js
     * mySearchJob.disablePreview();
     * ```
     *
     * Example with server response:
     * ```js
     * mySearchJob.disablePreview().subscribe(response => {
     *     // Do something with the response.
     * })
     * ```
     *
     * @returns {Observable} A "hot" Observable that emits the server response.
     * @public
     */

  }, {
    key: "disablePreview",
    value: function disablePreview() {
      return this.control('disablepreview');
    }
    /**
     * Saves the search.
     *
     * Example:
     * ```js
     * mySearchJob.save();
     * ```
     *
     * Example with server response:
     * ```js
     * mySearchJob.save().subscribe(response => {
     *     // Do something with the response.
     * })
     * ```
     *
     * @returns {Observable} A "hot" Observable that emits the server response.
     * @public
     */

  }, {
    key: "save",
    value: function save() {
      return this.control('save');
    }
    /**
     * Unsaves the search.
     *
     * Example:
     * ```js
     * mySearchJob.unsave();
     * ```
     *
     * Example with server response:
     * ```js
     * mySearchJob.unsave().subscribe(response => {
     *     // Do something with the response.
     * })
     * ```
     *
     * @returns {Observable} A "hot" Observable that emits the server response.
     * @public
     */

  }, {
    key: "unsave",
    value: function unsave() {
      return this.control('unsave');
    }
    /**
     * Keep the search alive on the server by touching it periodically once it is complete.
     * @public
     */

  }, {
    key: "startKeepAlive",
    value: function startKeepAlive() {
      var _this2 = this;

      this.stopKeepAlive();
      this.keepAliveSubscription = this.whenDone().catch(function () {
        return _rxjs.Observable.empty();
      }).map(function (searchState) {
        var ttl = (0, _lodash.isNull)(_this2.ttl) ? (0, _lodash.get)(searchState, ['content', 'ttl']) : _this2.ttl; // Multiple by 500 to convert ttl to millisecond and divide by 2 to touch the search
        // job halfway through the ttl.

        return Math.min(ttl * 500, maxSafeInterval);
      }).concatMap(function (interval) {
        return _rxjs.Observable.interval(interval);
      }).exhaustMap(function () {
        return _this2.touch();
      }).catch(function (err, caught) {
        return caught;
      }) // Retry if touch failed.
      .subscribe();
    }
    /**
     * Stops the keep alive process. Call this method to dispose of resources if this search job is no
     * longer used (and has a keep alive process). If this search job is not using the cache, consider
     * using `cancel` instead.
     * @public
     */

  }, {
    key: "stopKeepAlive",
    value: function stopKeepAlive() {
      if (this.keepAliveSubscription) {
        this.keepAliveSubscription.unsubscribe();
        this.keepAliveSubscription = null;
      }
    }
    /**
     * Called when the user navigates away from the page.
     * @private
     */

  }]);

  return SearchJob;
}();

_defineProperty(SearchJob, "splunkConfig", undefined);

_defineProperty(SearchJob, "baseFetchInit", undefined);

var _default = SearchJob;
exports.default = _default;
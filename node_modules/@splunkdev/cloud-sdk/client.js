"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
exports.__esModule = true;
var errors_1 = require("./errors");
exports.SplunkError = errors_1.SplunkError;
var version_1 = __importDefault(require("./version"));
exports.DEFAULT_URLS = {
    api: 'https://api.scp.splunk.com',
    app: 'https://app.scp.splunk.com'
};
exports.REQUEST_STATUS = {
    queued: 'queued',
    retried: 'retried'
};
var SEARCH_SUBMIT_QUEUE = 'search-submit';
/**
 * Internal class that holds the state for a pending service request promise (including the promise and it's callbacks).
 */
var RequestFutureHolder = /** @class */ (function () {
    function RequestFutureHolder(request, requestStatusCallback) {
        var _this = this;
        this.unsetErrorHandler = function (reason) {
            throw new Error('Unexpectedly don\'t have an error handler');
        };
        this.unsetSuccessHandler = function (value) {
            throw new Error('Unexpectedly don\'t have a success handler');
        };
        this.onError = this.unsetErrorHandler;
        this.onSuccess = this
            .unsetSuccessHandler;
        this.request = request;
        this.promise = new Promise(function (onSuccess, onError) {
            _this.onSuccess = onSuccess;
            _this.onError = onError;
        });
        this.statusCallback = requestStatusCallback;
    }
    return RequestFutureHolder;
}());
/*
 * These defaults are used when nothing is specified in the client specification. If we decide to enable retries
 * for all clients by default, this should be removed in favor of DefaultQueueManagerParams below.
 */
var DEFAULT_REQUEST_QUEUE_PARAMS = {
    initialTimeout: 1000,
    exponent: 2.0,
    retries: 0,
    maxInFlight: 3,
    enableRetryHeader: false
};
/**
 * RequestQueueManagerParams allows for configuration of retry behaviors. The constructor takes two parameters,
 * the first is the set of parameters to use when there are
 */
var RequestQueueManagerParams = /** @class */ (function () {
    function RequestQueueManagerParams(defaults, overrides) {
        if (defaults === void 0) { defaults = DEFAULT_REQUEST_QUEUE_PARAMS; }
        if (overrides === void 0) { overrides = new Map(); }
        this.defaults = defaults;
        this.overrides = overrides;
    }
    return RequestQueueManagerParams;
}());
exports.RequestQueueManagerParams = RequestQueueManagerParams;
/**
 * This class holds the future defaults for request queues.
 */
var DefaultQueueManagerParams = /** @class */ (function (_super) {
    __extends(DefaultQueueManagerParams, _super);
    function DefaultQueueManagerParams() {
        return _super.call(this, {
            retries: 4,
            initialTimeout: 500,
            exponent: 2,
            maxInFlight: 3
        }, new Map([
            [
                SEARCH_SUBMIT_QUEUE,
                {
                    retries: 6,
                    initialTimeout: 1000,
                    exponent: 1.6,
                    maxInFlight: 3
                },
            ],
        ])) || this;
    }
    return DefaultQueueManagerParams;
}(RequestQueueManagerParams));
exports.DefaultQueueManagerParams = DefaultQueueManagerParams;
/**
 * Internal class that holds multiple RequestQueues.  Will auto-create a queue for a given name if it doesn't exist.
 */
var RequestQueueManager = /** @class */ (function () {
    function RequestQueueManager(params) {
        if (params === void 0) { params = new RequestQueueManagerParams(); }
        this.queues = new Map();
        this.params = params;
    }
    RequestQueueManager.prototype.add = function (queueName, request, requestStatusCallback) {
        return this.getQueue(queueName).add(request, requestStatusCallback);
    };
    RequestQueueManager.prototype.getQueue = function (queueName) {
        if (!this.queues.has(queueName)) {
            var queue = new RequestQueue(this.params.overrides.get(queueName) || this.params.defaults);
            this.queues.set(queueName, queue);
        }
        return this.queues.get(queueName);
    };
    return RequestQueueManager;
}());
/**
 * Internal class that manages requests- the intent is to keep the requests largely in order and not flood the server
 * when it is already overloaded. When the client gets a backoff signal (429), it should not continue to make new
 * requests until the request is successfully completed. Rather than a strict serial execution, this implementation will
 * allow a certain number of 'in-flight' requests to lend the specified degree of parallelism.
 */
var RequestQueue = /** @class */ (function () {
    function RequestQueue(params) {
        this.retryStatuses = new Set([429, 503]);
        this.queue = [];
        this.inFlight = new Set();
        this.params = params;
    }
    /**
     * Enqueue a request for execution as soon as possible.  Returns a Promise that contains both the final request
     * used and the resultant response, ready for calling a ResponseHook.
     */
    RequestQueue.prototype.add = function (request, requestStatusCallback) {
        return __awaiter(this, void 0, void 0, function () {
            var holder;
            return __generator(this, function (_a) {
                holder = new RequestFutureHolder(request, requestStatusCallback);
                this.queue.push(holder);
                if (holder.statusCallback !== undefined) {
                    setTimeout(holder.statusCallback, 0, { request: request, status: exports.REQUEST_STATUS.queued });
                }
                this.dispatch_requests();
                return [2 /*return*/, holder.promise];
            });
        });
    };
    /**
     * Looks for pending requests that can be dispatched, and dispatches them if there is a slot available.
     */
    RequestQueue.prototype.dispatch_requests = function () {
        var _this = this;
        if (this.inFlight.size < this.params.maxInFlight) {
            var holder_1 = this.queue.shift();
            if (holder_1 !== undefined) {
                this.inFlight.add(holder_1);
                // tslint:disable-next-line:no-floating-promises
                this.dispatch(holder_1)
                    .then(holder_1.onSuccess, holder_1.onError)
                    .then(function () {
                    _this.inFlight["delete"](holder_1);
                    _this.dispatch_requests();
                });
            }
        }
    };
    /**
     * Actually dispatches a request, retrying if it receives a transient error.
     */
    RequestQueue.prototype.dispatch = function (holder) {
        return __awaiter(this, void 0, void 0, function () {
            var retry, timeout, initialTime, response, needsRetry, currentRequest;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        retry = 0;
                        timeout = this.params.initialTimeout;
                        initialTime = Date.now();
                        needsRetry = false;
                        _a.label = 1;
                    case 1:
                        currentRequest = holder.request.clone();
                        if (retry > 0 && this.params.enableRetryHeader) {
                            // The following cannot be set unless gateway adds the header to Access-Control-Allow-Headers
                            // TODO: Enable by default when allowed by gateway
                            currentRequest.headers.set('Retry', initialTime + ":" + retry);
                            if (holder.statusCallback !== undefined) {
                                setTimeout(holder.statusCallback, 0, { status: exports.REQUEST_STATUS.retried, request: currentRequest });
                            }
                        }
                        return [4 /*yield*/, fetch(currentRequest)];
                    case 2:
                        response = _a.sent();
                        if (!this.retryStatuses.has(response.status)) return [3 /*break*/, 5];
                        needsRetry = true;
                        retry += 1;
                        if (!(retry <= this.params.retries)) return [3 /*break*/, 4];
                        return [4 /*yield*/, _sleep(timeout)];
                    case 3:
                        _a.sent();
                        timeout = timeout * this.params.exponent;
                        _a.label = 4;
                    case 4: return [3 /*break*/, 6];
                    case 5:
                        needsRetry = false;
                        _a.label = 6;
                    case 6:
                        if (needsRetry && retry <= this.params.retries) return [3 /*break*/, 1];
                        _a.label = 7;
                    case 7: return [2 /*return*/, [response, currentRequest]];
                }
            });
        });
    };
    return RequestQueue;
}());
/**
 * Interrogates the response. Decodes the response if successful or throws an error.
 */
function handleResponse(response) {
    if (response.ok) {
        if (response.headers.get('Content-Type') === ContentType.CSV ||
            response.headers.get('Content-Type') === ContentType.GZIP) {
            return response
                .text()
                .then(function (text) { return ({ body: text, headers: response.headers, status: response.status }); });
        } // else
        return response
            .text()
            .then(decodeJson)
            .then(function (json) { return ({ body: json, headers: response.headers, status: response.status }); });
    } // else
    return response.text().then(function (text) {
        var err;
        try {
            var json = JSON.parse(text);
            if (!json.message) {
                err = errors_1.buildSplunkError({
                    message: "Malformed error message (no message) for endpoint: " + response.url + ".",
                    httpStatusCode: response.status,
                    details: {
                        response: text
                    }
                });
            }
            else {
                err = errors_1.buildSplunkError({
                    message: json.message,
                    code: json.code,
                    moreInfo: json.moreInfo,
                    httpStatusCode: response.status,
                    details: json.details
                });
            }
        }
        catch (ex) {
            err = errors_1.buildSplunkError({
                message: response.statusText + " - unable to process response",
                httpStatusCode: response.status,
                details: {
                    response: text
                }
            });
        }
        throw err;
    });
}
/**
 * Decodes the JSON into an object. Returns a string if empty or an
 * error if unable to parse the text as JSON.
 */
// TODO(david): Should we throw if response is empty? We may get here on DELETE
function decodeJson(text) {
    if (text === '') {
        return text;
    }
    try {
        return JSON.parse(text);
    }
    catch (e) {
        throw new Error("Unable to parse message: \"" + text + "\"");
    }
}
var _sleep = function (millis) {
    return new Promise(function (resolve) {
        setTimeout(resolve, millis);
    });
};
/**
 * This class acts as a raw proxy for Splunk Cloud, implementing
 * authorization for requests, setting the proper headers, calling HTTP methods, etc.
 * Do not use this class directly. Instead, use the service proxies that implement
 * the service endpoints.
 */
var ServiceClient = /** @class */ (function () {
    /**
     * Creates a `ServiceClient` object with the given `ServiceClientArgs` object.
     * @param args A `ServiceClientArgs` object.
     */
    function ServiceClient(args) {
        var _this = this;
        this.responseHooks = [];
        /**
         * Adds a response hook to the list of response handlers. Each response hook is called with a response for each request,
         * in the order it was defined. If the callback returns a `Response` object, the `Response` object replaces the argument it was
         * called with.
         * You can use a response hook for different purposes. For example, use a response hook as a logging request--if the
         * callback returns `null`,  it does not affect the result. Use a response hook for retrying failed requests--retry
         * the request, and if successful, return the response.
         * @param hook A callback that takes a `Response` object and optionally returns a `Response` object.
         */
        this.addResponseHook = function (hook) {
            _this.responseHooks.push(hook);
        };
        /**
         * Clears response hooks from the client.
         */
        this.clearResponseHooks = function () {
            _this.responseHooks = [];
        };
        this.invokeHooks = function (response, request) {
            return _this.responseHooks.reduce(function (result, cb) {
                // Result starts as a known good Promise<Result>
                return result.then(function (chainResponse) {
                    // Call the callback, get the result
                    var cbResult;
                    try {
                        cbResult = cb.call(null, chainResponse, request);
                    }
                    catch (err) {
                        cbResult = null;
                    }
                    // If the callback is a Promise, then it may be a Promise<Result>
                    // if it isn't, then just return the last known good promise.
                    // It may also be a Promise of something else.  If that's the
                    // case, we need to wait until the promise resolves to check.
                    if (cbResult instanceof Promise) {
                        return cbResult.then(function (output) {
                            if (output.ok !== undefined) {
                                return output;
                            }
                            // If it's not a response, substitute our last known
                            // good response.
                            return chainResponse;
                        });
                    }
                    return chainResponse;
                });
            }, Promise.resolve(response));
        };
        /**
         * Builds the URL from a service + endpoint, with the query encoded in the URL
         * (concatenates the URL with the path).
         *
         * If the query contains an array value, the query is encoded as `foo=1,2`
         * rather than `foo=1&foo=2`. Some services expect the latter form, but
         * only the former format is supported at this time.
         *
         * @param cluster The cluster endpoint to target (`api` or `app`).
         * @param path The path to the resource that is being requested.
         * @param query The `QueryArgs` object.
         * @return A fully-qualified URL.
         */
        this.buildUrl = function (cluster, path, query) {
            var serviceCluster = _this.urls[cluster] || exports.DEFAULT_URLS.api;
            var basePath = "" + serviceCluster + escape(path);
            if (query && Object.keys(query).length > 0) {
                var queryEncoded = Object.keys(query)
                    .filter(function (k) { return query[k] !== undefined && query[k] !== null; }) // filter out undefined and null
                    .map(function (k) { return encodeURIComponent(k) + "=" + encodeURIComponent(String(query[k])); })
                    .join('&');
                return basePath + "?" + queryEncoded;
            }
            return basePath;
        };
        /**
         * Builds headers that are required for a request to Splunk Cloud, such as:
         * "Authorization", "Content-Type", and "Splunk-Client".
         * @param headers Additional headers to use for each request
         * @return A key-values map of headers
         */
        this.buildHeaders = function (headers) { return __awaiter(_this, void 0, void 0, function () {
            var token, requestParamHeaders;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.tokenSource()];
                    case 1:
                        token = _a.sent();
                        requestParamHeaders = new Headers({
                            'Authorization': "Bearer " + token,
                            'Content-Type': ContentType.JSON,
                            'Splunk-Client': version_1["default"].useragent + "/" + version_1["default"].version
                        });
                        if (headers !== undefined && headers !== {}) {
                            Object.keys(headers).forEach(function (key) {
                                requestParamHeaders.append(key, headers[key]);
                            });
                        }
                        return [2 /*return*/, requestParamHeaders];
                }
            });
        }); };
        /**
         * Builds a path for a request to a service.
         * @param servicePrefix The name of the service with its version, for example "search/v1".
         * @param segments An array of path elements that are checked and added to the path, for example "['jobs', jobId]".
         * @param overrideTenant The tenant to use instead of the tenant that is associated with this client object.
         * @return A fully-qualified path to the resource.
         */
        this.buildPath = function (servicePrefix, segments, overrideTenant) {
            var e_1, _a;
            var effectiveTenant = overrideTenant || _this.tenant;
            if (!effectiveTenant && segments[0] !== 'system') {
                throw new Error('No tenant specified');
            }
            var path = segments[0] === 'system'
                ? "/" + segments.join('/')
                : "/" + effectiveTenant + servicePrefix + "/" + segments.join('/');
            try {
                for (var segments_1 = __values(segments), segments_1_1 = segments_1.next(); !segments_1_1.done; segments_1_1 = segments_1.next()) {
                    var elem = segments_1_1.value;
                    if (elem && elem.trim() === '') {
                        throw new Error("Empty elements in path: " + path);
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (segments_1_1 && !segments_1_1.done && (_a = segments_1["return"])) _a.call(segments_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return path;
        };
        /**
         * A proxy for fetch that builds the URL, applies headers and the query string, and invokes hooks
         * before returning a `Response` object.
         * @param method The HTTP request method (GET, POST, PATCH, or DELETE).
         * @param cluster The cluster endpoint to target (`api` or `app`).
         * @param path The path to the resource that is being requested.
         * @param opts Request options.
         * @param data Data for the request body. Objects are converted to strings.
         */
        this.fetch = function (method, cluster, path, opts, data) {
            if (opts === void 0) { opts = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var url, queue, headers, options, request, requestStatusCallback;
                var _this = this;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            url = this.buildUrl(cluster, path, opts.query);
                            queue = opts.queue || ServiceClient.queueFromPath(path, method);
                            return [4 /*yield*/, this.buildHeaders(opts.headers)];
                        case 1:
                            headers = _a.sent();
                            options = {
                                method: method,
                                headers: headers,
                                body: JSON.stringify(data)
                            };
                            request = new Request(url, options);
                            requestStatusCallback = opts.statusCallback;
                            return [2 /*return*/, this.queueManager
                                    .add(queue, request, requestStatusCallback)
                                    .then(function (responseRequest) { return _this.invokeHooks.apply(_this, __spread(responseRequest)); })];
                    }
                });
            });
        };
        /**
         * Performs a GET request on the specified path.
         * This implementation is internal but can be used for APIs that are not supported by an SDK.
         * @param cluster The cluster endpoint to target (`api` or `app`).
         * @param path The path to the resource that is being requested.
         * @param opts Request options.
         * @return An `HTTPResponse` object.
         */
        this.get = function (cluster, path, opts) {
            if (opts === void 0) { opts = {}; }
            return _this.fetch('GET', cluster, path, opts).then(handleResponse);
        };
        /**
         * Performs a POST request on the specified path.
         * This implementation is internal but can be used for APIs that are not supported by an SDK.
         * @param cluster The cluster endpoint to target (`api` or `app`).
         * @param path The path to the resource that is being requested.
         * @param data A data object that is converted to JSON and used as the request body.
         * @param opts Request options.
         * @return An `HTTPResponse` object.
         */
        this.post = function (cluster, path, data, opts) {
            if (data === void 0) { data = null; }
            if (opts === void 0) { opts = {}; }
            return _this.fetch('POST', cluster, path, opts, data).then(handleResponse);
        };
        /**
         * Performs a PUT request on the specified path.
         * This implementation is internal but can be used for APIs that are not supported by an SDK.
         * @param cluster The cluster endpoint to target (`api` or `app`).
         * @param path The path to the resource that is being requested.
         * @param data A data object that is converted to JSON and used as the request body.
         * @param opts Request options.
         * @return An `HTTPResponse` object.
         */
        this.put = function (cluster, path, data, opts) {
            if (opts === void 0) { opts = {}; }
            return _this.fetch('PUT', cluster, path, opts, data).then(handleResponse);
        };
        /**
         * Performs a PATCH request on the specified path.
         * This implementation is internal but can be used for APIs that are not supported by an SDK.
         * @param cluster The cluster endpoint to target (`api` or `app`).
         * @param path The path to the resource that is being requested.
         * @param data A data object that is converted to JSON and used as the request body.
         * @param opts Request options.
         * @return An `HTTPResponse` object.
         */
        this.patch = function (cluster, path, data, opts) {
            if (opts === void 0) { opts = {}; }
            return _this.fetch('PATCH', cluster, path, opts, data).then(handleResponse);
        };
        /**
         * Performs a DELETE request on the specified path.
         * This implementation is internal but can be used for APIs that are not supported by an SDK.
         * @param cluster The cluster endpoint to target (`api` or `app`).
         * @param path The path to the resource that is being requested.
         * @param data A data object that is converted to JSON and used as the request body.
         * @param opts Request options.
         * @return An `HTTPResponse` object.
         */
        this["delete"] = function (cluster, path, data, opts) {
            if (data === void 0) { data = {}; }
            if (opts === void 0) { opts = {}; }
            return _this.fetch('DELETE', cluster, path, opts, data).then(handleResponse);
        };
        var tokenSourceProvider = args.tokenSource;
        if (typeof tokenSourceProvider === 'string') {
            // If we have a string, wrap it in a promise
            this.tokenSource = function () { return new Promise(function (resolve) { return resolve(tokenSourceProvider); }); };
        }
        else if (typeof tokenSourceProvider === 'function') {
            // If we have an async function, just call it when we need a token
            this.tokenSource = tokenSourceProvider;
        }
        else if (typeof tokenSourceProvider !== 'undefined' &&
            'getAccessToken' in tokenSourceProvider) {
            // Else wrap a token manager.
            this.authManager = tokenSourceProvider;
            this.tokenSource = (function () {
                var authManager = _this.authManager;
                return function () { return authManager.getAccessToken(); };
            })();
        }
        else {
            throw new errors_1.SplunkError({ message: 'Unsupported token source' });
        }
        this.urls = args.urls || exports.DEFAULT_URLS;
        this.tenant = args.defaultTenant;
        this.queueManager = new RequestQueueManager(args.requestQueueManagerParams);
    }
    ServiceClient.queueFromPath = function (path, method) {
        if (method === 'POST' && path.match('/search/.*/jobs$')) {
            return SEARCH_SUBMIT_QUEUE;
        }
        var service = path.split('/')[2]; // Default is service from the URL
        if (service) {
            return service;
        }
        return 'default';
    };
    return ServiceClient;
}());
exports.ServiceClient = ServiceClient;
var ContentType;
(function (ContentType) {
    ContentType["CSV"] = "text/csv";
    ContentType["GZIP"] = "application/gzip";
    ContentType["JSON"] = "application/json";
})(ContentType = exports.ContentType || (exports.ContentType = {}));
//# sourceMappingURL=client.js.map
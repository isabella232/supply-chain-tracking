"use strict";
/**
 * Copyright 2019 Splunk, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"): you may
 * not use this file except in compliance with the License. You may obtain
 * a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations
 * under the License.
 */
exports.__esModule = true;
/**
 * The default batch size for the EventBatcher.
 */
exports.DEFAULT_BATCH_SIZE = 1040000;
/**
 * The default batch count for the EventBatcher.
 */
exports.DEFAULT_BATCH_COUNT = 500;
/**
 * Provides the ability to keep a growing number of events queued up and sends them to
 * the ingest service.
 * The events are flushed on a periodic interval or when the set capacity has been reached.
 */
var EventBatcher = /** @class */ (function () {
    /**
     * @param ingest The proxy for the Ingest service API.
     * @param batchSize The size of events, in bytes.
     * @param batchCount The number of events.
     * @param timeout The interval to send the events and flush the queue, in milliseconds.
     */
    function EventBatcher(ingest, batchSize, batchCount, timeout) {
        var _this = this;
        // Ingest service has a kinesis internal limit, ~1MiB 1048576 bytes
        this.batchSize = exports.DEFAULT_BATCH_SIZE;
        // Ingest service has a kinesis internal limit, 500 records per PUT
        this.batchCount = exports.DEFAULT_BATCH_COUNT;
        /**
         * Adds a new event to the array and sends all of the events if the event limits are met.
         *
         * @param event A single event.
         */
        this.add = function (event) {
            _this.queue.push(event);
            return _this.run();
        };
        /**
         * Creates a periodic task to send all of the events.
         *
         * @return The timer that was created.
         */
        this.setTimer = function () {
            return setTimeout(function () {
                if (_this.queue.length > 0) {
                    return _this.flush();
                }
            }, _this.timeout);
        };
        /**
         * Resets the timer and updates the timer ID.
         */
        this.resetTimer = function () {
            _this.stopTimer();
            _this.timer = _this.setTimer();
        };
        /**
         * Cleans up the events and timer.
         * @return A promise to be completed when the events are accepted by the service.
         */
        this.flush = function () {
            _this.resetTimer();
            var data = _this.queue;
            _this.queue = [];
            var promises = _this.promiseQueue;
            _this.promiseQueue = [];
            _this.resetTimer();
            return _this.ingest.postEvents(data)
                .then(function (response) {
                promises.forEach(function (p) { return p.resolve(response); });
                return response;
            }, function (err) {
                promises.forEach(function (p) { return p.reject(err); });
                throw err;
            });
        };
        /**
         * Processes the events in the queue and sends them to the HTTP Event Collector (HEC)
         * when the queue limits are met or exceeded.
         * If the events are sent, a promise is returned. Otherwise, the event is queued until the limit is reached.
         * A timer runs periodically to ensure that events do not stay queued too long.
         *
         * @return `null` if the event has not yet been sent.
         */
        this.run = function () {
            var maxCountReached = (_this.queue.length >= _this.batchCount);
            var eventByteSize = JSON.stringify(_this.queue).length;
            if (maxCountReached || eventByteSize >= _this.batchSize) {
                return _this.flush();
            }
            return new Promise(function (resolve, reject) { return _this.promiseQueue.push({
                resolve: resolve,
                reject: reject
            }); });
        };
        /**
         * Performs a flush operation if the queue is not empty.
         */
        this.stop = function () {
            _this.stopTimer();
            if (_this.queue !== undefined && _this.queue.length > 0) {
                return _this.flush();
            }
            return Promise.resolve('Queue is empty, all events flushed');
        };
        /**
         * Stops the timer.
         */
        this.stopTimer = function () {
            clearTimeout(_this.timer);
        };
        this.ingest = ingest;
        this.batchSize = Math.min(batchSize, exports.DEFAULT_BATCH_SIZE);
        this.batchCount = Math.min(batchCount, exports.DEFAULT_BATCH_COUNT);
        // TODO: set some sane defaults so this can be optional
        this.timeout = timeout;
        this.queue = [];
        this.timer = this.setTimer();
        this.promiseQueue = [];
    }
    return EventBatcher;
}());
exports.EventBatcher = EventBatcher;
//# sourceMappingURL=ingest_event_batcher.js.map
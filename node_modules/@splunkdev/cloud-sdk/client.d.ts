/**
 * Copyright 2019 Splunk, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"): you may
 * not use this file except in compliance with the License. You may obtain
 * a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations
 * under the License.
 */
import { AuthManager } from './auth_manager';
import { SplunkError, SplunkErrorParams } from './errors';
export { SplunkError, SplunkErrorParams };
export declare const DEFAULT_URLS: {
    api: string;
    app: string;
};
export declare const REQUEST_STATUS: {
    queued: string;
    retried: string;
};
interface RequestQueueParams {
    initialTimeout: number;
    exponent: number;
    retries: number;
    maxInFlight: number;
    enableRetryHeader?: boolean;
}
/**
 * RequestQueueManagerParams allows for configuration of retry behaviors. The constructor takes two parameters,
 * the first is the set of parameters to use when there are
 */
export declare class RequestQueueManagerParams {
    defaults: RequestQueueParams;
    overrides: Map<string, RequestQueueParams>;
    constructor(defaults?: RequestQueueParams, overrides?: Map<string, RequestQueueParams>);
}
/**
 * This class holds the future defaults for request queues.
 */
export declare class DefaultQueueManagerParams extends RequestQueueManagerParams {
    constructor();
}
export declare type ResponseHook = (response: Response, request: Request) => Promise<Response> | any;
export declare type TokenProviderAsyncFunction = () => Promise<string>;
export interface ServiceClientArgs {
    /**
     * The default tenant to use for requests.
     */
    defaultTenant?: string;
    /**
     * An async function that returns a token, a string that is a token, or an object that contains an
     * async function named `getAccessToken` that returns a token.
     */
    tokenSource: AuthManager | string | TokenProviderAsyncFunction;
    /**
     * An object of key-value pairs, where the keys represent a Splunk Cloud Platform cluster, and values are the base URL for the cluster.
     * Example: `{ "api": "https://api.scp.splunk.com" }`
     */
    urls?: {
        [key: string]: string;
    };
    /**
     * Parameters that govern how messages are passed to the service, including how they are retried (and how
     * back-off is applied) upon transient errors like an HTTP 429.
     */
    requestQueueManagerParams?: RequestQueueManagerParams;
}
/**
 * This class acts as a raw proxy for Splunk Cloud, implementing
 * authorization for requests, setting the proper headers, calling HTTP methods, etc.
 * Do not use this class directly. Instead, use the service proxies that implement
 * the service endpoints.
 */
export declare class ServiceClient {
    private readonly tokenSource;
    private readonly urls;
    private readonly tenant?;
    private readonly authManager?;
    private responseHooks;
    private queueManager;
    /**
     * Creates a `ServiceClient` object with the given `ServiceClientArgs` object.
     * @param args A `ServiceClientArgs` object.
     */
    constructor(args: ServiceClientArgs);
    /**
     * Adds a response hook to the list of response handlers. Each response hook is called with a response for each request,
     * in the order it was defined. If the callback returns a `Response` object, the `Response` object replaces the argument it was
     * called with.
     * You can use a response hook for different purposes. For example, use a response hook as a logging request--if the
     * callback returns `null`,  it does not affect the result. Use a response hook for retrying failed requests--retry
     * the request, and if successful, return the response.
     * @param hook A callback that takes a `Response` object and optionally returns a `Response` object.
     */
    addResponseHook: (hook: ResponseHook) => void;
    /**
     * Clears response hooks from the client.
     */
    clearResponseHooks: () => void;
    private invokeHooks;
    /**
     * Builds the URL from a service + endpoint, with the query encoded in the URL
     * (concatenates the URL with the path).
     *
     * If the query contains an array value, the query is encoded as `foo=1,2`
     * rather than `foo=1&foo=2`. Some services expect the latter form, but
     * only the former format is supported at this time.
     *
     * @param cluster The cluster endpoint to target (`api` or `app`).
     * @param path The path to the resource that is being requested.
     * @param query The `QueryArgs` object.
     * @return A fully-qualified URL.
     */
    buildUrl: (cluster: string, path: string, query?: QueryArgs | undefined) => string;
    /**
     * Builds headers that are required for a request to Splunk Cloud, such as:
     * "Authorization", "Content-Type", and "Splunk-Client".
     * @param headers Additional headers to use for each request
     * @return A key-values map of headers
     */
    private buildHeaders;
    /**
     * Builds a path for a request to a service.
     * @param servicePrefix The name of the service with its version, for example "search/v1".
     * @param segments An array of path elements that are checked and added to the path, for example "['jobs', jobId]".
     * @param overrideTenant The tenant to use instead of the tenant that is associated with this client object.
     * @return A fully-qualified path to the resource.
     */
    buildPath: (servicePrefix: string, segments: string[], overrideTenant?: string | undefined) => string;
    /**
     * A proxy for fetch that builds the URL, applies headers and the query string, and invokes hooks
     * before returning a `Response` object.
     * @param method The HTTP request method (GET, POST, PATCH, or DELETE).
     * @param cluster The cluster endpoint to target (`api` or `app`).
     * @param path The path to the resource that is being requested.
     * @param opts Request options.
     * @param data Data for the request body. Objects are converted to strings.
     */
    fetch: (method: HTTPMethod, cluster: string, path: string, opts?: RequestOptions, data?: any) => Promise<Response>;
    /**
     * Performs a GET request on the specified path.
     * This implementation is internal but can be used for APIs that are not supported by an SDK.
     * @param cluster The cluster endpoint to target (`api` or `app`).
     * @param path The path to the resource that is being requested.
     * @param opts Request options.
     * @return An `HTTPResponse` object.
     */
    get: (cluster: string, path: string, opts?: RequestOptions) => Promise<HTTPResponse>;
    /**
     * Performs a POST request on the specified path.
     * This implementation is internal but can be used for APIs that are not supported by an SDK.
     * @param cluster The cluster endpoint to target (`api` or `app`).
     * @param path The path to the resource that is being requested.
     * @param data A data object that is converted to JSON and used as the request body.
     * @param opts Request options.
     * @return An `HTTPResponse` object.
     */
    post: (cluster: string, path: string, data?: any, opts?: RequestOptions) => Promise<HTTPResponse>;
    /**
     * Performs a PUT request on the specified path.
     * This implementation is internal but can be used for APIs that are not supported by an SDK.
     * @param cluster The cluster endpoint to target (`api` or `app`).
     * @param path The path to the resource that is being requested.
     * @param data A data object that is converted to JSON and used as the request body.
     * @param opts Request options.
     * @return An `HTTPResponse` object.
     */
    put: (cluster: string, path: string, data: any, opts?: RequestOptions) => Promise<HTTPResponse>;
    /**
     * Performs a PATCH request on the specified path.
     * This implementation is internal but can be used for APIs that are not supported by an SDK.
     * @param cluster The cluster endpoint to target (`api` or `app`).
     * @param path The path to the resource that is being requested.
     * @param data A data object that is converted to JSON and used as the request body.
     * @param opts Request options.
     * @return An `HTTPResponse` object.
     */
    patch: (cluster: string, path: string, data: object, opts?: RequestOptions) => Promise<HTTPResponse>;
    /**
     * Performs a DELETE request on the specified path.
     * This implementation is internal but can be used for APIs that are not supported by an SDK.
     * @param cluster The cluster endpoint to target (`api` or `app`).
     * @param path The path to the resource that is being requested.
     * @param data A data object that is converted to JSON and used as the request body.
     * @param opts Request options.
     * @return An `HTTPResponse` object.
     */
    delete: (cluster: string, path: string, data?: object, opts?: RequestOptions) => Promise<HTTPResponse>;
    private static queueFromPath;
}
declare type HTTPMethod = 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE';
/**
 * Optional arguments for the HTTP request
 */
export interface RequestOptions {
    /**
     * Key-value pairs that are URL-encoded and added to the URL query string.
     */
    query?: QueryArgs;
    /**
     * Additional headers (other than "Authorization") to add to the request.
     */
    headers?: RequestHeaders;
    /**
     * Named retry queue to use (default is the name of the service)
     */
    queue?: string;
    /**
     * Callback function used to retrieve the status of a request
     */
    statusCallback?: (requestStatus: RequestStatus) => void;
}
export interface QueryArgs {
    [key: string]: any;
}
export declare enum ContentType {
    CSV = "text/csv",
    GZIP = "application/gzip",
    JSON = "application/json"
}
export interface RequestHeaders {
    [key: string]: string;
}
export interface HTTPResponse {
    body?: string | object;
    headers: Headers;
    status: number;
}
export interface RequestStatus {
    status: string;
    request?: object;
}
